{
    "id_table_1": {
        "caption": "TABLE I :  Number of Repairs by Category",
        "table": "S4.T1.2",
        "footnotes": [],
        "references": [
            "As an illustrative example, Listing  1  represents a flaky Dockerfile, the corresponding build failure, and a subsequent repair based on the build error. According to the build output (lines 95 to 114), using a virtual environment is required to install  pip  for the specified  alpine  base image in Dockerfile (line 1) due to the adaptation of  Python Enhancement Proposal (PEP) 668   2 2 2 https://peps.python.org/pep-0668/ , which addresses Externally Managed Environments. This specification prevents package managers such as  pip  from modifying packages in the interpreters default environment, ensuring compatibility and reducing the risk of breaking the underlying operating system managed by external package managers. As a result of this adaptation, this Dockerfile fails to build, whereas previous builds prior to this adaptation were all successful. Thus, the solution here is to create and activate a virtual environment, as shown in the Dockerfile context (lines 11 and 12).",
            "Existing Dockerfile static and dynamic analysis approaches assume the determinism of the Dockerfile behavior. Static analysis techniques  [ 2 ,  9 ,  10 ,  4 ,  7 ]  consider Dockerfile context to provide a set of smell patterns coherent with Docker best practices  3 3 3 https://docs.docker.com/build/building/best-practices/ . The only Dynamic analysis approach  [ 6 ] , primarily focuses on the Dockerfile build output as an invariant to introduce and expand the error patterns. While adhering to best practices is essential to mitigate errors and vulnerabilities in Dockerfiles and in some cases to prevent potential failures from happening, we argue that this alone is insufficient to address flakiness. For example, existing tools such as HadoLint  [ 9 ]  recommend pinning the exact version of the base image (e.g., rule: DL3006) or dependencies (e.g., rules: DL3007, DL3008, DL3013, DL3016, DL3018) to prevent errors caused by their internal changes. This practice can be applied to Listing  1  by using old or outdated  alpine  images as a solution. However, it does not provide a viable solution for the problem; applying such rules without considering the static and dynamic nature of Dockerfiles can introduce other types of flakiness, such as outdatedness and compatibility issues in the future.",
            "Dockerfiles rely on various elements such as operating systems, packages, environments, commands, and project source code, which can result in different forms of flakiness. Examples in Listing  1  and Listing  2  illustrate that understanding and resolving such flaky behavior requires analyzing both the static context (Dockerfile) and dynamic context (build output) along with its temporal changes. Currently, no existing study examines flakiness in Docker builds.  To characterize the extent and causes of Docker build flakiness, we first conduct a longitudinal study of 18,055 Dockerized repositories over a period of nine months ( section III ). Second, we propose  FlakiDock  an automated approach for repairing Dockerfile flakiness utilizing both static and dynamic information ( section IV ).",
            "Figure  1  illustrates our hierarchically structured taxonomy of Dockerfile flakiness. The left side shows the main categories of flakiness, while the right side lists the associated subcategories. The numbers within each box indicate the frequency of occurrences. The rest of this section provides an overview of the primary categories of flakiness identified in our taxonomy. Detailed information, including examples for each category and sub-category, can be found in our replication package  [ 15 ] .",
            "Dependency-Related Errors (DEP).  This is the most prevalent category, accounting for 61.29% of all errors. It encompasses 11 subcategories of errors that occur during the retrieval, installation, or post-installation operations of dependencies specified in Dockerfiles. These three steps of errors are shown in the first, second, and third rows of dependency-related error subcategories in Figure  1 . We define a  dependency  as a Base image or any external software package or library explicitly mentioned in the Dockerfile.",
            "In our demonstration dataset, a Dockerfile is denoted with  d d d italic_d , and every record is defined as tuple  ( S d , D d , C d , R d , I d ) subscript S d subscript D d subscript C d subscript R d subscript I d (S_{d},D_{d},C_{d},R_{d},I_{d}) ( italic_S start_POSTSUBSCRIPT italic_d end_POSTSUBSCRIPT , italic_D start_POSTSUBSCRIPT italic_d end_POSTSUBSCRIPT , italic_C start_POSTSUBSCRIPT italic_d end_POSTSUBSCRIPT , italic_R start_POSTSUBSCRIPT italic_d end_POSTSUBSCRIPT , italic_I start_POSTSUBSCRIPT italic_d end_POSTSUBSCRIPT )  containing several elements of the Flaky Dockerfile. The  S d subscript S d S_{d} italic_S start_POSTSUBSCRIPT italic_d end_POSTSUBSCRIPT  component contains the static information, i.e., Dockerfile context. The identifier  D d subscript D d D_{d} italic_D start_POSTSUBSCRIPT italic_d end_POSTSUBSCRIPT  indicates the pre-processed build output of the flaky Dockerfile, which is referred to as the dynamic information.  C d subscript C d C_{d} italic_C start_POSTSUBSCRIPT italic_d end_POSTSUBSCRIPT  defines the category label for the current Dockerfile based on the taxonomy illustrated in Fig  1 . Elements  R d subscript R d R_{d} italic_R start_POSTSUBSCRIPT italic_d end_POSTSUBSCRIPT  and  I d subscript I d I_{d} italic_I start_POSTSUBSCRIPT italic_d end_POSTSUBSCRIPT  denote the repair patch proposed for the Dockerfile and the number of iterations required for the repair to be tested to ensure its correctness, respectively. In case more than one repair is offered for a flaky Dockerfile,  R d subscript R d R_{d} italic_R start_POSTSUBSCRIPT italic_d end_POSTSUBSCRIPT  and  I d subscript I d I_{d} italic_I start_POSTSUBSCRIPT italic_d end_POSTSUBSCRIPT  form a list of values.",
            "The validation phase serves as a heuristic approach to determine whether the repair suggested by the LLM is effective. The structure of this stage is elaborated in Algorithm  1 . In the beginning, The repaired Dockerfile is built  n n n italic_n  times, and build outputs are captured, similar to the Dockerfile builder module described in  IV-B . If all build outputs are successful, the validator confirms the repairs correctness and finalizes it as a result. Otherwise, it identifies the most common error type observed from the feedback generated thus far. The feedback comparison relies on the similarity of build outputs, assessed using sentence transformation models."
        ]
    },
    "id_table_2": {
        "caption": "TABLE II :  Results for Dockerfile Flakiness Repair",
        "table": "S5.T2.6",
        "footnotes": [],
        "references": [
            "Listing  2  demonstrates another flaky Dockerfile that clings to the version pinning rule for the base image. As depicted in the Dockerfile (line 1), although the base image version is explicitly mentioned, inconsistent behavior is plausible due to using a relatively old base image. This flakiness is evident inside the build output (line 132), where the expression  pre_go17  is located. The error stems from the compatibility issue of a stale  GOLANG  base image, i.e., older than 1.17, with existing dependencies utilized in the Dockerfile (line 8), failing the compilation and build of the project. Accordingly, a base image version upgrade is required (line 2). Furthermore, updated  GOLANG  images require a different approach for handling executables (lines 3 and 4) due to the adoption of new techniques.",
            "Dockerfiles rely on various elements such as operating systems, packages, environments, commands, and project source code, which can result in different forms of flakiness. Examples in Listing  1  and Listing  2  illustrate that understanding and resolving such flaky behavior requires analyzing both the static context (Dockerfile) and dynamic context (build output) along with its temporal changes. Currently, no existing study examines flakiness in Docker builds.  To characterize the extent and causes of Docker build flakiness, we first conduct a longitudinal study of 18,055 Dockerized repositories over a period of nine months ( section III ). Second, we propose  FlakiDock  an automated approach for repairing Dockerfile flakiness utilizing both static and dynamic information ( section IV ).",
            "Environment Errors (ENV).    Environment Management Issues  and  Environment Configuration Issues  fall into this category, representing 3.7% of the errors corresponding to interactions with virtual environments. These environment errors often arise from changes made to the base images or other underlying infrastructures specified in the Dockerfile. Such changes enforce developers to strictly adhere to the new rules to minimize vulnerabilities and enhance the systems robustness. A detailed example of this type of error is illustrated in Listing  2  where an externally managed environment is required to alleviate the risk of disrupting the OS package management system.",
            "As demonstrated in Section  III , Dockerfile flakiness presents various complex symptoms in the build output. Leveraging the ability of LLMs to solve programming tasks across different domains  [ 16 ,  17 ,  18 ,  19 ,  20 ,  21 ,  22 ,  23 ,  24 ,  25 ,  26 ] , and the effectiveness of retrieval-augmented generation (RAG) techniques  [ 27 ,  28 ,  29 ] , we propose  FlakiDock , an automated approach using LLMs to repair Dockerfile flakiness. Our insight is that by providing LLMs with demonstrations containing  static  (Dockerfile) and  dynamic  (build outputs) information, along with repair patches from similar examples, the model can resolve flakiness in new Dockerfiles. Figure  2  provides an overview of our approach.",
            "This step contains the prompt design for Dockerfile flakiness repair generation. As shown in Figure  2 , the prompt comprises a natural language task description, the flaky Dockerfile along with its build output, and a Chain-of-Thoughts (CoT) explanation to guide the model through the repair process. The prompt is then augmented with demonstration examples retrieved from the similarity retriever. Each example  e e e italic_e  consists of a triple:  ( S e , D e , R e ) subscript S e subscript D e subscript R e (S_{e},D_{e},R_{e}) ( italic_S start_POSTSUBSCRIPT italic_e end_POSTSUBSCRIPT , italic_D start_POSTSUBSCRIPT italic_e end_POSTSUBSCRIPT , italic_R start_POSTSUBSCRIPT italic_e end_POSTSUBSCRIPT )  represents the Dockerfile, build output, and repair/repairs suggested for the flaky Dockerfile."
        ]
    },
    "global_footnotes": []
}