{
    "id_table_1": {
        "caption": "",
        "table": "S3.F4.sf2.10",
        "footnotes": [],
        "references": [
            "Take a look at the  FG  presented in  Fig.   1 , which represents an epidemic example with four persons  a  l  i  c  e a l i c e alice italic_a italic_l italic_i italic_c italic_e ,  b  o  b b o b bob italic_b italic_o italic_b ,  d  a  v  e d a v e dave italic_d italic_a italic_v italic_e , and  e  v  e e v e eve italic_e italic_v italic_e  as well as two possible medications  m 1 subscript m 1 m_{1} italic_m start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT  and  m 2 subscript m 2 m_{2} italic_m start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT  for treatment. For each person, there are two Boolean  randvars  (that is,  randvars  having a Boolean range)  S  i  c  k S i c k Sick italic_S italic_i italic_c italic_k  and  T  r  a  v  e  l T r a v e l Travel italic_T italic_r italic_a italic_v italic_e italic_l , indicating whether the person is sick and travels, respectively. Moreover, there is another Boolean  randvar   T  r  e  a  t T r e a t Treat italic_T italic_r italic_e italic_a italic_t  for each combination of person and medication, specifying whether the person is treated with the medication. The Boolean  randvar   E  p  i  d E p i d Epid italic_E italic_p italic_i italic_d  states whether an epidemic is present.",
            "Figure   2  shows a  PFG   G = { g i } i = 0 3 G subscript superscript subscript g i 3 i 0 G=\\{g_{i}\\}^{3}_{i=0} italic_G = { italic_g start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT } start_POSTSUPERSCRIPT 3 end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_i = 0 end_POSTSUBSCRIPT  with  g 0 =  0  ( E  p  i  d ) |  g_{0}=\\phi_{0}(Epid)_{|\\top} italic_g start_POSTSUBSCRIPT 0 end_POSTSUBSCRIPT = italic_ start_POSTSUBSCRIPT 0 end_POSTSUBSCRIPT ( italic_E italic_p italic_i italic_d ) start_POSTSUBSCRIPT |  end_POSTSUBSCRIPT ,  g 1 =  1  ( T  r  a  v  e  l  ( P ) , S  i  c  k  ( P ) , E  p  i  d ) |  g_{1}=\\phi_{1}(Travel(P),\\allowbreak Sick(P),\\allowbreak Epid)_{|\\top} italic_g start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT = italic_ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ( italic_T italic_r italic_a italic_v italic_e italic_l ( italic_P ) , italic_S italic_i italic_c italic_k ( italic_P ) , italic_E italic_p italic_i italic_d ) start_POSTSUBSCRIPT |  end_POSTSUBSCRIPT ,  g 2 =  2  ( T  r  e  a  t  ( P , M ) , S  i  c  k  ( P ) , E  p  i  d ) |  g_{2}=\\phi_{2}(Treat(P,M),\\allowbreak Sick(P),\\allowbreak Epid)_{|\\top} italic_g start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT = italic_ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ( italic_T italic_r italic_e italic_a italic_t ( italic_P , italic_M ) , italic_S italic_i italic_c italic_k ( italic_P ) , italic_E italic_p italic_i italic_d ) start_POSTSUBSCRIPT |  end_POSTSUBSCRIPT , and  g 3 =  2  ( T  r  a  v  e  l  ( P ) ) |  g_{3}=\\phi_{2}(Travel(P))_{|\\top} italic_g start_POSTSUBSCRIPT 3 end_POSTSUBSCRIPT = italic_ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ( italic_T italic_r italic_a italic_v italic_e italic_l ( italic_P ) ) start_POSTSUBSCRIPT |  end_POSTSUBSCRIPT . Grounding  G G G italic_G  yields again the  FG  shown in  Fig.   1  (assuming that the domains of the  logvars  are defined as in  Ex.   2 ).",
            "A summary of our proposed learning algorithm is provided in  Alg.   1 .",
            "So far, we discussed the steps to learn a propositional  FG  from a given relational database ( Alg.   1  to  Alg.   1  in  Alg.   1 ). We next describe the procedure to transform the learned  FG  into a  PFG  ( Alg.   1  in  Alg.   1 )."
        ]
    },
    "id_table_2": {
        "caption": "",
        "table": "S3.F4.sf2.20",
        "footnotes": [],
        "references": [
            "Figure   2  shows a  PFG   G = { g i } i = 0 3 G subscript superscript subscript g i 3 i 0 G=\\{g_{i}\\}^{3}_{i=0} italic_G = { italic_g start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT } start_POSTSUPERSCRIPT 3 end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_i = 0 end_POSTSUBSCRIPT  with  g 0 =  0  ( E  p  i  d ) |  g_{0}=\\phi_{0}(Epid)_{|\\top} italic_g start_POSTSUBSCRIPT 0 end_POSTSUBSCRIPT = italic_ start_POSTSUBSCRIPT 0 end_POSTSUBSCRIPT ( italic_E italic_p italic_i italic_d ) start_POSTSUBSCRIPT |  end_POSTSUBSCRIPT ,  g 1 =  1  ( T  r  a  v  e  l  ( P ) , S  i  c  k  ( P ) , E  p  i  d ) |  g_{1}=\\phi_{1}(Travel(P),\\allowbreak Sick(P),\\allowbreak Epid)_{|\\top} italic_g start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT = italic_ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ( italic_T italic_r italic_a italic_v italic_e italic_l ( italic_P ) , italic_S italic_i italic_c italic_k ( italic_P ) , italic_E italic_p italic_i italic_d ) start_POSTSUBSCRIPT |  end_POSTSUBSCRIPT ,  g 2 =  2  ( T  r  e  a  t  ( P , M ) , S  i  c  k  ( P ) , E  p  i  d ) |  g_{2}=\\phi_{2}(Treat(P,M),\\allowbreak Sick(P),\\allowbreak Epid)_{|\\top} italic_g start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT = italic_ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ( italic_T italic_r italic_e italic_a italic_t ( italic_P , italic_M ) , italic_S italic_i italic_c italic_k ( italic_P ) , italic_E italic_p italic_i italic_d ) start_POSTSUBSCRIPT |  end_POSTSUBSCRIPT , and  g 3 =  2  ( T  r  a  v  e  l  ( P ) ) |  g_{3}=\\phi_{2}(Travel(P))_{|\\top} italic_g start_POSTSUBSCRIPT 3 end_POSTSUBSCRIPT = italic_ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ( italic_T italic_r italic_a italic_v italic_e italic_l ( italic_P ) ) start_POSTSUBSCRIPT |  end_POSTSUBSCRIPT . Grounding  G G G italic_G  yields again the  FG  shown in  Fig.   1  (assuming that the domains of the  logvars  are defined as in  Ex.   2 ).",
            "The  ACP  algorithm  [ 23 ]  builds on the  colour passing  algorithm  [ 2 ,  15 ]  and solves the problem of constructing a  PFG  from a given  FG .  Algorithm   2  provides a formal description of the  ACP  algorithm."
        ]
    },
    "id_table_3": {
        "caption": "",
        "table": "S3.F4.sf2.30",
        "footnotes": [],
        "references": [
            "An overview of the architecture of our proposed architecture is depicted in  Fig.   3 . The whole process consists of three primary steps, which can again be decomposed into various subroutines. The three primary steps consist of (i) constructing a propositional  FG , (ii) transforming the propositional  FG  into a  PFG , and (iii) sampling from the  PFG  to generate new synthetic relational data. Besides the generated synthetic data, the  PFG  is also a valuable output of the architecture (indicated by the  + + +  sign), as it can be used for various tasks such as probabilistic inference, causal inference, or bootstrap  PFG  learning, for example."
        ]
    },
    "id_table_4": {
        "caption": "",
        "table": "Pt0.A1.F7.125",
        "footnotes": [],
        "references": [
            "Consider the  ER  model depicted in  Fig.   4(a) , which consists of the entity classes  C = { P  a  t  i  e  n  t , M  e  d  i  c  a  t  i  o  n } C P a t i e n t M e d i c a t i o n \\mathcal{C}=\\{Patient,Medication\\} caligraphic_C = { italic_P italic_a italic_t italic_i italic_e italic_n italic_t , italic_M italic_e italic_d italic_i italic_c italic_a italic_t italic_i italic_o italic_n }  and the relationship classes  R = { T  r  e  a  t } R T r e a t \\mathcal{R}=\\{Treat\\} caligraphic_R = { italic_T italic_r italic_e italic_a italic_t } . The  ER  model further contains the attributes  A  ( P  a  t  i  e  n  t ) = { A  g  e } A P a t i e n t A g e \\mathcal{A}(Patient)=\\{Age\\} caligraphic_A ( italic_P italic_a italic_t italic_i italic_e italic_n italic_t ) = { italic_A italic_g italic_e }  and  A  ( M  e  d  i  c  a  t  i  o  n ) = { C  o  s  t  s } A M e d i c a t i o n C o s t s \\mathcal{A}(Medication)=\\{Costs\\} caligraphic_A ( italic_M italic_e italic_d italic_i italic_c italic_a italic_t italic_i italic_o italic_n ) = { italic_C italic_o italic_s italic_t italic_s } .",
            "Take a look at a simple toy example database containing information on patients and the medications they take, as depicted in  Fig.   4 . For simplicity, each patient only has a single attribute  A  g  e A g e Age italic_A italic_g italic_e  which can either be  < 18 absent 18 <18 < 18  or   18 absent 18 \\geq 18  18  and each medication has a single attribute  C  o  s  t  s C o s t s Costs italic_C italic_o italic_s italic_t italic_s  which can either be  l  o  w l o w low italic_l italic_o italic_w  or  h  i  g  h h i g h high italic_h italic_i italic_g italic_h . Further, there is a relation  T  r  e  a  t T r e a t Treat italic_T italic_r italic_e italic_a italic_t  connecting patients with the medications they take. The specific entries of the database are depicted in  Fig.   4(b) , where we again keep the tables simple for illustrative purposes.",
            "Consider again the example database depicted in  Fig.   4 . For the sake of the example, assume that the initial clustering returns two patient clusters  C p 1 = { a  l  i  c  e , e  v  e } subscript C subscript p 1 a l i c e e v e C_{p_{1}}=\\{alice,eve\\} italic_C start_POSTSUBSCRIPT italic_p start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUBSCRIPT = { italic_a italic_l italic_i italic_c italic_e , italic_e italic_v italic_e }  as well as  C p 2 = { b  o  b , c  h  a  r  l  i  e , d  a  v  e } subscript C subscript p 2 b o b c h a r l i e d a v e C_{p_{2}}=\\{bob,charlie,dave\\} italic_C start_POSTSUBSCRIPT italic_p start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUBSCRIPT = { italic_b italic_o italic_b , italic_c italic_h italic_a italic_r italic_l italic_i italic_e , italic_d italic_a italic_v italic_e }  and two medication clusters  C m 1 = { m  y  a  l  e  p  t , d  a  n  y  e  l  z  a , e  l  i  q  u  i  s } subscript C subscript m 1 m y a l e p t d a n y e l z a e l i q u i s C_{m_{1}}=\\{myalept,danyelza,eliquis\\} italic_C start_POSTSUBSCRIPT italic_m start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUBSCRIPT = { italic_m italic_y italic_a italic_l italic_e italic_p italic_t , italic_d italic_a italic_n italic_y italic_e italic_l italic_z italic_a , italic_e italic_l italic_i italic_q italic_u italic_i italic_s }  and  C m 2 = { p  a  r  a  c  e  t  a  m  o  l , i  b  u  p  r  o  f  e  n } subscript C subscript m 2 p a r a c e t a m o l i b u p r o f e n C_{m_{2}}=\\{paracetamol,ibuprofen\\} italic_C start_POSTSUBSCRIPT italic_m start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUBSCRIPT = { italic_p italic_a italic_r italic_a italic_c italic_e italic_t italic_a italic_m italic_o italic_l , italic_i italic_b italic_u italic_p italic_r italic_o italic_f italic_e italic_n } . Then, the resulting  FG  contains the  randvars   A  g  e . p 1 formulae-sequence A g e subscript p 1 Age.p_{1} italic_A italic_g italic_e . italic_p start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ,  A  g  e . p 2 formulae-sequence A g e subscript p 2 Age.p_{2} italic_A italic_g italic_e . italic_p start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ,  C  o  s  t  s . m 1 formulae-sequence C o s t s subscript m 1 Costs.m_{1} italic_C italic_o italic_s italic_t italic_s . italic_m start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , and  C  o  s  t  s . m 2 formulae-sequence C o s t s subscript m 2 Costs.m_{2} italic_C italic_o italic_s italic_t italic_s . italic_m start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , that is, there exists one  randvar  for each cluster per attribute. The probability that, e.g.,  A  g  e . p 1 < 18 formulae-sequence A g e subscript p 1 18 Age.p_{1}<18 italic_A italic_g italic_e . italic_p start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT < 18  is then set to  0.5 0.5 0.5 0.5  (as one out of two entries belonging to the cluster  C p 1 subscript C subscript p 1 C_{p_{1}} italic_C start_POSTSUBSCRIPT italic_p start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUBSCRIPT  has  A  g  e < 18 A g e 18 Age<18 italic_A italic_g italic_e < 18 ) and the probability that  A  g  e . p 2 < 18 formulae-sequence A g e subscript p 2 18 Age.p_{2}<18 italic_A italic_g italic_e . italic_p start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT < 18  is set to  0.33 0.33 0.33 0.33  (as one out of three entries belonging to the cluster  C p 2 subscript C subscript p 2 C_{p_{2}} italic_C start_POSTSUBSCRIPT italic_p start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUBSCRIPT  has  A  g  e < 18 A g e 18 Age<18 italic_A italic_g italic_e < 18 ).",
            "Given the database from  Fig.   4  and the clusters  C p 1 subscript C subscript p 1 C_{p_{1}} italic_C start_POSTSUBSCRIPT italic_p start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUBSCRIPT ,  C p 2 subscript C subscript p 2 C_{p_{2}} italic_C start_POSTSUBSCRIPT italic_p start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUBSCRIPT ,  C m 1 subscript C subscript m 1 C_{m_{1}} italic_C start_POSTSUBSCRIPT italic_m start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUBSCRIPT , and  C m 2 subscript C subscript m 2 C_{m_{2}} italic_C start_POSTSUBSCRIPT italic_m start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUBSCRIPT  from  Ex.   6 , the resulting  FG  contains the  randvars   A  g  e . p 1 formulae-sequence A g e subscript p 1 Age.p_{1} italic_A italic_g italic_e . italic_p start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ,  A  g  e . p 2 formulae-sequence A g e subscript p 2 Age.p_{2} italic_A italic_g italic_e . italic_p start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ,  C  o  s  t  s . m 1 formulae-sequence C o s t s subscript m 1 Costs.m_{1} italic_C italic_o italic_s italic_t italic_s . italic_m start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ,  C  o  s  t  s . m 2 formulae-sequence C o s t s subscript m 2 Costs.m_{2} italic_C italic_o italic_s italic_t italic_s . italic_m start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ,  T  r  e  a  t . p 1 . m 1 formulae-sequence T r e a t subscript p 1 subscript m 1 Treat.p_{1}.m_{1} italic_T italic_r italic_e italic_a italic_t . italic_p start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT . italic_m start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ,  T  r  e  a  t . p 1 . m 2 formulae-sequence T r e a t subscript p 1 subscript m 2 Treat.p_{1}.m_{2} italic_T italic_r italic_e italic_a italic_t . italic_p start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT . italic_m start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ,  T  r  e  a  t . p 2 . m 1 formulae-sequence T r e a t subscript p 2 subscript m 1 Treat.p_{2}.m_{1} italic_T italic_r italic_e italic_a italic_t . italic_p start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT . italic_m start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , and  T  r  e  a  t . p 2 . m 2 formulae-sequence T r e a t subscript p 2 subscript m 2 Treat.p_{2}.m_{2} italic_T italic_r italic_e italic_a italic_t . italic_p start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT . italic_m start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT .",
            "Consider again the database given in  Fig.   4 . When checking whether the  randvars   P  a  t  i  e  n  t P a t i e n t Patient italic_P italic_a italic_t italic_i italic_e italic_n italic_t  and  M  e  d  i  c  a  t  i  o  n M e d i c a t i o n Medication italic_M italic_e italic_d italic_i italic_c italic_a italic_t italic_i italic_o italic_n  are independent, we need a joined table which contains both  P  a  t  i  e  n  t P a t i e n t Patient italic_P italic_a italic_t italic_i italic_e italic_n italic_t  and  M  e  d  i  c  a  t  i  o  n M e d i c a t i o n Medication italic_M italic_e italic_d italic_i italic_c italic_a italic_t italic_i italic_o italic_n .",
            "As we add  randvars  for the relationships as well, we augment the full join with an additional column for each relationship, indicating which relationships are present in the database and which are not. We also augment the full join with combinations of entities that do not occur in the relationships from the given database (similar to a cross join) such as the combination of patient  b  o  b b o b bob italic_b italic_o italic_b  and medication  m  y  a  l  e  p  t m y a l e p t myalept italic_m italic_y italic_a italic_l italic_e italic_p italic_t  in  Fig.   4 , for which we add a row with value  f  a  l  s  e f a l s e false italic_f italic_a italic_l italic_s italic_e  in the column  T  r  e  a  t T r e a t Treat italic_T italic_r italic_e italic_a italic_t . More details about the augmented full join are given in  Appendix   0.A .",
            "Take a look at the  FG  shown in  Fig.   5 . The  FG  results from the learning procedure described above applied to the database illustrated in  Fig.   4 . The potentials for, e.g.,   1 2 ( A g e . p 2 ) \\phi_{1}^{2}(Age.p_{2}) italic_ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ( italic_A italic_g italic_e . italic_p start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT )  are obtained by counting the occurrences of  A  g  e . p 2 < 18 formulae-sequence A g e subscript p 2 18 Age.p_{2}<18 italic_A italic_g italic_e . italic_p start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT < 18  and  A  g  e . p 2  18 formulae-sequence A g e subscript p 2 18 Age.p_{2}\\geq 18 italic_A italic_g italic_e . italic_p start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT  18  in the augmented full join shown in  Fig.   7  ( Appendix   0.A ). Recall that  C p 2 = { b  o  b , c  h  a  r  l  i  e , d  a  v  e } subscript C subscript p 2 b o b c h a r l i e d a v e C_{p_{2}}=\\{bob,charlie,dave\\} italic_C start_POSTSUBSCRIPT italic_p start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUBSCRIPT = { italic_b italic_o italic_b , italic_c italic_h italic_a italic_r italic_l italic_i italic_e , italic_d italic_a italic_v italic_e } . Thus, in this particular example, it holds that   1 2 ( A g e . p 2 < 18 ) = 5 \\phi_{1}^{2}(Age.p_{2}<18)=5 italic_ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ( italic_A italic_g italic_e . italic_p start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT < 18 ) = 5  and   1 2 ( A g e . p 2  18 ) = 10 \\phi_{1}^{2}(Age.p_{2}\\geq 18)=10 italic_ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ( italic_A italic_g italic_e . italic_p start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT  18 ) = 10 .",
            "We call the full join of the tables, where an additional column for each relationship is added and missing relationships are encoded by an additional row containing the value  f  a  l  s  e f a l s e false italic_f italic_a italic_l italic_s italic_e  in the corresponding relationship column, the  augmented full join . The augmented full join can therefore be thought of as a cross join with an additional column for each relationship, which contains a Boolean value indicating which relationships are present in the database. For example, the augmented full join of the tables given in the example from  Fig.   4  is illustrated in  Fig.   7 . In this particular example, the augmented full join contains the additional column  T  r  e  a  t T r e a t Treat italic_T italic_r italic_e italic_a italic_t , which contains the value  t  r  u  e t r u e true italic_t italic_r italic_u italic_e  if the relationship of a given combination of  P  a  t  i  e  n  t  I  d P a t i e n t I d PatientId italic_P italic_a italic_t italic_i italic_e italic_n italic_t italic_I italic_d  and  M  e  d  i  c  a  t  i  o  n  I  d M e d i c a t i o n I d MedicationId italic_M italic_e italic_d italic_i italic_c italic_a italic_t italic_i italic_o italic_n italic_I italic_d  in a specific row actually exists. Otherwise, the column  T  r  e  a  t T r e a t Treat italic_T italic_r italic_e italic_a italic_t  contains the value  f  a  l  s  e f a l s e false italic_f italic_a italic_l italic_s italic_e ."
        ]
    },
    "id_table_5": {
        "caption": "",
        "table": "Pt0.A2.F8.pic1.35.35.35.35.35.35.35.35.35.35.35.35.25.15.7.7.7.7.7.7.7.7.7.7.7",
        "footnotes": [],
        "references": [
            "Therefore, we slightly adjust the learning procedure to include multiple  randvars  for the same attribute of different individual objects into the learned  FG . However, we cannot simply include a  randvar  for each object per attribute because there would be no uncertainty in the resulting model. To continue  Ex.   5 , assume we add a  randvar   A  g  e A g e Age italic_A italic_g italic_e  for each patient to the learned  FG . Then, the prior probability distribution for the  randvar   A  g  e A g e Age italic_A italic_g italic_e  of a specific patient would map the value found in the database for  A  g  e A g e Age italic_A italic_g italic_e  to probability one and all other values to probability zero, e.g., the probability that  A  g  e . a  l  i  c  e < 18 formulae-sequence A g e a l i c e 18 Age.alice<18 italic_A italic_g italic_e . italic_a italic_l italic_i italic_c italic_e < 18  would be set to zero and the probability that  A  g  e . a  l  i  c  e  18 formulae-sequence A g e a l i c e 18 Age.alice\\geq 18 italic_A italic_g italic_e . italic_a italic_l italic_i italic_c italic_e  18  would be set to one. Consequently, the  FG  would not model any uncertainty at all. To mitigate this issue, we propose to perform an initial clustering of entities to find clusters of indistinguishable objects (here patients and medications), which allows us to naturally define the domains of the  logvars  when transforming the learned  FG  into an  PFG . After the initial clustering, we then insert a  randvar  for each cluster per attribute into the  FG . Performing an initial clustering of entities allows us to model uncertainty while keeping objects and relationships in the model.",
            "Take a look at the  FG  shown in  Fig.   5 . The  FG  results from the learning procedure described above applied to the database illustrated in  Fig.   4 . The potentials for, e.g.,   1 2 ( A g e . p 2 ) \\phi_{1}^{2}(Age.p_{2}) italic_ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ( italic_A italic_g italic_e . italic_p start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT )  are obtained by counting the occurrences of  A  g  e . p 2 < 18 formulae-sequence A g e subscript p 2 18 Age.p_{2}<18 italic_A italic_g italic_e . italic_p start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT < 18  and  A  g  e . p 2  18 formulae-sequence A g e subscript p 2 18 Age.p_{2}\\geq 18 italic_A italic_g italic_e . italic_p start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT  18  in the augmented full join shown in  Fig.   7  ( Appendix   0.A ). Recall that  C p 2 = { b  o  b , c  h  a  r  l  i  e , d  a  v  e } subscript C subscript p 2 b o b c h a r l i e d a v e C_{p_{2}}=\\{bob,charlie,dave\\} italic_C start_POSTSUBSCRIPT italic_p start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUBSCRIPT = { italic_b italic_o italic_b , italic_c italic_h italic_a italic_r italic_l italic_i italic_e , italic_d italic_a italic_v italic_e } . Thus, in this particular example, it holds that   1 2 ( A g e . p 2 < 18 ) = 5 \\phi_{1}^{2}(Age.p_{2}<18)=5 italic_ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ( italic_A italic_g italic_e . italic_p start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT < 18 ) = 5  and   1 2 ( A g e . p 2  18 ) = 10 \\phi_{1}^{2}(Age.p_{2}\\geq 18)=10 italic_ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ( italic_A italic_g italic_e . italic_p start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT  18 ) = 10 .",
            "To obtain a  PFG  from a given  FG , we need to find groups of identically behaving  randvars  and factors in the  FG . Then,  PRVs  with  logvars  represent such groups of indistinguishable  randvars  and  parfactors  represent groups of identical factors. Replacing indistinguishable  randvars  by  PRVs  with  logvars  further abstracts from individuals and thus yields a promising foundation for privacy guarantees  [ 12 ] . The  ACP  algorithm (which is a generalisation of the  colour passing  algorithm  [ 2 ,  15 ] ) is able to construct a  PFG  from a given propositional  FG   [ 23 ] . The idea behind  ACP  is to exploit symmetries in a propositional  FG  and then group together symmetric subgraphs.  \\Ac acp looks for symmetries based on potentials of factors, on ranges and evidence of  randvars , as well as on the graph structure by passing around colours. A formal description as well as an example run of the  ACP  algorithm can be found in  Appendix   0.B .  Figure   6  shows the  PFG  resulting from calling  ACP  on the  FG  depicted in  Fig.   5  under the assumption that all potentials of the factors   i subscript italic- i \\phi_{i} italic_ start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT ,  i  { 1 , ... , 4 } i 1 ... 4 i\\in\\{1,\\ldots,4\\} italic_i  { 1 , ... , 4 } , are considered identical. Note that the assumption of identical factors is just for the sake of the example as in general, not all potentials are identical (and hence, not all of the factors   i subscript italic- i \\phi_{i} italic_ start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT  are grouped into a single group).",
            "Assume we want to sample the  PFG  which yields the  FG  shown in  Fig.   5  when grounding the model. Sampling thus yields a value for every  randvar  in the  FG , thereby allowing to synthesise new objects and relationships between them following the full joint probability distribution encoded by the model. An exemplary data sample could look like this:  A  g  e . p 1 < 18 formulae-sequence A g e subscript p 1 18 Age.p_{1}<18 italic_A italic_g italic_e . italic_p start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT < 18 ,  A  g  e . p 2  18 formulae-sequence A g e subscript p 2 18 Age.p_{2}\\geq 18 italic_A italic_g italic_e . italic_p start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT  18 ,  T  r  e  a  t . p 1 . m 1 = f  a  l  s  e formulae-sequence T r e a t subscript p 1 subscript m 1 f a l s e Treat.p_{1}.m_{1}=false italic_T italic_r italic_e italic_a italic_t . italic_p start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT . italic_m start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT = italic_f italic_a italic_l italic_s italic_e ,  T  r  e  a  t . p 1 . m 2 = f  a  l  s  e formulae-sequence T r e a t subscript p 1 subscript m 2 f a l s e Treat.p_{1}.m_{2}=false italic_T italic_r italic_e italic_a italic_t . italic_p start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT . italic_m start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT = italic_f italic_a italic_l italic_s italic_e ,  T  r  e  a  t . p 2 . m 1 = t  r  u  e formulae-sequence T r e a t subscript p 2 subscript m 1 t r u e Treat.p_{2}.m_{1}=true italic_T italic_r italic_e italic_a italic_t . italic_p start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT . italic_m start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT = italic_t italic_r italic_u italic_e ,  T  r  e  a  t . p 2 . m 2 = f  a  l  s  e formulae-sequence T r e a t subscript p 2 subscript m 2 f a l s e Treat.p_{2}.m_{2}=false italic_T italic_r italic_e italic_a italic_t . italic_p start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT . italic_m start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT = italic_f italic_a italic_l italic_s italic_e ,  C  o  s  t  s . m 1 = l  o  w formulae-sequence C o s t s subscript m 1 l o w Costs.m_{1}=low italic_C italic_o italic_s italic_t italic_s . italic_m start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT = italic_l italic_o italic_w ,  C  o  s  t  s . m 2 = h  i  g  h formulae-sequence C o s t s subscript m 2 h i g h Costs.m_{2}=high italic_C italic_o italic_s italic_t italic_s . italic_m start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT = italic_h italic_i italic_g italic_h  (values are chosen arbitrarily for the sake of the example)."
        ]
    },
    "id_table_6": {
        "caption": "",
        "table": "Pt0.A2.F8.pic1.42.42.42.42.42.42.42.42.42.42.42.42.32.22.14.7.7.7.7.7.7.7.7.7.7",
        "footnotes": [],
        "references": [
            "Given the database from  Fig.   4  and the clusters  C p 1 subscript C subscript p 1 C_{p_{1}} italic_C start_POSTSUBSCRIPT italic_p start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUBSCRIPT ,  C p 2 subscript C subscript p 2 C_{p_{2}} italic_C start_POSTSUBSCRIPT italic_p start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUBSCRIPT ,  C m 1 subscript C subscript m 1 C_{m_{1}} italic_C start_POSTSUBSCRIPT italic_m start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUBSCRIPT , and  C m 2 subscript C subscript m 2 C_{m_{2}} italic_C start_POSTSUBSCRIPT italic_m start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUBSCRIPT  from  Ex.   6 , the resulting  FG  contains the  randvars   A  g  e . p 1 formulae-sequence A g e subscript p 1 Age.p_{1} italic_A italic_g italic_e . italic_p start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ,  A  g  e . p 2 formulae-sequence A g e subscript p 2 Age.p_{2} italic_A italic_g italic_e . italic_p start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ,  C  o  s  t  s . m 1 formulae-sequence C o s t s subscript m 1 Costs.m_{1} italic_C italic_o italic_s italic_t italic_s . italic_m start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ,  C  o  s  t  s . m 2 formulae-sequence C o s t s subscript m 2 Costs.m_{2} italic_C italic_o italic_s italic_t italic_s . italic_m start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ,  T  r  e  a  t . p 1 . m 1 formulae-sequence T r e a t subscript p 1 subscript m 1 Treat.p_{1}.m_{1} italic_T italic_r italic_e italic_a italic_t . italic_p start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT . italic_m start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ,  T  r  e  a  t . p 1 . m 2 formulae-sequence T r e a t subscript p 1 subscript m 2 Treat.p_{1}.m_{2} italic_T italic_r italic_e italic_a italic_t . italic_p start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT . italic_m start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ,  T  r  e  a  t . p 2 . m 1 formulae-sequence T r e a t subscript p 2 subscript m 1 Treat.p_{2}.m_{1} italic_T italic_r italic_e italic_a italic_t . italic_p start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT . italic_m start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , and  T  r  e  a  t . p 2 . m 2 formulae-sequence T r e a t subscript p 2 subscript m 2 Treat.p_{2}.m_{2} italic_T italic_r italic_e italic_a italic_t . italic_p start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT . italic_m start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT .",
            "To obtain a  PFG  from a given  FG , we need to find groups of identically behaving  randvars  and factors in the  FG . Then,  PRVs  with  logvars  represent such groups of indistinguishable  randvars  and  parfactors  represent groups of identical factors. Replacing indistinguishable  randvars  by  PRVs  with  logvars  further abstracts from individuals and thus yields a promising foundation for privacy guarantees  [ 12 ] . The  ACP  algorithm (which is a generalisation of the  colour passing  algorithm  [ 2 ,  15 ] ) is able to construct a  PFG  from a given propositional  FG   [ 23 ] . The idea behind  ACP  is to exploit symmetries in a propositional  FG  and then group together symmetric subgraphs.  \\Ac acp looks for symmetries based on potentials of factors, on ranges and evidence of  randvars , as well as on the graph structure by passing around colours. A formal description as well as an example run of the  ACP  algorithm can be found in  Appendix   0.B .  Figure   6  shows the  PFG  resulting from calling  ACP  on the  FG  depicted in  Fig.   5  under the assumption that all potentials of the factors   i subscript italic- i \\phi_{i} italic_ start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT ,  i  { 1 , ... , 4 } i 1 ... 4 i\\in\\{1,\\ldots,4\\} italic_i  { 1 , ... , 4 } , are considered identical. Note that the assumption of identical factors is just for the sake of the example as in general, not all potentials are identical (and hence, not all of the factors   i subscript italic- i \\phi_{i} italic_ start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT  are grouped into a single group)."
        ]
    },
    "id_table_7": {
        "caption": "",
        "table": "Pt0.A2.F8.pic1.49.49.49.49.49.49.49.49.49.49.49.49.39.29.21.7.7.7.7.7.7.7.7.7.7",
        "footnotes": [],
        "references": [
            "Take a look at the  FG  shown in  Fig.   5 . The  FG  results from the learning procedure described above applied to the database illustrated in  Fig.   4 . The potentials for, e.g.,   1 2 ( A g e . p 2 ) \\phi_{1}^{2}(Age.p_{2}) italic_ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ( italic_A italic_g italic_e . italic_p start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT )  are obtained by counting the occurrences of  A  g  e . p 2 < 18 formulae-sequence A g e subscript p 2 18 Age.p_{2}<18 italic_A italic_g italic_e . italic_p start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT < 18  and  A  g  e . p 2  18 formulae-sequence A g e subscript p 2 18 Age.p_{2}\\geq 18 italic_A italic_g italic_e . italic_p start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT  18  in the augmented full join shown in  Fig.   7  ( Appendix   0.A ). Recall that  C p 2 = { b  o  b , c  h  a  r  l  i  e , d  a  v  e } subscript C subscript p 2 b o b c h a r l i e d a v e C_{p_{2}}=\\{bob,charlie,dave\\} italic_C start_POSTSUBSCRIPT italic_p start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUBSCRIPT = { italic_b italic_o italic_b , italic_c italic_h italic_a italic_r italic_l italic_i italic_e , italic_d italic_a italic_v italic_e } . Thus, in this particular example, it holds that   1 2 ( A g e . p 2 < 18 ) = 5 \\phi_{1}^{2}(Age.p_{2}<18)=5 italic_ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ( italic_A italic_g italic_e . italic_p start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT < 18 ) = 5  and   1 2 ( A g e . p 2  18 ) = 10 \\phi_{1}^{2}(Age.p_{2}\\geq 18)=10 italic_ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ( italic_A italic_g italic_e . italic_p start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT  18 ) = 10 .",
            "We call the full join of the tables, where an additional column for each relationship is added and missing relationships are encoded by an additional row containing the value  f  a  l  s  e f a l s e false italic_f italic_a italic_l italic_s italic_e  in the corresponding relationship column, the  augmented full join . The augmented full join can therefore be thought of as a cross join with an additional column for each relationship, which contains a Boolean value indicating which relationships are present in the database. For example, the augmented full join of the tables given in the example from  Fig.   4  is illustrated in  Fig.   7 . In this particular example, the augmented full join contains the additional column  T  r  e  a  t T r e a t Treat italic_T italic_r italic_e italic_a italic_t , which contains the value  t  r  u  e t r u e true italic_t italic_r italic_u italic_e  if the relationship of a given combination of  P  a  t  i  e  n  t  I  d P a t i e n t I d PatientId italic_P italic_a italic_t italic_i italic_e italic_n italic_t italic_I italic_d  and  M  e  d  i  c  a  t  i  o  n  I  d M e d i c a t i o n I d MedicationId italic_M italic_e italic_d italic_i italic_c italic_a italic_t italic_i italic_o italic_n italic_I italic_d  in a specific row actually exists. Otherwise, the column  T  r  e  a  t T r e a t Treat italic_T italic_r italic_e italic_a italic_t  contains the value  f  a  l  s  e f a l s e false italic_f italic_a italic_l italic_s italic_e ."
        ]
    }
}