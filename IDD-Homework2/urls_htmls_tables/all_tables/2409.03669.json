{
    "id_table_1": {
        "caption": "",
        "table": "A3.EGx1",
        "footnotes": [],
        "references": [
            "A process curve is a finite time-series  C = ( Y  ( x ) ) x  I C subscript Y x x I C=(Y(x))_{x\\in I} italic_C = ( italic_Y ( italic_x ) ) start_POSTSUBSCRIPT italic_x  italic_I end_POSTSUBSCRIPT  with  Y  ( x )  R c Y x superscript R c Y(x)\\in\\mathbb{R}^{c} italic_Y ( italic_x )  blackboard_R start_POSTSUPERSCRIPT italic_c end_POSTSUPERSCRIPT  and  I  R I R I\\subset\\mathbb{R} italic_I  blackboard_R  a finite set, where  Y : R  R c : Y  R superscript R c Y:\\mathbb{R}\\to\\mathbb{R}^{c} italic_Y : blackboard_R  blackboard_R start_POSTSUPERSCRIPT italic_c end_POSTSUPERSCRIPT  represent physical properties of the process to be measured and  x x x italic_x  an independent variable, often the time (see Remark  2.1  for concrete examples). We call  c  N c N c\\in\\mathbb{N} italic_c  blackboard_N  the  dimension  of the process curve. Whenever a manufacturing process finishes its work on a component, a process curve is yielded. Thus, when the same process is executed on multiple parts sequentially, a sequence  C 1 , ... , C T subscript C 1 ... subscript C T C_{1},\\ldots,C_{T} italic_C start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , ... , italic_C start_POSTSUBSCRIPT italic_T end_POSTSUBSCRIPT  is obtained where each  C t subscript C t C_{t} italic_C start_POSTSUBSCRIPT italic_t end_POSTSUBSCRIPT  arises under slightly different physical conditions, i.e.,  C t = ( Y t  ( x ) ) x  I t subscript C t subscript subscript Y t x x subscript I t C_{t}=(Y_{t}(x))_{x\\in I_{t}} italic_C start_POSTSUBSCRIPT italic_t end_POSTSUBSCRIPT = ( italic_Y start_POSTSUBSCRIPT italic_t end_POSTSUBSCRIPT ( italic_x ) ) start_POSTSUBSCRIPT italic_x  italic_I start_POSTSUBSCRIPT italic_t end_POSTSUBSCRIPT end_POSTSUBSCRIPT . The different conditions can be due to different properties of the components or due to degradation and wareout effects of tools within the machine running the process. Also, the elements in  I t subscript I t I_{t} italic_I start_POSTSUBSCRIPT italic_t end_POSTSUBSCRIPT  can vary from execution to execution, for instance due to different offsets.",
            "Assuming no tool degradation but only component variance, we could assume that  w  ( t ) w t w(t) italic_w ( italic_t )  is sampled in each process from a fixed but unknown distribution on  R k superscript R k \\mathbb{R}^{k} blackboard_R start_POSTSUPERSCRIPT italic_k end_POSTSUPERSCRIPT , like  w  ( t )  N  ,  similar-to w t subscript N   w(t)\\sim\\mathcal{N}_{\\mu,\\sigma} italic_w ( italic_t )  caligraphic_N start_POSTSUBSCRIPT italic_ , italic_ end_POSTSUBSCRIPT  with fixed    R k  superscript R k \\mu\\in\\mathbb{R}^{k} italic_  blackboard_R start_POSTSUPERSCRIPT italic_k end_POSTSUPERSCRIPT  and    R k  k  superscript R k k \\sigma\\in\\mathbb{R}^{k\\times k} italic_  blackboard_R start_POSTSUPERSCRIPT italic_k  italic_k end_POSTSUPERSCRIPT  for all  t  [ T ] t delimited-[] T t\\in[T] italic_t  [ italic_T ] . Tool degradation, however, affects the curve substantially, often by letting certain  support points  of the curve move. For instance, in a staking process, the position and value of the maximal force, i.e., where the first derivative is zero, starts shifting (see Figure  1 ). Often, these support points can be formulated in terms of derivatives of  f f f italic_f . More formally, let   x i subscript superscript i x \\partial^{i}_{x}  start_POSTSUPERSCRIPT italic_i end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_x end_POSTSUBSCRIPT  be the  ( i ) i (i) ( italic_i ) -th derivative of  f f f italic_f  according to the second argument and let for  t  [ T ] t delimited-[] T t\\in[T] italic_t  [ italic_T ] ,  x i  ( t ) , y i  ( t )  R n i superscript x i t superscript y i t superscript R subscript n i x^{i}(t),y^{i}(t)\\in\\mathbb{R}^{n_{i}} italic_x start_POSTSUPERSCRIPT italic_i end_POSTSUPERSCRIPT ( italic_t ) , italic_y start_POSTSUPERSCRIPT italic_i end_POSTSUPERSCRIPT ( italic_t )  blackboard_R start_POSTSUPERSCRIPT italic_n start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT end_POSTSUPERSCRIPT  be such support points of the  t t t italic_t -curve  C t subscript C t C_{t} italic_C start_POSTSUBSCRIPT italic_t end_POSTSUBSCRIPT , i.e.:",
            "with  b = d b d b\\neq d italic_b = italic_d . That is, the mean of the support point drifts linearly from  b b b italic_b  to  d d d italic_d  between  t 0 subscript t 0 t_{0} italic_t start_POSTSUBSCRIPT 0 end_POSTSUBSCRIPT  and  t 1 subscript t 1 t_{1} italic_t start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT  (see also Figure  1 ).",
            "In this section, we explain the synthetization method of process curves. Here, we neither focus on how the  w  ( t ) w t w(t) italic_w ( italic_t )  behave in latent space, nor on how  f f f italic_f  is formulated exactly. Instead, our key idea is to model the behavior of support points over time and seek for parameters  w  ( t ) w t w(t) italic_w ( italic_t )  using non-linear optimization satisfying the support point conditions in ( 2.1 ). That way, we obtain a generic and controllable representation of the process curves that is capable of modelling physical transformations over time by letting the physically motivated support points drift over time. Without restricting generality and to keep notation simple, we will assume for the remainder that  c = 1 c 1 c=1 italic_c = 1 . The multivariate case is a straight-forward application of our approach by modeling each variable in  Y Y Y italic_Y  individually (see Remark  3.1 ). For this, let  f : R k  R  R : f  superscript R k R R f:\\mathbb{R}^{k}\\times\\mathbb{R}\\to\\mathbb{R} italic_f : blackboard_R start_POSTSUPERSCRIPT italic_k end_POSTSUPERSCRIPT  blackboard_R  blackboard_R  be an  l l l italic_l -times differentiable map and let for each  i  [ l ] i delimited-[] l i\\in[l] italic_i  [ italic_l ] ,  x i  R n i superscript x i superscript R subscript n i x^{i}\\in\\mathbb{R}^{n_{i}} italic_x start_POSTSUPERSCRIPT italic_i end_POSTSUPERSCRIPT  blackboard_R start_POSTSUPERSCRIPT italic_n start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT end_POSTSUPERSCRIPT  and  y i  R n i superscript y i superscript R subscript n i y^{i}\\in\\mathbb{R}^{n_{i}} italic_y start_POSTSUPERSCRIPT italic_i end_POSTSUPERSCRIPT  blackboard_R start_POSTSUPERSCRIPT italic_n start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT end_POSTSUPERSCRIPT  be two  n i subscript n i n_{i} italic_n start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT -dimensional vectors. We want to find  w  superscript w w^{*} italic_w start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT  such that",
            "Assuming that  f  C l + 2  ( R k  R ) f superscript C l 2 superscript R k R f\\in\\mathcal{C}^{l+2}(\\mathbb{R}^{k}\\times\\mathbb{R}) italic_f  caligraphic_C start_POSTSUPERSCRIPT italic_l + 2 end_POSTSUPERSCRIPT ( blackboard_R start_POSTSUPERSCRIPT italic_k end_POSTSUPERSCRIPT  blackboard_R ) , i.e.  f f f italic_f  is  l + 2 l 2 l+2 italic_l + 2 -times differentiable, and given  x i  R n i superscript x i superscript R subscript n i x^{i}\\in\\mathbb{R}^{n_{i}} italic_x start_POSTSUPERSCRIPT italic_i end_POSTSUPERSCRIPT  blackboard_R start_POSTSUPERSCRIPT italic_n start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT end_POSTSUPERSCRIPT  and  y i  R n i superscript y i superscript R subscript n i y^{i}\\in\\mathbb{R}^{n_{i}} italic_y start_POSTSUPERSCRIPT italic_i end_POSTSUPERSCRIPT  blackboard_R start_POSTSUPERSCRIPT italic_n start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT end_POSTSUPERSCRIPT  for each  i  [ l ] i delimited-[] l i\\in[l] italic_i  [ italic_l ] , we can solve ( 3.1 ) using second-order quasi-Newton methods  [ 6 , Chapter 3]  for the objective function",
            "which serves as a possible candidate for  D D {\\mathcal{D}} caligraphic_D . Clearly, if   1   2 subscript  1 subscript  2 \\tau_{1}\\geq\\tau_{2} italic_ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT  italic_ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , then  D ^  ( s ,  1 )  D ^  ( s ,  2 ) ^ D s subscript  1 ^ D s subscript  2 \\hat{\\mathcal{D}}(s,\\tau_{1})\\subseteq\\hat{\\mathcal{D}}(s,\\tau_{2}) over^ start_ARG caligraphic_D end_ARG ( italic_s , italic_ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT )  over^ start_ARG caligraphic_D end_ARG ( italic_s , italic_ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ) . Its also straight-forward to see that for every    \\tau italic_ , the set  D ^  ( s ,  ) ^ D s  \\hat{\\mathcal{D}}(s,\\tau) over^ start_ARG caligraphic_D end_ARG ( italic_s , italic_ )  decomposes uniquely into drift segments  D ^ 1 , ... , D ^ l subscript ^ D 1 ... subscript ^ D l \\hat{\\mathcal{D}}_{1},\\ldots,\\hat{\\mathcal{D}}_{l} over^ start_ARG caligraphic_D end_ARG start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , ... , over^ start_ARG caligraphic_D end_ARG start_POSTSUBSCRIPT italic_l end_POSTSUBSCRIPT  as defined in Definition  4.1  and that the length and number of these atomic segments depends on    \\tau italic_ . Now, to quantify the predictive power of the detector yielding  s s s italic_s , one needs to quantify how  close   D ^  ( s ,  ) ^ D s  \\hat{\\mathcal{D}}(s,\\cdot) over^ start_ARG caligraphic_D end_ARG ( italic_s ,  )  is to  D D {\\mathcal{D}} caligraphic_D  when    \\tau italic_  varies. There are many established set-theoretic measurements that are widely used in practice to quantify the distance between two finite and binary sets  A A A italic_A  and  B B B italic_B , like the Jaccard index  | A  B | | A  B | A B A B \\frac{|A\\cap B|}{|A\\cup B|} divide start_ARG | italic_A  italic_B | end_ARG start_ARG | italic_A  italic_B | end_ARG , the Hamming distance  | A  B | + | B  A | A B B A |A\\setminus B|+|B\\setminus A| | italic_A  italic_B | + | italic_B  italic_A | , or the Overlap coefficient  | A  B | min  ( | A | , | B | ) A B A B \\frac{|A\\cap B|}{\\min(|A|,|B|)} divide start_ARG | italic_A  italic_B | end_ARG start_ARG roman_min ( | italic_A | , | italic_B | ) end_ARG  just to name a few. Most scores, however, have as a build-in assumption that the elements of the set are iid and hence the temporal context is largely ignored making them unsuitable for process drift detection. Moreover, for most detectors we have to select a discrimination threshold    \\tau italic_ , making evaluation cumbersome as it requires to tune the threshold on a separate held-out dataset. Moreover, in most practical scenarios,  D D {\\mathcal{D}} caligraphic_D  is only a small subset and thus the evaluation metric has to consider highly imbalanced szenarios as well.",
            "Algorithm  1  illustrates in detail how the  Overlap score   OLS  ( D , s ,  ) OLS D s  \\textnormal{OLS}({\\mathcal{D}},s,\\tau) OLS ( caligraphic_D , italic_s , italic_ )  can be computed algorithmically.",
            "Next, we benchmark existing algorithms on data generated with our framework  driftbench  and reporting the TAUC 1 1 1 All datasets and algorithms used are available in the repository of  driftbench . . The goal of the benchmark is to provide a proof of concept for our score and data generation method, not to be very comprehensive on the model side. Thus, based on our literature research in Section  1  we have hand-selected a small set of typically used model patterns drift detectors used in practice consists of (see Section  5.1 ).",
            "We benchmark the algorithms listed in  5.1  on three different datasets (see Figure  6 ) created with our framework  driftbench , all designed to comprise different inherent challenges.",
            "should be smaller than zero. Here, we want it to be   1 1 -1 - 1 . Finally, we want to the curve to be concave at around  x =  1 x 1 x=-1 italic_x = - 1 . All in all, these conditions result into the following equations, some of them are visualized in Figure  10 :",
            "The first example we look at is a typical scenario that appears if window-based approaches are used, namely that the prediction lags a bit behind of the true window, but still the detector overlaps a significant proportion of the drift segment (see Figure  12 . Other than the TPR, the sOLS rewards these predictors and thus the sTAUC shows a larger value than the AUC.",
            "Another typical scenario is that a detector shows significantly large values at the start and end of the true drift segment, but sag in between (see Figure  13 ). This could appear when using methods based on detecting change points. In principal, the detector correctly identifies the temporal context of the drift segment, although showing lower scores while the curves drift. Such predictions also score higher values in the sTAUC than the AUC.",
            "A situation where the sTAUC coincides with the AUC mostly is in when only one true and predicted drift segment exist (see Figure  14 ). In cases where the center of the predicted segment coincides with the center of the true segment, the AUC and sTAUC match almost exactly when the length of the predicted segment is varied (see left graphic in Figure  15 ). If the predicted segment has fixed length that equals the length of the true segment and the position of its center is varied from  50 50 50 50  to  350 350 350 350 , AUC and sTAUC coincide mostly, but the sTAUC shows a faster rise when the predicted segment overlaps with the true segment due to the effects explained in Section  B.1 ."
        ]
    }
}