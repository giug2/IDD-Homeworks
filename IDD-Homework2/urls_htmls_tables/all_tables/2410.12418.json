{
    "id_table_1": {
        "caption": "Table 1:  Erdos-Renyi and Scale-free graphs.",
        "table": "S9.EGx1",
        "footnotes": [],
        "references": [
            "Sharing Knowledge Graphs.  Let us introduce our setting through a simple but relevant example from the Central Bank of Italy. Figure  1  shows a company ownership KG: the vertices represent companies and there is an edge from company  A A A italic_A  to company  B B B italic_B  with weight  w w w italic_w  when  A A A italic_A  owns a fraction  w w w italic_w  of the shares of  B B B italic_B . The notion of  company control  denotes that a company can exert decision power on another one. In Vadalog, this can be modeled as follows:",
            "The Bank of Italy wants to share the whole KG in Figure  1  with untrusted or anyway external financial organizations, along with the new control relationship (red dashed edges). At the same time, it would like to protect the identity of the involved companies  [ 40 ,  47 ] . More in general, central banks and financial institutions foster collaboration between the financial world and the academic community for institutional, research, and educational purposes, for which data, and hence KG sharing is of the essence. In our example, independently of the identities, the KG would enable external organisations to perform relevant analyses. For example, they could single out the Italian holdings having more than  K K K italic_K  controlled companies (e.g., company A in Figure  1  for  K = 2 K 2 K=2 italic_K = 2 , see also Example  1.2 ) and use them to train dedicated machine learning models to study the structure of the market, for instance by understanding whether the company is a family business or an entity managed by a professional investor; if its ultimate proprietor is within the EU area; if it pinpoints a market weakness by being likely subject to a takeover action, and many more, which are anyway beyond our scope.",
            "Figure  1  represents a company KG: the ground extensional component is denoted by the blue edges and nodes, the intensional component are the rules in Example  1.1 , and the dash red edges are the control relationships of the derived extensional component. The edges  ( A , D ) A D (A,D) ( italic_A , italic_D )  and  ( D , E ) D E (D,E) ( italic_D , italic_E )  are added because the blue links between such vertices have weights larger than  0.5 0.5 0.5 0.5 . Then the red edge  ( A , E ) A E (A,E) ( italic_A , italic_E )  is added because  A A A italic_A  controls  D D D italic_D , which owns  0.6 > 0.5 0.6 0.5 0.6>0.5 0.6 > 0.5  of shares of  E E E italic_E , and the red edge  ( A , B ) A B (A,B) ( italic_A , italic_B )  is added because  A A A italic_A  controls  E E E italic_E  and together the blue edges  ( A , B ) A B (A,B) ( italic_A , italic_B )  and  ( E , B ) E B (E,B) ( italic_E , italic_B )  have a weight of  0.65 > 0.5 0.65 0.5 0.65>0.5 0.65 > 0.5 .   \\hfill\\blacksquare",
            "Notice that since  E  (   ( G ) )  E E E  G E(\\Sigma(G))\\supseteq E italic_E ( roman_ ( italic_G ) )  italic_E , for every  X  V X V X\\subseteq V italic_X  italic_V  it holds that    ( G  [ X ] )    ( G )  [ X ]  G delimited-[] X  G delimited-[] X \\Sigma(G[X])\\subseteq\\Sigma(G)[X] roman_ ( italic_G [ italic_X ] )  roman_ ( italic_G ) [ italic_X ]  but they do not necessarily coincide, meaning that some derived edges in    ( G )  [ X ]  G delimited-[] X \\Sigma(G)[X] roman_ ( italic_G ) [ italic_X ]  may derive from information that it is not fully contained in  G  [ X ] G delimited-[] X G[X] italic_G [ italic_X ] . Indeed, in Figure  1 , if we consider  X = { A , B , E } X A B E X=\\{A,B,E\\} italic_X = { italic_A , italic_B , italic_E } , then    ( G  [ X ] )  G delimited-[] X \\Sigma(G[X]) roman_ ( italic_G [ italic_X ] )  comprises the edges  ( A , B ) A B (A,B) ( italic_A , italic_B )  and  ( E , B ) E B (E,B) ( italic_E , italic_B ) , while    ( G )  [ X ]  G delimited-[] X \\Sigma(G)[X] roman_ ( italic_G ) [ italic_X ]  has also the derived edges  ( A , B ) A B (A,B) ( italic_A , italic_B )  and  ( A , E ) A E (A,E) ( italic_A , italic_E ) ; therefore    ( G  [ X ] )  G delimited-[] X \\Sigma(G[X]) roman_ ( italic_G [ italic_X ] )  is a proper subgraph of    ( G )  [ X ]  G delimited-[] X \\Sigma(G)[X] roman_ ( italic_G ) [ italic_X ] .",
            "Items (1)(3) of Def.  4.1  are trivially fulfilled for the  ( k , x  ) k superscript x  (k,x^{\\prime}) ( italic_k , italic_x start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ) -isomorphism anonymisation. Let now consider  X   V superscript X  V X^{\\prime}\\subset V italic_X start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT  italic_V  such that  | X  | = x   x superscript X  superscript x  x |X^{\\prime}|=x^{\\prime}\\leq x | italic_X start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT | = italic_x start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT  italic_x  and  G  [ X  ] G delimited-[] superscript X  G[X^{\\prime}] italic_G [ italic_X start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ]  is weakly connected. Then there must exist  X 1  V subscript X 1 V X_{1}\\subseteq V italic_X start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT  italic_V  such that  X   X 1 superscript X  subscript X 1 X^{\\prime}\\subseteq X_{1} italic_X start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT  italic_X start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ,  | X 1 | = x subscript X 1 x |X_{1}|=x | italic_X start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT | = italic_x , and  G  [ X 1 ] G delimited-[] subscript X 1 G[X_{1}] italic_G [ italic_X start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ]  is weakly connected, since  G G G italic_G  is weakly connected. By hypothesis there exist  X 2 , X 3 , ... , X k  V A subscript X 2 subscript X 3 ... subscript X k subscript V A X_{2},X_{3},\\ldots,X_{k}\\subseteq V_{A} italic_X start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , italic_X start_POSTSUBSCRIPT 3 end_POSTSUBSCRIPT , ... , italic_X start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT  italic_V start_POSTSUBSCRIPT italic_A end_POSTSUBSCRIPT  of cardinality  x x x italic_x  that fulfil item (4). Then   2  ( X  ) , ... ,  k  ( X  ) subscript  2 superscript X  ... subscript  k superscript X  \\Phi_{2}(X^{\\prime}),\\dots,\\Phi_{k}(X^{\\prime}) roman_ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ( italic_X start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ) , ... , roman_ start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_X start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT )  fulfil item (4) of Definition  4.1  for the  ( k , x  ) k superscript x  (k,x^{\\prime}) ( italic_k , italic_x start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ) -isomorphism anonymisation, since    ( A  [ X  ] ) =   ( A )  [ X  ]  A delimited-[] superscript X   A delimited-[] superscript X  \\Sigma(A[X^{\\prime}])=\\Sigma(A)[X^{\\prime}] roman_ ( italic_A [ italic_X start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ] ) = roman_ ( italic_A ) [ italic_X start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ]  and    ( A  [  i  ( X  ) ] ) =   ( A )  [  i  ( X  ) ]  A delimited-[] subscript  i superscript X   A delimited-[] subscript  i superscript X  \\Sigma(A[\\Phi_{i}(X^{\\prime})])=\\Sigma(A)[\\Phi_{i}(X^{\\prime})] roman_ ( italic_A [ roman_ start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT ( italic_X start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ) ] ) = roman_ ( italic_A ) [ roman_ start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT ( italic_X start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ) ]  for all  i  [ k ] i delimited-[] k i\\in[k] italic_i  [ italic_k ] .",
            "Note that Proposition  4.1  can be violated if  G G G italic_G  is not weakly connected. In such a case, a  ( k , x ) k x (k,x) ( italic_k , italic_x ) -isomorphism anonymisation  A A A italic_A  does not guarantee that a weakly connected component  C C C italic_C  of size  x  < x superscript x  x x^{\\prime}<x italic_x start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT < italic_x  is isomorphic to  k  1 k 1 k-1 italic_k - 1  other subgraphs, as it is not contained in any weakly connected subgraphs of size  x x x italic_x . This problem can be overcome by performing a  ( k , x  ) k superscript x  (k,x^{\\prime}) ( italic_k , italic_x start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ) -isomorphism anonymisation on every weakly connected component  C C C italic_C  of  G G G italic_G , with  x  = min  { x , | C | } superscript x  x C x^{\\prime}=\\min\\{x,|C|\\} italic_x start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT = roman_min { italic_x , | italic_C | } .",
            "Coversely, the hypothesis of the NAG to be weakly connected could be removed. Indeed, suppose to have a  ( k , x ) k x (k,x) ( italic_k , italic_x ) -isomorphism anonymisation  A A A italic_A  of  G G G italic_G  and a NAG of size  x x x italic_x  not weakly connected. Let  C 1 , ... , C m subscript C 1 ... subscript C m C_{1},\\dots,C_{m} italic_C start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , ... , italic_C start_POSTSUBSCRIPT italic_m end_POSTSUBSCRIPT  be its weakly connected components with  | C j | = x j subscript C j subscript x j |C_{j}|=x_{j} | italic_C start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT | = italic_x start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT  for  j  [ m ] j delimited-[] m j\\in[m] italic_j  [ italic_m ] : then each  C j subscript C j C_{j} italic_C start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT  is a weakly connected NAG with  x j < x subscript x j x x_{j}<x italic_x start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT < italic_x . By Proposition  4.1 ,  A A A italic_A  is anonymised for any of such components, hence it is resistant to the original attack. In view of this, a NAG that is not weakly connected can be equivalently seen as a sequence  C 1 , ... , C m subscript C 1 ... subscript C m C_{1},\\dots,C_{m} italic_C start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , ... , italic_C start_POSTSUBSCRIPT italic_m end_POSTSUBSCRIPT  of weakly connected NAGs of smaller size.",
            "Algorithm  1  introduces KLONE, our first method to obtain a  ( k , x ) k x (k,x) ( italic_k , italic_x ) -isomorphism anonymisation of a KG. In particular, the anonymised graph  A A A italic_A  in output is a  ( k , x ) k x (k,x) ( italic_k , italic_x ) -isomorphism anonymisation of the input KG for every  x  [ n ] x delimited-[] n x\\in[n] italic_x  [ italic_n ] ; in other words,  A A A italic_A  is robust to the NAG attack regardless of the NAG size. The anonymised graph is constructed by: (a) noising the edge weights of the original KG while optimizing the utility metric  U  subscript U  \\mathcal{U}_{\\bigtriangleup} caligraphic_U start_POSTSUBSCRIPT  end_POSTSUBSCRIPT ; (b) augmenting the KG to guarantee the  k k k italic_k  isomorphisms per each induced subgraph; (c) adding synthetic edges to reach diversity of in- and out-degrees; (d) anonymising the vertex labels (e) assign the weights to the synthetic edges while again optimizing  U  subscript U  \\mathcal{U}_{\\bigtriangleup} caligraphic_U start_POSTSUBSCRIPT  end_POSTSUBSCRIPT .",
            "If the degree distributions  p i  n subscript p i n p_{in} italic_p start_POSTSUBSCRIPT italic_i italic_n end_POSTSUBSCRIPT  and  p o  u  t subscript p o u t p_{out} italic_p start_POSTSUBSCRIPT italic_o italic_u italic_t end_POSTSUBSCRIPT  have support in  [ n ] delimited-[] n [n] [ italic_n ] , then the anonymised graph  A A A italic_A  output of Algorithm  1  is such that  k  n  | V  ( A ) |  2  k  n + 1 k n V A 2 k n 1 kn\\leq|V(A)|\\leq 2kn+1 italic_k italic_n  | italic_V ( italic_A ) |  2 italic_k italic_n + 1 .",
            "By  line 3  of Algorithm  1  it is clear that  | V  ( A ) |  k  n V A k n |V(A)|\\geq kn | italic_V ( italic_A ) |  italic_k italic_n , as every copy  G j superscript G j G^{j} italic_G start_POSTSUPERSCRIPT italic_j end_POSTSUPERSCRIPT  has cardinality equal to  n n n italic_n  and no vertex is ever removed by the algorithm. To prove the other inequality, we need to show that the set  W = V  ( A )   i , j v i j W V A subscript i j superscript subscript v i j W=V(A)\\setminus\\bigcup_{i,j}v_{i}^{j} italic_W = italic_V ( italic_A )   start_POSTSUBSCRIPT italic_i , italic_j end_POSTSUBSCRIPT italic_v start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_j end_POSTSUPERSCRIPT , i.e. the set of new vertices that have been added to the graph in each iteration of  lines 14-16 , has at most  k  n + 1 k n 1 kn+1 italic_k italic_n + 1  elements. Let  D out subscript D out D_{{}_{\\text{out}}} italic_D start_POSTSUBSCRIPT start_FLOATSUBSCRIPT out end_FLOATSUBSCRIPT end_POSTSUBSCRIPT  be the maximum out-degree that has been assigned to a vertex  v i j superscript subscript v i j v_{i}^{j} italic_v start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_j end_POSTSUPERSCRIPT  for  i  [ n ] i delimited-[] n i\\in[n] italic_i  [ italic_n ]  and  j  [ k ] j delimited-[] k j\\in[k] italic_j  [ italic_k ] , and similarly  D in subscript D in D_{{}_{\\text{in}}} italic_D start_POSTSUBSCRIPT start_FLOATSUBSCRIPT in end_FLOATSUBSCRIPT end_POSTSUBSCRIPT  for the in-degree. The key observation is that  | W |  D = max  { D in , D out } W D subscript D in subscript D out |W|\\leq D=\\max\\{D_{{}_{\\text{in}}},D_{{}_{\\text{out}}}\\} | italic_W |  italic_D = roman_max { italic_D start_POSTSUBSCRIPT start_FLOATSUBSCRIPT in end_FLOATSUBSCRIPT end_POSTSUBSCRIPT , italic_D start_POSTSUBSCRIPT start_FLOATSUBSCRIPT out end_FLOATSUBSCRIPT end_POSTSUBSCRIPT } . Indeed by adding  D D D italic_D  new vertices, each  v i j superscript subscript v i j v_{i}^{j} italic_v start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_j end_POSTSUPERSCRIPT  could link to (a subset of) these vertices to meet their prescribed in- and out-degrees. It then suffices to prove that  D  k  n + 1 D k n 1 D\\leq kn+1 italic_D  italic_k italic_n + 1 . The assigned out-degree of  v i j superscript subscript v i j v_{i}^{j} italic_v start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_j end_POSTSUPERSCRIPT  depends on its current out-degree  d A out  ( v i j ) superscript subscript d A out superscript subscript v i j d_{{}_{A}}^{\\text{out}}(v_{i}^{j}) italic_d start_POSTSUBSCRIPT start_FLOATSUBSCRIPT italic_A end_FLOATSUBSCRIPT end_POSTSUBSCRIPT start_POSTSUPERSCRIPT out end_POSTSUPERSCRIPT ( italic_v start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_j end_POSTSUPERSCRIPT )  in the graph  A A A italic_A  and on the value  z z z italic_z  drawn from the distribution  p out subscript p out p_{{}_{\\text{out}}} italic_p start_POSTSUBSCRIPT start_FLOATSUBSCRIPT out end_FLOATSUBSCRIPT end_POSTSUBSCRIPT  ( line 11 ). The maximum value that  z z z italic_z  can attain is  n n n italic_n  by hypothesis. Notice that at each iteration  i i i italic_i  in  line 5  and  j j j italic_j  in  line 7 , the only edges that are added to the graph are the ones to/from  v i j superscript subscript v i j v_{i}^{j} italic_v start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_j end_POSTSUPERSCRIPT  ( lines 18-19 ). In adding them, no multiple edges are allowed, as we are excluding from the set of candidates  C C \\mathcal{C} caligraphic_C  of  v i j superscript subscript v i j v_{i}^{j} italic_v start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_j end_POSTSUPERSCRIPT  its in-/out-neighbours ( line 13 ). This implies that  d A out  ( v i j ) superscript subscript d A out superscript subscript v i j d_{{}_{A}}^{\\text{out}}(v_{i}^{j}) italic_d start_POSTSUBSCRIPT start_FLOATSUBSCRIPT italic_A end_FLOATSUBSCRIPT end_POSTSUBSCRIPT start_POSTSUPERSCRIPT out end_POSTSUPERSCRIPT ( italic_v start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_j end_POSTSUPERSCRIPT )  can be at most  M  ( i , j ) = n + ( i  1 )  k + j  i M i j n i 1 k j i M(i,j)=n+(i-1)k+j-i italic_M ( italic_i , italic_j ) = italic_n + ( italic_i - 1 ) italic_k + italic_j - italic_i , since  n n n italic_n  is the maximum out-degree that  v i j superscript subscript v i j v_{i}^{j} italic_v start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_j end_POSTSUPERSCRIPT  can have within  G j superscript G j G^{j} italic_G start_POSTSUPERSCRIPT italic_j end_POSTSUPERSCRIPT  and  ( i  1 )  ( k  1 ) + j  1 = ( i  1 )  k + j  i i 1 k 1 j 1 i 1 k j i (i-1)(k-1)+j-1=(i-1)k+j-i ( italic_i - 1 ) ( italic_k - 1 ) + italic_j - 1 = ( italic_i - 1 ) italic_k + italic_j - italic_i  is the number of vertices not in  V  ( G j ) V superscript G j V(G^{j}) italic_V ( italic_G start_POSTSUPERSCRIPT italic_j end_POSTSUPERSCRIPT )  that the algorithm have already explored in the past iterations (the cardinality of  V V \\mathcal{V} caligraphic_V ). Since  M  ( i , j )  n M i j n M(i,j)\\geq n italic_M ( italic_i , italic_j )  italic_n , we have that  max  { d A out  ( v i j ) + 1 , z  p out }  M  ( i , j ) + 1 = n + i  ( k  1 ) + j  k + 1 superscript subscript d A out superscript subscript v i j 1 similar-to z subscript p out M i j 1 n i k 1 j k 1 \\max\\{d_{{}_{A}}^{\\text{out}}(v_{i}^{j})+1,z\\sim p_{{}_{\\text{out}}}\\}\\leq M(i% ,j)+1=n+i(k-1)+j-k+1 roman_max { italic_d start_POSTSUBSCRIPT start_FLOATSUBSCRIPT italic_A end_FLOATSUBSCRIPT end_POSTSUBSCRIPT start_POSTSUPERSCRIPT out end_POSTSUPERSCRIPT ( italic_v start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_j end_POSTSUPERSCRIPT ) + 1 , italic_z  italic_p start_POSTSUBSCRIPT start_FLOATSUBSCRIPT out end_FLOATSUBSCRIPT end_POSTSUBSCRIPT }  italic_M ( italic_i , italic_j ) + 1 = italic_n + italic_i ( italic_k - 1 ) + italic_j - italic_k + 1 . Notice that  M  ( i , j ) M i j M(i,j) italic_M ( italic_i , italic_j )  is strictly increasing both in  i i i italic_i  and  j j j italic_j , thus reaching the maximum value of  k  n + 1 k n 1 kn+1 italic_k italic_n + 1  for  i = n i n i=n italic_i = italic_n  and  j = k j k j=k italic_j = italic_k , corresponding to the vertex  v n k superscript subscript v n k v_{n}^{k} italic_v start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_k end_POSTSUPERSCRIPT . Moreover, for fixed  i i i italic_i , it assumes all different values as  j j j italic_j  varies in  [ k ] delimited-[] k [k] [ italic_k ] , as required in the  while  loop in  lines 10-11 . Therefore we have that  D out  k  n + 1 subscript D out k n 1 D_{{}_{\\text{out}}}\\leq kn+1 italic_D start_POSTSUBSCRIPT start_FLOATSUBSCRIPT out end_FLOATSUBSCRIPT end_POSTSUBSCRIPT  italic_k italic_n + 1 . The same reasoning holds for  D in subscript D in D_{{}_{\\text{in}}} italic_D start_POSTSUBSCRIPT start_FLOATSUBSCRIPT in end_FLOATSUBSCRIPT end_POSTSUBSCRIPT , thus we have that  k  n + 1  D  | W | k n 1 D W kn+1\\geq D\\geq|W| italic_k italic_n + 1  italic_D  | italic_W | .",
            "Algorithm  1  returns a  ( k , x ) k x (k,x) ( italic_k , italic_x ) -isomorphism anonymisation of the input Knowledge Graph for every  x  [ n ] x delimited-[] n x\\in[n] italic_x  [ italic_n ] . Moreover, it runs in  O  ( M  k 2  n 2 ) O M superscript k 2 superscript n 2 O(Mk^{2}n^{2}) italic_O ( italic_M italic_k start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT italic_n start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT )  time, under the hypothesis that the computation of the utility metric  U  subscript U  \\mathcal{U}_{\\Delta} caligraphic_U start_POSTSUBSCRIPT roman_ end_POSTSUBSCRIPT  is  O  ( 1 ) O 1 O(1) italic_O ( 1 )  and the distributions  p i  n subscript p i n p_{in} italic_p start_POSTSUBSCRIPT italic_i italic_n end_POSTSUBSCRIPT  and  p o  u  t subscript p o u t p_{out} italic_p start_POSTSUBSCRIPT italic_o italic_u italic_t end_POSTSUBSCRIPT  have support in  [ n ] delimited-[] n [n] [ italic_n ] .",
            "Correctness.  We need to show that each item of Definition  4.1  is fulfilled by the output  A A A italic_A  of the algorithm, for every  x  [ n ] x delimited-[] n x\\in[n] italic_x  [ italic_n ] . The graph  G G G italic_G  is copied  k k k italic_k  times in  A A A italic_A  (weights included) in  line 3  and no vertex or edge is ever deleted by the algorithm, so item (1) of Definition  4.1  is fulfilled, as well as item (2) by  line 21  and item (3) by  line 1 . Let  G 1 , ... , G k superscript G 1 ... superscript G k G^{1},\\dots,G^{k} italic_G start_POSTSUPERSCRIPT 1 end_POSTSUPERSCRIPT , ... , italic_G start_POSTSUPERSCRIPT italic_k end_POSTSUPERSCRIPT  be the copies of  G G G italic_G  with  V  ( G j ) = { v 1 j , ... , v n j } V superscript G j subscript superscript v j 1 ... subscript superscript v j n V(G^{j})=\\{v^{j}_{1},\\dots,v^{j}_{n}\\} italic_V ( italic_G start_POSTSUPERSCRIPT italic_j end_POSTSUPERSCRIPT ) = { italic_v start_POSTSUPERSCRIPT italic_j end_POSTSUPERSCRIPT start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , ... , italic_v start_POSTSUPERSCRIPT italic_j end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT }  for  j  [ k ] j delimited-[] k j\\in[k] italic_j  [ italic_k ] . Consider the function   j : V  ( G 1 )  V  ( G j ) : subscript  j  V superscript G 1 V superscript G j \\Phi_{j}:V(G^{1})\\to V(G^{j}) roman_ start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT : italic_V ( italic_G start_POSTSUPERSCRIPT 1 end_POSTSUPERSCRIPT )  italic_V ( italic_G start_POSTSUPERSCRIPT italic_j end_POSTSUPERSCRIPT )  such that   j  ( v i 1 ) = v i j subscript  j subscript superscript v 1 i subscript superscript v j i \\Phi_{j}(v^{1}_{i})=v^{j}_{i} roman_ start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT ( italic_v start_POSTSUPERSCRIPT 1 end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT ) = italic_v start_POSTSUPERSCRIPT italic_j end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT  for each  i  [ n ] i delimited-[] n i\\in[n] italic_i  [ italic_n ] . Given  x  [ n ] x delimited-[] n x\\in[n] italic_x  [ italic_n ]  and  X 1 subscript X 1 X_{1} italic_X start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT  a set of  x x x italic_x  vertices of  G 1 superscript G 1 G^{1} italic_G start_POSTSUPERSCRIPT 1 end_POSTSUPERSCRIPT  such that  G 1  [ X 1 ] superscript G 1 delimited-[] subscript X 1 G^{1}[X_{1}] italic_G start_POSTSUPERSCRIPT 1 end_POSTSUPERSCRIPT [ italic_X start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ]  is weakly connected, the function   j | X 1 : X 1   j  ( X 1 )  V  ( G j ) \\Phi_{j_{|_{X_{1}}}}:X_{1}\\to\\Phi_{j}(X_{1})\\subseteq V(G^{j}) roman_ start_POSTSUBSCRIPT italic_j start_POSTSUBSCRIPT | start_POSTSUBSCRIPT italic_X start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUBSCRIPT end_POSTSUBSCRIPT end_POSTSUBSCRIPT : italic_X start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT  roman_ start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT ( italic_X start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT )  italic_V ( italic_G start_POSTSUPERSCRIPT italic_j end_POSTSUPERSCRIPT )  is a KG-isomorphism between  ( A  [ X 1 ] ,  ) A delimited-[] subscript X 1  (A[X_{1}],\\Sigma) ( italic_A [ italic_X start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ] , roman_ )  and  ( A  [  j  ( X 1 ) ] ,  ) A delimited-[] subscript  j subscript X 1  (A[\\Phi_{j}(X_{1})],\\Sigma) ( italic_A [ roman_ start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT ( italic_X start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ) ] , roman_ ) . Indeed the algorithm does not add edges between vertices of the same copy of  G G G italic_G  ( line 13 ), so it does not modify the topology of the induced subgraphs, meeting conditions ( 4 ) and ( 5 ) of KG-isomorphism. Moreover, by construction  X 1   j  ( X 1 ) =  subscript X 1 subscript  j subscript X 1 X_{1}\\cap\\Phi_{j}(X_{1})=\\emptyset italic_X start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT  roman_ start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT ( italic_X start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ) =  , thus items (4i) and (4ii) are satisfied. We are left with verifying item (4iii). The  while  loop in  lines 10-11  guarantees that, given  i  [ n ] i delimited-[] n i\\in[n] italic_i  [ italic_n ] , to each vertex in the set  { v i 1 , ... , v i k } subscript superscript v 1 i ... subscript superscript v k i \\{v^{1}_{i},\\dots,v^{k}_{i}\\} { italic_v start_POSTSUPERSCRIPT 1 end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT , ... , italic_v start_POSTSUPERSCRIPT italic_k end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT }  is associated a different out-degree and a different in-degree. This implies that   A  (  j  ( v i j ) ) =  A  (  j   ( v i j  ) ) subscript  A subscript  j subscript superscript v j i subscript  A subscript  superscript j  subscript superscript v superscript j  i \\xi_{{}_{A}}(\\Phi_{j}(v^{j}_{i}))\\neq\\xi_{{}_{A}}(\\Phi_{j^{\\prime}}(v^{j^{% \\prime}}_{i})) italic_ start_POSTSUBSCRIPT start_FLOATSUBSCRIPT italic_A end_FLOATSUBSCRIPT end_POSTSUBSCRIPT ( roman_ start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT ( italic_v start_POSTSUPERSCRIPT italic_j end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT ) ) = italic_ start_POSTSUBSCRIPT start_FLOATSUBSCRIPT italic_A end_FLOATSUBSCRIPT end_POSTSUBSCRIPT ( roman_ start_POSTSUBSCRIPT italic_j start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT end_POSTSUBSCRIPT ( italic_v start_POSTSUPERSCRIPT italic_j start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT ) )  for all  j = j  j superscript j  j\\neq j^{\\prime} italic_j = italic_j start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , thus satisfying item (4iii).  Computational time.  The computational time of the function  WeightNoising  (Algorithm  2 ) is  O  ( M  | S | ) O M S O(M|S|) italic_O ( italic_M | italic_S | ) , as the weight of each element of  S S S italic_S , the edge set in input, is updated  M M M italic_M  times. Therefore  line 1  of Algorithm  1  runs in  O  ( M  n 2 ) O M superscript n 2 O(Mn^{2}) italic_O ( italic_M italic_n start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT )  since  | E |  n 2 E superscript n 2 |E|\\leq n^{2} | italic_E |  italic_n start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT . As for  line 22 , let  V  ( A ) =  j V  ( G j )  W V A subscript j V subscript G j W V(A)=\\bigcup_{j}V(G_{j})\\cup W italic_V ( italic_A ) =  start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT italic_V ( italic_G start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT )  italic_W ; by the proof of Lemma  5.1  we have that  | W |  k  n + 1 W k n 1 |W|\\leq kn+1 | italic_W |  italic_k italic_n + 1 . We have already observed that Algorithm  1  ( lines 1319 ) adds edges only between  V  ( G j ) V subscript G j V(G_{j}) italic_V ( italic_G start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT )  and  V  ( G j  ) V subscript G superscript j  V(G_{j^{\\prime}}) italic_V ( italic_G start_POSTSUBSCRIPT italic_j start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT end_POSTSUBSCRIPT )  with  j = j  j superscript j  j\\neq j^{\\prime} italic_j = italic_j start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , i.e. between vertices that belong to two different copies of  G G G italic_G , and between   j V  ( G j ) subscript j V subscript G j \\bigcup_{j}V(G_{j})  start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT italic_V ( italic_G start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT )  and  W W W italic_W . Consequently, in the first case it can add a maximum of  ( k  1 )  k  n 2 k 1 k superscript n 2 (k-1)kn^{2} ( italic_k - 1 ) italic_k italic_n start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT  edges, while in the second case it can add up to  2  k  n  ( k  n + 1 ) 2 k n k n 1 2kn(kn+1) 2 italic_k italic_n ( italic_k italic_n + 1 )  edges. Therefore we have that  | S |  ( k  1 )  k  n 2 + 2  k  n  ( k  n + 1 ) S k 1 k superscript n 2 2 k n k n 1 |S|\\leq(k-1)kn^{2}+2kn(kn+1) | italic_S |  ( italic_k - 1 ) italic_k italic_n start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT + 2 italic_k italic_n ( italic_k italic_n + 1 )  and so the computational time of the function  WeightNoising  in  line 22  is  O  ( M  k 2  n 2 ) O M superscript k 2 superscript n 2 O(Mk^{2}n^{2}) italic_O ( italic_M italic_k start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT italic_n start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) . Lets now focus on the remaining parts of the algorithm.  Lines 24  clearly have a run time of  O  ( k  n ) O k n O(kn) italic_O ( italic_k italic_n ) . We claim that, for fixed  i i i italic_i  and  j j j italic_j , the maximum number of iterations that the  while  loop in  lines 1011  can do is  n + k n k n+k italic_n + italic_k . Indeed suppose that  d A   ( v i j ) superscript subscript d A  superscript subscript v i j d_{{}_{A}}^{\\varphi}(v_{i}^{j}) italic_d start_POSTSUBSCRIPT start_FLOATSUBSCRIPT italic_A end_FLOATSUBSCRIPT end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_ end_POSTSUPERSCRIPT ( italic_v start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_j end_POSTSUPERSCRIPT )  is equal to some   j   superscript subscript  superscript j   \\delta_{j^{\\prime}}^{\\varphi} italic_ start_POSTSUBSCRIPT italic_j start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_ end_POSTSUPERSCRIPT  for  j  < j superscript j  j j^{\\prime}<j italic_j start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT < italic_j , so that we enter the  while  loop. Let  {  1  , ... ,  j  1  } subscript superscript   1 ... subscript superscript   j 1 \\{\\delta^{\\varphi}_{1},\\dots,\\delta^{\\varphi}_{j-1}\\} { italic_ start_POSTSUPERSCRIPT italic_ end_POSTSUPERSCRIPT start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , ... , italic_ start_POSTSUPERSCRIPT italic_ end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_j - 1 end_POSTSUBSCRIPT }  be the already assigned degrees; we have three cases:",
            "If (i) holds,  max  {  j  + 1 , z  p  } =  j  + 1 superscript subscript  j  1 similar-to z subscript p  superscript subscript  j  1 \\max\\{\\delta_{j}^{\\varphi}+1,z\\sim p_{\\varphi}\\}=\\delta_{j}^{\\varphi}+1 roman_max { italic_ start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_ end_POSTSUPERSCRIPT + 1 , italic_z  italic_p start_POSTSUBSCRIPT italic_ end_POSTSUBSCRIPT } = italic_ start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_ end_POSTSUPERSCRIPT + 1 ; therefore, since at every iteration   j  superscript subscript  j  \\delta_{j}^{\\varphi} italic_ start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_ end_POSTSUPERSCRIPT  is increased by  1 1 1 1 , in at most  j  2 j 2 j-2 italic_j - 2  iterations we exit the  while  loop. If (ii) holds, the worst case is achieved when  z = n z n z=n italic_z = italic_n  in each draw from the distribution  p  subscript p  p_{\\varphi} italic_p start_POSTSUBSCRIPT italic_ end_POSTSUBSCRIPT  and   s  = n subscript superscript   s n \\delta^{\\varphi}_{s}=n italic_ start_POSTSUPERSCRIPT italic_ end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_s end_POSTSUBSCRIPT = italic_n  for some  s  [ j  1 ] s delimited-[] j 1 s\\in[j-1] italic_s  [ italic_j - 1 ] . This implies that  max  {  j  + 1 , z  p  } = z superscript subscript  j  1 similar-to z subscript p  z \\max\\{\\delta_{j}^{\\varphi}+1,z\\sim p_{\\varphi}\\}=z roman_max { italic_ start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_ end_POSTSUPERSCRIPT + 1 , italic_z  italic_p start_POSTSUBSCRIPT italic_ end_POSTSUBSCRIPT } = italic_z  until   j  > n superscript subscript  j  n \\delta_{j}^{\\varphi}>n italic_ start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_ end_POSTSUPERSCRIPT > italic_n , which is achieved in at most  n  1 n 1 n-1 italic_n - 1  iterations. Finally for case (iii), if  d A   ( v i j ) > n superscript subscript d A  superscript subscript v i j n d_{{}_{A}}^{\\varphi}(v_{i}^{j})>n italic_d start_POSTSUBSCRIPT start_FLOATSUBSCRIPT italic_A end_FLOATSUBSCRIPT end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_ end_POSTSUPERSCRIPT ( italic_v start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_j end_POSTSUPERSCRIPT ) > italic_n  we conclude as in case (i), where the number of iterations is upper-bounded by  j  2 j 2 j-2 italic_j - 2 . If  d A   ( v i j )  n superscript subscript d A  superscript subscript v i j n d_{{}_{A}}^{\\varphi}(v_{i}^{j})\\leq n italic_d start_POSTSUBSCRIPT start_FLOATSUBSCRIPT italic_A end_FLOATSUBSCRIPT end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_ end_POSTSUPERSCRIPT ( italic_v start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_j end_POSTSUPERSCRIPT )  italic_n , the worst case is achieved when  d A   ( v i j ) = 1 =  1  superscript subscript d A  superscript subscript v i j 1 superscript subscript  1  d_{{}_{A}}^{\\varphi}(v_{i}^{j})=1=\\delta_{1}^{\\varphi} italic_d start_POSTSUBSCRIPT start_FLOATSUBSCRIPT italic_A end_FLOATSUBSCRIPT end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_ end_POSTSUPERSCRIPT ( italic_v start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_j end_POSTSUPERSCRIPT ) = 1 = italic_ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_ end_POSTSUPERSCRIPT ,  z = n =  2  z n superscript subscript  2  z=n=\\delta_{2}^{\\varphi} italic_z = italic_n = italic_ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_ end_POSTSUPERSCRIPT  in each draw from the distribution  p  subscript p  p_{\\varphi} italic_p start_POSTSUBSCRIPT italic_ end_POSTSUBSCRIPT  and   s  = n + s  2 superscript subscript  s  n s 2 \\delta_{s}^{\\varphi}=n+s-2 italic_ start_POSTSUBSCRIPT italic_s end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_ end_POSTSUPERSCRIPT = italic_n + italic_s - 2  for each  s = 3 , ... , j  1 s 3 ... j 1 s=3,\\dots,j-1 italic_s = 3 , ... , italic_j - 1 . In this case the  while  loop must do  n + j  3 n j 3 n+j-3 italic_n + italic_j - 3  iterations before exiting, i.e. when   j  superscript subscript  j  \\delta_{j}^{\\varphi} italic_ start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_ end_POSTSUPERSCRIPT  reaches the value  n + j  3 n j 3 n+j-3 italic_n + italic_j - 3 . Since  j  k j k j\\leq k italic_j  italic_k , we conclude that  lines 10-11  iterate at most  n + k n k n+k italic_n + italic_k  times. Finally, by Lemma  5.1  we have that  | C |  2  k  n + 1 C 2 k n 1 |\\mathcal{C}|\\leq 2kn+1 | caligraphic_C |  2 italic_k italic_n + 1  in  line 13 . By the same Lemma, the total number of vertices added by the algorithm is at most  k  n + 1 k n 1 kn+1 italic_k italic_n + 1  and so the total number of edges added is  O  ( k 2  n 2 ) O superscript k 2 superscript n 2 O(k^{2}n^{2}) italic_O ( italic_k start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT italic_n start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) , which describe the overall computational time of  lines 1419 . Therefore the  for  loop in  lines 520  runs in  O  ( 2  n  k  ( n + k + 2  k  n + 1 ) ) + O  ( k 2  n 2 ) = O  ( k 2  n 2 ) O 2 n k n k 2 k n 1 O superscript k 2 superscript n 2 O superscript k 2 superscript n 2 O(2nk(n+k+2kn+1))+O(k^{2}n^{2})=O(k^{2}n^{2}) italic_O ( 2 italic_n italic_k ( italic_n + italic_k + 2 italic_k italic_n + 1 ) ) + italic_O ( italic_k start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT italic_n start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) = italic_O ( italic_k start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT italic_n start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) . Since  line 21  runs in  O  ( k  n ) O k n O(kn) italic_O ( italic_k italic_n ) , the total computational time is  O  ( M  k 2  n 2 ) O M superscript k 2 superscript n 2 O(Mk^{2}n^{2}) italic_O ( italic_M italic_k start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT italic_n start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) .",
            "From each bucket  B  B B B \\mathcal{B}\\in\\mathbb{B} caligraphic_B  blackboard_B  we want to choose  k k k italic_k  KG-isomorphic subgraphs with pairwise disjoint set of vertices ( lines 49 ). If the bucket  B B \\mathcal{B} caligraphic_B  has less than  k k k italic_k  vertex-disjoint subgraphs, we copy (and add to  A A A italic_A ) some of them until reaching  k k k italic_k  vertex-disjoint subgraphs ( lines 68 ). After this process, we leave in each bucket only the  k k k italic_k  chosen subgraphs ( line 9 ): they will be the ones fulfilling item (4) of Definition  4.1  of KG-isomorphism. We call  V V \\mathcal{V} caligraphic_V  the set of all the vertices appearing in at least a subgraph of a bucket: these are the vertices for which we want to guarantee the diversity of the sensitive attributes    \\xi italic_ . In  line 10  we ensure that the new graph  A A A italic_A  is weakly connected by randomly adding a synthetic edge between the original graph and each other weakly connected component. At the end of this part, each subgraph of the input KG  G G G italic_G  of cardinality  x x x italic_x  has other  k  1 k 1 k-1 italic_k - 1  subgraphs in  A A A italic_A  that are KG-isomorphic to it.",
            "Lines 1630  add the necessary synthetic edges to meet the in- and out- degrees assigned in the previous step, thus making  A A A italic_A  satisfying condition (4iii) of the (k,x)-isomorphism anonymization in Definition  4.1 . For each  v  V v V v\\in\\mathcal{V} italic_v  caligraphic_V  we aim at selecting a set  C C \\mathcal{C} caligraphic_C  of candidate vertices from (to) which add    \\Delta roman_  new edges to (from)  v v v italic_v  in order to achieve the chosen in-(out-) degree. Such set  C C \\mathcal{C} caligraphic_C  is made of all the vertices  u u u italic_u  of the graph such that (i) its current out-(in-) degree  d A    ( u ) superscript subscript d A  u d_{A}^{\\neg\\varphi}(u) italic_d start_POSTSUBSCRIPT italic_A end_POSTSUBSCRIPT start_POSTSUPERSCRIPT  italic_ end_POSTSUPERSCRIPT ( italic_u )  is less that the assigned one  D    ( u ) superscript D  u D^{\\neg\\varphi}(u) italic_D start_POSTSUPERSCRIPT  italic_ end_POSTSUPERSCRIPT ( italic_u ) , so that they have space for new synthetic out- (in-)coming edges ( line 19 , where   i  n = o  u  t i n o u t \\neg in=out  italic_i italic_n = italic_o italic_u italic_t  and   o  u  t = i  n o u t i n \\neg out=in  italic_o italic_u italic_t = italic_i italic_n ), (ii) it does not belong to any of the subgraphs  H H H italic_H  appearing in the buckets for which  v  V  ( H ) v V H v\\in V(H) italic_v  italic_V ( italic_H )  ( line 20 ) and (iii) there does not already exist an edge between  v v v italic_v  and  u u u italic_u  ( line 20 ). Item (i) is important for not exceeding  D    ( u ) superscript D  u D^{\\neg\\varphi}(u) italic_D start_POSTSUPERSCRIPT  italic_ end_POSTSUPERSCRIPT ( italic_u ) , while point (ii) is crucial for not breaking the isomorphism between subgraphs since if  u , v  V  ( H ) u v V H u,v\\in V(H) italic_u , italic_v  italic_V ( italic_H ) , then adding an edge between  v v v italic_v  and  u u u italic_u  would modify the topology of  H H H italic_H . If the cardinality of  C C \\mathcal{C} caligraphic_C  is less than the required number    \\Delta roman_  of edges to be added ( line 21 ), we add to it  m =   | C | m  C m=\\Delta-|\\mathcal{C}| italic_m = roman_ - | caligraphic_C |  vertices of  A A A italic_A  that do not belong to  V V \\mathcal{V} caligraphic_V , as for them no prescribed in-/out-degree is required ( lines 22-23 ). If this is not possible because  V  ( A )  V V A V V(A)\\setminus\\mathcal{V} italic_V ( italic_A )  caligraphic_V  is too small, we create and augment  A A A italic_A  with new vertices ( lines 2426 ) to be added to  C C \\mathcal{C} caligraphic_C  so that  | C | =  C  |\\mathcal{C}|=\\Delta | caligraphic_C | = roman_ . We then randomly select    \\Delta roman_  vertices from  C C \\mathcal{C} caligraphic_C  ( line 28 ) and add the corresponding edges from (to) them to (from)  v v v italic_v  ( lines 29-30 ).",
            "( Sketch ) We need to show that each item of Definition  4.1  is fulfilled by the output  A A A italic_A  of the algorithm. The first observation is that no vertex or edge is ever deleted, so item (1) is fulfilled. Item (2) is satisfied in  line 31  and item (3) by  line 1  with the  WeightNoising  function.  Lines 29  guarantee that for each induced subgraph of size  x x x italic_x  there exist in  A A A italic_A  other  k  1 k 1 k-1 italic_k - 1  vertex-disjoint induced subgraphs that are KG-isomorphic to it. Indeed the  IsomorphismBucketing  function group together all the subgraphs of size  x x x italic_x  in KG-isomorphic classes. The  k k k italic_k  subgraphs are then chosen in each class if there are enough, otherwise some subgraphs of the class are copied and added to the graph until there are  k k k italic_k  of them ( lines 68 ). Since the chosen subgraphs are all vertex-disjoint item (4i) is fulfilled. Notice also that no edge is ever added within vertices of the same subgraph ( line 20 ), so the topology of the subgraphs are not modified: hence by construction item (4ii) is met. Finally, the function  IsomorphingPartitioning  ensures to group together the vertices that need to have different sensitive attributes    \\xi italic_ , as it puts in the same class all the vertices for which there is a KG-isomorphism that maps one to another. Subsequently the function  ChooseDeg  allocate different in- and out- degree to each vertex of a class and  lines 1630  add the needed synthetic edges, thus satisfying item (4iii).",
            "Lastly, we consider six different real-world graphs from the literature, namely the Company Ownership graph  [ 43 ] , MovieLens small  [ 24 ] , Econ-Mahindas  [ 53 ] , Infect-Dublin  [ 53 ] , Power-1138-Bus  [ 53 ]  and Bitcoin Alpha  [ 38 ] . The Company Ownership KG focuses on Italian companies and has already been introduced in Section  2  and Figure  1 ; it plays an extremely important role for central banks and financial authorities to study and guarantee economic stability. The characteristics of the above mentioned graphs, such as the number of vertices and edges, are reported in Table  2 .",
            "For the financial domain, we model the  control  relationship  [ 43 ]  between two companies, already introduced in Example  1.1 . Finally, in some experiments we also consider the  ultimate controller   [ 44 ] , introduced in Example  4.1 .",
            "where ( 12 ) selects all the vertices of the KG with at least  2 2 2 2  out-going edges, and ( 13 ) selects all the vertices of the KG with at least  2 2 2 2  out-going edges with weight greater than  q q q italic_q . We set  q = 0 q 0 q=0 italic_q = 0  for all the considered networks but the economics networks, for which  q = 0.5 q 0.5 q=0.5 italic_q = 0.5 , as it is the threshold for establishing control.   \\hfill\\blacksquare",
            "Split & Merge for Very Large Graphs . Although anonymization is a one-time process, large-scale graphs can be computationally expensive for applications requiring rapid and frequent processing. To address this challenge, simple divide-and-conquer heuristics can utilise our algorithms to create an anonymized graph more efficiently. In our experiments, we introduce a divide-and-conquer heuristic called  split-and-merge , which uses a modified Kernighan-Lin heuristic  [ 35 ]  to partition the original graph into smaller disjoint components. Specifically, the original graph  G G G italic_G  is recursively split into two balanced and disjoint subgraphs, by minimizing the cut set. The resulting weakly connected components  { G i } i  [ m ] subscript subscript G i i delimited-[] m \\{G_{i}\\}_{i\\in[m]} { italic_G start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT } start_POSTSUBSCRIPT italic_i  [ italic_m ] end_POSTSUBSCRIPT  are then anonymized individually and in parallel (trading compute for speed). The anonymized components are then recombined (merging phase, which adds edges between the components) to produce the final anonymized graph  A A A italic_A  according to a chosen method. By construction, any induced subgraph  Z  G Z G Z\\subseteq G italic_Z  italic_G  will either be entirely contained within a component  G i subscript G i G_{i} italic_G start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT  or not, depending on whether some edges of  Z Z Z italic_Z  are part of the cut sets. In the first case ( Z  G i Z subscript G i Z\\subseteq G_{i} italic_Z  italic_G start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT ), the subgraph is guaranteed to have other  k  1 k 1 k-1 italic_k - 1  KG-isomorphic subgraphs with different sensitive attributes, since the component  G i subscript G i G_{i} italic_G start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT  has been anonymized individually. In the latter scenario ( Z  G i not-subset-of-or-equals Z subscript G i Z\\not\\subseteq G_{i} italic_Z  italic_G start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT ), the presence of KG-isomorphic subgraphs is not guaranteed. However, if  Z Z Z italic_Z  is KG-isomorphic to another subgraph  Y  G j Y subscript G j Y\\subseteq G_{j} italic_Y  italic_G start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT , then again it has other  k  1 k 1 k-1 italic_k - 1  KG-isomorphic subgraphs with different sensitive attributes by construction. Otherwise,  Z Z Z italic_Z  must be explicitly anonymized during the merging phase. Our heuristics guarantees the anonymization of these subgraphs by excluding the cut-set edges from  A A A italic_A  during the merging phase, while adding other synthetic edges. This approach ensures that an attacker cannot re-identify the subgraphs, as the original ones no longer appear. However, it is important to note that this procedure may violate the augmentation requirement stated in item (1) of Definition  4.1 , making our heuristic useful when augmentation is not a priority. We plan to address this limitation as future work.",
            "Erdos-Renyi  In Figure  4  we investigates the fidelity and utility for the Erdos-Renyi graph models. In Figure ( 4 a) and ( 4 b), we vary the number of vertices  n n n italic_n  of the input graph, from 100 to 10,000. Figure ( 4 a) shows the percentage of vertices added by the algorithm with respect to the original ones ( Nodes Overhead ): KLONE consistently adds around 200% more vertices, influenced by the privacy requirement  k = 3 k 3 k=3 italic_k = 3 , while KGUARD adds fewer vertices as it exploits the isomorphic subgraphs that are already present in the input graph. The dotted horizontal line represents the theoretical upper bound of  ( 2  k  1 ) % percent 2 k 1 (2k-1)\\% ( 2 italic_k - 1 ) %  added vertices for KLONE (Lemma  5.1 ). The efficiency of KGUARD with respect to KLONE in terms of added structures is reflected in Figure ( 4 b), where KGUARD exhibits significantly lower utility loss compared to KLONE. In Figures ( 4 c) and ( 4 d), we vary the privacy requirement  k k k italic_k  from 2 to 8. As expected, in Figure ( 4 c) KLONE shows a linear increase in additional vertices with respect to  k k k italic_k , while KGUARD exhibits only a slight increase due to the need for some new added subgraphs. This trend is also reflected in the utility loss in Figure ( 4 d), where KLONE has worse utility compared to KGUARD. Finally, in Figures ( 4 e) and ( 4 f) we evaluate the anonymisation quality by varying the size  x x x italic_x  of the subgraphs. The performance of KLONE remains unaffected by  x x x italic_x  as expected, since the algorithm provides a  ( k , x ) k x (k,x) ( italic_k , italic_x ) -isomorphism anonymization for any  x  [ n ] x delimited-[] n x\\in[n] italic_x  [ italic_n ]  (Proposition  5.1 ), instead KGUARD overhead increases with the size of subgraphs  x x x italic_x . In general, when  x x x italic_x  is sufficiently large, or if we are uncertain about the attacker knowledge, KLONE might be the better choice. In fact, while KGUARD computational time increases with  x x x italic_x , KLONE maintains a consistent cost as a single anonymization  A A A italic_A  of  G G G italic_G  is effective for any choice of  x x x italic_x .",
            "Finally, in Table  1  we present a detailed evaluation of utility and fidelity for Erdos-Renyi and scale-free networks. The results show that KGUARD generally outperforms KLONE, showing distributions that are closer to the original graph both for weights ( Weights     \\downarrow  ), and degrees ( Degree     \\downarrow  ), along with better utility metrics. The table also explores a scenario with denser networks for  n = 500 n 500 n=500 italic_n = 500 : the number of edges is tripled for the Erdos-Renyi network, while the parameter    \\alpha italic_  is decreased from 5 to 3 for the scale-free network. Overall, we observe increased computational time due to the presence of higher number of edges, while we have comparable performance in terms of utility and fidelity.",
            "Analytical comparison . In Table  4  we summarize the performance of our anonymisation algorithms on the knowledge graph  G G G italic_G  against various levels of the attackers knowledge and we compare it with the existing work. The attacker can observe a weighted or unweighted induced subgraph,  G  [ X ] G delimited-[] X G[X] italic_G [ italic_X ]  and  G u  [ X ] superscript G u delimited-[] X G^{u}[X] italic_G start_POSTSUPERSCRIPT italic_u end_POSTSUPERSCRIPT [ italic_X ]  respectively. Moreover, the attacker can have knowledge also on the derived edges of the graph, namely    ( G )  G \\Sigma(G) roman_ ( italic_G ) , or on the entire reasoning rules    \\Sigma roman_ , namely the NAG  ( G  [ X ] ,  ) G delimited-[] X  (G[X],\\Sigma) ( italic_G [ italic_X ] , roman_ ) . The last cases refer to the use by the attacker of any other reasoning rules    superscript  \\Sigma^{*} roman_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT  useful to perform the attack. The    \\checkmark   indicates that we reach a  ( k , x ) k x (k,x) ( italic_k , italic_x ) -isomorphism anonymization for any size  x x x italic_x , which means that any subgraph has at least other  k  1 k 1 k-1 italic_k - 1  KG-isomorphic copies, while the specification  [  x   x ] delimited-[] for-all superscript x  x [\\forall x^{\\prime}\\leq x] [  italic_x start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT  italic_x ]  indicates that it is reached a  ( k , x ) k x (k,x) ( italic_k , italic_x ) -isomorphism anonymization for any size  x  superscript x  x^{\\prime} italic_x start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT  up to a fixed  x x x italic_x  in input. For KLONE, in Proposition  5.1  we proved that it reaches a  ( k , x ) k x (k,x) ( italic_k , italic_x ) -anonymisation for every  x  [ n ] x delimited-[] n x\\!\\in\\![n] italic_x  [ italic_n ] , thus it is resistant to an attack of type  ( G  [ X ] ,  ) G delimited-[] X  (G[X],\\Sigma) ( italic_G [ italic_X ] , roman_ )  for any  X  V  ( G ) X V G X\\!\\subseteq\\!V(G) italic_X  italic_V ( italic_G ) . Accordingly, it is resistant to attackers with less knowledge, namely    ( G  [ X ] )  G delimited-[] X \\Sigma(G[X]) roman_ ( italic_G [ italic_X ] ) ,  G  [ X ] G delimited-[] X G[X] italic_G [ italic_X ]  and all the unweighted ones. We are left to prove that it is resistant also to an attack of type  ( G  [ X ] ,   ) G delimited-[] X superscript  (G[X],\\Sigma^{*}) ( italic_G [ italic_X ] , roman_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT )  with    superscript  \\Sigma^{*} roman_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT  any set of reasoning rules. Such rules necessarily depend on the knowledge graph  G G G italic_G : since KLONE copies  G G G italic_G  exactly  k k k italic_k  times (after the perturbation of the weights), any rule of    superscript  \\Sigma^{*} roman_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT  will have the same outputs on each of the copies, so that for any  X  V X V X\\subset V italic_X  italic_V ,  ( G  [ X ] ,   ) G delimited-[] X superscript  (G[X],\\Sigma^{*}) ( italic_G [ italic_X ] , roman_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT )  is KG-isomorphic to other  k  1 k 1 k-1 italic_k - 1  subgraphs in  A A A italic_A , namely one in each copy of  G G G italic_G . As for KGUARD, Proposition  6.1  proved that it always produces a  ( k , x ) k x (k,x) ( italic_k , italic_x ) - isomorphism anonymisation  A A A italic_A  for given  k , x  N k x N k,x\\!\\in\\!\\mathbb{N} italic_k , italic_x  blackboard_N . However, unless    \\Sigma roman_  has some other properties (see Proposition  4.1 ) we cannot guarantee a  ( k , x  ) k superscript x  (k,x^{\\prime}) ( italic_k , italic_x start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ) -isomorphism anonymisation for any given  x  < x superscript x  x x^{\\prime}<x italic_x start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT < italic_x . Consider now an attack of type    ( G  [ X  ] )  G delimited-[] superscript X  \\Sigma(G[X^{\\prime}]) roman_ ( italic_G [ italic_X start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ] ) , where the attacker knows the derived edges of the induced subgraph  G  [ X  ] G delimited-[] superscript X  G[X^{\\prime}] italic_G [ italic_X start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ]  but he is not aware of the reasoning rules    \\Sigma roman_ . If  | X  | = x superscript X  x |X^{\\prime}|\\!=\\!x | italic_X start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT | = italic_x  we know that  A A A italic_A  is resistant to such attack, as the attacker has less knowledge than the NAG attack  ( G  [ X  ] ,  ) G delimited-[] superscript X   (G[X^{\\prime}],\\Sigma) ( italic_G [ italic_X start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ] , roman_ ) . Suppose now that  | X  | = x  < x superscript X  superscript x  x |X^{\\prime}|\\!=\\!x^{\\prime}\\!<\\!x | italic_X start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT | = italic_x start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT < italic_x . Since  G G G italic_G  is weakly connected, there exists  X X X italic_X  such that  X   X  V superscript X  X V X^{\\prime}\\!\\subseteq\\!X\\!\\subseteq\\!V italic_X start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT  italic_X  italic_V ,  | X | = x X x |X|\\!=\\!x | italic_X | = italic_x  and  G  [ X ] G delimited-[] X G[X] italic_G [ italic_X ]  is weakly connected. Since  G  [ X  ]  G  [ X ] G delimited-[] superscript X  G delimited-[] X G[X^{\\prime}]\\subseteq G[X] italic_G [ italic_X start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ]  italic_G [ italic_X ] , it holds that    ( G  [ X  ] )    ( G  [ X ] )  [ X  ]  G delimited-[] superscript X   G delimited-[] X delimited-[] superscript X  \\Sigma(G[X^{\\prime}])\\!\\subseteq\\!\\Sigma(G[X])[X^{\\prime}] roman_ ( italic_G [ italic_X start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ] )  roman_ ( italic_G [ italic_X ] ) [ italic_X start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ] : if they are equal, then  A A A italic_A  is resistant to the attack because the  ( k , x ) k x (k,x) ( italic_k , italic_x ) -isomorphism anonymisation guarantees that    ( G  [ X ] )  G delimited-[] X \\Sigma(G[X]) roman_ ( italic_G [ italic_X ] )  has other  k  1 k 1 k-1 italic_k - 1  KG-isomorphic copies, and so it holds for    ( G  [ X ] )  [ X  ] =   ( G  [ X  ] )  G delimited-[] X delimited-[] superscript X   G delimited-[] superscript X  \\Sigma(G[X])[X^{\\prime}]=\\Sigma(G[X^{\\prime}]) roman_ ( italic_G [ italic_X ] ) [ italic_X start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ] = roman_ ( italic_G [ italic_X start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ] ) . If    ( G  [ X  ] )    ( G  [ X ] )  [ X  ]  G delimited-[] superscript X   G delimited-[] X delimited-[] superscript X  \\Sigma(G[X^{\\prime}])\\!\\subset\\!\\Sigma(G[X])[X^{\\prime}] roman_ ( italic_G [ italic_X start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ] )  roman_ ( italic_G [ italic_X ] ) [ italic_X start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ] , it means that    ( G  [ X  ] )  G delimited-[] superscript X  \\Sigma(G[X^{\\prime}]) roman_ ( italic_G [ italic_X start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ] )  is not a subgraph induced by a set of vertices, so  A A A italic_A  is resistant again to the attack. Finally, this implies that  A A A italic_A  is resistant to all the attacks that involve less knowledge than    ( G  [ X ] )  G delimited-[] X \\Sigma(G[X]) roman_ ( italic_G [ italic_X ] ) , namely  G  [ X ] G delimited-[] X G[X] italic_G [ italic_X ]  and the unweighted ones (Table  4 ). Diversity is always guaranteed for both our algorithms."
        ]
    },
    "id_table_2": {
        "caption": "Table 2:  Anonymisation results for real-world graphs.",
        "table": "S9.EGx2",
        "footnotes": [],
        "references": [
            "The Bank of Italy wants to share the whole KG in Figure  1  with untrusted or anyway external financial organizations, along with the new control relationship (red dashed edges). At the same time, it would like to protect the identity of the involved companies  [ 40 ,  47 ] . More in general, central banks and financial institutions foster collaboration between the financial world and the academic community for institutional, research, and educational purposes, for which data, and hence KG sharing is of the essence. In our example, independently of the identities, the KG would enable external organisations to perform relevant analyses. For example, they could single out the Italian holdings having more than  K K K italic_K  controlled companies (e.g., company A in Figure  1  for  K = 2 K 2 K=2 italic_K = 2 , see also Example  1.2 ) and use them to train dedicated machine learning models to study the structure of the market, for instance by understanding whether the company is a family business or an entity managed by a professional investor; if its ultimate proprietor is within the EU area; if it pinpoints a market weakness by being likely subject to a takeover action, and many more, which are anyway beyond our scope.",
            "A key privacy issue arises when an attacker knows the relationships of a few financial entities and uses such information to identify the entities involved and their relationships. This kind of attack is known in the literature as a  subgraph-based attack   [ 55 ] , and it is commonly used to study anonymisation/re-identification problems in graphs. The attacker has access to the subgraph induced by a few entities, the  Neighborhood Attack Graph  (NAG), and uses it to infer the identities of the vertices and their relationships in the graph. For example, in Figure  2  a), the knowledge of the NAG lets the attacker  retrieve the identities  of the vertices  ( 1 , 2 , 3 ) 1 2 3 (1,2,3) ( 1 , 2 , 3 ) , since such subgraph can be uniquely matched with the subgraph induced by the companies  ( A , B , E ) A B E (A,B,E) ( italic_A , italic_B , italic_E ) , which is the only structure presenting that topology. Once the attacker knows the identities of the vertices, she can discover further properties that were not known beforehand, which we will call  sensitive attribute  altogether: in the example, besides the node labels, the relationships in which  E E E italic_E  and  F F F italic_F  take part are disclosed, specifically, the fact that  F F F italic_F  holds  10 % percent 10 10\\% 10 %  of  E E E italic_E .",
            "The need for novel structural anonymisation techniques.  Structural anonymisation consists of generating synthetic graph replicas, which are artificially produced, but resemble the original graph and thus are still functional to perform the analysis tasks  [ 47 ] . With reference to the notion of  k-anonymity , we have that a graph is  k-anonymous  when it exhibits at least  k k k italic_k  similar (e.g., isomorphic) structures with respect to the adversary knowledge  [ 25 ,  55 ] . This guarantees that such structure, and therefore its nodes, cannot be re-identified in the network with a probability higher than  1 / k 1 k 1/k 1 / italic_k . For example, the graph in Figure  2  b) is  2 2 2 2 -anonymous with respect to the NAG: the perturbation of the weights, the anonymization of vertex names, and the addition of the green synthetic edge, make the attacker unable to distinguish between the subgraphs with (anonymised) vertices  (  ,  ,  )   italic- (\\delta,\\lambda,\\epsilon) ( italic_ , italic_ , italic_ )  and  (  ,  ,  )    (\\beta,\\gamma,\\eta) ( italic_ , italic_ , italic_ ) .",
            "Protect entities from re-identification attacks that exploit reasoning . As shown in Figure  2  c), the addition of the derived red edge through reasoning makes the NAG isomorphic only to the induced subgraph  (  ,  ,  )    (\\beta,\\gamma,\\eta) ( italic_ , italic_ , italic_ ) . Anonymisation should account for derived edges: in Figure  2  d), the synthetic green edge  (  ,  )  italic- (\\delta,\\epsilon) ( italic_ , italic_ )  is purposely weighted to create two isomorphic subgraphs.",
            "Preserve the knowledge encoded in the KG . Anonymisation should retain as much as possible the knowledge of the KG, in terms of its ability to support downstream tasks such as the answer to specific business questions. For example, with respect to Query ( 3 ), we see in Figure  2  d) that the anonymised KG still produces the correct answer no companies for  K = 2 K 2 K=2 italic_K = 2 .",
            "Ensure diversity for the sensitive attribute . We see in Figure  2  b) that an attacker can infer that vertex 1 has two incoming and zero outgoing relationships, respectively, independently of whether it maps to   italic- \\epsilon italic_  or    \\beta italic_ , as both of them have the same in- and out-degree, thus hampering k-anonimity. More in general, we should ensure the differentiation, namely, the  l-diversity   [ 42 ]  (or simply  diversity ), of the sensitive attributes of nodes while also preserving R.1 and R.2, a nontrivial challenge in the presence of derived edges. In Figure  2  d), for example, the synthetic green edges  (  ,  ) italic-  (\\epsilon,\\gamma) ( italic_ , italic_ )  and  (  ,  )   (\\delta,\\beta) ( italic_ , italic_ )  help uphold diversity for both the in- and out- degree.",
            "Overview.  The remainder of the paper is organised as follows. Section  2  introduces the notation and the main background concepts. Section  3  and  4  formalise our problem and introduce the  ( k , x ) k x (k,x) ( italic_k , italic_x ) -isomorphism anonymisation along with the semantic utility metric. Sections  5  and  6  present the anonymisation algorithms, while in Section  7  we experimentally evaluate our approaches. In Section  8  and  9 , we respectively present the related work and the conclusion. Some of the proofs are in the on-line Appendix  [ 5 ] .",
            "Our goal is preventing an adversary attack from being able to uniquely map the NAG into a KG, as this would lead to the re-identification of the entities within the graph. For classical graphs, this is usually solved by introducing in the graph, for each induced subgraph,  k  1 k 1 k-1 italic_k - 1  other isomorphic subgraphs, so that the attacker cannot uniquely identify a NAG. Unfortunately, this is not enough in a KG scenario, since the applications of the rules of    \\Sigma roman_  may make the replicated subgraphs no longer isomorphic, hence enabling the re-identification of the vertices (R.1), as we have shown in Figure  2 (c). In fact, the attacker can enrich the NAG by applying    \\Sigma roman_  and single out a subgraph, as we formalise in the notion of  KG-isomorphism .",
            "In other words, two subgraphs are KG-isomorphic if they share both the topology of the ground and of the derived component. For example, in Figure  2 (d), the NAG and the induced subgraphs  G  [ {  ,  ,  } ] G delimited-[]    G[\\{\\beta,\\gamma,\\eta\\}] italic_G [ { italic_ , italic_ , italic_ } ]  and  G  [ {  ,  ,  } ] G delimited-[]  italic-  G[\\{\\delta,\\epsilon,\\lambda\\}] italic_G [ { italic_ , italic_ , italic_ } ]  are all KG-isomorphic.",
            "Our setting is even more challenging: even when a NAG is KG-isomorphic to many subgraphs in the released KG, the attacker may still infer information on the number of connections of the involved nodes, i.e., their in- and out-degrees (R.3). For instance, in Figure  2 (d), if we had not added the green edges  (  ,  )   (\\delta,\\beta) ( italic_ , italic_ )  and  (  ,  ) italic-  (\\epsilon,\\gamma) ( italic_ , italic_ ) , the attacker would have inferred that entity  1 1 1 1  of the NAG has out-degree equal to  0 0  and in-degree equal to  2 2 2 2 . We define the node properties to be protected as  sensitive attributes , as follows.",
            "More in details, (a) is performed in  line 1 , where the weights are chosen in way such that the utility  U  subscript U  \\mathcal{U}_{\\Delta} caligraphic_U start_POSTSUBSCRIPT roman_ end_POSTSUBSCRIPT  is minimized. Ideally, we would like the change of weights to completely preserve the output of the queries on the KG. This is done by the  WeightNoising  function in Algorithm  2 , which randomly samples new weights for  M M M italic_M  times and chooses the ones that reach the smallest value of  U  subscript U  \\mathcal{U}_{\\Delta} caligraphic_U start_POSTSUBSCRIPT roman_ end_POSTSUBSCRIPT . Phase (b) is in  lines 2-3 . At this point, the graph  A A A italic_A  is the disjoint union of  k k k italic_k  copies of  G G G italic_G , which guarantees that each induced subgraph is KG-isomorphic to other  k  1 k 1 k-1 italic_k - 1  different subgraphs according to Definition  3.2 . These copies are linked together in  line 4  to guarantee that  A A A italic_A  is weakly connected. Phase (c) is addressed in  lines 520 . The  for  loop in  line 5  iterates on the vertices of a copy of  G G G italic_G  while the  for  loop in  line 7  iterates on the copies of  G G G italic_G , such that  v i j superscript subscript v i j v_{i}^{j} italic_v start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_j end_POSTSUPERSCRIPT  refers to the  i i i italic_i -th vertex in the  j j j italic_j -th copy  G j superscript G j G^{j} italic_G start_POSTSUPERSCRIPT italic_j end_POSTSUPERSCRIPT  of  G G G italic_G ; the last  for  loop in  line 8  repeats the procedure both for in-degree and out-degree. The goal is to add synthetic edges such that all the copies  { v i 2 , ... , v i k } superscript subscript v i 2 ... superscript subscript v i k \\{v_{i}^{2},\\dots,v_{i}^{k}\\} { italic_v start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT , ... , italic_v start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_k end_POSTSUPERSCRIPT }  of the vertex  v i 1 superscript subscript v i 1 v_{i}^{1} italic_v start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 1 end_POSTSUPERSCRIPT  have different sensitive attributes (Definition  3.3 ). To do so, we randomly assign a new in- (out-) degree to each of them with the use of the input degree distributions  p i  n subscript p i n p_{in} italic_p start_POSTSUBSCRIPT italic_i italic_n end_POSTSUBSCRIPT  and  p o  u  t subscript p o u t p_{out} italic_p start_POSTSUBSCRIPT italic_o italic_u italic_t end_POSTSUBSCRIPT , making sure that this value is bigger than the original one (since we do not want to remove any of the original edges) and that they are all different from one another ( lines 911 ). We then select a set of candidate vertices  C C \\mathcal{C} caligraphic_C  from (to) which add    \\Delta roman_  new edges to (from) each  v i j superscript subscript v i j v_{i}^{j} italic_v start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_j end_POSTSUPERSCRIPT  in order to meet the chosen in- (out-) degree. This set  C C \\mathcal{C} caligraphic_C  consists of all the vertices of the graph that (i) do not belong to the same copy  G j superscript G j G^{j} italic_G start_POSTSUPERSCRIPT italic_j end_POSTSUPERSCRIPT  of  v i j superscript subscript v i j v_{i}^{j} italic_v start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_j end_POSTSUPERSCRIPT , (ii) for which there is not already an existing edge and (iii) that do not belong to  V V \\mathcal{V} caligraphic_V , i.e., the set of vertices for which we have already added the synthetic edges to meet the chosen in- (out-) degree ( line 13 ). Condition (i) is necessary to not break the KG-isomorphisms between the subgraphs on the different copies of  G G G italic_G . If the cardinality of  C C \\mathcal{C} caligraphic_C  is less than the required number of edges that have to be added, we augment the graph with the needed number of new vertices ( lines 1416 ). We then randomly select    \\Delta roman_  vertices from  C C \\mathcal{C} caligraphic_C  and add the corresponding edges ( lines 1719 ). Finally, phase (d) is addressed in  line 21 , where to each vertex is assigned a new label; in phase (e) we assign a weight to each added synthetic edge ( line 22 ) to optimise the utility  U  subscript U  \\mathcal{U}_{\\Delta} caligraphic_U start_POSTSUBSCRIPT roman_ end_POSTSUBSCRIPT  again by the use of the function  WeightNoising .",
            "Correctness.  We need to show that each item of Definition  4.1  is fulfilled by the output  A A A italic_A  of the algorithm, for every  x  [ n ] x delimited-[] n x\\in[n] italic_x  [ italic_n ] . The graph  G G G italic_G  is copied  k k k italic_k  times in  A A A italic_A  (weights included) in  line 3  and no vertex or edge is ever deleted by the algorithm, so item (1) of Definition  4.1  is fulfilled, as well as item (2) by  line 21  and item (3) by  line 1 . Let  G 1 , ... , G k superscript G 1 ... superscript G k G^{1},\\dots,G^{k} italic_G start_POSTSUPERSCRIPT 1 end_POSTSUPERSCRIPT , ... , italic_G start_POSTSUPERSCRIPT italic_k end_POSTSUPERSCRIPT  be the copies of  G G G italic_G  with  V  ( G j ) = { v 1 j , ... , v n j } V superscript G j subscript superscript v j 1 ... subscript superscript v j n V(G^{j})=\\{v^{j}_{1},\\dots,v^{j}_{n}\\} italic_V ( italic_G start_POSTSUPERSCRIPT italic_j end_POSTSUPERSCRIPT ) = { italic_v start_POSTSUPERSCRIPT italic_j end_POSTSUPERSCRIPT start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , ... , italic_v start_POSTSUPERSCRIPT italic_j end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT }  for  j  [ k ] j delimited-[] k j\\in[k] italic_j  [ italic_k ] . Consider the function   j : V  ( G 1 )  V  ( G j ) : subscript  j  V superscript G 1 V superscript G j \\Phi_{j}:V(G^{1})\\to V(G^{j}) roman_ start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT : italic_V ( italic_G start_POSTSUPERSCRIPT 1 end_POSTSUPERSCRIPT )  italic_V ( italic_G start_POSTSUPERSCRIPT italic_j end_POSTSUPERSCRIPT )  such that   j  ( v i 1 ) = v i j subscript  j subscript superscript v 1 i subscript superscript v j i \\Phi_{j}(v^{1}_{i})=v^{j}_{i} roman_ start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT ( italic_v start_POSTSUPERSCRIPT 1 end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT ) = italic_v start_POSTSUPERSCRIPT italic_j end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT  for each  i  [ n ] i delimited-[] n i\\in[n] italic_i  [ italic_n ] . Given  x  [ n ] x delimited-[] n x\\in[n] italic_x  [ italic_n ]  and  X 1 subscript X 1 X_{1} italic_X start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT  a set of  x x x italic_x  vertices of  G 1 superscript G 1 G^{1} italic_G start_POSTSUPERSCRIPT 1 end_POSTSUPERSCRIPT  such that  G 1  [ X 1 ] superscript G 1 delimited-[] subscript X 1 G^{1}[X_{1}] italic_G start_POSTSUPERSCRIPT 1 end_POSTSUPERSCRIPT [ italic_X start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ]  is weakly connected, the function   j | X 1 : X 1   j  ( X 1 )  V  ( G j ) \\Phi_{j_{|_{X_{1}}}}:X_{1}\\to\\Phi_{j}(X_{1})\\subseteq V(G^{j}) roman_ start_POSTSUBSCRIPT italic_j start_POSTSUBSCRIPT | start_POSTSUBSCRIPT italic_X start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUBSCRIPT end_POSTSUBSCRIPT end_POSTSUBSCRIPT : italic_X start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT  roman_ start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT ( italic_X start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT )  italic_V ( italic_G start_POSTSUPERSCRIPT italic_j end_POSTSUPERSCRIPT )  is a KG-isomorphism between  ( A  [ X 1 ] ,  ) A delimited-[] subscript X 1  (A[X_{1}],\\Sigma) ( italic_A [ italic_X start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ] , roman_ )  and  ( A  [  j  ( X 1 ) ] ,  ) A delimited-[] subscript  j subscript X 1  (A[\\Phi_{j}(X_{1})],\\Sigma) ( italic_A [ roman_ start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT ( italic_X start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ) ] , roman_ ) . Indeed the algorithm does not add edges between vertices of the same copy of  G G G italic_G  ( line 13 ), so it does not modify the topology of the induced subgraphs, meeting conditions ( 4 ) and ( 5 ) of KG-isomorphism. Moreover, by construction  X 1   j  ( X 1 ) =  subscript X 1 subscript  j subscript X 1 X_{1}\\cap\\Phi_{j}(X_{1})=\\emptyset italic_X start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT  roman_ start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT ( italic_X start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ) =  , thus items (4i) and (4ii) are satisfied. We are left with verifying item (4iii). The  while  loop in  lines 10-11  guarantees that, given  i  [ n ] i delimited-[] n i\\in[n] italic_i  [ italic_n ] , to each vertex in the set  { v i 1 , ... , v i k } subscript superscript v 1 i ... subscript superscript v k i \\{v^{1}_{i},\\dots,v^{k}_{i}\\} { italic_v start_POSTSUPERSCRIPT 1 end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT , ... , italic_v start_POSTSUPERSCRIPT italic_k end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT }  is associated a different out-degree and a different in-degree. This implies that   A  (  j  ( v i j ) ) =  A  (  j   ( v i j  ) ) subscript  A subscript  j subscript superscript v j i subscript  A subscript  superscript j  subscript superscript v superscript j  i \\xi_{{}_{A}}(\\Phi_{j}(v^{j}_{i}))\\neq\\xi_{{}_{A}}(\\Phi_{j^{\\prime}}(v^{j^{% \\prime}}_{i})) italic_ start_POSTSUBSCRIPT start_FLOATSUBSCRIPT italic_A end_FLOATSUBSCRIPT end_POSTSUBSCRIPT ( roman_ start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT ( italic_v start_POSTSUPERSCRIPT italic_j end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT ) ) = italic_ start_POSTSUBSCRIPT start_FLOATSUBSCRIPT italic_A end_FLOATSUBSCRIPT end_POSTSUBSCRIPT ( roman_ start_POSTSUBSCRIPT italic_j start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT end_POSTSUBSCRIPT ( italic_v start_POSTSUPERSCRIPT italic_j start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT ) )  for all  j = j  j superscript j  j\\neq j^{\\prime} italic_j = italic_j start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , thus satisfying item (4iii).  Computational time.  The computational time of the function  WeightNoising  (Algorithm  2 ) is  O  ( M  | S | ) O M S O(M|S|) italic_O ( italic_M | italic_S | ) , as the weight of each element of  S S S italic_S , the edge set in input, is updated  M M M italic_M  times. Therefore  line 1  of Algorithm  1  runs in  O  ( M  n 2 ) O M superscript n 2 O(Mn^{2}) italic_O ( italic_M italic_n start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT )  since  | E |  n 2 E superscript n 2 |E|\\leq n^{2} | italic_E |  italic_n start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT . As for  line 22 , let  V  ( A ) =  j V  ( G j )  W V A subscript j V subscript G j W V(A)=\\bigcup_{j}V(G_{j})\\cup W italic_V ( italic_A ) =  start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT italic_V ( italic_G start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT )  italic_W ; by the proof of Lemma  5.1  we have that  | W |  k  n + 1 W k n 1 |W|\\leq kn+1 | italic_W |  italic_k italic_n + 1 . We have already observed that Algorithm  1  ( lines 1319 ) adds edges only between  V  ( G j ) V subscript G j V(G_{j}) italic_V ( italic_G start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT )  and  V  ( G j  ) V subscript G superscript j  V(G_{j^{\\prime}}) italic_V ( italic_G start_POSTSUBSCRIPT italic_j start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT end_POSTSUBSCRIPT )  with  j = j  j superscript j  j\\neq j^{\\prime} italic_j = italic_j start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , i.e. between vertices that belong to two different copies of  G G G italic_G , and between   j V  ( G j ) subscript j V subscript G j \\bigcup_{j}V(G_{j})  start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT italic_V ( italic_G start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT )  and  W W W italic_W . Consequently, in the first case it can add a maximum of  ( k  1 )  k  n 2 k 1 k superscript n 2 (k-1)kn^{2} ( italic_k - 1 ) italic_k italic_n start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT  edges, while in the second case it can add up to  2  k  n  ( k  n + 1 ) 2 k n k n 1 2kn(kn+1) 2 italic_k italic_n ( italic_k italic_n + 1 )  edges. Therefore we have that  | S |  ( k  1 )  k  n 2 + 2  k  n  ( k  n + 1 ) S k 1 k superscript n 2 2 k n k n 1 |S|\\leq(k-1)kn^{2}+2kn(kn+1) | italic_S |  ( italic_k - 1 ) italic_k italic_n start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT + 2 italic_k italic_n ( italic_k italic_n + 1 )  and so the computational time of the function  WeightNoising  in  line 22  is  O  ( M  k 2  n 2 ) O M superscript k 2 superscript n 2 O(Mk^{2}n^{2}) italic_O ( italic_M italic_k start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT italic_n start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) . Lets now focus on the remaining parts of the algorithm.  Lines 24  clearly have a run time of  O  ( k  n ) O k n O(kn) italic_O ( italic_k italic_n ) . We claim that, for fixed  i i i italic_i  and  j j j italic_j , the maximum number of iterations that the  while  loop in  lines 1011  can do is  n + k n k n+k italic_n + italic_k . Indeed suppose that  d A   ( v i j ) superscript subscript d A  superscript subscript v i j d_{{}_{A}}^{\\varphi}(v_{i}^{j}) italic_d start_POSTSUBSCRIPT start_FLOATSUBSCRIPT italic_A end_FLOATSUBSCRIPT end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_ end_POSTSUPERSCRIPT ( italic_v start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_j end_POSTSUPERSCRIPT )  is equal to some   j   superscript subscript  superscript j   \\delta_{j^{\\prime}}^{\\varphi} italic_ start_POSTSUBSCRIPT italic_j start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_ end_POSTSUPERSCRIPT  for  j  < j superscript j  j j^{\\prime}<j italic_j start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT < italic_j , so that we enter the  while  loop. Let  {  1  , ... ,  j  1  } subscript superscript   1 ... subscript superscript   j 1 \\{\\delta^{\\varphi}_{1},\\dots,\\delta^{\\varphi}_{j-1}\\} { italic_ start_POSTSUPERSCRIPT italic_ end_POSTSUPERSCRIPT start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , ... , italic_ start_POSTSUPERSCRIPT italic_ end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_j - 1 end_POSTSUBSCRIPT }  be the already assigned degrees; we have three cases:",
            "We first find all the weakly connected subgraphs of the KG induced by a set of  x x x italic_x  vertices ( line 2 , function  ConnectedInducedSubgraphs ) 1 1 1 We adapt the algorithm by S. Karakashian et al.  [ 34 ]  to the case of directed graphs.  and gather them in  H H \\mathcal{H} caligraphic_H . Then, for each subgraph  H  H H H H\\in\\mathcal{H} italic_H  caligraphic_H , we apply the reasoning rules    \\Sigma roman_  to obtain their derived extensional component; together, they form the set  G G \\mathcal{G} caligraphic_G  ( line 2 ). Then, we group together the subgraphs of  G G \\mathcal{G} caligraphic_G  into KG-isomorphic clusters, referred to as  buckets : each bucket only contains subgraphs that are KG-isomorphic to each other according to Definition  3.2 . This happens in  line 3 , where the function  IsomorphismBucketing  returns  B B \\mathbb{B} blackboard_B , the set of buckets, and  I I \\mathbb{I} blackboard_I  the set of KG-isomorphism functions between any pair of KG-isomophic subgraphs found; to do so we use the algorithm in  [ 15 ] . The process of isomorphism bucketing is quite straightforward and it is done iteratively on the elements of  G G \\mathcal{G} caligraphic_G . Indeed, let  B B \\mathbb{B} blackboard_B  the set of KG-isomorphic buckets of the first  i i i italic_i  elements of  G G \\mathcal{G} caligraphic_G  and let  H i + 1  G subscript H i 1 G H_{i+1}\\in\\mathcal{G} italic_H start_POSTSUBSCRIPT italic_i + 1 end_POSTSUBSCRIPT  caligraphic_G  the next considered subgraph. Since the KG-isomorphism induces an equivalence relation, it suffices to check whether  H i + 1 subscript H i 1 H_{i+1} italic_H start_POSTSUBSCRIPT italic_i + 1 end_POSTSUBSCRIPT  is isomorphic to a representative of each equivalence class (bucket): if so, than  H i + 1 subscript H i 1 H_{i+1} italic_H start_POSTSUBSCRIPT italic_i + 1 end_POSTSUBSCRIPT  is added to such bucket, otherwise a new bucket is created with  H i + 1 subscript H i 1 H_{i+1} italic_H start_POSTSUBSCRIPT italic_i + 1 end_POSTSUBSCRIPT  as representative.",
            "Lastly, we consider six different real-world graphs from the literature, namely the Company Ownership graph  [ 43 ] , MovieLens small  [ 24 ] , Econ-Mahindas  [ 53 ] , Infect-Dublin  [ 53 ] , Power-1138-Bus  [ 53 ]  and Bitcoin Alpha  [ 38 ] . The Company Ownership KG focuses on Italian companies and has already been introduced in Section  2  and Figure  1 ; it plays an extremely important role for central banks and financial authorities to study and guarantee economic stability. The characteristics of the above mentioned graphs, such as the number of vertices and edges, are reported in Table  2 .",
            "where ( 12 ) selects all the vertices of the KG with at least  2 2 2 2  out-going edges, and ( 13 ) selects all the vertices of the KG with at least  2 2 2 2  out-going edges with weight greater than  q q q italic_q . We set  q = 0 q 0 q=0 italic_q = 0  for all the considered networks but the economics networks, for which  q = 0.5 q 0.5 q=0.5 italic_q = 0.5 , as it is the threshold for establishing control.   \\hfill\\blacksquare",
            "In this section, we investigate the performance of our approaches for anonymizing six real-world graphs from various domains, including energy and economics. Table  2  reports for each graph the number of vertices and edges, along with the anonymization performance for KLONE and KGUARD with  k = 3 k 3 k=3 italic_k = 3  and  x = 4 x 4 x=4 italic_x = 4 . Specifically, we report the utility metrics, the  Nodes overhead  ( % percent \\% % ) previously introduced, and the Wasserstein distances between their degree distributions ( Degree     \\downarrow  ) and weight distributions ( Weights     \\downarrow  ). In the experiments, both KGUARD and KLONE consistently achieve a perfect utility  U U \\mathcal{U} caligraphic_U , close to 0, indicating that the anonymized graph  A A A italic_A  has no loss of information compared to graph  G G G italic_G  in terms of utility queries.",
            "We investigate the privacy of our approaches compared to existing work, specifically the work of J. Cheng et al.  [ 14 ]  to which we refer as  k-Iso . This method anonymizes graphs by forming  k k k italic_k  pairwise isomorphic subgraphs, making them indistinguishable to an adversary. However, as we qualitatively showed in Figure  2 , neglecting derived links in KGs results in severe privacy issues and information leaks. In Table  3 , we quantitatively evaluate the impact of derived edges using a    \\delta italic_ - anonymity  metric for  x = 4 x 4 x\\!=\\!4 italic_x = 4  and  k = 3 k 3 k\\!=\\!3 italic_k = 3 . We recall that such metric measures the percentage of isomorphic subgraph structures that are not uniquely identifiable. The table confirms our theoretical analysis: our approaches anonymise each individual subgraphs, and consistently achieve    a  n  o  n  y  m  i  t  y = 1.0  a n o n y m i t y 1.0 \\delta-anonymity=1.0 italic_ - italic_a italic_n italic_o italic_n italic_y italic_m italic_i italic_t italic_y = 1.0 . Contrarily the state-of-the-art approach  k-Iso  does not protect the privacy of all entities: in the worst case (Bitcoin-Alpha) only 60% of subgraphs are effectively not uniquely identifiable, leaving 40% of potentially identifiable entities by an attacker. The best case for the state-of-the-art algorithm is the Infect-Dublin network, which is less impacted by privacy leaks from derived edges, due to its simple structure and the absence of edge weights.",
            "Several definitions of privacy have been proposed over the years, ranging from traditional syntactic privacy definitions  [ 54 ] , to more recent semantic privacy definitions like differential privacy  [ 32 ,  48 ,  33 ,  18 ] . In the last years, traditional anonymization concepts originally developed for relational databases  [ 11 ,  31 ]  have been extended to graph data, including models such as  t t t italic_t -closeness,  k k k italic_k -degree, and  k k k italic_k -neighborhood anonymity  [ 47 ,  52 ] . These approaches fall under the category of  structural anonymization , which involves altering the graph structure to preserve privacy. For example, the  k k k italic_k -degree anonymity  [ 36 ,  12 ]  ensures privacy by selectively adding or removing edges in the graph. However, these methods targets specific graph types like directed  [ 37 ,  12 ]  or weighted graphs  [ 41 ] , and when applied to KGs they can expose sensitive data as they neglect the implications of newly derived knowledge (see Figure  2 ). On the other hand, differential privacy faces significant challenges when applied to highly correlated and network data  [ 33 ] . Adding noise to nodes or edges often fails to conceal the overall structure and relationships within the data. While excessive noise can severely degrade data utility, making the synthetic KG and query results useless for a specific downstream task. These two limitations make differential privacy not directly suitable for our domain."
        ]
    },
    "id_table_3": {
        "caption": "Table 3:  Anonymisation rate of different graph data.",
        "table": "S9.EGx3",
        "footnotes": [],
        "references": [
            "Preserve the knowledge encoded in the KG . Anonymisation should retain as much as possible the knowledge of the KG, in terms of its ability to support downstream tasks such as the answer to specific business questions. For example, with respect to Query ( 3 ), we see in Figure  2  d) that the anonymised KG still produces the correct answer no companies for  K = 2 K 2 K=2 italic_K = 2 .",
            "Overview.  The remainder of the paper is organised as follows. Section  2  introduces the notation and the main background concepts. Section  3  and  4  formalise our problem and introduce the  ( k , x ) k x (k,x) ( italic_k , italic_x ) -isomorphism anonymisation along with the semantic utility metric. Sections  5  and  6  present the anonymisation algorithms, while in Section  7  we experimentally evaluate our approaches. In Section  8  and  9 , we respectively present the related work and the conclusion. Some of the proofs are in the on-line Appendix  [ 5 ] .",
            "Queries . We express business tasks on KGs as queries, like the one in Example  3 . A  conjunctive query  (CQ)  q  ( D ) q D q(D) italic_q ( italic_D )  over a schema  S S \\mathbf{S} bold_S  of a database  D D D italic_D  is an implication  Ans  ( x )    ( x , y )  Ans x bold-italic- x y \\text{Ans}(\\mathbf{x})\\leftarrow\\boldsymbol{\\phi}(\\mathbf{x},\\mathbf{y}) Ans ( bold_x )  bold_italic_ ( bold_x , bold_y ) , where    ( x , y ) bold-italic- x y \\boldsymbol{\\phi}(\\mathbf{x},\\mathbf{y}) bold_italic_ ( bold_x , bold_y )  is a conjunction of atoms over  S S \\mathbf{S} bold_S ,  Ans  is an n-ary predicate that does not occur in  S S \\mathbf{S} bold_S , and  x x \\mathbf{x} bold_x  and  y y \\mathbf{y} bold_y  are vectors of terms. In the presence of    \\Sigma roman_ , it is evaluated as a set of tuples as follows:  q  ( D ) = { t  d  o  m  ( D ) n : Ans  ( t )    ( D ) } q D conditional-set t d o m superscript D n Ans t  D q(D)=\\{t\\in dom(D)^{n}:\\text{Ans}(t)\\in\\Sigma(D)\\} italic_q ( italic_D ) = { italic_t  italic_d italic_o italic_m ( italic_D ) start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT : Ans ( italic_t )  roman_ ( italic_D ) } . Since in our KG context, we consider relational mappings  G D subscript G D G_{D} italic_G start_POSTSUBSCRIPT italic_D end_POSTSUBSCRIPT  of graphs  G G G italic_G , by extension we will refer to  q ( G ) = { t  d o m ( G D ) n : Ans ( t )   ( G D ) q(G)=\\{t\\in dom(G_{D})^{n}:\\text{Ans}(t)\\in\\Sigma(G_{D}) italic_q ( italic_G ) = { italic_t  italic_d italic_o italic_m ( italic_G start_POSTSUBSCRIPT italic_D end_POSTSUBSCRIPT ) start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT : Ans ( italic_t )  roman_ ( italic_G start_POSTSUBSCRIPT italic_D end_POSTSUBSCRIPT ) }. As we shall see, in the anonymisation process it is crucial that the result of queries is altered as little as possible, still providing ground for robust analysis. This will be formalised in our utility notions.",
            "The commutative property in reasoning with KGs . It is interesting to observe that, in general, a  ( k , x ) k x (k,x) ( italic_k , italic_x ) -isomorphism anonymisation does not guarantee the anonymity against every attack with a NAG of size smaller than  x x x italic_x . In fact, an edge between two vertices of an induced subgraph may be derived as a consequence of information outside such subgraph. To see this case more clearly, consider Picture (1) in Figure  3 , which shows an example of company ownership graph  G G G italic_G ; the orange edges are derived with the following reasoning rules ( ultimate controller : we add a derived edge from  x x x italic_x  to  y y y italic_y  if  x x x italic_x  controls  y y y italic_y  and  x x x italic_x  is not controlled by any entity).",
            "The two subgraphs induced respectively by the vertex sets  X = { A , B , C , D , E } X A B C D E X=\\{A,B,C,D,E\\} italic_X = { italic_A , italic_B , italic_C , italic_D , italic_E }  and  Y = { F , G , H , I , L } Y F G H I L Y=\\{F,G,H,I,L\\} italic_Y = { italic_F , italic_G , italic_H , italic_I , italic_L }  are KG-isomorphic. In this scenario, a NAG attack of size  x = | X | = | Y | = 5 x X Y 5 x=|X|=|Y|=5 italic_x = | italic_X | = | italic_Y | = 5  cannot uniquely re-identify the entities, thanks to the  k = 2 k 2 k=2 italic_k = 2  isomorphic structures. However, an attack of size  4 = x  < x 4 superscript x  x 4=x^{\\prime}<x 4 = italic_x start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT < italic_x  would be effective. Indeed let  X  = { A , B , C , D }  X superscript X  A B C D X X^{\\prime}=\\{A,B,C,D\\}\\subset X italic_X start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT = { italic_A , italic_B , italic_C , italic_D }  italic_X  and  Y  = { F , G , H , L }  Y superscript Y  F G H L Y Y^{\\prime}=\\{F,G,H,L\\}\\subset Y italic_Y start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT = { italic_F , italic_G , italic_H , italic_L }  italic_Y . Picture (2) in Figure  3  shows the KGs that we obtain through reasoning respectively on  G  [ X  ] G delimited-[] superscript X  G[X^{\\prime}] italic_G [ italic_X start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ]  and  G  [ Y  ] G delimited-[] superscript Y  G[Y^{\\prime}] italic_G [ italic_Y start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ] : these two structures are not KG-isomorphic as only in the first one the reasoning produces a derived edge. Therefore, the attacker could uniquely re-identify the correct structure. However, when for any  X  V  ( G ) X V G X\\subset V(G) italic_X  italic_V ( italic_G ) , it holds that    ( G )  [ X ] =   ( G  [ X ] )  G delimited-[] X  G delimited-[] X \\Sigma(G)[X]=\\Sigma(G[X]) roman_ ( italic_G ) [ italic_X ] = roman_ ( italic_G [ italic_X ] ) , which we call as a  commutative  property on the subgraphs of  G G G italic_G  of the reasoning rules    \\Sigma roman_ , then a  ( k , x ) k x (k,x) ( italic_k , italic_x ) -isomorphism anonymisation guarantees anonymity for any  x   x superscript x  x x^{\\prime}\\leq x italic_x start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT  italic_x .",
            "More in details, (a) is performed in  line 1 , where the weights are chosen in way such that the utility  U  subscript U  \\mathcal{U}_{\\Delta} caligraphic_U start_POSTSUBSCRIPT roman_ end_POSTSUBSCRIPT  is minimized. Ideally, we would like the change of weights to completely preserve the output of the queries on the KG. This is done by the  WeightNoising  function in Algorithm  2 , which randomly samples new weights for  M M M italic_M  times and chooses the ones that reach the smallest value of  U  subscript U  \\mathcal{U}_{\\Delta} caligraphic_U start_POSTSUBSCRIPT roman_ end_POSTSUBSCRIPT . Phase (b) is in  lines 2-3 . At this point, the graph  A A A italic_A  is the disjoint union of  k k k italic_k  copies of  G G G italic_G , which guarantees that each induced subgraph is KG-isomorphic to other  k  1 k 1 k-1 italic_k - 1  different subgraphs according to Definition  3.2 . These copies are linked together in  line 4  to guarantee that  A A A italic_A  is weakly connected. Phase (c) is addressed in  lines 520 . The  for  loop in  line 5  iterates on the vertices of a copy of  G G G italic_G  while the  for  loop in  line 7  iterates on the copies of  G G G italic_G , such that  v i j superscript subscript v i j v_{i}^{j} italic_v start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_j end_POSTSUPERSCRIPT  refers to the  i i i italic_i -th vertex in the  j j j italic_j -th copy  G j superscript G j G^{j} italic_G start_POSTSUPERSCRIPT italic_j end_POSTSUPERSCRIPT  of  G G G italic_G ; the last  for  loop in  line 8  repeats the procedure both for in-degree and out-degree. The goal is to add synthetic edges such that all the copies  { v i 2 , ... , v i k } superscript subscript v i 2 ... superscript subscript v i k \\{v_{i}^{2},\\dots,v_{i}^{k}\\} { italic_v start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT , ... , italic_v start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_k end_POSTSUPERSCRIPT }  of the vertex  v i 1 superscript subscript v i 1 v_{i}^{1} italic_v start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 1 end_POSTSUPERSCRIPT  have different sensitive attributes (Definition  3.3 ). To do so, we randomly assign a new in- (out-) degree to each of them with the use of the input degree distributions  p i  n subscript p i n p_{in} italic_p start_POSTSUBSCRIPT italic_i italic_n end_POSTSUBSCRIPT  and  p o  u  t subscript p o u t p_{out} italic_p start_POSTSUBSCRIPT italic_o italic_u italic_t end_POSTSUBSCRIPT , making sure that this value is bigger than the original one (since we do not want to remove any of the original edges) and that they are all different from one another ( lines 911 ). We then select a set of candidate vertices  C C \\mathcal{C} caligraphic_C  from (to) which add    \\Delta roman_  new edges to (from) each  v i j superscript subscript v i j v_{i}^{j} italic_v start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_j end_POSTSUPERSCRIPT  in order to meet the chosen in- (out-) degree. This set  C C \\mathcal{C} caligraphic_C  consists of all the vertices of the graph that (i) do not belong to the same copy  G j superscript G j G^{j} italic_G start_POSTSUPERSCRIPT italic_j end_POSTSUPERSCRIPT  of  v i j superscript subscript v i j v_{i}^{j} italic_v start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_j end_POSTSUPERSCRIPT , (ii) for which there is not already an existing edge and (iii) that do not belong to  V V \\mathcal{V} caligraphic_V , i.e., the set of vertices for which we have already added the synthetic edges to meet the chosen in- (out-) degree ( line 13 ). Condition (i) is necessary to not break the KG-isomorphisms between the subgraphs on the different copies of  G G G italic_G . If the cardinality of  C C \\mathcal{C} caligraphic_C  is less than the required number of edges that have to be added, we augment the graph with the needed number of new vertices ( lines 1416 ). We then randomly select    \\Delta roman_  vertices from  C C \\mathcal{C} caligraphic_C  and add the corresponding edges ( lines 1719 ). Finally, phase (d) is addressed in  line 21 , where to each vertex is assigned a new label; in phase (e) we assign a weight to each added synthetic edge ( line 22 ) to optimise the utility  U  subscript U  \\mathcal{U}_{\\Delta} caligraphic_U start_POSTSUBSCRIPT roman_ end_POSTSUBSCRIPT  again by the use of the function  WeightNoising .",
            "Algorithm  3  introduces  KGUARD , our second proposed algorithm to obtain a  ( k , x ) k x (k,x) ( italic_k , italic_x ) -isomorphism anonymisation of a KG. Our aim is to reduce the number of synthetic vertices and edges added by KLONE to reach the  ( k , x ) k x (k,x) ( italic_k , italic_x ) -isomorphism anonymisation by leveraging the subgraph isomorphisms that already exist in the original KG. The anonymised graph is constructed by: (a) noising the edge weights of the original KG while optimizing the utility metric  U  subscript U  \\mathcal{U}_{\\bigtriangleup} caligraphic_U start_POSTSUBSCRIPT  end_POSTSUBSCRIPT ; (b) finding all the induced subgraphs of size  x x x italic_x  and bucketing them into KG-isomorphic classes; (c) selecting  k k k italic_k  subgraphs in each bucket to guarantee the  k k k italic_k  KG-isomorphisms and/or duplicating some of such subgraphs if the bucket has less than  k k k italic_k  elements; (d) assigning different in- and out-degrees to the vertices mapped into each other by the KG-isomorphisms to reach diversity; (e) adding the synthetic edges to meet the requested in- and out-degrees; (f) anonymising the vertex labels; (g) assigning the weights to the synthetic edges while optimising  U  subscript U  \\mathcal{U}_{\\bigtriangleup} caligraphic_U start_POSTSUBSCRIPT  end_POSTSUBSCRIPT . Items (a), (f) and (g) are the same as in KLONE so we refer the reader to the previous section; they are in KGUARD respectively in  line 1 ,  line 31  and  line 32 . We now provide details of all the other items.",
            "We first find all the weakly connected subgraphs of the KG induced by a set of  x x x italic_x  vertices ( line 2 , function  ConnectedInducedSubgraphs ) 1 1 1 We adapt the algorithm by S. Karakashian et al.  [ 34 ]  to the case of directed graphs.  and gather them in  H H \\mathcal{H} caligraphic_H . Then, for each subgraph  H  H H H H\\in\\mathcal{H} italic_H  caligraphic_H , we apply the reasoning rules    \\Sigma roman_  to obtain their derived extensional component; together, they form the set  G G \\mathcal{G} caligraphic_G  ( line 2 ). Then, we group together the subgraphs of  G G \\mathcal{G} caligraphic_G  into KG-isomorphic clusters, referred to as  buckets : each bucket only contains subgraphs that are KG-isomorphic to each other according to Definition  3.2 . This happens in  line 3 , where the function  IsomorphismBucketing  returns  B B \\mathbb{B} blackboard_B , the set of buckets, and  I I \\mathbb{I} blackboard_I  the set of KG-isomorphism functions between any pair of KG-isomophic subgraphs found; to do so we use the algorithm in  [ 15 ] . The process of isomorphism bucketing is quite straightforward and it is done iteratively on the elements of  G G \\mathcal{G} caligraphic_G . Indeed, let  B B \\mathbb{B} blackboard_B  the set of KG-isomorphic buckets of the first  i i i italic_i  elements of  G G \\mathcal{G} caligraphic_G  and let  H i + 1  G subscript H i 1 G H_{i+1}\\in\\mathcal{G} italic_H start_POSTSUBSCRIPT italic_i + 1 end_POSTSUBSCRIPT  caligraphic_G  the next considered subgraph. Since the KG-isomorphism induces an equivalence relation, it suffices to check whether  H i + 1 subscript H i 1 H_{i+1} italic_H start_POSTSUBSCRIPT italic_i + 1 end_POSTSUBSCRIPT  is isomorphic to a representative of each equivalence class (bucket): if so, than  H i + 1 subscript H i 1 H_{i+1} italic_H start_POSTSUBSCRIPT italic_i + 1 end_POSTSUBSCRIPT  is added to such bucket, otherwise a new bucket is created with  H i + 1 subscript H i 1 H_{i+1} italic_H start_POSTSUBSCRIPT italic_i + 1 end_POSTSUBSCRIPT  as representative.",
            "Algorithm  3  returns a  ( k , x ) k x (k,x) ( italic_k , italic_x ) -isomorphism anonymisation  ( A ,  ) A  (A,\\Sigma) ( italic_A , roman_ )  of the input knowledge graph  ( G ,  ) G  (G,\\Sigma) ( italic_G , roman_ ) , for chosen  k , x  N k x N k,x\\in\\mathbb{N} italic_k , italic_x  blackboard_N  with  x  n x n x\\leq n italic_x  italic_n  and  k  ( n x ) k binomial n x k\\leq\\binom{n}{x} italic_k  ( FRACOP start_ARG italic_n end_ARG start_ARG italic_x end_ARG ) .",
            "We evaluate our work according to three key aspects of synthetic graph data, namely  fidelity ,  utility , and  privacy   [ 51 ] . The fidelity measures how much the anonymised graph is statistically  close  to the original one. We evaluate it in terms of number of vertices added to the original graph and of the Wasserstein-1 distance  [ 17 ]  between the original and anonymised graph of the degree and weight distributions. We then evaluate the utility of the anonymised graph with the metrics  U U \\mathcal{U} caligraphic_U  and  U  subscript U  \\mathcal{U}_{\\bigtriangleup} caligraphic_U start_POSTSUBSCRIPT  end_POSTSUBSCRIPT  of Definition  3.4 , measuring the correctness of potential down-stream tasks in the form of reasoning queries (see Section  3 ).For example, in the financial domain, they enable analysis on the number of holdings, payments, or controlled entities. We consider the following two business related queries:",
            "where ( 12 ) selects all the vertices of the KG with at least  2 2 2 2  out-going edges, and ( 13 ) selects all the vertices of the KG with at least  2 2 2 2  out-going edges with weight greater than  q q q italic_q . We set  q = 0 q 0 q=0 italic_q = 0  for all the considered networks but the economics networks, for which  q = 0.5 q 0.5 q=0.5 italic_q = 0.5 , as it is the threshold for establishing control.   \\hfill\\blacksquare",
            "We investigate the privacy of our approaches compared to existing work, specifically the work of J. Cheng et al.  [ 14 ]  to which we refer as  k-Iso . This method anonymizes graphs by forming  k k k italic_k  pairwise isomorphic subgraphs, making them indistinguishable to an adversary. However, as we qualitatively showed in Figure  2 , neglecting derived links in KGs results in severe privacy issues and information leaks. In Table  3 , we quantitatively evaluate the impact of derived edges using a    \\delta italic_ - anonymity  metric for  x = 4 x 4 x\\!=\\!4 italic_x = 4  and  k = 3 k 3 k\\!=\\!3 italic_k = 3 . We recall that such metric measures the percentage of isomorphic subgraph structures that are not uniquely identifiable. The table confirms our theoretical analysis: our approaches anonymise each individual subgraphs, and consistently achieve    a  n  o  n  y  m  i  t  y = 1.0  a n o n y m i t y 1.0 \\delta-anonymity=1.0 italic_ - italic_a italic_n italic_o italic_n italic_y italic_m italic_i italic_t italic_y = 1.0 . Contrarily the state-of-the-art approach  k-Iso  does not protect the privacy of all entities: in the worst case (Bitcoin-Alpha) only 60% of subgraphs are effectively not uniquely identifiable, leaving 40% of potentially identifiable entities by an attacker. The best case for the state-of-the-art algorithm is the Infect-Dublin network, which is less impacted by privacy leaks from derived edges, due to its simple structure and the absence of edge weights."
        ]
    },
    "id_table_4": {
        "caption": "Table 4:  Comparison of different attack models and solutions:    If a  commutative  property holds on    \\Sigma roman_  and  G G G italic_G  (Proposition  4.1 ), otherwise it holds for  [ x  = x ] delimited-[] superscript x  x [x^{\\prime}=x] [ italic_x start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT = italic_x ] ;    Only  k k k italic_k -isomorphism with  G G G italic_G  undirected graph;    Possibly adaptable to these cases.",
        "table": "S9.EGx4",
        "footnotes": [
            ""
        ],
        "references": [
            "Overview.  The remainder of the paper is organised as follows. Section  2  introduces the notation and the main background concepts. Section  3  and  4  formalise our problem and introduce the  ( k , x ) k x (k,x) ( italic_k , italic_x ) -isomorphism anonymisation along with the semantic utility metric. Sections  5  and  6  present the anonymisation algorithms, while in Section  7  we experimentally evaluate our approaches. In Section  8  and  9 , we respectively present the related work and the conclusion. Some of the proofs are in the on-line Appendix  [ 5 ] .",
            "Items (1)(3) of Def.  4.1  are trivially fulfilled for the  ( k , x  ) k superscript x  (k,x^{\\prime}) ( italic_k , italic_x start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ) -isomorphism anonymisation. Let now consider  X   V superscript X  V X^{\\prime}\\subset V italic_X start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT  italic_V  such that  | X  | = x   x superscript X  superscript x  x |X^{\\prime}|=x^{\\prime}\\leq x | italic_X start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT | = italic_x start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT  italic_x  and  G  [ X  ] G delimited-[] superscript X  G[X^{\\prime}] italic_G [ italic_X start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ]  is weakly connected. Then there must exist  X 1  V subscript X 1 V X_{1}\\subseteq V italic_X start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT  italic_V  such that  X   X 1 superscript X  subscript X 1 X^{\\prime}\\subseteq X_{1} italic_X start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT  italic_X start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ,  | X 1 | = x subscript X 1 x |X_{1}|=x | italic_X start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT | = italic_x , and  G  [ X 1 ] G delimited-[] subscript X 1 G[X_{1}] italic_G [ italic_X start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ]  is weakly connected, since  G G G italic_G  is weakly connected. By hypothesis there exist  X 2 , X 3 , ... , X k  V A subscript X 2 subscript X 3 ... subscript X k subscript V A X_{2},X_{3},\\ldots,X_{k}\\subseteq V_{A} italic_X start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , italic_X start_POSTSUBSCRIPT 3 end_POSTSUBSCRIPT , ... , italic_X start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT  italic_V start_POSTSUBSCRIPT italic_A end_POSTSUBSCRIPT  of cardinality  x x x italic_x  that fulfil item (4). Then   2  ( X  ) , ... ,  k  ( X  ) subscript  2 superscript X  ... subscript  k superscript X  \\Phi_{2}(X^{\\prime}),\\dots,\\Phi_{k}(X^{\\prime}) roman_ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ( italic_X start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ) , ... , roman_ start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_X start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT )  fulfil item (4) of Definition  4.1  for the  ( k , x  ) k superscript x  (k,x^{\\prime}) ( italic_k , italic_x start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ) -isomorphism anonymisation, since    ( A  [ X  ] ) =   ( A )  [ X  ]  A delimited-[] superscript X   A delimited-[] superscript X  \\Sigma(A[X^{\\prime}])=\\Sigma(A)[X^{\\prime}] roman_ ( italic_A [ italic_X start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ] ) = roman_ ( italic_A ) [ italic_X start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ]  and    ( A  [  i  ( X  ) ] ) =   ( A )  [  i  ( X  ) ]  A delimited-[] subscript  i superscript X   A delimited-[] subscript  i superscript X  \\Sigma(A[\\Phi_{i}(X^{\\prime})])=\\Sigma(A)[\\Phi_{i}(X^{\\prime})] roman_ ( italic_A [ roman_ start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT ( italic_X start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ) ] ) = roman_ ( italic_A ) [ roman_ start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT ( italic_X start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ) ]  for all  i  [ k ] i delimited-[] k i\\in[k] italic_i  [ italic_k ] .",
            "Note that Proposition  4.1  can be violated if  G G G italic_G  is not weakly connected. In such a case, a  ( k , x ) k x (k,x) ( italic_k , italic_x ) -isomorphism anonymisation  A A A italic_A  does not guarantee that a weakly connected component  C C C italic_C  of size  x  < x superscript x  x x^{\\prime}<x italic_x start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT < italic_x  is isomorphic to  k  1 k 1 k-1 italic_k - 1  other subgraphs, as it is not contained in any weakly connected subgraphs of size  x x x italic_x . This problem can be overcome by performing a  ( k , x  ) k superscript x  (k,x^{\\prime}) ( italic_k , italic_x start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ) -isomorphism anonymisation on every weakly connected component  C C C italic_C  of  G G G italic_G , with  x  = min  { x , | C | } superscript x  x C x^{\\prime}=\\min\\{x,|C|\\} italic_x start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT = roman_min { italic_x , | italic_C | } .",
            "Coversely, the hypothesis of the NAG to be weakly connected could be removed. Indeed, suppose to have a  ( k , x ) k x (k,x) ( italic_k , italic_x ) -isomorphism anonymisation  A A A italic_A  of  G G G italic_G  and a NAG of size  x x x italic_x  not weakly connected. Let  C 1 , ... , C m subscript C 1 ... subscript C m C_{1},\\dots,C_{m} italic_C start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , ... , italic_C start_POSTSUBSCRIPT italic_m end_POSTSUBSCRIPT  be its weakly connected components with  | C j | = x j subscript C j subscript x j |C_{j}|=x_{j} | italic_C start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT | = italic_x start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT  for  j  [ m ] j delimited-[] m j\\in[m] italic_j  [ italic_m ] : then each  C j subscript C j C_{j} italic_C start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT  is a weakly connected NAG with  x j < x subscript x j x x_{j}<x italic_x start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT < italic_x . By Proposition  4.1 ,  A A A italic_A  is anonymised for any of such components, hence it is resistant to the original attack. In view of this, a NAG that is not weakly connected can be equivalently seen as a sequence  C 1 , ... , C m subscript C 1 ... subscript C m C_{1},\\dots,C_{m} italic_C start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , ... , italic_C start_POSTSUBSCRIPT italic_m end_POSTSUBSCRIPT  of weakly connected NAGs of smaller size.",
            "Correctness.  We need to show that each item of Definition  4.1  is fulfilled by the output  A A A italic_A  of the algorithm, for every  x  [ n ] x delimited-[] n x\\in[n] italic_x  [ italic_n ] . The graph  G G G italic_G  is copied  k k k italic_k  times in  A A A italic_A  (weights included) in  line 3  and no vertex or edge is ever deleted by the algorithm, so item (1) of Definition  4.1  is fulfilled, as well as item (2) by  line 21  and item (3) by  line 1 . Let  G 1 , ... , G k superscript G 1 ... superscript G k G^{1},\\dots,G^{k} italic_G start_POSTSUPERSCRIPT 1 end_POSTSUPERSCRIPT , ... , italic_G start_POSTSUPERSCRIPT italic_k end_POSTSUPERSCRIPT  be the copies of  G G G italic_G  with  V  ( G j ) = { v 1 j , ... , v n j } V superscript G j subscript superscript v j 1 ... subscript superscript v j n V(G^{j})=\\{v^{j}_{1},\\dots,v^{j}_{n}\\} italic_V ( italic_G start_POSTSUPERSCRIPT italic_j end_POSTSUPERSCRIPT ) = { italic_v start_POSTSUPERSCRIPT italic_j end_POSTSUPERSCRIPT start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , ... , italic_v start_POSTSUPERSCRIPT italic_j end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT }  for  j  [ k ] j delimited-[] k j\\in[k] italic_j  [ italic_k ] . Consider the function   j : V  ( G 1 )  V  ( G j ) : subscript  j  V superscript G 1 V superscript G j \\Phi_{j}:V(G^{1})\\to V(G^{j}) roman_ start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT : italic_V ( italic_G start_POSTSUPERSCRIPT 1 end_POSTSUPERSCRIPT )  italic_V ( italic_G start_POSTSUPERSCRIPT italic_j end_POSTSUPERSCRIPT )  such that   j  ( v i 1 ) = v i j subscript  j subscript superscript v 1 i subscript superscript v j i \\Phi_{j}(v^{1}_{i})=v^{j}_{i} roman_ start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT ( italic_v start_POSTSUPERSCRIPT 1 end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT ) = italic_v start_POSTSUPERSCRIPT italic_j end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT  for each  i  [ n ] i delimited-[] n i\\in[n] italic_i  [ italic_n ] . Given  x  [ n ] x delimited-[] n x\\in[n] italic_x  [ italic_n ]  and  X 1 subscript X 1 X_{1} italic_X start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT  a set of  x x x italic_x  vertices of  G 1 superscript G 1 G^{1} italic_G start_POSTSUPERSCRIPT 1 end_POSTSUPERSCRIPT  such that  G 1  [ X 1 ] superscript G 1 delimited-[] subscript X 1 G^{1}[X_{1}] italic_G start_POSTSUPERSCRIPT 1 end_POSTSUPERSCRIPT [ italic_X start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ]  is weakly connected, the function   j | X 1 : X 1   j  ( X 1 )  V  ( G j ) \\Phi_{j_{|_{X_{1}}}}:X_{1}\\to\\Phi_{j}(X_{1})\\subseteq V(G^{j}) roman_ start_POSTSUBSCRIPT italic_j start_POSTSUBSCRIPT | start_POSTSUBSCRIPT italic_X start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUBSCRIPT end_POSTSUBSCRIPT end_POSTSUBSCRIPT : italic_X start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT  roman_ start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT ( italic_X start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT )  italic_V ( italic_G start_POSTSUPERSCRIPT italic_j end_POSTSUPERSCRIPT )  is a KG-isomorphism between  ( A  [ X 1 ] ,  ) A delimited-[] subscript X 1  (A[X_{1}],\\Sigma) ( italic_A [ italic_X start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ] , roman_ )  and  ( A  [  j  ( X 1 ) ] ,  ) A delimited-[] subscript  j subscript X 1  (A[\\Phi_{j}(X_{1})],\\Sigma) ( italic_A [ roman_ start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT ( italic_X start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ) ] , roman_ ) . Indeed the algorithm does not add edges between vertices of the same copy of  G G G italic_G  ( line 13 ), so it does not modify the topology of the induced subgraphs, meeting conditions ( 4 ) and ( 5 ) of KG-isomorphism. Moreover, by construction  X 1   j  ( X 1 ) =  subscript X 1 subscript  j subscript X 1 X_{1}\\cap\\Phi_{j}(X_{1})=\\emptyset italic_X start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT  roman_ start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT ( italic_X start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ) =  , thus items (4i) and (4ii) are satisfied. We are left with verifying item (4iii). The  while  loop in  lines 10-11  guarantees that, given  i  [ n ] i delimited-[] n i\\in[n] italic_i  [ italic_n ] , to each vertex in the set  { v i 1 , ... , v i k } subscript superscript v 1 i ... subscript superscript v k i \\{v^{1}_{i},\\dots,v^{k}_{i}\\} { italic_v start_POSTSUPERSCRIPT 1 end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT , ... , italic_v start_POSTSUPERSCRIPT italic_k end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT }  is associated a different out-degree and a different in-degree. This implies that   A  (  j  ( v i j ) ) =  A  (  j   ( v i j  ) ) subscript  A subscript  j subscript superscript v j i subscript  A subscript  superscript j  subscript superscript v superscript j  i \\xi_{{}_{A}}(\\Phi_{j}(v^{j}_{i}))\\neq\\xi_{{}_{A}}(\\Phi_{j^{\\prime}}(v^{j^{% \\prime}}_{i})) italic_ start_POSTSUBSCRIPT start_FLOATSUBSCRIPT italic_A end_FLOATSUBSCRIPT end_POSTSUBSCRIPT ( roman_ start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT ( italic_v start_POSTSUPERSCRIPT italic_j end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT ) ) = italic_ start_POSTSUBSCRIPT start_FLOATSUBSCRIPT italic_A end_FLOATSUBSCRIPT end_POSTSUBSCRIPT ( roman_ start_POSTSUBSCRIPT italic_j start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT end_POSTSUBSCRIPT ( italic_v start_POSTSUPERSCRIPT italic_j start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT ) )  for all  j = j  j superscript j  j\\neq j^{\\prime} italic_j = italic_j start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , thus satisfying item (4iii).  Computational time.  The computational time of the function  WeightNoising  (Algorithm  2 ) is  O  ( M  | S | ) O M S O(M|S|) italic_O ( italic_M | italic_S | ) , as the weight of each element of  S S S italic_S , the edge set in input, is updated  M M M italic_M  times. Therefore  line 1  of Algorithm  1  runs in  O  ( M  n 2 ) O M superscript n 2 O(Mn^{2}) italic_O ( italic_M italic_n start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT )  since  | E |  n 2 E superscript n 2 |E|\\leq n^{2} | italic_E |  italic_n start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT . As for  line 22 , let  V  ( A ) =  j V  ( G j )  W V A subscript j V subscript G j W V(A)=\\bigcup_{j}V(G_{j})\\cup W italic_V ( italic_A ) =  start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT italic_V ( italic_G start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT )  italic_W ; by the proof of Lemma  5.1  we have that  | W |  k  n + 1 W k n 1 |W|\\leq kn+1 | italic_W |  italic_k italic_n + 1 . We have already observed that Algorithm  1  ( lines 1319 ) adds edges only between  V  ( G j ) V subscript G j V(G_{j}) italic_V ( italic_G start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT )  and  V  ( G j  ) V subscript G superscript j  V(G_{j^{\\prime}}) italic_V ( italic_G start_POSTSUBSCRIPT italic_j start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT end_POSTSUBSCRIPT )  with  j = j  j superscript j  j\\neq j^{\\prime} italic_j = italic_j start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , i.e. between vertices that belong to two different copies of  G G G italic_G , and between   j V  ( G j ) subscript j V subscript G j \\bigcup_{j}V(G_{j})  start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT italic_V ( italic_G start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT )  and  W W W italic_W . Consequently, in the first case it can add a maximum of  ( k  1 )  k  n 2 k 1 k superscript n 2 (k-1)kn^{2} ( italic_k - 1 ) italic_k italic_n start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT  edges, while in the second case it can add up to  2  k  n  ( k  n + 1 ) 2 k n k n 1 2kn(kn+1) 2 italic_k italic_n ( italic_k italic_n + 1 )  edges. Therefore we have that  | S |  ( k  1 )  k  n 2 + 2  k  n  ( k  n + 1 ) S k 1 k superscript n 2 2 k n k n 1 |S|\\leq(k-1)kn^{2}+2kn(kn+1) | italic_S |  ( italic_k - 1 ) italic_k italic_n start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT + 2 italic_k italic_n ( italic_k italic_n + 1 )  and so the computational time of the function  WeightNoising  in  line 22  is  O  ( M  k 2  n 2 ) O M superscript k 2 superscript n 2 O(Mk^{2}n^{2}) italic_O ( italic_M italic_k start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT italic_n start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) . Lets now focus on the remaining parts of the algorithm.  Lines 24  clearly have a run time of  O  ( k  n ) O k n O(kn) italic_O ( italic_k italic_n ) . We claim that, for fixed  i i i italic_i  and  j j j italic_j , the maximum number of iterations that the  while  loop in  lines 1011  can do is  n + k n k n+k italic_n + italic_k . Indeed suppose that  d A   ( v i j ) superscript subscript d A  superscript subscript v i j d_{{}_{A}}^{\\varphi}(v_{i}^{j}) italic_d start_POSTSUBSCRIPT start_FLOATSUBSCRIPT italic_A end_FLOATSUBSCRIPT end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_ end_POSTSUPERSCRIPT ( italic_v start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_j end_POSTSUPERSCRIPT )  is equal to some   j   superscript subscript  superscript j   \\delta_{j^{\\prime}}^{\\varphi} italic_ start_POSTSUBSCRIPT italic_j start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_ end_POSTSUPERSCRIPT  for  j  < j superscript j  j j^{\\prime}<j italic_j start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT < italic_j , so that we enter the  while  loop. Let  {  1  , ... ,  j  1  } subscript superscript   1 ... subscript superscript   j 1 \\{\\delta^{\\varphi}_{1},\\dots,\\delta^{\\varphi}_{j-1}\\} { italic_ start_POSTSUPERSCRIPT italic_ end_POSTSUPERSCRIPT start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , ... , italic_ start_POSTSUPERSCRIPT italic_ end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_j - 1 end_POSTSUBSCRIPT }  be the already assigned degrees; we have three cases:",
            "From each bucket  B  B B B \\mathcal{B}\\in\\mathbb{B} caligraphic_B  blackboard_B  we want to choose  k k k italic_k  KG-isomorphic subgraphs with pairwise disjoint set of vertices ( lines 49 ). If the bucket  B B \\mathcal{B} caligraphic_B  has less than  k k k italic_k  vertex-disjoint subgraphs, we copy (and add to  A A A italic_A ) some of them until reaching  k k k italic_k  vertex-disjoint subgraphs ( lines 68 ). After this process, we leave in each bucket only the  k k k italic_k  chosen subgraphs ( line 9 ): they will be the ones fulfilling item (4) of Definition  4.1  of KG-isomorphism. We call  V V \\mathcal{V} caligraphic_V  the set of all the vertices appearing in at least a subgraph of a bucket: these are the vertices for which we want to guarantee the diversity of the sensitive attributes    \\xi italic_ . In  line 10  we ensure that the new graph  A A A italic_A  is weakly connected by randomly adding a synthetic edge between the original graph and each other weakly connected component. At the end of this part, each subgraph of the input KG  G G G italic_G  of cardinality  x x x italic_x  has other  k  1 k 1 k-1 italic_k - 1  subgraphs in  A A A italic_A  that are KG-isomorphic to it.",
            "Lines 1115  regard the assignment of a new in- and out-degree to the vertices of the KG-isomorphic subgraphs in order to guarantee diversity. To do so we first partition the set  V V \\mathcal{V} caligraphic_V  in equivalence classes  { V 1 , ... , V s } subscript V 1 ... subscript V s \\{V_{1},\\dots,V_{s}\\} { italic_V start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , ... , italic_V start_POSTSUBSCRIPT italic_s end_POSTSUBSCRIPT }  where  u , v  V u v V u,v\\in\\mathcal{V} italic_u , italic_v  caligraphic_V  belong to the same class if and only if there exists a KG-isomorphism    I  I \\Phi\\in\\mathbb{I} roman_  blackboard_I  such that    ( u ) = v  u v \\Phi(u)=v roman_ ( italic_u ) = italic_v . In other words, all the vertices in a class must have different sensitive attributes because they belong to subgraphs that are KG-isomorphic. This is done in  line 11  by the function  IsomorphismPartitioning . Then  lines 1215  assign a different in- and out-degree to each vertex belonging to the same class, with the use of the function  ChooseDeg . This function, described by Algorithm  4 , is similar to what done in KLONE: we draw them at random according to the input distributions  p in subscript p in p_{\\text{in}} italic_p start_POSTSUBSCRIPT in end_POSTSUBSCRIPT  and  p out subscript p out p_{\\text{out}} italic_p start_POSTSUBSCRIPT out end_POSTSUBSCRIPT , while making sure that the chosen values are always bigger or equal than the original one and that they are all different between each others.",
            "Lines 1630  add the necessary synthetic edges to meet the in- and out- degrees assigned in the previous step, thus making  A A A italic_A  satisfying condition (4iii) of the (k,x)-isomorphism anonymization in Definition  4.1 . For each  v  V v V v\\in\\mathcal{V} italic_v  caligraphic_V  we aim at selecting a set  C C \\mathcal{C} caligraphic_C  of candidate vertices from (to) which add    \\Delta roman_  new edges to (from)  v v v italic_v  in order to achieve the chosen in-(out-) degree. Such set  C C \\mathcal{C} caligraphic_C  is made of all the vertices  u u u italic_u  of the graph such that (i) its current out-(in-) degree  d A    ( u ) superscript subscript d A  u d_{A}^{\\neg\\varphi}(u) italic_d start_POSTSUBSCRIPT italic_A end_POSTSUBSCRIPT start_POSTSUPERSCRIPT  italic_ end_POSTSUPERSCRIPT ( italic_u )  is less that the assigned one  D    ( u ) superscript D  u D^{\\neg\\varphi}(u) italic_D start_POSTSUPERSCRIPT  italic_ end_POSTSUPERSCRIPT ( italic_u ) , so that they have space for new synthetic out- (in-)coming edges ( line 19 , where   i  n = o  u  t i n o u t \\neg in=out  italic_i italic_n = italic_o italic_u italic_t  and   o  u  t = i  n o u t i n \\neg out=in  italic_o italic_u italic_t = italic_i italic_n ), (ii) it does not belong to any of the subgraphs  H H H italic_H  appearing in the buckets for which  v  V  ( H ) v V H v\\in V(H) italic_v  italic_V ( italic_H )  ( line 20 ) and (iii) there does not already exist an edge between  v v v italic_v  and  u u u italic_u  ( line 20 ). Item (i) is important for not exceeding  D    ( u ) superscript D  u D^{\\neg\\varphi}(u) italic_D start_POSTSUPERSCRIPT  italic_ end_POSTSUPERSCRIPT ( italic_u ) , while point (ii) is crucial for not breaking the isomorphism between subgraphs since if  u , v  V  ( H ) u v V H u,v\\in V(H) italic_u , italic_v  italic_V ( italic_H ) , then adding an edge between  v v v italic_v  and  u u u italic_u  would modify the topology of  H H H italic_H . If the cardinality of  C C \\mathcal{C} caligraphic_C  is less than the required number    \\Delta roman_  of edges to be added ( line 21 ), we add to it  m =   | C | m  C m=\\Delta-|\\mathcal{C}| italic_m = roman_ - | caligraphic_C |  vertices of  A A A italic_A  that do not belong to  V V \\mathcal{V} caligraphic_V , as for them no prescribed in-/out-degree is required ( lines 22-23 ). If this is not possible because  V  ( A )  V V A V V(A)\\setminus\\mathcal{V} italic_V ( italic_A )  caligraphic_V  is too small, we create and augment  A A A italic_A  with new vertices ( lines 2426 ) to be added to  C C \\mathcal{C} caligraphic_C  so that  | C | =  C  |\\mathcal{C}|=\\Delta | caligraphic_C | = roman_ . We then randomly select    \\Delta roman_  vertices from  C C \\mathcal{C} caligraphic_C  ( line 28 ) and add the corresponding edges from (to) them to (from)  v v v italic_v  ( lines 29-30 ).",
            "( Sketch ) We need to show that each item of Definition  4.1  is fulfilled by the output  A A A italic_A  of the algorithm. The first observation is that no vertex or edge is ever deleted, so item (1) is fulfilled. Item (2) is satisfied in  line 31  and item (3) by  line 1  with the  WeightNoising  function.  Lines 29  guarantee that for each induced subgraph of size  x x x italic_x  there exist in  A A A italic_A  other  k  1 k 1 k-1 italic_k - 1  vertex-disjoint induced subgraphs that are KG-isomorphic to it. Indeed the  IsomorphismBucketing  function group together all the subgraphs of size  x x x italic_x  in KG-isomorphic classes. The  k k k italic_k  subgraphs are then chosen in each class if there are enough, otherwise some subgraphs of the class are copied and added to the graph until there are  k k k italic_k  of them ( lines 68 ). Since the chosen subgraphs are all vertex-disjoint item (4i) is fulfilled. Notice also that no edge is ever added within vertices of the same subgraph ( line 20 ), so the topology of the subgraphs are not modified: hence by construction item (4ii) is met. Finally, the function  IsomorphingPartitioning  ensures to group together the vertices that need to have different sensitive attributes    \\xi italic_ , as it puts in the same class all the vertices for which there is a KG-isomorphism that maps one to another. Subsequently the function  ChooseDeg  allocate different in- and out- degree to each vertex of a class and  lines 1630  add the needed synthetic edges, thus satisfying item (4iii).",
            "For the financial domain, we model the  control  relationship  [ 43 ]  between two companies, already introduced in Example  1.1 . Finally, in some experiments we also consider the  ultimate controller   [ 44 ] , introduced in Example  4.1 .",
            "We evaluate our work according to three key aspects of synthetic graph data, namely  fidelity ,  utility , and  privacy   [ 51 ] . The fidelity measures how much the anonymised graph is statistically  close  to the original one. We evaluate it in terms of number of vertices added to the original graph and of the Wasserstein-1 distance  [ 17 ]  between the original and anonymised graph of the degree and weight distributions. We then evaluate the utility of the anonymised graph with the metrics  U U \\mathcal{U} caligraphic_U  and  U  subscript U  \\mathcal{U}_{\\bigtriangleup} caligraphic_U start_POSTSUBSCRIPT  end_POSTSUBSCRIPT  of Definition  3.4 , measuring the correctness of potential down-stream tasks in the form of reasoning queries (see Section  3 ).For example, in the financial domain, they enable analysis on the number of holdings, payments, or controlled entities. We consider the following two business related queries:",
            "Split & Merge for Very Large Graphs . Although anonymization is a one-time process, large-scale graphs can be computationally expensive for applications requiring rapid and frequent processing. To address this challenge, simple divide-and-conquer heuristics can utilise our algorithms to create an anonymized graph more efficiently. In our experiments, we introduce a divide-and-conquer heuristic called  split-and-merge , which uses a modified Kernighan-Lin heuristic  [ 35 ]  to partition the original graph into smaller disjoint components. Specifically, the original graph  G G G italic_G  is recursively split into two balanced and disjoint subgraphs, by minimizing the cut set. The resulting weakly connected components  { G i } i  [ m ] subscript subscript G i i delimited-[] m \\{G_{i}\\}_{i\\in[m]} { italic_G start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT } start_POSTSUBSCRIPT italic_i  [ italic_m ] end_POSTSUBSCRIPT  are then anonymized individually and in parallel (trading compute for speed). The anonymized components are then recombined (merging phase, which adds edges between the components) to produce the final anonymized graph  A A A italic_A  according to a chosen method. By construction, any induced subgraph  Z  G Z G Z\\subseteq G italic_Z  italic_G  will either be entirely contained within a component  G i subscript G i G_{i} italic_G start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT  or not, depending on whether some edges of  Z Z Z italic_Z  are part of the cut sets. In the first case ( Z  G i Z subscript G i Z\\subseteq G_{i} italic_Z  italic_G start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT ), the subgraph is guaranteed to have other  k  1 k 1 k-1 italic_k - 1  KG-isomorphic subgraphs with different sensitive attributes, since the component  G i subscript G i G_{i} italic_G start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT  has been anonymized individually. In the latter scenario ( Z  G i not-subset-of-or-equals Z subscript G i Z\\not\\subseteq G_{i} italic_Z  italic_G start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT ), the presence of KG-isomorphic subgraphs is not guaranteed. However, if  Z Z Z italic_Z  is KG-isomorphic to another subgraph  Y  G j Y subscript G j Y\\subseteq G_{j} italic_Y  italic_G start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT , then again it has other  k  1 k 1 k-1 italic_k - 1  KG-isomorphic subgraphs with different sensitive attributes by construction. Otherwise,  Z Z Z italic_Z  must be explicitly anonymized during the merging phase. Our heuristics guarantees the anonymization of these subgraphs by excluding the cut-set edges from  A A A italic_A  during the merging phase, while adding other synthetic edges. This approach ensures that an attacker cannot re-identify the subgraphs, as the original ones no longer appear. However, it is important to note that this procedure may violate the augmentation requirement stated in item (1) of Definition  4.1 , making our heuristic useful when augmentation is not a priority. We plan to address this limitation as future work.",
            "Erdos-Renyi  In Figure  4  we investigates the fidelity and utility for the Erdos-Renyi graph models. In Figure ( 4 a) and ( 4 b), we vary the number of vertices  n n n italic_n  of the input graph, from 100 to 10,000. Figure ( 4 a) shows the percentage of vertices added by the algorithm with respect to the original ones ( Nodes Overhead ): KLONE consistently adds around 200% more vertices, influenced by the privacy requirement  k = 3 k 3 k=3 italic_k = 3 , while KGUARD adds fewer vertices as it exploits the isomorphic subgraphs that are already present in the input graph. The dotted horizontal line represents the theoretical upper bound of  ( 2  k  1 ) % percent 2 k 1 (2k-1)\\% ( 2 italic_k - 1 ) %  added vertices for KLONE (Lemma  5.1 ). The efficiency of KGUARD with respect to KLONE in terms of added structures is reflected in Figure ( 4 b), where KGUARD exhibits significantly lower utility loss compared to KLONE. In Figures ( 4 c) and ( 4 d), we vary the privacy requirement  k k k italic_k  from 2 to 8. As expected, in Figure ( 4 c) KLONE shows a linear increase in additional vertices with respect to  k k k italic_k , while KGUARD exhibits only a slight increase due to the need for some new added subgraphs. This trend is also reflected in the utility loss in Figure ( 4 d), where KLONE has worse utility compared to KGUARD. Finally, in Figures ( 4 e) and ( 4 f) we evaluate the anonymisation quality by varying the size  x x x italic_x  of the subgraphs. The performance of KLONE remains unaffected by  x x x italic_x  as expected, since the algorithm provides a  ( k , x ) k x (k,x) ( italic_k , italic_x ) -isomorphism anonymization for any  x  [ n ] x delimited-[] n x\\in[n] italic_x  [ italic_n ]  (Proposition  5.1 ), instead KGUARD overhead increases with the size of subgraphs  x x x italic_x . In general, when  x x x italic_x  is sufficiently large, or if we are uncertain about the attacker knowledge, KLONE might be the better choice. In fact, while KGUARD computational time increases with  x x x italic_x , KLONE maintains a consistent cost as a single anonymization  A A A italic_A  of  G G G italic_G  is effective for any choice of  x x x italic_x .",
            "Utility Example . In the case of the company ownership graph, we could release the anonymized graph  A A A italic_A  to external analysts, who might use it to solve a downstream task such as  How many Italian companies control at least 2 other companies? . For both algorithms, the analysts would obtain an approximately correct lower bound on the real number (since  U U \\mathcal{U} caligraphic_U  is close to 0), meaning that the companies that would have been identified in response to this query in the original graph  G G G italic_G  are also present in the anonymized graph  A A A italic_A . However, to preserve company identities, both approaches have created some redundant structures that might also positively answer this question. The symmetric utility  U  subscript U  \\mathcal{U}_{\\bigtriangleup} caligraphic_U start_POSTSUBSCRIPT  end_POSTSUBSCRIPT  reports the number of additional companies retrieved from this query that exist in  A A A italic_A  but not in  G G G italic_G . We find that 49% and 79% of the companies responding to this query, for KGUARD and KLONE respectively, are actually synthetic copies used to prevent re-identification. In general, our analysis confirms that  U  subscript U  \\mathcal{U}_{\\bigtriangleup} caligraphic_U start_POSTSUBSCRIPT  end_POSTSUBSCRIPT  depends on the number of additional structures created in the anonymized graph  A A A italic_A . For KLONE, the additional structures only partially depend on the input graph, and are mainly influenced by the number of anonymization copies  k k k italic_k  required (as shown also in Figure  4 ). In contrast, KGUARD works specifically on each subgraph, and additional structures are only needed if the original graph contains very unique subgraphs that require duplication. This difference is evident in various real-world graphs: while KLONE maintains a relatively high symmetric utility, KGUARD achieves values as low as 0.176 for the MovieLens graph, where fewer structures are needed and only 2% vertices are added.",
            "Analytical comparison . In Table  4  we summarize the performance of our anonymisation algorithms on the knowledge graph  G G G italic_G  against various levels of the attackers knowledge and we compare it with the existing work. The attacker can observe a weighted or unweighted induced subgraph,  G  [ X ] G delimited-[] X G[X] italic_G [ italic_X ]  and  G u  [ X ] superscript G u delimited-[] X G^{u}[X] italic_G start_POSTSUPERSCRIPT italic_u end_POSTSUPERSCRIPT [ italic_X ]  respectively. Moreover, the attacker can have knowledge also on the derived edges of the graph, namely    ( G )  G \\Sigma(G) roman_ ( italic_G ) , or on the entire reasoning rules    \\Sigma roman_ , namely the NAG  ( G  [ X ] ,  ) G delimited-[] X  (G[X],\\Sigma) ( italic_G [ italic_X ] , roman_ ) . The last cases refer to the use by the attacker of any other reasoning rules    superscript  \\Sigma^{*} roman_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT  useful to perform the attack. The    \\checkmark   indicates that we reach a  ( k , x ) k x (k,x) ( italic_k , italic_x ) -isomorphism anonymization for any size  x x x italic_x , which means that any subgraph has at least other  k  1 k 1 k-1 italic_k - 1  KG-isomorphic copies, while the specification  [  x   x ] delimited-[] for-all superscript x  x [\\forall x^{\\prime}\\leq x] [  italic_x start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT  italic_x ]  indicates that it is reached a  ( k , x ) k x (k,x) ( italic_k , italic_x ) -isomorphism anonymization for any size  x  superscript x  x^{\\prime} italic_x start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT  up to a fixed  x x x italic_x  in input. For KLONE, in Proposition  5.1  we proved that it reaches a  ( k , x ) k x (k,x) ( italic_k , italic_x ) -anonymisation for every  x  [ n ] x delimited-[] n x\\!\\in\\![n] italic_x  [ italic_n ] , thus it is resistant to an attack of type  ( G  [ X ] ,  ) G delimited-[] X  (G[X],\\Sigma) ( italic_G [ italic_X ] , roman_ )  for any  X  V  ( G ) X V G X\\!\\subseteq\\!V(G) italic_X  italic_V ( italic_G ) . Accordingly, it is resistant to attackers with less knowledge, namely    ( G  [ X ] )  G delimited-[] X \\Sigma(G[X]) roman_ ( italic_G [ italic_X ] ) ,  G  [ X ] G delimited-[] X G[X] italic_G [ italic_X ]  and all the unweighted ones. We are left to prove that it is resistant also to an attack of type  ( G  [ X ] ,   ) G delimited-[] X superscript  (G[X],\\Sigma^{*}) ( italic_G [ italic_X ] , roman_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT )  with    superscript  \\Sigma^{*} roman_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT  any set of reasoning rules. Such rules necessarily depend on the knowledge graph  G G G italic_G : since KLONE copies  G G G italic_G  exactly  k k k italic_k  times (after the perturbation of the weights), any rule of    superscript  \\Sigma^{*} roman_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT  will have the same outputs on each of the copies, so that for any  X  V X V X\\subset V italic_X  italic_V ,  ( G  [ X ] ,   ) G delimited-[] X superscript  (G[X],\\Sigma^{*}) ( italic_G [ italic_X ] , roman_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT )  is KG-isomorphic to other  k  1 k 1 k-1 italic_k - 1  subgraphs in  A A A italic_A , namely one in each copy of  G G G italic_G . As for KGUARD, Proposition  6.1  proved that it always produces a  ( k , x ) k x (k,x) ( italic_k , italic_x ) - isomorphism anonymisation  A A A italic_A  for given  k , x  N k x N k,x\\!\\in\\!\\mathbb{N} italic_k , italic_x  blackboard_N . However, unless    \\Sigma roman_  has some other properties (see Proposition  4.1 ) we cannot guarantee a  ( k , x  ) k superscript x  (k,x^{\\prime}) ( italic_k , italic_x start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ) -isomorphism anonymisation for any given  x  < x superscript x  x x^{\\prime}<x italic_x start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT < italic_x . Consider now an attack of type    ( G  [ X  ] )  G delimited-[] superscript X  \\Sigma(G[X^{\\prime}]) roman_ ( italic_G [ italic_X start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ] ) , where the attacker knows the derived edges of the induced subgraph  G  [ X  ] G delimited-[] superscript X  G[X^{\\prime}] italic_G [ italic_X start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ]  but he is not aware of the reasoning rules    \\Sigma roman_ . If  | X  | = x superscript X  x |X^{\\prime}|\\!=\\!x | italic_X start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT | = italic_x  we know that  A A A italic_A  is resistant to such attack, as the attacker has less knowledge than the NAG attack  ( G  [ X  ] ,  ) G delimited-[] superscript X   (G[X^{\\prime}],\\Sigma) ( italic_G [ italic_X start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ] , roman_ ) . Suppose now that  | X  | = x  < x superscript X  superscript x  x |X^{\\prime}|\\!=\\!x^{\\prime}\\!<\\!x | italic_X start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT | = italic_x start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT < italic_x . Since  G G G italic_G  is weakly connected, there exists  X X X italic_X  such that  X   X  V superscript X  X V X^{\\prime}\\!\\subseteq\\!X\\!\\subseteq\\!V italic_X start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT  italic_X  italic_V ,  | X | = x X x |X|\\!=\\!x | italic_X | = italic_x  and  G  [ X ] G delimited-[] X G[X] italic_G [ italic_X ]  is weakly connected. Since  G  [ X  ]  G  [ X ] G delimited-[] superscript X  G delimited-[] X G[X^{\\prime}]\\subseteq G[X] italic_G [ italic_X start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ]  italic_G [ italic_X ] , it holds that    ( G  [ X  ] )    ( G  [ X ] )  [ X  ]  G delimited-[] superscript X   G delimited-[] X delimited-[] superscript X  \\Sigma(G[X^{\\prime}])\\!\\subseteq\\!\\Sigma(G[X])[X^{\\prime}] roman_ ( italic_G [ italic_X start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ] )  roman_ ( italic_G [ italic_X ] ) [ italic_X start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ] : if they are equal, then  A A A italic_A  is resistant to the attack because the  ( k , x ) k x (k,x) ( italic_k , italic_x ) -isomorphism anonymisation guarantees that    ( G  [ X ] )  G delimited-[] X \\Sigma(G[X]) roman_ ( italic_G [ italic_X ] )  has other  k  1 k 1 k-1 italic_k - 1  KG-isomorphic copies, and so it holds for    ( G  [ X ] )  [ X  ] =   ( G  [ X  ] )  G delimited-[] X delimited-[] superscript X   G delimited-[] superscript X  \\Sigma(G[X])[X^{\\prime}]=\\Sigma(G[X^{\\prime}]) roman_ ( italic_G [ italic_X ] ) [ italic_X start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ] = roman_ ( italic_G [ italic_X start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ] ) . If    ( G  [ X  ] )    ( G  [ X ] )  [ X  ]  G delimited-[] superscript X   G delimited-[] X delimited-[] superscript X  \\Sigma(G[X^{\\prime}])\\!\\subset\\!\\Sigma(G[X])[X^{\\prime}] roman_ ( italic_G [ italic_X start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ] )  roman_ ( italic_G [ italic_X ] ) [ italic_X start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ] , it means that    ( G  [ X  ] )  G delimited-[] superscript X  \\Sigma(G[X^{\\prime}]) roman_ ( italic_G [ italic_X start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ] )  is not a subgraph induced by a set of vertices, so  A A A italic_A  is resistant again to the attack. Finally, this implies that  A A A italic_A  is resistant to all the attacks that involve less knowledge than    ( G  [ X ] )  G delimited-[] X \\Sigma(G[X]) roman_ ( italic_G [ italic_X ] ) , namely  G  [ X ] G delimited-[] X G[X] italic_G [ italic_X ]  and the unweighted ones (Table  4 ). Diversity is always guaranteed for both our algorithms."
        ]
    },
    "id_table_5": {
        "caption": "",
        "table": "S9.EGx5",
        "footnotes": [],
        "references": [
            "Overview.  The remainder of the paper is organised as follows. Section  2  introduces the notation and the main background concepts. Section  3  and  4  formalise our problem and introduce the  ( k , x ) k x (k,x) ( italic_k , italic_x ) -isomorphism anonymisation along with the semantic utility metric. Sections  5  and  6  present the anonymisation algorithms, while in Section  7  we experimentally evaluate our approaches. In Section  8  and  9 , we respectively present the related work and the conclusion. Some of the proofs are in the on-line Appendix  [ 5 ] .",
            "Correctness.  We need to show that each item of Definition  4.1  is fulfilled by the output  A A A italic_A  of the algorithm, for every  x  [ n ] x delimited-[] n x\\in[n] italic_x  [ italic_n ] . The graph  G G G italic_G  is copied  k k k italic_k  times in  A A A italic_A  (weights included) in  line 3  and no vertex or edge is ever deleted by the algorithm, so item (1) of Definition  4.1  is fulfilled, as well as item (2) by  line 21  and item (3) by  line 1 . Let  G 1 , ... , G k superscript G 1 ... superscript G k G^{1},\\dots,G^{k} italic_G start_POSTSUPERSCRIPT 1 end_POSTSUPERSCRIPT , ... , italic_G start_POSTSUPERSCRIPT italic_k end_POSTSUPERSCRIPT  be the copies of  G G G italic_G  with  V  ( G j ) = { v 1 j , ... , v n j } V superscript G j subscript superscript v j 1 ... subscript superscript v j n V(G^{j})=\\{v^{j}_{1},\\dots,v^{j}_{n}\\} italic_V ( italic_G start_POSTSUPERSCRIPT italic_j end_POSTSUPERSCRIPT ) = { italic_v start_POSTSUPERSCRIPT italic_j end_POSTSUPERSCRIPT start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , ... , italic_v start_POSTSUPERSCRIPT italic_j end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT }  for  j  [ k ] j delimited-[] k j\\in[k] italic_j  [ italic_k ] . Consider the function   j : V  ( G 1 )  V  ( G j ) : subscript  j  V superscript G 1 V superscript G j \\Phi_{j}:V(G^{1})\\to V(G^{j}) roman_ start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT : italic_V ( italic_G start_POSTSUPERSCRIPT 1 end_POSTSUPERSCRIPT )  italic_V ( italic_G start_POSTSUPERSCRIPT italic_j end_POSTSUPERSCRIPT )  such that   j  ( v i 1 ) = v i j subscript  j subscript superscript v 1 i subscript superscript v j i \\Phi_{j}(v^{1}_{i})=v^{j}_{i} roman_ start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT ( italic_v start_POSTSUPERSCRIPT 1 end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT ) = italic_v start_POSTSUPERSCRIPT italic_j end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT  for each  i  [ n ] i delimited-[] n i\\in[n] italic_i  [ italic_n ] . Given  x  [ n ] x delimited-[] n x\\in[n] italic_x  [ italic_n ]  and  X 1 subscript X 1 X_{1} italic_X start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT  a set of  x x x italic_x  vertices of  G 1 superscript G 1 G^{1} italic_G start_POSTSUPERSCRIPT 1 end_POSTSUPERSCRIPT  such that  G 1  [ X 1 ] superscript G 1 delimited-[] subscript X 1 G^{1}[X_{1}] italic_G start_POSTSUPERSCRIPT 1 end_POSTSUPERSCRIPT [ italic_X start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ]  is weakly connected, the function   j | X 1 : X 1   j  ( X 1 )  V  ( G j ) \\Phi_{j_{|_{X_{1}}}}:X_{1}\\to\\Phi_{j}(X_{1})\\subseteq V(G^{j}) roman_ start_POSTSUBSCRIPT italic_j start_POSTSUBSCRIPT | start_POSTSUBSCRIPT italic_X start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUBSCRIPT end_POSTSUBSCRIPT end_POSTSUBSCRIPT : italic_X start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT  roman_ start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT ( italic_X start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT )  italic_V ( italic_G start_POSTSUPERSCRIPT italic_j end_POSTSUPERSCRIPT )  is a KG-isomorphism between  ( A  [ X 1 ] ,  ) A delimited-[] subscript X 1  (A[X_{1}],\\Sigma) ( italic_A [ italic_X start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ] , roman_ )  and  ( A  [  j  ( X 1 ) ] ,  ) A delimited-[] subscript  j subscript X 1  (A[\\Phi_{j}(X_{1})],\\Sigma) ( italic_A [ roman_ start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT ( italic_X start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ) ] , roman_ ) . Indeed the algorithm does not add edges between vertices of the same copy of  G G G italic_G  ( line 13 ), so it does not modify the topology of the induced subgraphs, meeting conditions ( 4 ) and ( 5 ) of KG-isomorphism. Moreover, by construction  X 1   j  ( X 1 ) =  subscript X 1 subscript  j subscript X 1 X_{1}\\cap\\Phi_{j}(X_{1})=\\emptyset italic_X start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT  roman_ start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT ( italic_X start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ) =  , thus items (4i) and (4ii) are satisfied. We are left with verifying item (4iii). The  while  loop in  lines 10-11  guarantees that, given  i  [ n ] i delimited-[] n i\\in[n] italic_i  [ italic_n ] , to each vertex in the set  { v i 1 , ... , v i k } subscript superscript v 1 i ... subscript superscript v k i \\{v^{1}_{i},\\dots,v^{k}_{i}\\} { italic_v start_POSTSUPERSCRIPT 1 end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT , ... , italic_v start_POSTSUPERSCRIPT italic_k end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT }  is associated a different out-degree and a different in-degree. This implies that   A  (  j  ( v i j ) ) =  A  (  j   ( v i j  ) ) subscript  A subscript  j subscript superscript v j i subscript  A subscript  superscript j  subscript superscript v superscript j  i \\xi_{{}_{A}}(\\Phi_{j}(v^{j}_{i}))\\neq\\xi_{{}_{A}}(\\Phi_{j^{\\prime}}(v^{j^{% \\prime}}_{i})) italic_ start_POSTSUBSCRIPT start_FLOATSUBSCRIPT italic_A end_FLOATSUBSCRIPT end_POSTSUBSCRIPT ( roman_ start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT ( italic_v start_POSTSUPERSCRIPT italic_j end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT ) ) = italic_ start_POSTSUBSCRIPT start_FLOATSUBSCRIPT italic_A end_FLOATSUBSCRIPT end_POSTSUBSCRIPT ( roman_ start_POSTSUBSCRIPT italic_j start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT end_POSTSUBSCRIPT ( italic_v start_POSTSUPERSCRIPT italic_j start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT ) )  for all  j = j  j superscript j  j\\neq j^{\\prime} italic_j = italic_j start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , thus satisfying item (4iii).  Computational time.  The computational time of the function  WeightNoising  (Algorithm  2 ) is  O  ( M  | S | ) O M S O(M|S|) italic_O ( italic_M | italic_S | ) , as the weight of each element of  S S S italic_S , the edge set in input, is updated  M M M italic_M  times. Therefore  line 1  of Algorithm  1  runs in  O  ( M  n 2 ) O M superscript n 2 O(Mn^{2}) italic_O ( italic_M italic_n start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT )  since  | E |  n 2 E superscript n 2 |E|\\leq n^{2} | italic_E |  italic_n start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT . As for  line 22 , let  V  ( A ) =  j V  ( G j )  W V A subscript j V subscript G j W V(A)=\\bigcup_{j}V(G_{j})\\cup W italic_V ( italic_A ) =  start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT italic_V ( italic_G start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT )  italic_W ; by the proof of Lemma  5.1  we have that  | W |  k  n + 1 W k n 1 |W|\\leq kn+1 | italic_W |  italic_k italic_n + 1 . We have already observed that Algorithm  1  ( lines 1319 ) adds edges only between  V  ( G j ) V subscript G j V(G_{j}) italic_V ( italic_G start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT )  and  V  ( G j  ) V subscript G superscript j  V(G_{j^{\\prime}}) italic_V ( italic_G start_POSTSUBSCRIPT italic_j start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT end_POSTSUBSCRIPT )  with  j = j  j superscript j  j\\neq j^{\\prime} italic_j = italic_j start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , i.e. between vertices that belong to two different copies of  G G G italic_G , and between   j V  ( G j ) subscript j V subscript G j \\bigcup_{j}V(G_{j})  start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT italic_V ( italic_G start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT )  and  W W W italic_W . Consequently, in the first case it can add a maximum of  ( k  1 )  k  n 2 k 1 k superscript n 2 (k-1)kn^{2} ( italic_k - 1 ) italic_k italic_n start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT  edges, while in the second case it can add up to  2  k  n  ( k  n + 1 ) 2 k n k n 1 2kn(kn+1) 2 italic_k italic_n ( italic_k italic_n + 1 )  edges. Therefore we have that  | S |  ( k  1 )  k  n 2 + 2  k  n  ( k  n + 1 ) S k 1 k superscript n 2 2 k n k n 1 |S|\\leq(k-1)kn^{2}+2kn(kn+1) | italic_S |  ( italic_k - 1 ) italic_k italic_n start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT + 2 italic_k italic_n ( italic_k italic_n + 1 )  and so the computational time of the function  WeightNoising  in  line 22  is  O  ( M  k 2  n 2 ) O M superscript k 2 superscript n 2 O(Mk^{2}n^{2}) italic_O ( italic_M italic_k start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT italic_n start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) . Lets now focus on the remaining parts of the algorithm.  Lines 24  clearly have a run time of  O  ( k  n ) O k n O(kn) italic_O ( italic_k italic_n ) . We claim that, for fixed  i i i italic_i  and  j j j italic_j , the maximum number of iterations that the  while  loop in  lines 1011  can do is  n + k n k n+k italic_n + italic_k . Indeed suppose that  d A   ( v i j ) superscript subscript d A  superscript subscript v i j d_{{}_{A}}^{\\varphi}(v_{i}^{j}) italic_d start_POSTSUBSCRIPT start_FLOATSUBSCRIPT italic_A end_FLOATSUBSCRIPT end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_ end_POSTSUPERSCRIPT ( italic_v start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_j end_POSTSUPERSCRIPT )  is equal to some   j   superscript subscript  superscript j   \\delta_{j^{\\prime}}^{\\varphi} italic_ start_POSTSUBSCRIPT italic_j start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_ end_POSTSUPERSCRIPT  for  j  < j superscript j  j j^{\\prime}<j italic_j start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT < italic_j , so that we enter the  while  loop. Let  {  1  , ... ,  j  1  } subscript superscript   1 ... subscript superscript   j 1 \\{\\delta^{\\varphi}_{1},\\dots,\\delta^{\\varphi}_{j-1}\\} { italic_ start_POSTSUPERSCRIPT italic_ end_POSTSUPERSCRIPT start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , ... , italic_ start_POSTSUPERSCRIPT italic_ end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_j - 1 end_POSTSUBSCRIPT }  be the already assigned degrees; we have three cases:",
            "If (i) holds,  max  {  j  + 1 , z  p  } =  j  + 1 superscript subscript  j  1 similar-to z subscript p  superscript subscript  j  1 \\max\\{\\delta_{j}^{\\varphi}+1,z\\sim p_{\\varphi}\\}=\\delta_{j}^{\\varphi}+1 roman_max { italic_ start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_ end_POSTSUPERSCRIPT + 1 , italic_z  italic_p start_POSTSUBSCRIPT italic_ end_POSTSUBSCRIPT } = italic_ start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_ end_POSTSUPERSCRIPT + 1 ; therefore, since at every iteration   j  superscript subscript  j  \\delta_{j}^{\\varphi} italic_ start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_ end_POSTSUPERSCRIPT  is increased by  1 1 1 1 , in at most  j  2 j 2 j-2 italic_j - 2  iterations we exit the  while  loop. If (ii) holds, the worst case is achieved when  z = n z n z=n italic_z = italic_n  in each draw from the distribution  p  subscript p  p_{\\varphi} italic_p start_POSTSUBSCRIPT italic_ end_POSTSUBSCRIPT  and   s  = n subscript superscript   s n \\delta^{\\varphi}_{s}=n italic_ start_POSTSUPERSCRIPT italic_ end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_s end_POSTSUBSCRIPT = italic_n  for some  s  [ j  1 ] s delimited-[] j 1 s\\in[j-1] italic_s  [ italic_j - 1 ] . This implies that  max  {  j  + 1 , z  p  } = z superscript subscript  j  1 similar-to z subscript p  z \\max\\{\\delta_{j}^{\\varphi}+1,z\\sim p_{\\varphi}\\}=z roman_max { italic_ start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_ end_POSTSUPERSCRIPT + 1 , italic_z  italic_p start_POSTSUBSCRIPT italic_ end_POSTSUBSCRIPT } = italic_z  until   j  > n superscript subscript  j  n \\delta_{j}^{\\varphi}>n italic_ start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_ end_POSTSUPERSCRIPT > italic_n , which is achieved in at most  n  1 n 1 n-1 italic_n - 1  iterations. Finally for case (iii), if  d A   ( v i j ) > n superscript subscript d A  superscript subscript v i j n d_{{}_{A}}^{\\varphi}(v_{i}^{j})>n italic_d start_POSTSUBSCRIPT start_FLOATSUBSCRIPT italic_A end_FLOATSUBSCRIPT end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_ end_POSTSUPERSCRIPT ( italic_v start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_j end_POSTSUPERSCRIPT ) > italic_n  we conclude as in case (i), where the number of iterations is upper-bounded by  j  2 j 2 j-2 italic_j - 2 . If  d A   ( v i j )  n superscript subscript d A  superscript subscript v i j n d_{{}_{A}}^{\\varphi}(v_{i}^{j})\\leq n italic_d start_POSTSUBSCRIPT start_FLOATSUBSCRIPT italic_A end_FLOATSUBSCRIPT end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_ end_POSTSUPERSCRIPT ( italic_v start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_j end_POSTSUPERSCRIPT )  italic_n , the worst case is achieved when  d A   ( v i j ) = 1 =  1  superscript subscript d A  superscript subscript v i j 1 superscript subscript  1  d_{{}_{A}}^{\\varphi}(v_{i}^{j})=1=\\delta_{1}^{\\varphi} italic_d start_POSTSUBSCRIPT start_FLOATSUBSCRIPT italic_A end_FLOATSUBSCRIPT end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_ end_POSTSUPERSCRIPT ( italic_v start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_j end_POSTSUPERSCRIPT ) = 1 = italic_ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_ end_POSTSUPERSCRIPT ,  z = n =  2  z n superscript subscript  2  z=n=\\delta_{2}^{\\varphi} italic_z = italic_n = italic_ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_ end_POSTSUPERSCRIPT  in each draw from the distribution  p  subscript p  p_{\\varphi} italic_p start_POSTSUBSCRIPT italic_ end_POSTSUBSCRIPT  and   s  = n + s  2 superscript subscript  s  n s 2 \\delta_{s}^{\\varphi}=n+s-2 italic_ start_POSTSUBSCRIPT italic_s end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_ end_POSTSUPERSCRIPT = italic_n + italic_s - 2  for each  s = 3 , ... , j  1 s 3 ... j 1 s=3,\\dots,j-1 italic_s = 3 , ... , italic_j - 1 . In this case the  while  loop must do  n + j  3 n j 3 n+j-3 italic_n + italic_j - 3  iterations before exiting, i.e. when   j  superscript subscript  j  \\delta_{j}^{\\varphi} italic_ start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_ end_POSTSUPERSCRIPT  reaches the value  n + j  3 n j 3 n+j-3 italic_n + italic_j - 3 . Since  j  k j k j\\leq k italic_j  italic_k , we conclude that  lines 10-11  iterate at most  n + k n k n+k italic_n + italic_k  times. Finally, by Lemma  5.1  we have that  | C |  2  k  n + 1 C 2 k n 1 |\\mathcal{C}|\\leq 2kn+1 | caligraphic_C |  2 italic_k italic_n + 1  in  line 13 . By the same Lemma, the total number of vertices added by the algorithm is at most  k  n + 1 k n 1 kn+1 italic_k italic_n + 1  and so the total number of edges added is  O  ( k 2  n 2 ) O superscript k 2 superscript n 2 O(k^{2}n^{2}) italic_O ( italic_k start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT italic_n start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) , which describe the overall computational time of  lines 1419 . Therefore the  for  loop in  lines 520  runs in  O  ( 2  n  k  ( n + k + 2  k  n + 1 ) ) + O  ( k 2  n 2 ) = O  ( k 2  n 2 ) O 2 n k n k 2 k n 1 O superscript k 2 superscript n 2 O superscript k 2 superscript n 2 O(2nk(n+k+2kn+1))+O(k^{2}n^{2})=O(k^{2}n^{2}) italic_O ( 2 italic_n italic_k ( italic_n + italic_k + 2 italic_k italic_n + 1 ) ) + italic_O ( italic_k start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT italic_n start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) = italic_O ( italic_k start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT italic_n start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) . Since  line 21  runs in  O  ( k  n ) O k n O(kn) italic_O ( italic_k italic_n ) , the total computational time is  O  ( M  k 2  n 2 ) O M superscript k 2 superscript n 2 O(Mk^{2}n^{2}) italic_O ( italic_M italic_k start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT italic_n start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) .",
            "Erdos-Renyi  In Figure  4  we investigates the fidelity and utility for the Erdos-Renyi graph models. In Figure ( 4 a) and ( 4 b), we vary the number of vertices  n n n italic_n  of the input graph, from 100 to 10,000. Figure ( 4 a) shows the percentage of vertices added by the algorithm with respect to the original ones ( Nodes Overhead ): KLONE consistently adds around 200% more vertices, influenced by the privacy requirement  k = 3 k 3 k=3 italic_k = 3 , while KGUARD adds fewer vertices as it exploits the isomorphic subgraphs that are already present in the input graph. The dotted horizontal line represents the theoretical upper bound of  ( 2  k  1 ) % percent 2 k 1 (2k-1)\\% ( 2 italic_k - 1 ) %  added vertices for KLONE (Lemma  5.1 ). The efficiency of KGUARD with respect to KLONE in terms of added structures is reflected in Figure ( 4 b), where KGUARD exhibits significantly lower utility loss compared to KLONE. In Figures ( 4 c) and ( 4 d), we vary the privacy requirement  k k k italic_k  from 2 to 8. As expected, in Figure ( 4 c) KLONE shows a linear increase in additional vertices with respect to  k k k italic_k , while KGUARD exhibits only a slight increase due to the need for some new added subgraphs. This trend is also reflected in the utility loss in Figure ( 4 d), where KLONE has worse utility compared to KGUARD. Finally, in Figures ( 4 e) and ( 4 f) we evaluate the anonymisation quality by varying the size  x x x italic_x  of the subgraphs. The performance of KLONE remains unaffected by  x x x italic_x  as expected, since the algorithm provides a  ( k , x ) k x (k,x) ( italic_k , italic_x ) -isomorphism anonymization for any  x  [ n ] x delimited-[] n x\\in[n] italic_x  [ italic_n ]  (Proposition  5.1 ), instead KGUARD overhead increases with the size of subgraphs  x x x italic_x . In general, when  x x x italic_x  is sufficiently large, or if we are uncertain about the attacker knowledge, KLONE might be the better choice. In fact, while KGUARD computational time increases with  x x x italic_x , KLONE maintains a consistent cost as a single anonymization  A A A italic_A  of  G G G italic_G  is effective for any choice of  x x x italic_x .",
            "Scale-free . Figure  5  illustrates the performance of our algorithms on a scale-free network with   = 5  5 \\alpha\\!=\\!5 italic_ = 5  and with varying numbers of vertices up to  100 , 000 100 000 100,000 100 , 000 . For networks exceeding  10 , 000 10 000 10,000 10 , 000  vertices (denoted by the vertical red line) we employ and evaluate our split  & \\& &  merge procedure. Figure ( 5 a) shows that, as the network size increases, KGUARD introduces very few additional vertices, while KLONE remains consistent with around 200% added vertices. Indeed, as the graph size increases, it is more probable to find within it subgraphs that are already KG-isomorphic, thus reducing the number of vertices that KGUARD needs to add. We also note that the split  & \\& &  merge procedure does not introduce any significant overhead. In Figure ( 5 b) and ( 5 c) we evaluate the fidelity of degree and weight distributions with respect to the original graph. As the number of vertices increases, KGUARD performs better due to fewer alterations made to the graph, while KLONE shows a higher discrepancy in distributions compared to the original graph, with a stable Wasserstein distance due to the consistent changes it makes to the graph. Interestingly, the split  & \\& &  merge procedure only slightly impacts KGUARD performance: the algorithm focuses on smaller subgraphs of   1 , 000 similar-to absent 1 000 \\sim 1,000  1 , 000  vertices, which require more redundancy to ensure privacy. This overhead is justified in Figure ( 5 d), where the split procedure significantly reduces the computational time.",
            "Analytical comparison . In Table  4  we summarize the performance of our anonymisation algorithms on the knowledge graph  G G G italic_G  against various levels of the attackers knowledge and we compare it with the existing work. The attacker can observe a weighted or unweighted induced subgraph,  G  [ X ] G delimited-[] X G[X] italic_G [ italic_X ]  and  G u  [ X ] superscript G u delimited-[] X G^{u}[X] italic_G start_POSTSUPERSCRIPT italic_u end_POSTSUPERSCRIPT [ italic_X ]  respectively. Moreover, the attacker can have knowledge also on the derived edges of the graph, namely    ( G )  G \\Sigma(G) roman_ ( italic_G ) , or on the entire reasoning rules    \\Sigma roman_ , namely the NAG  ( G  [ X ] ,  ) G delimited-[] X  (G[X],\\Sigma) ( italic_G [ italic_X ] , roman_ ) . The last cases refer to the use by the attacker of any other reasoning rules    superscript  \\Sigma^{*} roman_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT  useful to perform the attack. The    \\checkmark   indicates that we reach a  ( k , x ) k x (k,x) ( italic_k , italic_x ) -isomorphism anonymization for any size  x x x italic_x , which means that any subgraph has at least other  k  1 k 1 k-1 italic_k - 1  KG-isomorphic copies, while the specification  [  x   x ] delimited-[] for-all superscript x  x [\\forall x^{\\prime}\\leq x] [  italic_x start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT  italic_x ]  indicates that it is reached a  ( k , x ) k x (k,x) ( italic_k , italic_x ) -isomorphism anonymization for any size  x  superscript x  x^{\\prime} italic_x start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT  up to a fixed  x x x italic_x  in input. For KLONE, in Proposition  5.1  we proved that it reaches a  ( k , x ) k x (k,x) ( italic_k , italic_x ) -anonymisation for every  x  [ n ] x delimited-[] n x\\!\\in\\![n] italic_x  [ italic_n ] , thus it is resistant to an attack of type  ( G  [ X ] ,  ) G delimited-[] X  (G[X],\\Sigma) ( italic_G [ italic_X ] , roman_ )  for any  X  V  ( G ) X V G X\\!\\subseteq\\!V(G) italic_X  italic_V ( italic_G ) . Accordingly, it is resistant to attackers with less knowledge, namely    ( G  [ X ] )  G delimited-[] X \\Sigma(G[X]) roman_ ( italic_G [ italic_X ] ) ,  G  [ X ] G delimited-[] X G[X] italic_G [ italic_X ]  and all the unweighted ones. We are left to prove that it is resistant also to an attack of type  ( G  [ X ] ,   ) G delimited-[] X superscript  (G[X],\\Sigma^{*}) ( italic_G [ italic_X ] , roman_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT )  with    superscript  \\Sigma^{*} roman_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT  any set of reasoning rules. Such rules necessarily depend on the knowledge graph  G G G italic_G : since KLONE copies  G G G italic_G  exactly  k k k italic_k  times (after the perturbation of the weights), any rule of    superscript  \\Sigma^{*} roman_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT  will have the same outputs on each of the copies, so that for any  X  V X V X\\subset V italic_X  italic_V ,  ( G  [ X ] ,   ) G delimited-[] X superscript  (G[X],\\Sigma^{*}) ( italic_G [ italic_X ] , roman_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT )  is KG-isomorphic to other  k  1 k 1 k-1 italic_k - 1  subgraphs in  A A A italic_A , namely one in each copy of  G G G italic_G . As for KGUARD, Proposition  6.1  proved that it always produces a  ( k , x ) k x (k,x) ( italic_k , italic_x ) - isomorphism anonymisation  A A A italic_A  for given  k , x  N k x N k,x\\!\\in\\!\\mathbb{N} italic_k , italic_x  blackboard_N . However, unless    \\Sigma roman_  has some other properties (see Proposition  4.1 ) we cannot guarantee a  ( k , x  ) k superscript x  (k,x^{\\prime}) ( italic_k , italic_x start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ) -isomorphism anonymisation for any given  x  < x superscript x  x x^{\\prime}<x italic_x start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT < italic_x . Consider now an attack of type    ( G  [ X  ] )  G delimited-[] superscript X  \\Sigma(G[X^{\\prime}]) roman_ ( italic_G [ italic_X start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ] ) , where the attacker knows the derived edges of the induced subgraph  G  [ X  ] G delimited-[] superscript X  G[X^{\\prime}] italic_G [ italic_X start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ]  but he is not aware of the reasoning rules    \\Sigma roman_ . If  | X  | = x superscript X  x |X^{\\prime}|\\!=\\!x | italic_X start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT | = italic_x  we know that  A A A italic_A  is resistant to such attack, as the attacker has less knowledge than the NAG attack  ( G  [ X  ] ,  ) G delimited-[] superscript X   (G[X^{\\prime}],\\Sigma) ( italic_G [ italic_X start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ] , roman_ ) . Suppose now that  | X  | = x  < x superscript X  superscript x  x |X^{\\prime}|\\!=\\!x^{\\prime}\\!<\\!x | italic_X start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT | = italic_x start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT < italic_x . Since  G G G italic_G  is weakly connected, there exists  X X X italic_X  such that  X   X  V superscript X  X V X^{\\prime}\\!\\subseteq\\!X\\!\\subseteq\\!V italic_X start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT  italic_X  italic_V ,  | X | = x X x |X|\\!=\\!x | italic_X | = italic_x  and  G  [ X ] G delimited-[] X G[X] italic_G [ italic_X ]  is weakly connected. Since  G  [ X  ]  G  [ X ] G delimited-[] superscript X  G delimited-[] X G[X^{\\prime}]\\subseteq G[X] italic_G [ italic_X start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ]  italic_G [ italic_X ] , it holds that    ( G  [ X  ] )    ( G  [ X ] )  [ X  ]  G delimited-[] superscript X   G delimited-[] X delimited-[] superscript X  \\Sigma(G[X^{\\prime}])\\!\\subseteq\\!\\Sigma(G[X])[X^{\\prime}] roman_ ( italic_G [ italic_X start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ] )  roman_ ( italic_G [ italic_X ] ) [ italic_X start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ] : if they are equal, then  A A A italic_A  is resistant to the attack because the  ( k , x ) k x (k,x) ( italic_k , italic_x ) -isomorphism anonymisation guarantees that    ( G  [ X ] )  G delimited-[] X \\Sigma(G[X]) roman_ ( italic_G [ italic_X ] )  has other  k  1 k 1 k-1 italic_k - 1  KG-isomorphic copies, and so it holds for    ( G  [ X ] )  [ X  ] =   ( G  [ X  ] )  G delimited-[] X delimited-[] superscript X   G delimited-[] superscript X  \\Sigma(G[X])[X^{\\prime}]=\\Sigma(G[X^{\\prime}]) roman_ ( italic_G [ italic_X ] ) [ italic_X start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ] = roman_ ( italic_G [ italic_X start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ] ) . If    ( G  [ X  ] )    ( G  [ X ] )  [ X  ]  G delimited-[] superscript X   G delimited-[] X delimited-[] superscript X  \\Sigma(G[X^{\\prime}])\\!\\subset\\!\\Sigma(G[X])[X^{\\prime}] roman_ ( italic_G [ italic_X start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ] )  roman_ ( italic_G [ italic_X ] ) [ italic_X start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ] , it means that    ( G  [ X  ] )  G delimited-[] superscript X  \\Sigma(G[X^{\\prime}]) roman_ ( italic_G [ italic_X start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ] )  is not a subgraph induced by a set of vertices, so  A A A italic_A  is resistant again to the attack. Finally, this implies that  A A A italic_A  is resistant to all the attacks that involve less knowledge than    ( G  [ X ] )  G delimited-[] X \\Sigma(G[X]) roman_ ( italic_G [ italic_X ] ) , namely  G  [ X ] G delimited-[] X G[X] italic_G [ italic_X ]  and the unweighted ones (Table  4 ). Diversity is always guaranteed for both our algorithms."
        ]
    },
    "id_table_6": {
        "caption": "",
        "table": "S9.EGx6",
        "footnotes": [],
        "references": [
            "Overview.  The remainder of the paper is organised as follows. Section  2  introduces the notation and the main background concepts. Section  3  and  4  formalise our problem and introduce the  ( k , x ) k x (k,x) ( italic_k , italic_x ) -isomorphism anonymisation along with the semantic utility metric. Sections  5  and  6  present the anonymisation algorithms, while in Section  7  we experimentally evaluate our approaches. In Section  8  and  9 , we respectively present the related work and the conclusion. Some of the proofs are in the on-line Appendix  [ 5 ] .",
            "Analytical comparison . In Table  4  we summarize the performance of our anonymisation algorithms on the knowledge graph  G G G italic_G  against various levels of the attackers knowledge and we compare it with the existing work. The attacker can observe a weighted or unweighted induced subgraph,  G  [ X ] G delimited-[] X G[X] italic_G [ italic_X ]  and  G u  [ X ] superscript G u delimited-[] X G^{u}[X] italic_G start_POSTSUPERSCRIPT italic_u end_POSTSUPERSCRIPT [ italic_X ]  respectively. Moreover, the attacker can have knowledge also on the derived edges of the graph, namely    ( G )  G \\Sigma(G) roman_ ( italic_G ) , or on the entire reasoning rules    \\Sigma roman_ , namely the NAG  ( G  [ X ] ,  ) G delimited-[] X  (G[X],\\Sigma) ( italic_G [ italic_X ] , roman_ ) . The last cases refer to the use by the attacker of any other reasoning rules    superscript  \\Sigma^{*} roman_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT  useful to perform the attack. The    \\checkmark   indicates that we reach a  ( k , x ) k x (k,x) ( italic_k , italic_x ) -isomorphism anonymization for any size  x x x italic_x , which means that any subgraph has at least other  k  1 k 1 k-1 italic_k - 1  KG-isomorphic copies, while the specification  [  x   x ] delimited-[] for-all superscript x  x [\\forall x^{\\prime}\\leq x] [  italic_x start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT  italic_x ]  indicates that it is reached a  ( k , x ) k x (k,x) ( italic_k , italic_x ) -isomorphism anonymization for any size  x  superscript x  x^{\\prime} italic_x start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT  up to a fixed  x x x italic_x  in input. For KLONE, in Proposition  5.1  we proved that it reaches a  ( k , x ) k x (k,x) ( italic_k , italic_x ) -anonymisation for every  x  [ n ] x delimited-[] n x\\!\\in\\![n] italic_x  [ italic_n ] , thus it is resistant to an attack of type  ( G  [ X ] ,  ) G delimited-[] X  (G[X],\\Sigma) ( italic_G [ italic_X ] , roman_ )  for any  X  V  ( G ) X V G X\\!\\subseteq\\!V(G) italic_X  italic_V ( italic_G ) . Accordingly, it is resistant to attackers with less knowledge, namely    ( G  [ X ] )  G delimited-[] X \\Sigma(G[X]) roman_ ( italic_G [ italic_X ] ) ,  G  [ X ] G delimited-[] X G[X] italic_G [ italic_X ]  and all the unweighted ones. We are left to prove that it is resistant also to an attack of type  ( G  [ X ] ,   ) G delimited-[] X superscript  (G[X],\\Sigma^{*}) ( italic_G [ italic_X ] , roman_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT )  with    superscript  \\Sigma^{*} roman_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT  any set of reasoning rules. Such rules necessarily depend on the knowledge graph  G G G italic_G : since KLONE copies  G G G italic_G  exactly  k k k italic_k  times (after the perturbation of the weights), any rule of    superscript  \\Sigma^{*} roman_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT  will have the same outputs on each of the copies, so that for any  X  V X V X\\subset V italic_X  italic_V ,  ( G  [ X ] ,   ) G delimited-[] X superscript  (G[X],\\Sigma^{*}) ( italic_G [ italic_X ] , roman_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT )  is KG-isomorphic to other  k  1 k 1 k-1 italic_k - 1  subgraphs in  A A A italic_A , namely one in each copy of  G G G italic_G . As for KGUARD, Proposition  6.1  proved that it always produces a  ( k , x ) k x (k,x) ( italic_k , italic_x ) - isomorphism anonymisation  A A A italic_A  for given  k , x  N k x N k,x\\!\\in\\!\\mathbb{N} italic_k , italic_x  blackboard_N . However, unless    \\Sigma roman_  has some other properties (see Proposition  4.1 ) we cannot guarantee a  ( k , x  ) k superscript x  (k,x^{\\prime}) ( italic_k , italic_x start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ) -isomorphism anonymisation for any given  x  < x superscript x  x x^{\\prime}<x italic_x start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT < italic_x . Consider now an attack of type    ( G  [ X  ] )  G delimited-[] superscript X  \\Sigma(G[X^{\\prime}]) roman_ ( italic_G [ italic_X start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ] ) , where the attacker knows the derived edges of the induced subgraph  G  [ X  ] G delimited-[] superscript X  G[X^{\\prime}] italic_G [ italic_X start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ]  but he is not aware of the reasoning rules    \\Sigma roman_ . If  | X  | = x superscript X  x |X^{\\prime}|\\!=\\!x | italic_X start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT | = italic_x  we know that  A A A italic_A  is resistant to such attack, as the attacker has less knowledge than the NAG attack  ( G  [ X  ] ,  ) G delimited-[] superscript X   (G[X^{\\prime}],\\Sigma) ( italic_G [ italic_X start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ] , roman_ ) . Suppose now that  | X  | = x  < x superscript X  superscript x  x |X^{\\prime}|\\!=\\!x^{\\prime}\\!<\\!x | italic_X start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT | = italic_x start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT < italic_x . Since  G G G italic_G  is weakly connected, there exists  X X X italic_X  such that  X   X  V superscript X  X V X^{\\prime}\\!\\subseteq\\!X\\!\\subseteq\\!V italic_X start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT  italic_X  italic_V ,  | X | = x X x |X|\\!=\\!x | italic_X | = italic_x  and  G  [ X ] G delimited-[] X G[X] italic_G [ italic_X ]  is weakly connected. Since  G  [ X  ]  G  [ X ] G delimited-[] superscript X  G delimited-[] X G[X^{\\prime}]\\subseteq G[X] italic_G [ italic_X start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ]  italic_G [ italic_X ] , it holds that    ( G  [ X  ] )    ( G  [ X ] )  [ X  ]  G delimited-[] superscript X   G delimited-[] X delimited-[] superscript X  \\Sigma(G[X^{\\prime}])\\!\\subseteq\\!\\Sigma(G[X])[X^{\\prime}] roman_ ( italic_G [ italic_X start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ] )  roman_ ( italic_G [ italic_X ] ) [ italic_X start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ] : if they are equal, then  A A A italic_A  is resistant to the attack because the  ( k , x ) k x (k,x) ( italic_k , italic_x ) -isomorphism anonymisation guarantees that    ( G  [ X ] )  G delimited-[] X \\Sigma(G[X]) roman_ ( italic_G [ italic_X ] )  has other  k  1 k 1 k-1 italic_k - 1  KG-isomorphic copies, and so it holds for    ( G  [ X ] )  [ X  ] =   ( G  [ X  ] )  G delimited-[] X delimited-[] superscript X   G delimited-[] superscript X  \\Sigma(G[X])[X^{\\prime}]=\\Sigma(G[X^{\\prime}]) roman_ ( italic_G [ italic_X ] ) [ italic_X start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ] = roman_ ( italic_G [ italic_X start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ] ) . If    ( G  [ X  ] )    ( G  [ X ] )  [ X  ]  G delimited-[] superscript X   G delimited-[] X delimited-[] superscript X  \\Sigma(G[X^{\\prime}])\\!\\subset\\!\\Sigma(G[X])[X^{\\prime}] roman_ ( italic_G [ italic_X start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ] )  roman_ ( italic_G [ italic_X ] ) [ italic_X start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ] , it means that    ( G  [ X  ] )  G delimited-[] superscript X  \\Sigma(G[X^{\\prime}]) roman_ ( italic_G [ italic_X start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ] )  is not a subgraph induced by a set of vertices, so  A A A italic_A  is resistant again to the attack. Finally, this implies that  A A A italic_A  is resistant to all the attacks that involve less knowledge than    ( G  [ X ] )  G delimited-[] X \\Sigma(G[X]) roman_ ( italic_G [ italic_X ] ) , namely  G  [ X ] G delimited-[] X G[X] italic_G [ italic_X ]  and the unweighted ones (Table  4 ). Diversity is always guaranteed for both our algorithms."
        ]
    },
    "id_table_7": {
        "caption": "",
        "table": "S9.EGx7",
        "footnotes": [],
        "references": [
            "Overview.  The remainder of the paper is organised as follows. Section  2  introduces the notation and the main background concepts. Section  3  and  4  formalise our problem and introduce the  ( k , x ) k x (k,x) ( italic_k , italic_x ) -isomorphism anonymisation along with the semantic utility metric. Sections  5  and  6  present the anonymisation algorithms, while in Section  7  we experimentally evaluate our approaches. In Section  8  and  9 , we respectively present the related work and the conclusion. Some of the proofs are in the on-line Appendix  [ 5 ] .",
            "Higher values of  k k k italic_k  guarantee stronger protection from de-anonymization attacks, as  k k k italic_k  is related to the number of subgraphs in the KG that are KG-isomorphic to a NAG, thus bringing the probability to re-identify the correct structure down to at most  1 / k 1 k 1/k 1 / italic_k . The value of  x x x italic_x  is related to the size of NAGs we want to protect the KG from. At the same time, high values of  k k k italic_k  and  x x x italic_x  might substantially increase the computational cost of reaching a  ( k , x ) k x (k,x) ( italic_k , italic_x ) -isomorphism anonymisation of the KG (see Section  7 ). Therefore, the choice of  k k k italic_k  and  x x x italic_x  is to be evaluated case by case, depending on the application and on the desired level of privacy."
        ]
    },
    "id_table_8": {
        "caption": "",
        "table": "S9.EGx8",
        "footnotes": [],
        "references": [
            "Overview.  The remainder of the paper is organised as follows. Section  2  introduces the notation and the main background concepts. Section  3  and  4  formalise our problem and introduce the  ( k , x ) k x (k,x) ( italic_k , italic_x ) -isomorphism anonymisation along with the semantic utility metric. Sections  5  and  6  present the anonymisation algorithms, while in Section  7  we experimentally evaluate our approaches. In Section  8  and  9 , we respectively present the related work and the conclusion. Some of the proofs are in the on-line Appendix  [ 5 ] ."
        ]
    },
    "id_table_9": {
        "caption": "",
        "table": "S7.T1.8.8",
        "footnotes": [],
        "references": [
            "Overview.  The remainder of the paper is organised as follows. Section  2  introduces the notation and the main background concepts. Section  3  and  4  formalise our problem and introduce the  ( k , x ) k x (k,x) ( italic_k , italic_x ) -isomorphism anonymisation along with the semantic utility metric. Sections  5  and  6  present the anonymisation algorithms, while in Section  7  we experimentally evaluate our approaches. In Section  8  and  9 , we respectively present the related work and the conclusion. Some of the proofs are in the on-line Appendix  [ 5 ] ."
        ]
    },
    "id_table_10": {
        "caption": "",
        "table": "S7.T2.25",
        "footnotes": [
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "references": []
    },
    "id_table_11": {
        "caption": "",
        "table": "S7.T3.2",
        "footnotes": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "references": []
    },
    "id_table_12": {
        "caption": "",
        "table": "S7.T4.35",
        "footnotes": [
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "references": [
            "where ( 12 ) selects all the vertices of the KG with at least  2 2 2 2  out-going edges, and ( 13 ) selects all the vertices of the KG with at least  2 2 2 2  out-going edges with weight greater than  q q q italic_q . We set  q = 0 q 0 q=0 italic_q = 0  for all the considered networks but the economics networks, for which  q = 0.5 q 0.5 q=0.5 italic_q = 0.5 , as it is the threshold for establishing control.   \\hfill\\blacksquare"
        ]
    }
}