{
    "id_table_1": {
        "caption": "TABLE I:  Performance of other models and frameworks on SWE Bench Lite",
        "table": "S4.T1.1",
        "footnotes": [],
        "references": [
            "Building upon the set of candidate files identified in the previous step, this phase involves the creation of a schematic representation for each file, providing a comprehensive overview of its internal structure. This schematic representation encompasses detailed descriptions of all classes and functions within the file. The schema includes class names, contained methods, method arguments, applied decorators, and available docstrings.  This abstracted representation enables the Large Language Model (LLM) to gain a high-level perspective of the filegroup, facilitating more accurate identification of files closely related to the problem statement. The PreAssimilation Module is then employed to further refine the search space, narrowing down the potential bug location to the top L files.  Notably, the value of L is dynamically determined by the LLM itself, allowing for adaptive file selection based on the complexity and nature of the problem. Through extensive experimentation, we observed that in exploratory scenarios, such as when SuperCoder2.0 is tasked with creating a new feature, allowing the LLM to autonomously select relevant files yields optimal results.  For the specific evaluation conducted on SWE Bench Lite, we implemented a constraint limiting L to a maximum of two files. In this configuration, the PreAssimilator module returns either the single most relevant file or, in more complex cases, the two most pertinent files along with a rationale for their selection.  This file and method localisation approach (Figure  1 ) strikes a balance between comprehensive search and computational efficiency, enabling SuperCoder2.0 to focus on the most promising areas of the codebase while maintaining the flexibility to handle diverse problem types. The integration of LLM-driven file selection with the structured schematic representation enhances the systems ability to navigate and understand complex codebases, thereby improving its overall problem-solving capabilities."
        ]
    },
    "global_footnotes": []
}