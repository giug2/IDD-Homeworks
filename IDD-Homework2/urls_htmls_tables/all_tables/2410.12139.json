{
    "id_table_1": {
        "caption": "",
        "table": "S2.E2",
        "footnotes": [],
        "references": [
            "The predominant methodology currently used to handle multiple objectives is to combine them into one objective using a linear combination  (Vogt and Cottrell,  1999 ) . The advantage of this is that it can trace out the entire pareto frontier of the achievable objectives. The disadvantage is that you have to choose one linear combination for a large number of instances. This often results in cases where one objective is favored much more than the others. This is illustrated in Figure  1 . To explain this figure we introduce some notation.",
            "When the weight vector is the one mentioned above, we refer to the normalized cumulative scores as NDCG. Figure  1  shows scatter plots of the NDCGs for the two objectives, for different algorithms: a given algorithm produces ranking   i subscript  i \\pi_{i} italic_ start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT  for instance  i i i italic_i , and each dot in the plot is a point",
            "The key idea is to combine the two cumulative scores using a  concave  function  f f f italic_f . (Maximizing the product is the same as maximizing the sum of logs, which is a concave function.) Concave functions tend to favor more balanced outcomes almost by definition: the function at the average of two points is at least as high as the average of the function at the two points, i.e.,  f  ( x 1 + x 2 2 , y 1 + y 2 2 )  f  ( x 1 , y 1 ) + f  ( x 2 , y 2 ) 2 f subscript x 1 subscript x 2 2 subscript y 1 subscript y 2 2 f subscript x 1 subscript y 1 f subscript x 2 subscript y 2 2 f(\\tfrac{x_{1}+x_{2}}{2},\\tfrac{y_{1}+y_{2}}{2})\\geq\\tfrac{f(x_{1},y_{1})+f(x_% {2},y_{2})}{2} italic_f ( divide start_ARG italic_x start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT + italic_x start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_ARG start_ARG 2 end_ARG , divide start_ARG italic_y start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT + italic_y start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_ARG start_ARG 2 end_ARG )  divide start_ARG italic_f ( italic_x start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , italic_y start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ) + italic_f ( italic_x start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , italic_y start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ) end_ARG start_ARG 2 end_ARG . Figure  1  is a good demonstration of this.",
            "Here  f i  superscript subscript f i f_{i}^{*} italic_f start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT  is the Fenchel dual of  f f f italic_f  and  F  superscript F F^{*} italic_F start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT  is the Fenchel dual of  F . F F. italic_F .  If  (   ,  i  ,  i  ,   ,   ) superscript  superscript subscript  i superscript subscript  i superscript  superscript  (\\pi^{*},\\alpha_{i}^{*},\\beta_{i}^{*},\\alpha^{*},\\beta^{*}) ( italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , italic_ start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , italic_ start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT )  is some optimal solution for the primal ( 8 ) and  ( r  , c  , p i  , q i  , p  , q  ) superscript r superscript c superscript subscript p i superscript subscript q i superscript p superscript q (r^{*},c^{*},p_{i}^{*},q_{i}^{*},p^{*},q^{*}) ( italic_r start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , italic_c start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , italic_p start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , italic_q start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , italic_p start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , italic_q start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT )  is some optimal solution for the dual ( 9 ), then they should together satisfy the KKT conditions given in ( 10 ). Note that a constraint of primal is tight if the corresponding variable in the dual is strictly positive and vice-versa.",
            "Moreover the KKT conditions  10  can be simplified to:",
            "This fixed point equation can be solved using binary search in exactly the same way as in Proposition  2.8 .   c  s w i   ( ( p + p i )  a i + ( q + q i )  b i ) c subscript superscript s subscript w i p subscript p i subscript a i q subscript q i subscript b i \\partial cs^{*}_{{\\mathbf{w}}_{i}}\\left((p+p_{i}){\\mathbf{a}}_{i}+(q+q_{i}){% \\mathbf{b}}_{i}\\right)  italic_c italic_s start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT start_POSTSUBSCRIPT bold_w start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT end_POSTSUBSCRIPT ( ( italic_p + italic_p start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT ) bold_a start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT + ( italic_q + italic_q start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT ) bold_b start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT )  only depends on the ration   = ( q + q i ) / ( p + p i )  q subscript q i p subscript p i \\lambda=(q+q_{i})/(p+p_{i}) italic_ = ( italic_q + italic_q start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT ) / ( italic_p + italic_p start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT ) . Geometrically, this ratio is constant on any line passing through  (  p ,  q ) p q (-p,-q) ( - italic_p , - italic_q ) . Figure  4  shows the regions where   c  s w i   ( ( p + p i )  a i + ( q + q i )  b i ) c subscript superscript s subscript w i p subscript p i subscript a i q subscript q i subscript b i \\partial cs^{*}_{{\\mathbf{w}}_{i}}\\left((p+p_{i}){\\mathbf{a}}_{i}+(q+q_{i}){% \\mathbf{b}}_{i}\\right)  italic_c italic_s start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT start_POSTSUBSCRIPT bold_w start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT end_POSTSUBSCRIPT ( ( italic_p + italic_p start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT ) bold_a start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT + ( italic_q + italic_q start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT ) bold_b start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT )  remains constant. Now the fixed point equation ( 12 ) can be solved in exactly the same way as in the proof of Proposition  2.8 . We will skip the details.",
            "We first present the results on synthetic data. The purpose of this experiment is to illustrate how different objective functions affect the distribution of the NDCGs. These results are summarized in Figures  6  and  7 . We present the scatter plot of the NDCGs, just like in Figure  1 , as well as the cumulative distribution functions (CDFs).",
            "Other parameters of the experiment are as follows: we draw 50 results for each instance, i.e.,  n = 50 n 50 n=50 italic_n = 50 . The weight vector is the same as in the Introduction, ( 1 ), except that we only consider the top 10 results, i.e., the coordinates of  w w {\\mathbf{w}} bold_w  after the first 10 are 0. The number of different instances,  m m m italic_m  is 500.",
            "The objectives are ad revenue and relevance. We will denote the ad revenue by  A A A italic_A  and relevance by  B B B italic_B . We use the same weight vector  w w {\\mathbf{w}} bold_w  in the introduction, ( 1 ), up to 10 coordinates. Ad revenue can be added across instances, so we just sum up the ad revenue across different instances and tune the algorithms so that they all have roughly the same revenue. (The difference is less than  1 % percent 1 1\\% 1 % .) It makes less sense to add the relevance scores. In fact it is more important to make sure that no instance gets a really bad relevant score, rather than optimize for the mean or even the standard deviation. To do this, we aim to make the bottom quartile (25%) as high as possible.",
            "Suppose    ( 0 ) = 1 italic- 0 1 \\phi(0)=1 italic_ ( 0 ) = 1  and    ( m ) =  1 italic- m 1 \\phi(m)=-1 italic_ ( italic_m ) = - 1  (otherwise we are done), where   italic- \\phi italic_  is the function defined in Equation ( 7 ). We want to find an  i i i italic_i  such that    ( i ) = 0 italic- i 0 \\phi(i)=0 italic_ ( italic_i ) = 0  or    ( i ) = 1 ,   ( i + 1 ) =  1 formulae-sequence italic- i 1 italic- i 1 1 \\phi(i)=1,\\phi(i+1)=-1 italic_ ( italic_i ) = 1 , italic_ ( italic_i + 1 ) = - 1 . Set   l = 0 ,  u =  formulae-sequence subscript  l 0 subscript  u \\lambda_{\\ell}=0,\\lambda_{u}=\\infty italic_ start_POSTSUBSCRIPT roman_l end_POSTSUBSCRIPT = 0 , italic_ start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT =  . From Claim  A.3 , we can sample a uniformly random    C  [  l ,  u ]  C subscript  l subscript  u \\lambda\\in C\\cap[\\lambda_{\\ell},\\lambda_{u}] italic_  italic_C  [ italic_ start_POSTSUBSCRIPT roman_l end_POSTSUBSCRIPT , italic_ start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT ]  in  O  ( n  log  n ) O n n O(n\\log n) italic_O ( italic_n roman_log italic_n )  time. Suppose   =  i  subscript  i \\lambda=\\lambda_{i} italic_ = italic_ start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT , then we can find   i + 1 subscript  i 1 \\lambda_{i+1} italic_ start_POSTSUBSCRIPT italic_i + 1 end_POSTSUBSCRIPT  and  g i subscript g i g_{i} italic_g start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT  as shown in Claim  A.1  in  O  ( n  log  n ) O n n O(n\\log n) italic_O ( italic_n roman_log italic_n )  time. Therefore we can evaluate    ( i ) italic- i \\phi(i) italic_ ( italic_i )  in  O  ( n  log  n ) O n n O(n\\log n) italic_O ( italic_n roman_log italic_n )  time. Now we continue the binary search based on the value of    ( i ) italic- i \\phi(i) italic_ ( italic_i )  and update the value of the lower bound   l =  subscript  l  \\lambda_{\\ell}=\\lambda italic_ start_POSTSUBSCRIPT roman_l end_POSTSUBSCRIPT = italic_  or the upper bound   u =  subscript  u  \\lambda_{u}=\\lambda italic_ start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT = italic_ . In each iteration, the random    C  [  l ,  u ]  C subscript  l subscript  u \\lambda\\in C\\cap[\\lambda_{\\ell},\\lambda_{u}] italic_  italic_C  [ italic_ start_POSTSUBSCRIPT roman_l end_POSTSUBSCRIPT , italic_ start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT ]  will eliminate constant fraction of points in  C  [  l ,  u ] C subscript  l subscript  u C\\cap[\\lambda_{\\ell},\\lambda_{u}] italic_C  [ italic_ start_POSTSUBSCRIPT roman_l end_POSTSUBSCRIPT , italic_ start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT ]  i.e. the size of  C  [  l ,  u ] C subscript  l subscript  u C\\cap[\\lambda_{\\ell},\\lambda_{u}] italic_C  [ italic_ start_POSTSUBSCRIPT roman_l end_POSTSUBSCRIPT , italic_ start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT ]  shrinks by a constant factor in expectation. Therefore the algorithm should end in  O  ( log  n ) O n O(\\log n) italic_O ( roman_log italic_n )  iterations with high probability. In fact, we can stop the sampling process once the size of  C  [  l ,  u ] C subscript  l subscript  u C\\cap[\\lambda_{\\ell},\\lambda_{u}] italic_C  [ italic_ start_POSTSUBSCRIPT roman_l end_POSTSUBSCRIPT , italic_ start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT ]  becomes  O  ( n ) O n O(n) italic_O ( italic_n )  and then do a regular binary search on them by listing them all. Since the running time of each iteration is  O  ( n  log  n ) , O n n O(n\\log n), italic_O ( italic_n roman_log italic_n ) ,  the total running time is  O  ( n  log 2  n ) . O n superscript 2 n O(n\\log^{2}n). italic_O ( italic_n roman_log start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT italic_n ) ."
        ]
    },
    "id_table_2": {
        "caption": "",
        "table": "S2.E3",
        "footnotes": [],
        "references": [
            "For the general case, the algorithm gets an advantage as follows: replace one coordinate of  w w {\\mathbf{w}} bold_w , say  w j subscript w j w_{j} italic_w start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT , with the immediately preceding coordinate  w j  1 subscript w j 1 w_{j-1} italic_w start_POSTSUBSCRIPT italic_j - 1 end_POSTSUBSCRIPT . For the case of summing the top  k k k italic_k  entries, this corresponds to replacing the  ( k + 1 ) st superscript k 1 st (k+1)^{\\rm st} ( italic_k + 1 ) start_POSTSUPERSCRIPT roman_st end_POSTSUPERSCRIPT  coordinate which is a 0, with the  k th superscript k th k^{\\rm th} italic_k start_POSTSUPERSCRIPT roman_th end_POSTSUPERSCRIPT  coordinate which is a 1. The replacement can be different for different  i i i italic_i . Again, the ranking output by the algorithm with the new weights does as well as the optimum with the original weights  w w {\\mathbf{w}} bold_w . See Theorem  2.2  and Theorem  3.2  for formal statements.",
            "When there is no global function  F F F italic_F , for each  i i i italic_i , the algorithm just does a binary search (Proposition  2.8 ). In each iteration of the binary search, we compute a ranking optimal for a linear combination of the two objectives. The running time to solve each ranking problem (i.e. each instance  i i i italic_i ) is  O  ( n  log 2  n ) O n superscript 2 n O(n\\log^{2}n) italic_O ( italic_n roman_log start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT italic_n ) . In practice, the ranking algorithms are required to be very fast, so this is an important property. For the general case, this is still true, provided that we are given 2 additional parameters that are optimized appropriately. In practice, such parameters are tuned offline so we can still use the binary search to rank online any new instance  i i i italic_i .",
            "In Section  2  we give our binary search based algorithm for a single instance. The general case is presented in Section  3 . We present experimental results in Section  4 . Appendix contains some missing proofs.",
            "We will now prove Theorem  3.2 . We also make the mild assumption that the numbers in  a , b , w a b w {\\mathbf{a}},{\\mathbf{b}},{\\mathbf{w}} bold_a , bold_b , bold_w  are generic for the proof, which can be achieved by perturbing all the numbers with a tiny additive noise. In particular we will assume that  w 1 > w 2 >  > w n > 0 subscript w 1 subscript w 2  subscript w n 0 w_{1}>w_{2}>\\dots>w_{n}>0 italic_w start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT > italic_w start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT >  > italic_w start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT > 0 . This only perturbs  co w   ( a , b ) subscript superscript co w a b \\operatorname{\\mathsf{co}}^{*}_{\\mathbf{w}}({\\mathbf{a}},{\\mathbf{b}}) sansserif_co start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT start_POSTSUBSCRIPT bold_w end_POSTSUBSCRIPT ( bold_a , bold_b )  by a tiny amount. By a limiting argument, this shouldnt affect the result. To prove Theorem  2.2 , we create a convex programming relaxation for  co w   ( a , b ) subscript superscript co w a b \\operatorname{\\mathsf{co}}^{*}_{\\mathbf{w}}({\\mathbf{a}},{\\mathbf{b}}) sansserif_co start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT start_POSTSUBSCRIPT bold_w end_POSTSUBSCRIPT ( bold_a , bold_b )  as shown in ( 2 ) and denote its value by  OPT OPT \\mathsf{OPT} sansserif_OPT .",
            "It is clear that  OPT OPT \\mathsf{OPT} sansserif_OPT  is a relaxation for  co w   ( a , b ) subscript superscript co w a b \\operatorname{\\mathsf{co}}^{*}_{\\mathbf{w}}({\\mathbf{a}},{\\mathbf{b}}) sansserif_co start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT start_POSTSUBSCRIPT bold_w end_POSTSUBSCRIPT ( bold_a , bold_b )  with  co w   ( a , b )  OPT . subscript superscript co w a b OPT \\operatorname{\\mathsf{co}}^{*}_{\\mathbf{w}}({\\mathbf{a}},{\\mathbf{b}})\\leq% \\mathsf{OPT}. sansserif_co start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT start_POSTSUBSCRIPT bold_w end_POSTSUBSCRIPT ( bold_a , bold_b )  sansserif_OPT .  By convex programming duality,  OPT OPT \\mathsf{OPT} sansserif_OPT  can be expressed as a dual minimization problem ( 3 ) by introducing a dual variable for every constraint in the primal as shown in ( 2 ). Note that by Slaters condition, strong duality holds here  Boyd and Vandenberghe ( 2004 ) . The constraints in the dual correspond to variables in the primal as shown in ( 3 ).",
            "If  (   ,   ,   ) superscript  superscript  superscript  (\\pi^{*},\\alpha^{*},\\beta^{*}) ( italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT )  is some optimal solution for the primal ( 2 ) and  ( r  , c  , p  , q  ) superscript r superscript c superscript p superscript q ({\\mathbf{r}}^{*},{\\mathbf{c}}^{*},p^{*},q^{*}) ( bold_r start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , bold_c start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , italic_p start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , italic_q start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT )  is some optimal solution for the dual ( 3 ), then they should together satisfy the KKT conditions given in ( 4 ). A constraint of primal is tight if the corresponding variable in the dual is strictly positive and vice-versa.",
            "From Proposition  2.4  and Lemma  2.5 , the solution    superscript  \\pi^{*} italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT  for the primal program ( 2 ) is either a single permutation or a convex combination of two permutations which differ only by an adjacent transposition (i.e. swapping two elements next to each other).",
            "Suppose  a 1 , ... , a n subscript a 1 ... subscript a n a_{1},\\dots,a_{n} italic_a start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , ... , italic_a start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT  and  b 1 , ... , b n subscript b 1 ... subscript b n b_{1},\\dots,b_{n} italic_b start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , ... , italic_b start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT  are integers bounded by  B B B italic_B  in absolute value. We can solve the primal program ( 2 ), the dual program ( 3 ) and find  OPT = min p , q > 0  cs w   ( p  a + q  b ) + f   (  p ,  q ) OPT subscript p q 0 subscript superscript cs w p a q b superscript f p q \\mathsf{OPT}=\\min_{p,q>0}\\operatorname{\\mathsf{cs}}^{*}_{\\mathbf{w}}(p{\\mathbf% {a}}+q{\\mathbf{b}})+f^{*}(-p,-q) sansserif_OPT = roman_min start_POSTSUBSCRIPT italic_p , italic_q > 0 end_POSTSUBSCRIPT sansserif_cs start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT start_POSTSUBSCRIPT bold_w end_POSTSUBSCRIPT ( italic_p bold_a + italic_q bold_b ) + italic_f start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ( - italic_p , - italic_q )  in  O  ( n  log  n  log  B ) O n n B O(n\\log n\\log B) italic_O ( italic_n roman_log italic_n roman_log italic_B )  time. Moreover there is a strongly polynomial randomized algorithm which runs in  O  ( n  log 2  n ) O n superscript 2 n O(n\\log^{2}n) italic_O ( italic_n roman_log start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT italic_n )  time. 4 4 4 Strongly polynomial refers to the fact that the running time is independent of  B B B italic_B  or the actual numbers in  a , b a b {\\mathbf{a}},{\\mathbf{b}} bold_a , bold_b . In this model, it is assumed that arithmetic and comparison operations between  a i subscript a i a_{i} italic_a start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT s and  b i subscript b i b_{i} italic_b start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT s take constant time.",
            "To solve the primal program ( 2 ) and the dual program ( 3 ), it is enough to find  (   ,   ,   ) superscript  superscript  superscript  (\\pi^{*},\\alpha^{*},\\beta^{*}) ( italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT )  and  ( p  , q  ) superscript p superscript q (p^{*},q^{*}) ( italic_p start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , italic_q start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT )  which together satisfy all the simplified KKT conditions ( 5 ).",
            "Thus we need to find a fixed point for a set-valued map. We begin by calculating the subgradient   cs   ( p  a + q  b ) superscript cs p a q b \\partial\\operatorname{\\mathsf{cs}}^{*}(p{\\mathbf{a}}+q{\\mathbf{b}})  sansserif_cs start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ( italic_p bold_a + italic_q bold_b ) . Note that  cs   ( p  a + q  b ) = p  cs  ( a ,  ) + q  cs  ( b ,  ) superscript cs p a q b p cs a  q cs b  \\operatorname{\\mathsf{cs}}^{*}(p{\\mathbf{a}}+q{\\mathbf{b}})=p\\operatorname{% \\mathsf{cs}}({\\mathbf{a}},\\pi)+q\\operatorname{\\mathsf{cs}}({\\mathbf{b}},\\pi) sansserif_cs start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ( italic_p bold_a + italic_q bold_b ) = italic_p sansserif_cs ( bold_a , italic_ ) + italic_q sansserif_cs ( bold_b , italic_ )  where    \\pi italic_  is any permutation which sorts  p  a + q  b p a q b p{\\mathbf{a}}+q{\\mathbf{b}} italic_p bold_a + italic_q bold_b  in descending order. By Lemma  2.5 , there are two cases:",
            "Figure  2  shows the values of the subgradient   cs   ( p  a + q  b ) superscript cs p a q b \\partial\\operatorname{\\mathsf{cs}}^{*}(p{\\mathbf{a}}+q{\\mathbf{b}})  sansserif_cs start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ( italic_p bold_a + italic_q bold_b )  as a function of  ( p , q ) p q (p,q) ( italic_p , italic_q )  in the regions  A i , R i . subscript A i subscript R i A_{i},R_{i}. italic_A start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT , italic_R start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT .",
            "We are now ready to prove Theorem  2.2 .",
            "By Proposition  2.8  and Remark  2.6 , we can find a solution  (   ,   ,   ) superscript  superscript  superscript  (\\pi^{*},\\alpha^{*},\\beta^{*}) ( italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT )  to the primal program ( 2 ) where    superscript  \\pi^{*} italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT  is either a permutation or a convex combination of two permutations which differ by an adjacent transposition. If    superscript  \\pi^{*} italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT  is a permutation then",
            "Our approach to prove Theorem  3.2  is again very similar to how we proved Theorem  2.2 . We write a convex programming relaxation and solve its dual program. We will also assume that the sequences  a i , b i , w subscript a i subscript b i w {\\mathbf{a}}_{i},{\\mathbf{b}}_{i},{\\mathbf{w}} bold_a start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT , bold_b start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT , bold_w  are generic which can be ensure by perturbing all entries by tiny additive noise, this will not change  co w   ( a , b ) subscript superscript co w a b \\operatorname{\\mathsf{co}}^{*}_{\\mathbf{w}}({\\mathbf{a}},{\\mathbf{b}}) sansserif_co start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT start_POSTSUBSCRIPT bold_w end_POSTSUBSCRIPT ( bold_a , bold_b )  by much. By a limiting argument, this will not affect the result. We first develop a convex programming relaxation  OPT OPT \\mathsf{OPT} sansserif_OPT  as shown in ( 8 ).",
            "The proof is very similar to the proof of Proposition  2.4  where we write a linear program for each sub-problem and the corresponding dual linear program. We will skip the details.",
            "This fixed point equation can be solved using binary search in exactly the same way as in Proposition  2.8 .   c  s w i   ( ( p + p i )  a i + ( q + q i )  b i ) c subscript superscript s subscript w i p subscript p i subscript a i q subscript q i subscript b i \\partial cs^{*}_{{\\mathbf{w}}_{i}}\\left((p+p_{i}){\\mathbf{a}}_{i}+(q+q_{i}){% \\mathbf{b}}_{i}\\right)  italic_c italic_s start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT start_POSTSUBSCRIPT bold_w start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT end_POSTSUBSCRIPT ( ( italic_p + italic_p start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT ) bold_a start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT + ( italic_q + italic_q start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT ) bold_b start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT )  only depends on the ration   = ( q + q i ) / ( p + p i )  q subscript q i p subscript p i \\lambda=(q+q_{i})/(p+p_{i}) italic_ = ( italic_q + italic_q start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT ) / ( italic_p + italic_p start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT ) . Geometrically, this ratio is constant on any line passing through  (  p ,  q ) p q (-p,-q) ( - italic_p , - italic_q ) . Figure  4  shows the regions where   c  s w i   ( ( p + p i )  a i + ( q + q i )  b i ) c subscript superscript s subscript w i p subscript p i subscript a i q subscript q i subscript b i \\partial cs^{*}_{{\\mathbf{w}}_{i}}\\left((p+p_{i}){\\mathbf{a}}_{i}+(q+q_{i}){% \\mathbf{b}}_{i}\\right)  italic_c italic_s start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT start_POSTSUBSCRIPT bold_w start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT end_POSTSUBSCRIPT ( ( italic_p + italic_p start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT ) bold_a start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT + ( italic_q + italic_q start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT ) bold_b start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT )  remains constant. Now the fixed point equation ( 12 ) can be solved in exactly the same way as in the proof of Proposition  2.8 . We will skip the details.",
            "We are now ready to prove Theorem  3.2 .",
            "By Proposition  3.6  and  2.6 , we can find a solution to the primal program  8  where each   i  superscript subscript  i \\pi_{i}^{*} italic_ start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT  is either a permutation or a convex combination of two permutations which differ by an adjacent transposition. If   i  superscript subscript  i \\pi_{i}^{*} italic_ start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT  is a permutation then we just output    superscript  \\pi^{*} italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT  which is the optimal ranking for the  i t  h superscript i t h i^{th} italic_i start_POSTSUPERSCRIPT italic_t italic_h end_POSTSUPERSCRIPT  ranking problem. If    =    1 + ( 1   )   2 superscript   subscript  1 1  subscript  2 \\pi^{*}=\\mu\\pi_{1}+(1-\\mu)\\pi_{2} italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT = italic_ italic_ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT + ( 1 - italic_ ) italic_ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT  i.e. a convex combination of   1 ,  2 subscript  1 subscript  2 \\pi_{1},\\pi_{2} italic_ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , italic_ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT  which differ in the  j , j + 1 j j 1 j,j+1 italic_j , italic_j + 1  positions, then we output either   1 subscript  1 \\pi_{1} italic_ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT  or   2 subscript  2 \\pi_{2} italic_ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT  as the ranking for the  i t  h superscript i t h i^{th} italic_i start_POSTSUPERSCRIPT italic_t italic_h end_POSTSUPERSCRIPT  subproblem."
        ]
    },
    "id_table_3": {
        "caption": "",
        "table": "S2.E5",
        "footnotes": [],
        "references": [
            "For the general case, the algorithm gets an advantage as follows: replace one coordinate of  w w {\\mathbf{w}} bold_w , say  w j subscript w j w_{j} italic_w start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT , with the immediately preceding coordinate  w j  1 subscript w j 1 w_{j-1} italic_w start_POSTSUBSCRIPT italic_j - 1 end_POSTSUBSCRIPT . For the case of summing the top  k k k italic_k  entries, this corresponds to replacing the  ( k + 1 ) st superscript k 1 st (k+1)^{\\rm st} ( italic_k + 1 ) start_POSTSUPERSCRIPT roman_st end_POSTSUPERSCRIPT  coordinate which is a 0, with the  k th superscript k th k^{\\rm th} italic_k start_POSTSUPERSCRIPT roman_th end_POSTSUPERSCRIPT  coordinate which is a 1. The replacement can be different for different  i i i italic_i . Again, the ranking output by the algorithm with the new weights does as well as the optimum with the original weights  w w {\\mathbf{w}} bold_w . See Theorem  2.2  and Theorem  3.2  for formal statements.",
            "In Section  2  we give our binary search based algorithm for a single instance. The general case is presented in Section  3 . We present experimental results in Section  4 . Appendix contains some missing proofs.",
            "We will now prove Theorem  3.2 . We also make the mild assumption that the numbers in  a , b , w a b w {\\mathbf{a}},{\\mathbf{b}},{\\mathbf{w}} bold_a , bold_b , bold_w  are generic for the proof, which can be achieved by perturbing all the numbers with a tiny additive noise. In particular we will assume that  w 1 > w 2 >  > w n > 0 subscript w 1 subscript w 2  subscript w n 0 w_{1}>w_{2}>\\dots>w_{n}>0 italic_w start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT > italic_w start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT >  > italic_w start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT > 0 . This only perturbs  co w   ( a , b ) subscript superscript co w a b \\operatorname{\\mathsf{co}}^{*}_{\\mathbf{w}}({\\mathbf{a}},{\\mathbf{b}}) sansserif_co start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT start_POSTSUBSCRIPT bold_w end_POSTSUBSCRIPT ( bold_a , bold_b )  by a tiny amount. By a limiting argument, this shouldnt affect the result. To prove Theorem  2.2 , we create a convex programming relaxation for  co w   ( a , b ) subscript superscript co w a b \\operatorname{\\mathsf{co}}^{*}_{\\mathbf{w}}({\\mathbf{a}},{\\mathbf{b}}) sansserif_co start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT start_POSTSUBSCRIPT bold_w end_POSTSUBSCRIPT ( bold_a , bold_b )  as shown in ( 2 ) and denote its value by  OPT OPT \\mathsf{OPT} sansserif_OPT .",
            "It is clear that  OPT OPT \\mathsf{OPT} sansserif_OPT  is a relaxation for  co w   ( a , b ) subscript superscript co w a b \\operatorname{\\mathsf{co}}^{*}_{\\mathbf{w}}({\\mathbf{a}},{\\mathbf{b}}) sansserif_co start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT start_POSTSUBSCRIPT bold_w end_POSTSUBSCRIPT ( bold_a , bold_b )  with  co w   ( a , b )  OPT . subscript superscript co w a b OPT \\operatorname{\\mathsf{co}}^{*}_{\\mathbf{w}}({\\mathbf{a}},{\\mathbf{b}})\\leq% \\mathsf{OPT}. sansserif_co start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT start_POSTSUBSCRIPT bold_w end_POSTSUBSCRIPT ( bold_a , bold_b )  sansserif_OPT .  By convex programming duality,  OPT OPT \\mathsf{OPT} sansserif_OPT  can be expressed as a dual minimization problem ( 3 ) by introducing a dual variable for every constraint in the primal as shown in ( 2 ). Note that by Slaters condition, strong duality holds here  Boyd and Vandenberghe ( 2004 ) . The constraints in the dual correspond to variables in the primal as shown in ( 3 ).",
            "Note that  f  superscript f f^{*} italic_f start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT  is a convex function since it is the supremum of linear functions. Since  f  (  ,  ) f   f(\\alpha,\\beta) italic_f ( italic_ , italic_ )  is strictly increasing in each coordinate,  f   (  ,  ) =  superscript f   f^{*}(\\mu,\\nu)=\\infty italic_f start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ( italic_ , italic_ ) =   unless   ,  < 0   0 \\mu,\\nu<0 italic_ , italic_ < 0 . Since the dual is a minimization problem, the optimum value is attained only when   ,  < 0   0 \\mu,\\nu<0 italic_ , italic_ < 0 . Hereafter, wlog, we assume that  p , q > 0 p q 0 p,q>0 italic_p , italic_q > 0  in the dual ( 3 ). For example when  f  (  ,  ) = log  (    ) f     f(\\alpha,\\beta)=\\log(\\alpha\\beta) italic_f ( italic_ , italic_ ) = roman_log ( italic_ italic_ ) ,",
            "If  (   ,   ,   ) superscript  superscript  superscript  (\\pi^{*},\\alpha^{*},\\beta^{*}) ( italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT )  is some optimal solution for the primal ( 2 ) and  ( r  , c  , p  , q  ) superscript r superscript c superscript p superscript q ({\\mathbf{r}}^{*},{\\mathbf{c}}^{*},p^{*},q^{*}) ( bold_r start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , bold_c start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , italic_p start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , italic_q start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT )  is some optimal solution for the dual ( 3 ), then they should together satisfy the KKT conditions given in ( 4 ). A constraint of primal is tight if the corresponding variable in the dual is strictly positive and vice-versa.",
            "Let  p , q > 0 p q 0 p,q>0 italic_p , italic_q > 0  be fixed. Then the value of the minimization program in ( 3 ) is given by",
            "For a fixed  p , q > 0 p q 0 p,q>0 italic_p , italic_q > 0 , the dual program ( 3 ) reduces (after ignoring the fixed additive term  f   (  p ,  q ) superscript f p q f^{*}(-p,-q) italic_f start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ( - italic_p , - italic_q ) ) to the following linear program:",
            "Suppose  a 1 , ... , a n subscript a 1 ... subscript a n a_{1},\\dots,a_{n} italic_a start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , ... , italic_a start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT  and  b 1 , ... , b n subscript b 1 ... subscript b n b_{1},\\dots,b_{n} italic_b start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , ... , italic_b start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT  are integers bounded by  B B B italic_B  in absolute value. We can solve the primal program ( 2 ), the dual program ( 3 ) and find  OPT = min p , q > 0  cs w   ( p  a + q  b ) + f   (  p ,  q ) OPT subscript p q 0 subscript superscript cs w p a q b superscript f p q \\mathsf{OPT}=\\min_{p,q>0}\\operatorname{\\mathsf{cs}}^{*}_{\\mathbf{w}}(p{\\mathbf% {a}}+q{\\mathbf{b}})+f^{*}(-p,-q) sansserif_OPT = roman_min start_POSTSUBSCRIPT italic_p , italic_q > 0 end_POSTSUBSCRIPT sansserif_cs start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT start_POSTSUBSCRIPT bold_w end_POSTSUBSCRIPT ( italic_p bold_a + italic_q bold_b ) + italic_f start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ( - italic_p , - italic_q )  in  O  ( n  log  n  log  B ) O n n B O(n\\log n\\log B) italic_O ( italic_n roman_log italic_n roman_log italic_B )  time. Moreover there is a strongly polynomial randomized algorithm which runs in  O  ( n  log 2  n ) O n superscript 2 n O(n\\log^{2}n) italic_O ( italic_n roman_log start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT italic_n )  time. 4 4 4 Strongly polynomial refers to the fact that the running time is independent of  B B B italic_B  or the actual numbers in  a , b a b {\\mathbf{a}},{\\mathbf{b}} bold_a , bold_b . In this model, it is assumed that arithmetic and comparison operations between  a i subscript a i a_{i} italic_a start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT s and  b i subscript b i b_{i} italic_b start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT s take constant time.",
            "To solve the primal program ( 2 ) and the dual program ( 3 ), it is enough to find  (   ,   ,   ) superscript  superscript  superscript  (\\pi^{*},\\alpha^{*},\\beta^{*}) ( italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT )  and  ( p  , q  ) superscript p superscript q (p^{*},q^{*}) ( italic_p start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , italic_q start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT )  which together satisfy all the simplified KKT conditions ( 5 ).",
            "( i ) = 1 ,   ( i + 1 ) =  1 formulae-sequence italic- i 1 italic- i 1 1 \\phi(i)=1,\\phi(i+1)=-1 italic_ ( italic_i ) = 1 , italic_ ( italic_i + 1 ) = - 1 . In this case, we claim that there exists some     ( 0 , 1 ) superscript  0 1 \\mu^{*}\\in(0,1) italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT  ( 0 , 1 )  such that   f  (    g i + ( 1    )  g i + 1 )  R i + 1  f superscript  subscript g i 1 superscript  subscript g i 1 subscript R i 1 \\nabla f(\\mu^{*}g_{i}+(1-\\mu^{*})g_{i+1})\\in R_{i+1}  italic_f ( italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT italic_g start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT + ( 1 - italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ) italic_g start_POSTSUBSCRIPT italic_i + 1 end_POSTSUBSCRIPT )  italic_R start_POSTSUBSCRIPT italic_i + 1 end_POSTSUBSCRIPT . This is because the curve   : [ 0 , 1 ]  Q + + :   0 1 superscript Q absent \\gamma:[0,1]\\to\\mathcal{Q}^{++} italic_ : [ 0 , 1 ]  caligraphic_Q start_POSTSUPERSCRIPT + + end_POSTSUPERSCRIPT  given by    (  ) =  f  (   g i + ( 1   )  g i + 1 )    f  subscript g i 1  subscript g i 1 \\gamma(\\mu)=\\nabla f(\\mu g_{i}+(1-\\mu)g_{i+1}) italic_ ( italic_ ) =  italic_f ( italic_ italic_g start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT + ( 1 - italic_ ) italic_g start_POSTSUBSCRIPT italic_i + 1 end_POSTSUBSCRIPT )  starts and ends in opposite sides of the ray  R i + 1 subscript R i 1 R_{i+1} italic_R start_POSTSUBSCRIPT italic_i + 1 end_POSTSUBSCRIPT  as shown in Figure  3 , so it should cross it at some point     ( 0 , 1 ) superscript  0 1 \\mu^{*}\\in(0,1) italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT  ( 0 , 1 )  which can be found by binary search (here we need continuity of   f  f \\nabla f  italic_f ). We then set  ( p  , q  ) =  f  (    g i + ( 1    )  g i + 1 ) superscript p superscript q  f superscript  subscript g i 1 superscript  subscript g i 1 (p^{*},q^{*})=\\nabla f(\\mu^{*}g_{i}+(1-\\mu^{*})g_{i+1}) ( italic_p start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , italic_q start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ) =  italic_f ( italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT italic_g start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT + ( 1 - italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ) italic_g start_POSTSUBSCRIPT italic_i + 1 end_POSTSUBSCRIPT ) . Since  ( p  , q  )  R i + 1 superscript p superscript q subscript R i 1 (p^{*},q^{*})\\in R_{i+1} ( italic_p start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , italic_q start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT )  italic_R start_POSTSUBSCRIPT italic_i + 1 end_POSTSUBSCRIPT ,     g i + ( 1    )  g i + 1   cs   ( p   a + q   b ) superscript  subscript g i 1 superscript  subscript g i 1 superscript cs superscript p a superscript q b \\mu^{*}g_{i}+(1-\\mu^{*})g_{i+1}\\in\\partial\\operatorname{\\mathsf{cs}}^{*}(p^{*}% {\\mathbf{a}}+q^{*}{\\mathbf{b}}) italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT italic_g start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT + ( 1 - italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ) italic_g start_POSTSUBSCRIPT italic_i + 1 end_POSTSUBSCRIPT   sansserif_cs start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ( italic_p start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT bold_a + italic_q start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT bold_b ) . Applying   f  f \\nabla f  italic_f  to both sides, we get  ( p  , q  )   f  (  cs   ( p   a + q   b ) ) superscript p superscript q  f superscript cs superscript p a superscript q b (p^{*},q^{*})\\in\\nabla f(\\partial\\operatorname{\\mathsf{cs}}^{*}(p^{*}{\\mathbf{% a}}+q^{*}{\\mathbf{b}})) ( italic_p start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , italic_q start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT )   italic_f (  sansserif_cs start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ( italic_p start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT bold_a + italic_q start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT bold_b ) )  which is the fixed point condition ( 6 ). Setting    =     i + ( 1    )   i + 1 superscript  superscript  subscript  i 1 superscript  subscript  i 1 \\pi^{*}=\\mu^{*}\\sigma_{i}+(1-\\mu^{*})\\sigma_{i+1} italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT = italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT italic_ start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT + ( 1 - italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ) italic_ start_POSTSUBSCRIPT italic_i + 1 end_POSTSUBSCRIPT  and  (   ,   ) =    g i + ( 1    )  g i + 1 superscript  superscript  superscript  subscript g i 1 superscript  subscript g i 1 (\\alpha^{*},\\beta^{*})=\\mu^{*}g_{i}+(1-\\mu^{*})g_{i+1} ( italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ) = italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT italic_g start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT + ( 1 - italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ) italic_g start_POSTSUBSCRIPT italic_i + 1 end_POSTSUBSCRIPT  gives a solution to the simplified KKT conditions ( 5 ).",
            "Our approach to prove Theorem  3.2  is again very similar to how we proved Theorem  2.2 . We write a convex programming relaxation and solve its dual program. We will also assume that the sequences  a i , b i , w subscript a i subscript b i w {\\mathbf{a}}_{i},{\\mathbf{b}}_{i},{\\mathbf{w}} bold_a start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT , bold_b start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT , bold_w  are generic which can be ensure by perturbing all entries by tiny additive noise, this will not change  co w   ( a , b ) subscript superscript co w a b \\operatorname{\\mathsf{co}}^{*}_{\\mathbf{w}}({\\mathbf{a}},{\\mathbf{b}}) sansserif_co start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT start_POSTSUBSCRIPT bold_w end_POSTSUBSCRIPT ( bold_a , bold_b )  by much. By a limiting argument, this will not affect the result. We first develop a convex programming relaxation  OPT OPT \\mathsf{OPT} sansserif_OPT  as shown in ( 8 ).",
            "We are now ready to prove Theorem  3.2 .",
            "By Proposition  3.6  and  2.6 , we can find a solution to the primal program  8  where each   i  superscript subscript  i \\pi_{i}^{*} italic_ start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT  is either a permutation or a convex combination of two permutations which differ by an adjacent transposition. If   i  superscript subscript  i \\pi_{i}^{*} italic_ start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT  is a permutation then we just output    superscript  \\pi^{*} italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT  which is the optimal ranking for the  i t  h superscript i t h i^{th} italic_i start_POSTSUPERSCRIPT italic_t italic_h end_POSTSUPERSCRIPT  ranking problem. If    =    1 + ( 1   )   2 superscript   subscript  1 1  subscript  2 \\pi^{*}=\\mu\\pi_{1}+(1-\\mu)\\pi_{2} italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT = italic_ italic_ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT + ( 1 - italic_ ) italic_ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT  i.e. a convex combination of   1 ,  2 subscript  1 subscript  2 \\pi_{1},\\pi_{2} italic_ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , italic_ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT  which differ in the  j , j + 1 j j 1 j,j+1 italic_j , italic_j + 1  positions, then we output either   1 subscript  1 \\pi_{1} italic_ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT  or   2 subscript  2 \\pi_{2} italic_ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT  as the ranking for the  i t  h superscript i t h i^{th} italic_i start_POSTSUPERSCRIPT italic_t italic_h end_POSTSUPERSCRIPT  subproblem.",
            "Suppose    ( 0 ) = 1 italic- 0 1 \\phi(0)=1 italic_ ( 0 ) = 1  and    ( m ) =  1 italic- m 1 \\phi(m)=-1 italic_ ( italic_m ) = - 1  (otherwise we are done), where   italic- \\phi italic_  is the function defined in Equation ( 7 ). We want to find an  i i i italic_i  such that    ( i ) = 0 italic- i 0 \\phi(i)=0 italic_ ( italic_i ) = 0  or    ( i ) = 1 ,   ( i + 1 ) =  1 formulae-sequence italic- i 1 italic- i 1 1 \\phi(i)=1,\\phi(i+1)=-1 italic_ ( italic_i ) = 1 , italic_ ( italic_i + 1 ) = - 1 . Set   l = 0 ,  u =  formulae-sequence subscript  l 0 subscript  u \\lambda_{\\ell}=0,\\lambda_{u}=\\infty italic_ start_POSTSUBSCRIPT roman_l end_POSTSUBSCRIPT = 0 , italic_ start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT =  . From Claim  A.3 , we can sample a uniformly random    C  [  l ,  u ]  C subscript  l subscript  u \\lambda\\in C\\cap[\\lambda_{\\ell},\\lambda_{u}] italic_  italic_C  [ italic_ start_POSTSUBSCRIPT roman_l end_POSTSUBSCRIPT , italic_ start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT ]  in  O  ( n  log  n ) O n n O(n\\log n) italic_O ( italic_n roman_log italic_n )  time. Suppose   =  i  subscript  i \\lambda=\\lambda_{i} italic_ = italic_ start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT , then we can find   i + 1 subscript  i 1 \\lambda_{i+1} italic_ start_POSTSUBSCRIPT italic_i + 1 end_POSTSUBSCRIPT  and  g i subscript g i g_{i} italic_g start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT  as shown in Claim  A.1  in  O  ( n  log  n ) O n n O(n\\log n) italic_O ( italic_n roman_log italic_n )  time. Therefore we can evaluate    ( i ) italic- i \\phi(i) italic_ ( italic_i )  in  O  ( n  log  n ) O n n O(n\\log n) italic_O ( italic_n roman_log italic_n )  time. Now we continue the binary search based on the value of    ( i ) italic- i \\phi(i) italic_ ( italic_i )  and update the value of the lower bound   l =  subscript  l  \\lambda_{\\ell}=\\lambda italic_ start_POSTSUBSCRIPT roman_l end_POSTSUBSCRIPT = italic_  or the upper bound   u =  subscript  u  \\lambda_{u}=\\lambda italic_ start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT = italic_ . In each iteration, the random    C  [  l ,  u ]  C subscript  l subscript  u \\lambda\\in C\\cap[\\lambda_{\\ell},\\lambda_{u}] italic_  italic_C  [ italic_ start_POSTSUBSCRIPT roman_l end_POSTSUBSCRIPT , italic_ start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT ]  will eliminate constant fraction of points in  C  [  l ,  u ] C subscript  l subscript  u C\\cap[\\lambda_{\\ell},\\lambda_{u}] italic_C  [ italic_ start_POSTSUBSCRIPT roman_l end_POSTSUBSCRIPT , italic_ start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT ]  i.e. the size of  C  [  l ,  u ] C subscript  l subscript  u C\\cap[\\lambda_{\\ell},\\lambda_{u}] italic_C  [ italic_ start_POSTSUBSCRIPT roman_l end_POSTSUBSCRIPT , italic_ start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT ]  shrinks by a constant factor in expectation. Therefore the algorithm should end in  O  ( log  n ) O n O(\\log n) italic_O ( roman_log italic_n )  iterations with high probability. In fact, we can stop the sampling process once the size of  C  [  l ,  u ] C subscript  l subscript  u C\\cap[\\lambda_{\\ell},\\lambda_{u}] italic_C  [ italic_ start_POSTSUBSCRIPT roman_l end_POSTSUBSCRIPT , italic_ start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT ]  becomes  O  ( n ) O n O(n) italic_O ( italic_n )  and then do a regular binary search on them by listing them all. Since the running time of each iteration is  O  ( n  log  n ) , O n n O(n\\log n), italic_O ( italic_n roman_log italic_n ) ,  the total running time is  O  ( n  log 2  n ) . O n superscript 2 n O(n\\log^{2}n). italic_O ( italic_n roman_log start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT italic_n ) ."
        ]
    },
    "id_table_4": {
        "caption": "",
        "table": "A1.EGx1",
        "footnotes": [],
        "references": [
            "The source of the data is LinkedIn news feed: it is a random sample from one day of results. Here we do not go into the details of what the two objectives are, etc.; Section  4  has more details. On the right, we show the result of ranking using the sum of the two scores. The triangle shape of the scatter plot is persistent across different samples, and different choices of linear combinations. What we wish to avoid are the two corners of the triangle where one of the two NDCGs is rather small. Ideally, we like to be at the apex of the triangle which is at the top right corner of the figure.",
            "In Section  2  we give our binary search based algorithm for a single instance. The general case is presented in Section  3 . We present experimental results in Section  4 . Appendix contains some missing proofs.",
            "If  (   ,   ,   ) superscript  superscript  superscript  (\\pi^{*},\\alpha^{*},\\beta^{*}) ( italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT )  is some optimal solution for the primal ( 2 ) and  ( r  , c  , p  , q  ) superscript r superscript c superscript p superscript q ({\\mathbf{r}}^{*},{\\mathbf{c}}^{*},p^{*},q^{*}) ( bold_r start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , bold_c start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , italic_p start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , italic_q start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT )  is some optimal solution for the dual ( 3 ), then they should together satisfy the KKT conditions given in ( 4 ). A constraint of primal is tight if the corresponding variable in the dual is strictly positive and vice-versa.",
            "where  p  a + q  b = ( p  a 1 + q  b 1 , ... , p  a n + q  b n ) . p a q b p subscript a 1 q subscript b 1 ... p subscript a n q subscript b n p{\\mathbf{a}}+q{\\mathbf{b}}=(pa_{1}+qb_{1},\\dots,pa_{n}+qb_{n}). italic_p bold_a + italic_q bold_b = ( italic_p italic_a start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT + italic_q italic_b start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , ... , italic_p italic_a start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT + italic_q italic_b start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT ) .  Moreover the KKT condition ( 4 ) can be simplified to:",
            "From Proposition  2.4  and Lemma  2.5 , the solution    superscript  \\pi^{*} italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT  for the primal program ( 2 ) is either a single permutation or a convex combination of two permutations which differ only by an adjacent transposition (i.e. swapping two elements next to each other).",
            "The proof is very similar to the proof of Proposition  2.4  where we write a linear program for each sub-problem and the corresponding dual linear program. We will skip the details.",
            "This fixed point equation can be solved using binary search in exactly the same way as in Proposition  2.8 .   c  s w i   ( ( p + p i )  a i + ( q + q i )  b i ) c subscript superscript s subscript w i p subscript p i subscript a i q subscript q i subscript b i \\partial cs^{*}_{{\\mathbf{w}}_{i}}\\left((p+p_{i}){\\mathbf{a}}_{i}+(q+q_{i}){% \\mathbf{b}}_{i}\\right)  italic_c italic_s start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT start_POSTSUBSCRIPT bold_w start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT end_POSTSUBSCRIPT ( ( italic_p + italic_p start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT ) bold_a start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT + ( italic_q + italic_q start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT ) bold_b start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT )  only depends on the ration   = ( q + q i ) / ( p + p i )  q subscript q i p subscript p i \\lambda=(q+q_{i})/(p+p_{i}) italic_ = ( italic_q + italic_q start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT ) / ( italic_p + italic_p start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT ) . Geometrically, this ratio is constant on any line passing through  (  p ,  q ) p q (-p,-q) ( - italic_p , - italic_q ) . Figure  4  shows the regions where   c  s w i   ( ( p + p i )  a i + ( q + q i )  b i ) c subscript superscript s subscript w i p subscript p i subscript a i q subscript q i subscript b i \\partial cs^{*}_{{\\mathbf{w}}_{i}}\\left((p+p_{i}){\\mathbf{a}}_{i}+(q+q_{i}){% \\mathbf{b}}_{i}\\right)  italic_c italic_s start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT start_POSTSUBSCRIPT bold_w start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT end_POSTSUBSCRIPT ( ( italic_p + italic_p start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT ) bold_a start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT + ( italic_q + italic_q start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT ) bold_b start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT )  remains constant. Now the fixed point equation ( 12 ) can be solved in exactly the same way as in the proof of Proposition  2.8 . We will skip the details."
        ]
    },
    "id_table_5": {
        "caption": "",
        "table": "A1.EGx2",
        "footnotes": [],
        "references": [
            "From Proposition  2.4  and Lemma  2.5 , the solution    superscript  \\pi^{*} italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT  for the primal program ( 2 ) is either a single permutation or a convex combination of two permutations which differ only by an adjacent transposition (i.e. swapping two elements next to each other).",
            "To solve the primal program ( 2 ) and the dual program ( 3 ), it is enough to find  (   ,   ,   ) superscript  superscript  superscript  (\\pi^{*},\\alpha^{*},\\beta^{*}) ( italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT )  and  ( p  , q  ) superscript p superscript q (p^{*},q^{*}) ( italic_p start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , italic_q start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT )  which together satisfy all the simplified KKT conditions ( 5 ).",
            "Thus we need to find a fixed point for a set-valued map. We begin by calculating the subgradient   cs   ( p  a + q  b ) superscript cs p a q b \\partial\\operatorname{\\mathsf{cs}}^{*}(p{\\mathbf{a}}+q{\\mathbf{b}})  sansserif_cs start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ( italic_p bold_a + italic_q bold_b ) . Note that  cs   ( p  a + q  b ) = p  cs  ( a ,  ) + q  cs  ( b ,  ) superscript cs p a q b p cs a  q cs b  \\operatorname{\\mathsf{cs}}^{*}(p{\\mathbf{a}}+q{\\mathbf{b}})=p\\operatorname{% \\mathsf{cs}}({\\mathbf{a}},\\pi)+q\\operatorname{\\mathsf{cs}}({\\mathbf{b}},\\pi) sansserif_cs start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ( italic_p bold_a + italic_q bold_b ) = italic_p sansserif_cs ( bold_a , italic_ ) + italic_q sansserif_cs ( bold_b , italic_ )  where    \\pi italic_  is any permutation which sorts  p  a + q  b p a q b p{\\mathbf{a}}+q{\\mathbf{b}} italic_p bold_a + italic_q bold_b  in descending order. By Lemma  2.5 , there are two cases:",
            "( i ) = 0 italic- i 0 \\phi(i)=0 italic_ ( italic_i ) = 0 . In this case, we set  ( p  , q  ) =  f  ( g i ) . superscript p superscript q  f subscript g i (p^{*},q^{*})=\\nabla f(g_{i}). ( italic_p start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , italic_q start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ) =  italic_f ( italic_g start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT ) .  The condition    ( i ) = 0 italic- i 0 \\phi(i)=0 italic_ ( italic_i ) = 0  implies that  ( p  , q  )  R i  A i  R i + 1 . superscript p superscript q subscript R i subscript A i subscript R i 1 (p^{*},q^{*})\\in R_{i}\\cup A_{i}\\cup R_{i+1}. ( italic_p start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , italic_q start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT )  italic_R start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT  italic_A start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT  italic_R start_POSTSUBSCRIPT italic_i + 1 end_POSTSUBSCRIPT .  Therefore  g i   cs   ( p   a + q   b ) . subscript g i superscript cs superscript p a superscript q b g_{i}\\in\\partial\\operatorname{\\mathsf{cs}}^{*}(p^{*}{\\mathbf{a}}+q^{*}{\\mathbf% {b}}). italic_g start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT   sansserif_cs start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ( italic_p start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT bold_a + italic_q start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT bold_b ) .  Applying   f  f \\nabla f  italic_f  on both sides implies that  ( p  , q  ) =  f  ( g i )   f  (  cs   ( p   a + q   b ) ) superscript p superscript q  f subscript g i  f superscript cs superscript p a superscript q b (p^{*},q^{*})=\\nabla f(g_{i})\\in\\nabla f(\\partial\\operatorname{\\mathsf{cs}}^{*% }(p^{*}{\\mathbf{a}}+q^{*}{\\mathbf{b}})) ( italic_p start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , italic_q start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ) =  italic_f ( italic_g start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT )   italic_f (  sansserif_cs start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ( italic_p start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT bold_a + italic_q start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT bold_b ) )  which is the fixed point condition ( 6 ). Moreover setting    =  i superscript  subscript  i \\pi^{*}=\\sigma_{i} italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT = italic_ start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT  and  (   ,   ) = g i superscript  superscript  subscript g i (\\alpha^{*},\\beta^{*})=g_{i} ( italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ) = italic_g start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT  gives a solution to the simplified KKT conditions ( 5 ).",
            "( i ) = 1 ,   ( i + 1 ) =  1 formulae-sequence italic- i 1 italic- i 1 1 \\phi(i)=1,\\phi(i+1)=-1 italic_ ( italic_i ) = 1 , italic_ ( italic_i + 1 ) = - 1 . In this case, we claim that there exists some     ( 0 , 1 ) superscript  0 1 \\mu^{*}\\in(0,1) italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT  ( 0 , 1 )  such that   f  (    g i + ( 1    )  g i + 1 )  R i + 1  f superscript  subscript g i 1 superscript  subscript g i 1 subscript R i 1 \\nabla f(\\mu^{*}g_{i}+(1-\\mu^{*})g_{i+1})\\in R_{i+1}  italic_f ( italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT italic_g start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT + ( 1 - italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ) italic_g start_POSTSUBSCRIPT italic_i + 1 end_POSTSUBSCRIPT )  italic_R start_POSTSUBSCRIPT italic_i + 1 end_POSTSUBSCRIPT . This is because the curve   : [ 0 , 1 ]  Q + + :   0 1 superscript Q absent \\gamma:[0,1]\\to\\mathcal{Q}^{++} italic_ : [ 0 , 1 ]  caligraphic_Q start_POSTSUPERSCRIPT + + end_POSTSUPERSCRIPT  given by    (  ) =  f  (   g i + ( 1   )  g i + 1 )    f  subscript g i 1  subscript g i 1 \\gamma(\\mu)=\\nabla f(\\mu g_{i}+(1-\\mu)g_{i+1}) italic_ ( italic_ ) =  italic_f ( italic_ italic_g start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT + ( 1 - italic_ ) italic_g start_POSTSUBSCRIPT italic_i + 1 end_POSTSUBSCRIPT )  starts and ends in opposite sides of the ray  R i + 1 subscript R i 1 R_{i+1} italic_R start_POSTSUBSCRIPT italic_i + 1 end_POSTSUBSCRIPT  as shown in Figure  3 , so it should cross it at some point     ( 0 , 1 ) superscript  0 1 \\mu^{*}\\in(0,1) italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT  ( 0 , 1 )  which can be found by binary search (here we need continuity of   f  f \\nabla f  italic_f ). We then set  ( p  , q  ) =  f  (    g i + ( 1    )  g i + 1 ) superscript p superscript q  f superscript  subscript g i 1 superscript  subscript g i 1 (p^{*},q^{*})=\\nabla f(\\mu^{*}g_{i}+(1-\\mu^{*})g_{i+1}) ( italic_p start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , italic_q start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ) =  italic_f ( italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT italic_g start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT + ( 1 - italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ) italic_g start_POSTSUBSCRIPT italic_i + 1 end_POSTSUBSCRIPT ) . Since  ( p  , q  )  R i + 1 superscript p superscript q subscript R i 1 (p^{*},q^{*})\\in R_{i+1} ( italic_p start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , italic_q start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT )  italic_R start_POSTSUBSCRIPT italic_i + 1 end_POSTSUBSCRIPT ,     g i + ( 1    )  g i + 1   cs   ( p   a + q   b ) superscript  subscript g i 1 superscript  subscript g i 1 superscript cs superscript p a superscript q b \\mu^{*}g_{i}+(1-\\mu^{*})g_{i+1}\\in\\partial\\operatorname{\\mathsf{cs}}^{*}(p^{*}% {\\mathbf{a}}+q^{*}{\\mathbf{b}}) italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT italic_g start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT + ( 1 - italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ) italic_g start_POSTSUBSCRIPT italic_i + 1 end_POSTSUBSCRIPT   sansserif_cs start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ( italic_p start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT bold_a + italic_q start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT bold_b ) . Applying   f  f \\nabla f  italic_f  to both sides, we get  ( p  , q  )   f  (  cs   ( p   a + q   b ) ) superscript p superscript q  f superscript cs superscript p a superscript q b (p^{*},q^{*})\\in\\nabla f(\\partial\\operatorname{\\mathsf{cs}}^{*}(p^{*}{\\mathbf{% a}}+q^{*}{\\mathbf{b}})) ( italic_p start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , italic_q start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT )   italic_f (  sansserif_cs start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ( italic_p start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT bold_a + italic_q start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT bold_b ) )  which is the fixed point condition ( 6 ). Setting    =     i + ( 1    )   i + 1 superscript  superscript  subscript  i 1 superscript  subscript  i 1 \\pi^{*}=\\mu^{*}\\sigma_{i}+(1-\\mu^{*})\\sigma_{i+1} italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT = italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT italic_ start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT + ( 1 - italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ) italic_ start_POSTSUBSCRIPT italic_i + 1 end_POSTSUBSCRIPT  and  (   ,   ) =    g i + ( 1    )  g i + 1 superscript  superscript  superscript  subscript g i 1 superscript  subscript g i 1 (\\alpha^{*},\\beta^{*})=\\mu^{*}g_{i}+(1-\\mu^{*})g_{i+1} ( italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ) = italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT italic_g start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT + ( 1 - italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ) italic_g start_POSTSUBSCRIPT italic_i + 1 end_POSTSUBSCRIPT  gives a solution to the simplified KKT conditions ( 5 ).",
            "A scatter plot of the distribution of these values is shown in Figure  5 ."
        ]
    },
    "id_table_6": {
        "caption": "",
        "table": "S2.E7",
        "footnotes": [],
        "references": [
            "( i ) = 0 italic- i 0 \\phi(i)=0 italic_ ( italic_i ) = 0 . In this case, we set  ( p  , q  ) =  f  ( g i ) . superscript p superscript q  f subscript g i (p^{*},q^{*})=\\nabla f(g_{i}). ( italic_p start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , italic_q start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ) =  italic_f ( italic_g start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT ) .  The condition    ( i ) = 0 italic- i 0 \\phi(i)=0 italic_ ( italic_i ) = 0  implies that  ( p  , q  )  R i  A i  R i + 1 . superscript p superscript q subscript R i subscript A i subscript R i 1 (p^{*},q^{*})\\in R_{i}\\cup A_{i}\\cup R_{i+1}. ( italic_p start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , italic_q start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT )  italic_R start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT  italic_A start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT  italic_R start_POSTSUBSCRIPT italic_i + 1 end_POSTSUBSCRIPT .  Therefore  g i   cs   ( p   a + q   b ) . subscript g i superscript cs superscript p a superscript q b g_{i}\\in\\partial\\operatorname{\\mathsf{cs}}^{*}(p^{*}{\\mathbf{a}}+q^{*}{\\mathbf% {b}}). italic_g start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT   sansserif_cs start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ( italic_p start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT bold_a + italic_q start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT bold_b ) .  Applying   f  f \\nabla f  italic_f  on both sides implies that  ( p  , q  ) =  f  ( g i )   f  (  cs   ( p   a + q   b ) ) superscript p superscript q  f subscript g i  f superscript cs superscript p a superscript q b (p^{*},q^{*})=\\nabla f(g_{i})\\in\\nabla f(\\partial\\operatorname{\\mathsf{cs}}^{*% }(p^{*}{\\mathbf{a}}+q^{*}{\\mathbf{b}})) ( italic_p start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , italic_q start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ) =  italic_f ( italic_g start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT )   italic_f (  sansserif_cs start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ( italic_p start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT bold_a + italic_q start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT bold_b ) )  which is the fixed point condition ( 6 ). Moreover setting    =  i superscript  subscript  i \\pi^{*}=\\sigma_{i} italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT = italic_ start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT  and  (   ,   ) = g i superscript  superscript  subscript g i (\\alpha^{*},\\beta^{*})=g_{i} ( italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ) = italic_g start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT  gives a solution to the simplified KKT conditions ( 5 ).",
            "( i ) = 1 ,   ( i + 1 ) =  1 formulae-sequence italic- i 1 italic- i 1 1 \\phi(i)=1,\\phi(i+1)=-1 italic_ ( italic_i ) = 1 , italic_ ( italic_i + 1 ) = - 1 . In this case, we claim that there exists some     ( 0 , 1 ) superscript  0 1 \\mu^{*}\\in(0,1) italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT  ( 0 , 1 )  such that   f  (    g i + ( 1    )  g i + 1 )  R i + 1  f superscript  subscript g i 1 superscript  subscript g i 1 subscript R i 1 \\nabla f(\\mu^{*}g_{i}+(1-\\mu^{*})g_{i+1})\\in R_{i+1}  italic_f ( italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT italic_g start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT + ( 1 - italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ) italic_g start_POSTSUBSCRIPT italic_i + 1 end_POSTSUBSCRIPT )  italic_R start_POSTSUBSCRIPT italic_i + 1 end_POSTSUBSCRIPT . This is because the curve   : [ 0 , 1 ]  Q + + :   0 1 superscript Q absent \\gamma:[0,1]\\to\\mathcal{Q}^{++} italic_ : [ 0 , 1 ]  caligraphic_Q start_POSTSUPERSCRIPT + + end_POSTSUPERSCRIPT  given by    (  ) =  f  (   g i + ( 1   )  g i + 1 )    f  subscript g i 1  subscript g i 1 \\gamma(\\mu)=\\nabla f(\\mu g_{i}+(1-\\mu)g_{i+1}) italic_ ( italic_ ) =  italic_f ( italic_ italic_g start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT + ( 1 - italic_ ) italic_g start_POSTSUBSCRIPT italic_i + 1 end_POSTSUBSCRIPT )  starts and ends in opposite sides of the ray  R i + 1 subscript R i 1 R_{i+1} italic_R start_POSTSUBSCRIPT italic_i + 1 end_POSTSUBSCRIPT  as shown in Figure  3 , so it should cross it at some point     ( 0 , 1 ) superscript  0 1 \\mu^{*}\\in(0,1) italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT  ( 0 , 1 )  which can be found by binary search (here we need continuity of   f  f \\nabla f  italic_f ). We then set  ( p  , q  ) =  f  (    g i + ( 1    )  g i + 1 ) superscript p superscript q  f superscript  subscript g i 1 superscript  subscript g i 1 (p^{*},q^{*})=\\nabla f(\\mu^{*}g_{i}+(1-\\mu^{*})g_{i+1}) ( italic_p start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , italic_q start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ) =  italic_f ( italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT italic_g start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT + ( 1 - italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ) italic_g start_POSTSUBSCRIPT italic_i + 1 end_POSTSUBSCRIPT ) . Since  ( p  , q  )  R i + 1 superscript p superscript q subscript R i 1 (p^{*},q^{*})\\in R_{i+1} ( italic_p start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , italic_q start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT )  italic_R start_POSTSUBSCRIPT italic_i + 1 end_POSTSUBSCRIPT ,     g i + ( 1    )  g i + 1   cs   ( p   a + q   b ) superscript  subscript g i 1 superscript  subscript g i 1 superscript cs superscript p a superscript q b \\mu^{*}g_{i}+(1-\\mu^{*})g_{i+1}\\in\\partial\\operatorname{\\mathsf{cs}}^{*}(p^{*}% {\\mathbf{a}}+q^{*}{\\mathbf{b}}) italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT italic_g start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT + ( 1 - italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ) italic_g start_POSTSUBSCRIPT italic_i + 1 end_POSTSUBSCRIPT   sansserif_cs start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ( italic_p start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT bold_a + italic_q start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT bold_b ) . Applying   f  f \\nabla f  italic_f  to both sides, we get  ( p  , q  )   f  (  cs   ( p   a + q   b ) ) superscript p superscript q  f superscript cs superscript p a superscript q b (p^{*},q^{*})\\in\\nabla f(\\partial\\operatorname{\\mathsf{cs}}^{*}(p^{*}{\\mathbf{% a}}+q^{*}{\\mathbf{b}})) ( italic_p start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , italic_q start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT )   italic_f (  sansserif_cs start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ( italic_p start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT bold_a + italic_q start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT bold_b ) )  which is the fixed point condition ( 6 ). Setting    =     i + ( 1    )   i + 1 superscript  superscript  subscript  i 1 superscript  subscript  i 1 \\pi^{*}=\\mu^{*}\\sigma_{i}+(1-\\mu^{*})\\sigma_{i+1} italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT = italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT italic_ start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT + ( 1 - italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ) italic_ start_POSTSUBSCRIPT italic_i + 1 end_POSTSUBSCRIPT  and  (   ,   ) =    g i + ( 1    )  g i + 1 superscript  superscript  superscript  subscript g i 1 superscript  subscript g i 1 (\\alpha^{*},\\beta^{*})=\\mu^{*}g_{i}+(1-\\mu^{*})g_{i+1} ( italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ) = italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT italic_g start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT + ( 1 - italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT ) italic_g start_POSTSUBSCRIPT italic_i + 1 end_POSTSUBSCRIPT  gives a solution to the simplified KKT conditions ( 5 ).",
            "By Proposition  2.8  and Remark  2.6 , we can find a solution  (   ,   ,   ) superscript  superscript  superscript  (\\pi^{*},\\alpha^{*},\\beta^{*}) ( italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT )  to the primal program ( 2 ) where    superscript  \\pi^{*} italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT  is either a permutation or a convex combination of two permutations which differ by an adjacent transposition. If    superscript  \\pi^{*} italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT  is a permutation then",
            "By Proposition  3.6  and  2.6 , we can find a solution to the primal program  8  where each   i  superscript subscript  i \\pi_{i}^{*} italic_ start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT  is either a permutation or a convex combination of two permutations which differ by an adjacent transposition. If   i  superscript subscript  i \\pi_{i}^{*} italic_ start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT  is a permutation then we just output    superscript  \\pi^{*} italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT  which is the optimal ranking for the  i t  h superscript i t h i^{th} italic_i start_POSTSUPERSCRIPT italic_t italic_h end_POSTSUPERSCRIPT  ranking problem. If    =    1 + ( 1   )   2 superscript   subscript  1 1  subscript  2 \\pi^{*}=\\mu\\pi_{1}+(1-\\mu)\\pi_{2} italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT = italic_ italic_ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT + ( 1 - italic_ ) italic_ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT  i.e. a convex combination of   1 ,  2 subscript  1 subscript  2 \\pi_{1},\\pi_{2} italic_ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , italic_ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT  which differ in the  j , j + 1 j j 1 j,j+1 italic_j , italic_j + 1  positions, then we output either   1 subscript  1 \\pi_{1} italic_ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT  or   2 subscript  2 \\pi_{2} italic_ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT  as the ranking for the  i t  h superscript i t h i^{th} italic_i start_POSTSUPERSCRIPT italic_t italic_h end_POSTSUPERSCRIPT  subproblem.",
            "We first present the results on synthetic data. The purpose of this experiment is to illustrate how different objective functions affect the distribution of the NDCGs. These results are summarized in Figures  6  and  7 . We present the scatter plot of the NDCGs, just like in Figure  1 , as well as the cumulative distribution functions (CDFs).",
            "It can be seen from Figure  6  that the concave functions are quite a bit more clustered than the additive functions. This can also be seen in the table inside the figure, which shows the sum of the cumulative scores, the DCGs, as well as the mean of the normalized cumulative scores, the NDCGs. These quantities are almost the same across all algorithms. We also show the standard deviations of the NDCGs, which quite well captures how clustered the points are, and shows a significant difference between the concave and the additive functions."
        ]
    },
    "id_table_7": {
        "caption": "",
        "table": "A1.EGx3",
        "footnotes": [],
        "references": [
            "We first present the results on synthetic data. The purpose of this experiment is to illustrate how different objective functions affect the distribution of the NDCGs. These results are summarized in Figures  6  and  7 . We present the scatter plot of the NDCGs, just like in Figure  1 , as well as the cumulative distribution functions (CDFs).",
            "We present the CDFs of the NDCGs for the four algorithms in Figure  7 . The dots on the curves represent deciles, i.e., the values corresponding to the bottom  10 % percent 10 10\\% 10 %  of the population,  20 % percent 20 20\\% 20 % , and so on. Recall that a lower CDF implies that the values are higher. 6 6 6  Recall that a distribution  F F F italic_F  stochastically dominates another distribution  G G G italic_G  iff the cdf of  F F F italic_F  is always below that of  G G G italic_G .  The CDF shows that in the bottom half of the distribution, the concave functions are higher than the additive ones. Also the steeper shape of the CDFs for the concave functions show how they are more concentrated. There is indeed a price to pay in that the top half are worse but this is unavoidable. The additive function picks a point on the Pareto frontier after all; in fact, it maximizes the mean of  A A A italic_A  for a fixed mean of  B B B italic_B  and vice versa. The whole point is that the mean is not necessarily an appropriate metric.",
            "Suppose    ( 0 ) = 1 italic- 0 1 \\phi(0)=1 italic_ ( 0 ) = 1  and    ( m ) =  1 italic- m 1 \\phi(m)=-1 italic_ ( italic_m ) = - 1  (otherwise we are done), where   italic- \\phi italic_  is the function defined in Equation ( 7 ). We want to find an  i i i italic_i  such that    ( i ) = 0 italic- i 0 \\phi(i)=0 italic_ ( italic_i ) = 0  or    ( i ) = 1 ,   ( i + 1 ) =  1 formulae-sequence italic- i 1 italic- i 1 1 \\phi(i)=1,\\phi(i+1)=-1 italic_ ( italic_i ) = 1 , italic_ ( italic_i + 1 ) = - 1 . Set   l = 0 ,  u =  formulae-sequence subscript  l 0 subscript  u \\lambda_{\\ell}=0,\\lambda_{u}=\\infty italic_ start_POSTSUBSCRIPT roman_l end_POSTSUBSCRIPT = 0 , italic_ start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT =  . From Claim  A.3 , we can sample a uniformly random    C  [  l ,  u ]  C subscript  l subscript  u \\lambda\\in C\\cap[\\lambda_{\\ell},\\lambda_{u}] italic_  italic_C  [ italic_ start_POSTSUBSCRIPT roman_l end_POSTSUBSCRIPT , italic_ start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT ]  in  O  ( n  log  n ) O n n O(n\\log n) italic_O ( italic_n roman_log italic_n )  time. Suppose   =  i  subscript  i \\lambda=\\lambda_{i} italic_ = italic_ start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT , then we can find   i + 1 subscript  i 1 \\lambda_{i+1} italic_ start_POSTSUBSCRIPT italic_i + 1 end_POSTSUBSCRIPT  and  g i subscript g i g_{i} italic_g start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT  as shown in Claim  A.1  in  O  ( n  log  n ) O n n O(n\\log n) italic_O ( italic_n roman_log italic_n )  time. Therefore we can evaluate    ( i ) italic- i \\phi(i) italic_ ( italic_i )  in  O  ( n  log  n ) O n n O(n\\log n) italic_O ( italic_n roman_log italic_n )  time. Now we continue the binary search based on the value of    ( i ) italic- i \\phi(i) italic_ ( italic_i )  and update the value of the lower bound   l =  subscript  l  \\lambda_{\\ell}=\\lambda italic_ start_POSTSUBSCRIPT roman_l end_POSTSUBSCRIPT = italic_  or the upper bound   u =  subscript  u  \\lambda_{u}=\\lambda italic_ start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT = italic_ . In each iteration, the random    C  [  l ,  u ]  C subscript  l subscript  u \\lambda\\in C\\cap[\\lambda_{\\ell},\\lambda_{u}] italic_  italic_C  [ italic_ start_POSTSUBSCRIPT roman_l end_POSTSUBSCRIPT , italic_ start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT ]  will eliminate constant fraction of points in  C  [  l ,  u ] C subscript  l subscript  u C\\cap[\\lambda_{\\ell},\\lambda_{u}] italic_C  [ italic_ start_POSTSUBSCRIPT roman_l end_POSTSUBSCRIPT , italic_ start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT ]  i.e. the size of  C  [  l ,  u ] C subscript  l subscript  u C\\cap[\\lambda_{\\ell},\\lambda_{u}] italic_C  [ italic_ start_POSTSUBSCRIPT roman_l end_POSTSUBSCRIPT , italic_ start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT ]  shrinks by a constant factor in expectation. Therefore the algorithm should end in  O  ( log  n ) O n O(\\log n) italic_O ( roman_log italic_n )  iterations with high probability. In fact, we can stop the sampling process once the size of  C  [  l ,  u ] C subscript  l subscript  u C\\cap[\\lambda_{\\ell},\\lambda_{u}] italic_C  [ italic_ start_POSTSUBSCRIPT roman_l end_POSTSUBSCRIPT , italic_ start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT ]  becomes  O  ( n ) O n O(n) italic_O ( italic_n )  and then do a regular binary search on them by listing them all. Since the running time of each iteration is  O  ( n  log  n ) , O n n O(n\\log n), italic_O ( italic_n roman_log italic_n ) ,  the total running time is  O  ( n  log 2  n ) . O n superscript 2 n O(n\\log^{2}n). italic_O ( italic_n roman_log start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT italic_n ) ."
        ]
    },
    "id_table_8": {
        "caption": "",
        "table": "S3.E8",
        "footnotes": [],
        "references": [
            "When there is no global function  F F F italic_F , for each  i i i italic_i , the algorithm just does a binary search (Proposition  2.8 ). In each iteration of the binary search, we compute a ranking optimal for a linear combination of the two objectives. The running time to solve each ranking problem (i.e. each instance  i i i italic_i ) is  O  ( n  log 2  n ) O n superscript 2 n O(n\\log^{2}n) italic_O ( italic_n roman_log start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT italic_n ) . In practice, the ranking algorithms are required to be very fast, so this is an important property. For the general case, this is still true, provided that we are given 2 additional parameters that are optimized appropriately. In practice, such parameters are tuned offline so we can still use the binary search to rank online any new instance  i i i italic_i .",
            "By Proposition  2.8  and Remark  2.6 , we can find a solution  (   ,   ,   ) superscript  superscript  superscript  (\\pi^{*},\\alpha^{*},\\beta^{*}) ( italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT )  to the primal program ( 2 ) where    superscript  \\pi^{*} italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT  is either a permutation or a convex combination of two permutations which differ by an adjacent transposition. If    superscript  \\pi^{*} italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT  is a permutation then",
            "Our approach to prove Theorem  3.2  is again very similar to how we proved Theorem  2.2 . We write a convex programming relaxation and solve its dual program. We will also assume that the sequences  a i , b i , w subscript a i subscript b i w {\\mathbf{a}}_{i},{\\mathbf{b}}_{i},{\\mathbf{w}} bold_a start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT , bold_b start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT , bold_w  are generic which can be ensure by perturbing all entries by tiny additive noise, this will not change  co w   ( a , b ) subscript superscript co w a b \\operatorname{\\mathsf{co}}^{*}_{\\mathbf{w}}({\\mathbf{a}},{\\mathbf{b}}) sansserif_co start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT start_POSTSUBSCRIPT bold_w end_POSTSUBSCRIPT ( bold_a , bold_b )  by much. By a limiting argument, this will not affect the result. We first develop a convex programming relaxation  OPT OPT \\mathsf{OPT} sansserif_OPT  as shown in ( 8 ).",
            "It is clear that  OPT OPT \\mathsf{OPT} sansserif_OPT  is a relaxation for  co w   ( a , b ) subscript superscript co w a b \\operatorname{\\mathsf{co}}^{*}_{\\mathbf{w}}({\\mathbf{a}},{\\mathbf{b}}) sansserif_co start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT start_POSTSUBSCRIPT bold_w end_POSTSUBSCRIPT ( bold_a , bold_b )  with  co w   ( a , b )  OPT . subscript superscript co w a b OPT \\operatorname{\\mathsf{co}}^{*}_{\\mathbf{w}}({\\mathbf{a}},{\\mathbf{b}})\\leq% \\mathsf{OPT}. sansserif_co start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT start_POSTSUBSCRIPT bold_w end_POSTSUBSCRIPT ( bold_a , bold_b )  sansserif_OPT .  By convex programming duality,  OPT OPT \\mathsf{OPT} sansserif_OPT  can be expressed as a dual minimization problem ( 9 ) by introducing a dual variable for every constraint in the primal as shown in ( 8 ). Again by Slaters condition, strong duality holds  Boyd and Vandenberghe ( 2004 ) . The constraints in the dual correspond to variables in the primal as shown in ( 9 ).",
            "Here  f i  superscript subscript f i f_{i}^{*} italic_f start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT  is the Fenchel dual of  f f f italic_f  and  F  superscript F F^{*} italic_F start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT  is the Fenchel dual of  F . F F. italic_F .  If  (   ,  i  ,  i  ,   ,   ) superscript  superscript subscript  i superscript subscript  i superscript  superscript  (\\pi^{*},\\alpha_{i}^{*},\\beta_{i}^{*},\\alpha^{*},\\beta^{*}) ( italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , italic_ start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , italic_ start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT )  is some optimal solution for the primal ( 8 ) and  ( r  , c  , p i  , q i  , p  , q  ) superscript r superscript c superscript subscript p i superscript subscript q i superscript p superscript q (r^{*},c^{*},p_{i}^{*},q_{i}^{*},p^{*},q^{*}) ( italic_r start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , italic_c start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , italic_p start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , italic_q start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , italic_p start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , italic_q start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT )  is some optimal solution for the dual ( 9 ), then they should together satisfy the KKT conditions given in ( 10 ). Note that a constraint of primal is tight if the corresponding variable in the dual is strictly positive and vice-versa.",
            "This fixed point equation can be solved using binary search in exactly the same way as in Proposition  2.8 .   c  s w i   ( ( p + p i )  a i + ( q + q i )  b i ) c subscript superscript s subscript w i p subscript p i subscript a i q subscript q i subscript b i \\partial cs^{*}_{{\\mathbf{w}}_{i}}\\left((p+p_{i}){\\mathbf{a}}_{i}+(q+q_{i}){% \\mathbf{b}}_{i}\\right)  italic_c italic_s start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT start_POSTSUBSCRIPT bold_w start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT end_POSTSUBSCRIPT ( ( italic_p + italic_p start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT ) bold_a start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT + ( italic_q + italic_q start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT ) bold_b start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT )  only depends on the ration   = ( q + q i ) / ( p + p i )  q subscript q i p subscript p i \\lambda=(q+q_{i})/(p+p_{i}) italic_ = ( italic_q + italic_q start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT ) / ( italic_p + italic_p start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT ) . Geometrically, this ratio is constant on any line passing through  (  p ,  q ) p q (-p,-q) ( - italic_p , - italic_q ) . Figure  4  shows the regions where   c  s w i   ( ( p + p i )  a i + ( q + q i )  b i ) c subscript superscript s subscript w i p subscript p i subscript a i q subscript q i subscript b i \\partial cs^{*}_{{\\mathbf{w}}_{i}}\\left((p+p_{i}){\\mathbf{a}}_{i}+(q+q_{i}){% \\mathbf{b}}_{i}\\right)  italic_c italic_s start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT start_POSTSUBSCRIPT bold_w start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT end_POSTSUBSCRIPT ( ( italic_p + italic_p start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT ) bold_a start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT + ( italic_q + italic_q start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT ) bold_b start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT )  remains constant. Now the fixed point equation ( 12 ) can be solved in exactly the same way as in the proof of Proposition  2.8 . We will skip the details.",
            "By Proposition  3.6  and  2.6 , we can find a solution to the primal program  8  where each   i  superscript subscript  i \\pi_{i}^{*} italic_ start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT  is either a permutation or a convex combination of two permutations which differ by an adjacent transposition. If   i  superscript subscript  i \\pi_{i}^{*} italic_ start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT  is a permutation then we just output    superscript  \\pi^{*} italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT  which is the optimal ranking for the  i t  h superscript i t h i^{th} italic_i start_POSTSUPERSCRIPT italic_t italic_h end_POSTSUPERSCRIPT  ranking problem. If    =    1 + ( 1   )   2 superscript   subscript  1 1  subscript  2 \\pi^{*}=\\mu\\pi_{1}+(1-\\mu)\\pi_{2} italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT = italic_ italic_ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT + ( 1 - italic_ ) italic_ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT  i.e. a convex combination of   1 ,  2 subscript  1 subscript  2 \\pi_{1},\\pi_{2} italic_ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , italic_ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT  which differ in the  j , j + 1 j j 1 j,j+1 italic_j , italic_j + 1  positions, then we output either   1 subscript  1 \\pi_{1} italic_ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT  or   2 subscript  2 \\pi_{2} italic_ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT  as the ranking for the  i t  h superscript i t h i^{th} italic_i start_POSTSUPERSCRIPT italic_t italic_h end_POSTSUPERSCRIPT  subproblem.",
            "We present the CDFs of the NDCGs for relevance for the two algorithms in Figure  8 . The figure shows that in the bottom quartile the exp function does better, and the relation flips above this. For the bottom decile, the difference is significant. As mentioned earlier, this is exactly what we wanted to achieve."
        ]
    },
    "id_table_9": {
        "caption": "",
        "table": "S3.E9",
        "footnotes": [],
        "references": [
            "It is clear that  OPT OPT \\mathsf{OPT} sansserif_OPT  is a relaxation for  co w   ( a , b ) subscript superscript co w a b \\operatorname{\\mathsf{co}}^{*}_{\\mathbf{w}}({\\mathbf{a}},{\\mathbf{b}}) sansserif_co start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT start_POSTSUBSCRIPT bold_w end_POSTSUBSCRIPT ( bold_a , bold_b )  with  co w   ( a , b )  OPT . subscript superscript co w a b OPT \\operatorname{\\mathsf{co}}^{*}_{\\mathbf{w}}({\\mathbf{a}},{\\mathbf{b}})\\leq% \\mathsf{OPT}. sansserif_co start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT start_POSTSUBSCRIPT bold_w end_POSTSUBSCRIPT ( bold_a , bold_b )  sansserif_OPT .  By convex programming duality,  OPT OPT \\mathsf{OPT} sansserif_OPT  can be expressed as a dual minimization problem ( 9 ) by introducing a dual variable for every constraint in the primal as shown in ( 8 ). Again by Slaters condition, strong duality holds  Boyd and Vandenberghe ( 2004 ) . The constraints in the dual correspond to variables in the primal as shown in ( 9 ).",
            "Here  f i  superscript subscript f i f_{i}^{*} italic_f start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT  is the Fenchel dual of  f f f italic_f  and  F  superscript F F^{*} italic_F start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT  is the Fenchel dual of  F . F F. italic_F .  If  (   ,  i  ,  i  ,   ,   ) superscript  superscript subscript  i superscript subscript  i superscript  superscript  (\\pi^{*},\\alpha_{i}^{*},\\beta_{i}^{*},\\alpha^{*},\\beta^{*}) ( italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , italic_ start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , italic_ start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT )  is some optimal solution for the primal ( 8 ) and  ( r  , c  , p i  , q i  , p  , q  ) superscript r superscript c superscript subscript p i superscript subscript q i superscript p superscript q (r^{*},c^{*},p_{i}^{*},q_{i}^{*},p^{*},q^{*}) ( italic_r start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , italic_c start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , italic_p start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , italic_q start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , italic_p start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , italic_q start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT )  is some optimal solution for the dual ( 9 ), then they should together satisfy the KKT conditions given in ( 10 ). Note that a constraint of primal is tight if the corresponding variable in the dual is strictly positive and vice-versa.",
            "Let  p , q , p 1 , q 1 , ... , p m , q m > 0 p q subscript p 1 subscript q 1 ... subscript p m subscript q m 0 p,q,p_{1},q_{1},\\dots,p_{m},q_{m}>0 italic_p , italic_q , italic_p start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , italic_q start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , ... , italic_p start_POSTSUBSCRIPT italic_m end_POSTSUBSCRIPT , italic_q start_POSTSUBSCRIPT italic_m end_POSTSUBSCRIPT > 0  be fixed. Then the value of the minimization program in ( 9 ) is given by",
            "Another important aspect of a ranking algorithm in this context is the set of positions that ads occupy. In Figure  9 , we show this distribution: for each position, we show the number of instances for which there was an ad in that position. For the additive function, which is the graph at the bottom, most of the ads are clustered around positions 2 to 4, and the number gradually decreases further down. The distribution in case of the exp function is better spread out. Interestingly, the most common position an ad is shown is the very last one."
        ]
    },
    "id_table_10": {
        "caption": "",
        "table": "S3.E11",
        "footnotes": [],
        "references": [
            "Here  f i  superscript subscript f i f_{i}^{*} italic_f start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT  is the Fenchel dual of  f f f italic_f  and  F  superscript F F^{*} italic_F start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT  is the Fenchel dual of  F . F F. italic_F .  If  (   ,  i  ,  i  ,   ,   ) superscript  superscript subscript  i superscript subscript  i superscript  superscript  (\\pi^{*},\\alpha_{i}^{*},\\beta_{i}^{*},\\alpha^{*},\\beta^{*}) ( italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , italic_ start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , italic_ start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , italic_ start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT )  is some optimal solution for the primal ( 8 ) and  ( r  , c  , p i  , q i  , p  , q  ) superscript r superscript c superscript subscript p i superscript subscript q i superscript p superscript q (r^{*},c^{*},p_{i}^{*},q_{i}^{*},p^{*},q^{*}) ( italic_r start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , italic_c start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , italic_p start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , italic_q start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , italic_p start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT , italic_q start_POSTSUPERSCRIPT  end_POSTSUPERSCRIPT )  is some optimal solution for the dual ( 9 ), then they should together satisfy the KKT conditions given in ( 10 ). Note that a constraint of primal is tight if the corresponding variable in the dual is strictly positive and vice-versa.",
            "Moreover the KKT conditions  10  can be simplified to:"
        ]
    },
    "id_table_11": {
        "caption": "",
        "table": "A1.EGx4",
        "footnotes": [],
        "references": []
    }
}