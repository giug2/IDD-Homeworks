<!DOCTYPE html><html lang="en">
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title>[2010.07427] BlockFLA: Accountable Federated Learning via Hybrid Blockchain Architecture</title><meta property="og:description" content="Federated Learning (FL) is a distributed, and decentralized machine learning protocol. By executing FL, a set of agents can jointly train a model without sharing their datasets with each other, or a third-party. This m…">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="BlockFLA: Accountable Federated Learning via Hybrid Blockchain Architecture">
<meta name="twitter:image:src" content="https://ar5iv.labs.arxiv.org/assets/ar5iv_card.png">
<meta name="twitter:image:alt" content="ar5iv logo">
<meta property="og:title" content="BlockFLA: Accountable Federated Learning via Hybrid Blockchain Architecture">
<meta property="og:site_name" content="ar5iv">
<meta property="og:image" content="https://ar5iv.labs.arxiv.org/assets/ar5iv_card.png">
<meta property="og:type" content="article">
<meta property="og:url" content="https://ar5iv.labs.arxiv.org/html/2010.07427">

<!--Generated on Sat Mar  2 09:06:32 2024 by LaTeXML (version 0.8.8) http://dlmf.nist.gov/LaTeXML/.-->
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="keywords" lang="en" content="Hybrid Blockchain,  Hyperledger,  Ethereum,  Machine Learning,  Backdoor attacks,  Federated Learning,  Federated Averaging">

<script>
  function detectColorScheme(){
    var theme="light";
    var current_theme = localStorage.getItem("ar5iv_theme");
    if(current_theme){
      if(current_theme == "dark"){
        theme = "dark";
      } }
    else if(!window.matchMedia) { return false; }
    else if(window.matchMedia("(prefers-color-scheme: dark)").matches) {
      theme = "dark"; }
    if (theme=="dark") {
      document.documentElement.setAttribute("data-theme", "dark");
    } else {
      document.documentElement.setAttribute("data-theme", "light"); } }

  detectColorScheme();

  function toggleColorScheme(){
    var current_theme = localStorage.getItem("ar5iv_theme");
    if (current_theme) {
      if (current_theme == "light") {
        localStorage.setItem("ar5iv_theme", "dark"); }
      else {
        localStorage.setItem("ar5iv_theme", "light"); } }
    else {
        localStorage.setItem("ar5iv_theme", "dark"); }
    detectColorScheme(); }
</script>
<link media="all" rel="stylesheet" href="/assets/ar5iv-fonts.0.8.0.min.css"><link media="all" rel="stylesheet" href="/assets/ar5iv.0.8.0.min.css"><link media="all" rel="stylesheet" href="/assets/ar5iv-site.0.2.2.css">
</head>
<body>
<div class="ltx_page_main">
<div class="ltx_page_content">
<article class="ltx_document ltx_authors_1line ltx_leqno">
<h1 class="ltx_title ltx_title_document">
<span id="id1.id1" class="ltx_text ltx_font_sansserif">BlockFLA</span>: Accountable Federated Learning 
<br class="ltx_break">via Hybrid Blockchain Architecture</h1>
<div class="ltx_authors">
<span class="ltx_creator ltx_role_author">
<span class="ltx_personname">Harsh Bimal Desai
</span><span class="ltx_author_notes">
<span class="ltx_contact ltx_role_affiliation"><span id="id2.1.id1" class="ltx_text ltx_affiliation_institution">The University of Texas at Dallas</span><span id="id3.2.id2" class="ltx_text ltx_affiliation_city">Richardson</span><span id="id4.3.id3" class="ltx_text ltx_affiliation_state">Texas</span><span id="id5.4.id4" class="ltx_text ltx_affiliation_country">USA</span>
</span>
<span class="ltx_contact ltx_role_email"><a href="mailto:hbd140030@utdallas.edu">hbd140030@utdallas.edu</a>
</span></span></span>
<span class="ltx_author_before">, </span><span class="ltx_creator ltx_role_author">
<span class="ltx_personname">Mustafa Safa Ozdayi
</span><span class="ltx_author_notes">
<span class="ltx_contact ltx_role_affiliation"><span id="id6.1.id1" class="ltx_text ltx_affiliation_institution">The University of Texas at Dallas</span><span id="id7.2.id2" class="ltx_text ltx_affiliation_city">Richardson</span><span id="id8.3.id3" class="ltx_text ltx_affiliation_state">Texas</span><span id="id9.4.id4" class="ltx_text ltx_affiliation_country">USA</span>
</span>
<span class="ltx_contact ltx_role_email"><a href="mailto:mustafa.ozdayi@utdallas.edu">mustafa.ozdayi@utdallas.edu</a>
</span></span></span>
<span class="ltx_author_before"> and </span><span class="ltx_creator ltx_role_author">
<span class="ltx_personname">Murat Kantarcioglu
</span><span class="ltx_author_notes">
<span class="ltx_contact ltx_role_affiliation"><span id="id10.1.id1" class="ltx_text ltx_affiliation_institution">The University of Texas at Dallas</span><span id="id11.2.id2" class="ltx_text ltx_affiliation_city">Richardson</span><span id="id12.3.id3" class="ltx_text ltx_affiliation_state">Texas</span><span id="id13.4.id4" class="ltx_text ltx_affiliation_country">USA</span>
</span>
<span class="ltx_contact ltx_role_email"><a href="mailto:muratk@utdallas.edu">muratk@utdallas.edu</a>
</span></span></span>
</div>

<div class="ltx_abstract">
<h6 class="ltx_title ltx_title_abstract">Abstract.</h6>
<p id="id14.id1" class="ltx_p">Federated Learning (FL) is a distributed, and decentralized machine learning protocol. By executing FL, a set of agents can jointly train a model without sharing their datasets with each other, or a third-party. This makes FL particularly suitable for settings where data privacy is desired.</p>
<p id="id15.id2" class="ltx_p">At the same time, concealing training data gives attackers an opportunity to inject backdoors into the trained model. It has been shown that an attacker can inject backdoors to the trained model during FL, and then can leverage the backdoor to make the model misclassify later. Several works tried to alleviate this threat by designing robust aggregation functions. However, given more sophisticated attacks are developed over time, which by-pass the existing defenses, we approach this problem from a complementary angle in this work. Particularly, we aim to discourage backdoor attacks by detecting, and punishing the attackers, possibly after the end of training phase.</p>
<p id="id16.id3" class="ltx_p">To this end, we develop a hybrid blockchain-based FL framework that uses smart contracts to automatically detect, and punish the attackers via monetary penalties. Our framework is general in the sense that, any aggregation function, and any attacker detection algorithm can be plugged into it. We conduct experiments to demonstrate that our framework preserves the communication-efficient nature of FL, and provide empirical results to illustrate that it can successfully penalize attackers by leveraging our novel attacker detection algorithm.</p>
</div>
<div class="ltx_keywords">Hybrid Blockchain, Hyperledger, Ethereum, Machine Learning, Backdoor attacks, Federated Learning, Federated Averaging
</div>
<span id="id1" class="ltx_note ltx_note_frontmatter ltx_role_ccs"><sup class="ltx_note_mark">†</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">†</sup><span class="ltx_note_type">ccs: </span>Computer systems organization Peer-to-peer architectures</span></span></span><span id="id2" class="ltx_note ltx_note_frontmatter ltx_role_ccs"><sup class="ltx_note_mark">†</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">†</sup><span class="ltx_note_type">ccs: </span>Security and privacy Malware and its mitigation</span></span></span><span id="id3" class="ltx_note ltx_note_frontmatter ltx_role_ccs"><sup class="ltx_note_mark">†</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">†</sup><span class="ltx_note_type">ccs: </span>Computing methodologies Supervised learning</span></span></span>
<section id="S1" class="ltx_section">
<h2 class="ltx_title ltx_title_section">
<span class="ltx_tag ltx_tag_section">1. </span>Introduction</h2>

<div id="S1.p1" class="ltx_para">
<p id="S1.p1.1" class="ltx_p">Federated Learning <cite class="ltx_cite ltx_citemacro_citep">(McMahan et al<span class="ltx_text">.</span>, <a href="#bib.bib23" title="" class="ltx_ref">2016a</a>)</cite> (FL) is a multi-round machine learning protocol that is run between an aggregation server and a set of agents. FL allows the participating agents to collaboratively train a model without sharing their data with each other, or with a third-party. At a high level, each agent first locally trains a model on his dataset, and then send his model to the server for aggregation. In return, the server aggregates the received models,
and returns the aggregated model back to agents for the next round of training. The rounds can simply go on until the trained model reaches some desired performance metric (e.g., accuracy) on a validation dataset maintained by the server. Since the data does not leave its owner, FL is particularly suitable for settings where privacy-sensitive data is involved. A vast range of organizations can collaborate on training a model via FL, and obtain a better performing model with respect to a model that is only trained on locally available data, while maintaining privacy of the data.</p>
</div>
<div id="S1.p2" class="ltx_para">
<p id="S1.p2.1" class="ltx_p">However, since the data of agents is unvetted, FL is susceptible to a wide range of attacks.
We particularly consider <em id="S1.p2.1.1" class="ltx_emph ltx_font_italic">backdoor attacks</em> <cite class="ltx_cite ltx_citemacro_citep">(Bhagoji et al<span class="ltx_text">.</span>, <a href="#bib.bib6" title="" class="ltx_ref">2019</a>; Bagdasaryan et al<span class="ltx_text">.</span>, <a href="#bib.bib4" title="" class="ltx_ref">2020</a>)</cite> in this work as they are the biggest threat for FL to the best of our knowledge. In a backdoor attack, an adversary disturbs the training process to make the model learn a <em id="S1.p2.1.2" class="ltx_emph ltx_font_italic">targeted misclassification functionality</em> <cite class="ltx_cite ltx_citemacro_citep">(Chen
et al<span class="ltx_text">.</span>, <a href="#bib.bib10" title="" class="ltx_ref">2017</a>; Shafahi et al<span class="ltx_text">.</span>, <a href="#bib.bib31" title="" class="ltx_ref">2018</a>; Liu et al<span class="ltx_text">.</span>, <a href="#bib.bib20" title="" class="ltx_ref">2018</a>)</cite>.
In centralized setting, this is typically done by <em id="S1.p2.1.3" class="ltx_emph ltx_font_italic">data poisoning</em>. For example, in a classification task involving dogs and birds, the adversary could label all blue birds in the training data as dogs in an attempt to make the model to classify blue birds as dogs at the inference/test phase. In FL, since the data is decentralized, it is unlikely that an adversary could access all the training data. Thus, backdoor attacks are typically carried through <em id="S1.p2.1.4" class="ltx_emph ltx_font_italic">model poisoning</em> in the FL context  <cite class="ltx_cite ltx_citemacro_citep">(Bhagoji et al<span class="ltx_text">.</span>, <a href="#bib.bib6" title="" class="ltx_ref">2019</a>; Bagdasaryan et al<span class="ltx_text">.</span>, <a href="#bib.bib4" title="" class="ltx_ref">2020</a>; Sun
et al<span class="ltx_text">.</span>, <a href="#bib.bib33" title="" class="ltx_ref">2019</a>)</cite>. That is, the adversary tries to constructs an update that encodes the backdoor in a way such that, when it is aggregated with other agents’ updates, the aggregated model exhibits the backdoor.</p>
</div>
<div id="S1.p3" class="ltx_para">
<p id="S1.p3.1" class="ltx_p">Several works try to prevent such attacks by designing robust aggregation functions <cite class="ltx_cite ltx_citemacro_citep">(Yin
et al<span class="ltx_text">.</span>, <a href="#bib.bib35" title="" class="ltx_ref">2018</a>; Pillutla
et al<span class="ltx_text">.</span>, <a href="#bib.bib28" title="" class="ltx_ref">2019</a>; Blanchard et al<span class="ltx_text">.</span>, <a href="#bib.bib7" title="" class="ltx_ref">2017</a>; Mhamdi
et al<span class="ltx_text">.</span>, <a href="#bib.bib24" title="" class="ltx_ref">2018</a>; Ozdayi
et al<span class="ltx_text">.</span>, <a href="#bib.bib27" title="" class="ltx_ref">2020</a>; Sun
et al<span class="ltx_text">.</span>, <a href="#bib.bib33" title="" class="ltx_ref">2019</a>; Fung
et al<span class="ltx_text">.</span>, <a href="#bib.bib12" title="" class="ltx_ref">2020</a>; Bernstein et al<span class="ltx_text">.</span>, <a href="#bib.bib5" title="" class="ltx_ref">2018</a>)</cite>.
In our work, we approach this problem from a complementary angle, considering the fact that some of the proposed defenses are broken <cite class="ltx_cite ltx_citemacro_citep">(Bhagoji et al<span class="ltx_text">.</span>, <a href="#bib.bib6" title="" class="ltx_ref">2019</a>; Bagdasaryan et al<span class="ltx_text">.</span>, <a href="#bib.bib4" title="" class="ltx_ref">2020</a>)</cite>, and there is no guarantee that existing defenses will succeed in defending against any type of adversary. Concretely, we design a framework that incorporates <em id="S1.p3.1.1" class="ltx_emph ltx_font_italic">accountability</em> to the FL framework to discourage attackers. That is, <span id="S1.p3.1.2" class="ltx_text ltx_font_italic">even if an attack is not prevented during training, our framework allows one to detect and penalize the adversarial agents later at a time when the backdoor is found in the trained model</span>.</p>
</div>
<div id="S1.p4" class="ltx_para">
<p id="S1.p4.1" class="ltx_p">To make FL accountable, we leverage <em id="S1.p4.1.1" class="ltx_emph ltx_font_italic">blockchains</em> since they are compatible with the decentralized nature of FL, provide practical immutability, and Turing-complete computation on the logged data via smart contracts. The challenge in this context is to design a blockchain architecture with a low communication and latency overhead such that it can be seamlessly incorporated to the FL data flow. We address this problem by designing a hybrid architecture consisting of both a public, and a private blockchain. This is because latency in public blockchains is too high to run any computation intensive algorithms, and the data on the public blockchains can be accessed by anyone. On the other hand, even though private blockchains are communication efficient, and address privacy challenges by allowing sensitive data to be seen only by an approved set of participants, they do not allow for public accountability since transactions are approved by a predetermined set of users, and cannot be accessed publicly.
Thus, by combining public, and private blockchains in a novel architecture, we alleviate the weakness of each, and have an architecture that meets the needs of FL (cf. Figure <a href="#S3.F1" title="Figure 1 ‣ 3.2. On-Chain Aggregation ‣ 3. System Architecture ‣ BlockFLA: Accountable Federated Learning via Hybrid Blockchain Architecture" class="ltx_ref"><span class="ltx_text ltx_ref_tag">1</span></a> for an overview of our framework).</p>
</div>
<div id="S1.p5" class="ltx_para">
<p id="S1.p5.1" class="ltx_p">To our knowledge, this is the first work that implements FL over a hybrid blockchain architecture to discourage attacks by providing accountability, and penalty mechanisms. We also note that, our framework is general in the sense that, any aggregation method, such as FedAvg <cite class="ltx_cite ltx_citemacro_citep">(Sattler et al<span class="ltx_text">.</span>, <a href="#bib.bib30" title="" class="ltx_ref">2019</a>)</cite>, signSGD <cite class="ltx_cite ltx_citemacro_citep">(Bernstein et al<span class="ltx_text">.</span>, <a href="#bib.bib5" title="" class="ltx_ref">2018</a>)</cite>, and any attacker detection mechanism can be plugged into it.</p>
</div>
<section id="S1.SS1" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">1.1. </span>Overview of Our Contributions</h3>

<div id="S1.SS1.p1" class="ltx_para">
<p id="S1.SS1.p1.1" class="ltx_p">The key contributions of our work are as follows:</p>
<ul id="S1.I1" class="ltx_itemize">
<li id="S1.I1.i1" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">•</span> 
<div id="S1.I1.i1.p1" class="ltx_para">
<p id="S1.I1.i1.p1.1" class="ltx_p">We propose <span id="S1.I1.i1.p1.1.1" class="ltx_text ltx_font_sansserif">BlockFLA</span>: <span id="S1.I1.i1.p1.1.2" class="ltx_text ltx_font_bold">Block</span>chain-based <span id="S1.I1.i1.p1.1.3" class="ltx_text ltx_font_bold">F</span>ederated <span id="S1.I1.i1.p1.1.4" class="ltx_text ltx_font_bold">L</span>earning with <span id="S1.I1.i1.p1.1.5" class="ltx_text ltx_font_bold">A</span>ccountablity. <span id="S1.I1.i1.p1.1.6" class="ltx_text ltx_font_sansserif">BlockFLA</span> is a general FL framework that aims to deter adversarial attacks by providing accountability. <span id="S1.I1.i1.p1.1.7" class="ltx_text ltx_font_sansserif">BlockFLA</span> is general in the sense that, any aggregation function, and any attacker detection algorithm can be plugged into it.</p>
</div>
</li>
<li id="S1.I1.i2" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">•</span> 
<div id="S1.I1.i2.p1" class="ltx_para">
<p id="S1.I1.i2.p1.1" class="ltx_p">We provide a novel attacker detection algorithm for FL setting, particularly designed against pixel-pattern backdoor attacks and show its effectiveness empirically.</p>
</div>
</li>
<li id="S1.I1.i3" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">•</span> 
<div id="S1.I1.i3.p1" class="ltx_para">
<p id="S1.I1.i3.p1.1" class="ltx_p">We show extensive empirical evaluation of the <span id="S1.I1.i3.p1.1.1" class="ltx_text ltx_font_sansserif">BlockFLA</span> on different settings.</p>
</div>
</li>
<li id="S1.I1.i4" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">•</span> 
<div id="S1.I1.i4.p1" class="ltx_para">
<p id="S1.I1.i4.p1.1" class="ltx_p">We analyze the security, and privacy provided by <span id="S1.I1.i4.p1.1.1" class="ltx_text ltx_font_sansserif">BlockFLA</span> in detail.</p>
</div>
</li>
</ul>
</div>
<div id="S1.SS1.p2" class="ltx_para">
<p id="S1.SS1.p2.1" class="ltx_p">The remainder of the paper is structured as follows: In Section <a href="#S2" title="2. Background ‣ BlockFLA: Accountable Federated Learning via Hybrid Blockchain Architecture" class="ltx_ref"><span class="ltx_text ltx_ref_tag">2</span></a>,
we provide the necessary background to the reader. Section <a href="#S3" title="3. System Architecture ‣ BlockFLA: Accountable Federated Learning via Hybrid Blockchain Architecture" class="ltx_ref"><span class="ltx_text ltx_ref_tag">3</span></a> discusses the system architecture which illustrates a detailed outline of the on-chain aggregation, verification technique over the public chain, the penalty structure, log scheme and finally the trojan detection mechanism. In section <a href="#S4" title="4. Implementation ‣ BlockFLA: Accountable Federated Learning via Hybrid Blockchain Architecture" class="ltx_ref"><span class="ltx_text ltx_ref_tag">4</span></a> and section <a href="#S5" title="5. Optimization Techniques ‣ BlockFLA: Accountable Federated Learning via Hybrid Blockchain Architecture" class="ltx_ref"><span class="ltx_text ltx_ref_tag">5</span></a>, we go over our implementation and some optimization techniques used to improve the performance of the system. In section <a href="#S6" title="6. Experimental Evaluation ‣ BlockFLA: Accountable Federated Learning via Hybrid Blockchain Architecture" class="ltx_ref"><span class="ltx_text ltx_ref_tag">6</span></a> and section <a href="#S7" title="7. Security and Privacy Analysis ‣ BlockFLA: Accountable Federated Learning via Hybrid Blockchain Architecture" class="ltx_ref"><span class="ltx_text ltx_ref_tag">7</span></a> we provide experimental evaluation results and subsequently analyze the security and privacy parameters of the system. Section <a href="#S8" title="8. Related Work ‣ BlockFLA: Accountable Federated Learning via Hybrid Blockchain Architecture" class="ltx_ref"><span class="ltx_text ltx_ref_tag">8</span></a> details the comparison of the <span id="S1.SS1.p2.1.1" class="ltx_text ltx_font_sansserif">BlockFLA</span> system with other related blockchain based systems that integrate with Federated Learning. We conclude the paper with section <a href="#S9" title="9. Conclusions and Future Work ‣ BlockFLA: Accountable Federated Learning via Hybrid Blockchain Architecture" class="ltx_ref"><span class="ltx_text ltx_ref_tag">9</span></a> while providing some scope for the future work we intend to accomplish.</p>
</div>
</section>
</section>
<section id="S2" class="ltx_section">
<h2 class="ltx_title ltx_title_section">
<span class="ltx_tag ltx_tag_section">2. </span>Background</h2>

<div id="S2.p1" class="ltx_para">
<p id="S2.p1.1" class="ltx_p">In this section, we provide the necessary background to the reader.</p>
</div>
<section id="S2.SS1" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">2.1. </span>Federated Learning</h3>

<div id="S2.SS1.p1" class="ltx_para">
<p id="S2.SS1.p1.4" class="ltx_p">At a high level, FL is a multi-round machine learning protocol between an aggregation server and a set of agents, in which agents jointly train a model. Formally, participating agents try to minimize the average of their loss functions,</p>
<table id="S2.Ex1" class="ltx_equation ltx_eqn_table">

<tbody><tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math id="S2.Ex1.m1.3" class="ltx_Math" alttext="\operatorname*{arg\,min}_{w\in R^{d}}f(w)=\frac{1}{K}\sum_{k=1}^{K}f_{k}(w)," display="block"><semantics id="S2.Ex1.m1.3a"><mrow id="S2.Ex1.m1.3.3.1" xref="S2.Ex1.m1.3.3.1.1.cmml"><mrow id="S2.Ex1.m1.3.3.1.1" xref="S2.Ex1.m1.3.3.1.1.cmml"><mrow id="S2.Ex1.m1.3.3.1.1.2" xref="S2.Ex1.m1.3.3.1.1.2.cmml"><mrow id="S2.Ex1.m1.3.3.1.1.2.2" xref="S2.Ex1.m1.3.3.1.1.2.2.cmml"><munder id="S2.Ex1.m1.3.3.1.1.2.2.1" xref="S2.Ex1.m1.3.3.1.1.2.2.1.cmml"><mrow id="S2.Ex1.m1.3.3.1.1.2.2.1.2" xref="S2.Ex1.m1.3.3.1.1.2.2.1.2.cmml"><mi id="S2.Ex1.m1.3.3.1.1.2.2.1.2.2" xref="S2.Ex1.m1.3.3.1.1.2.2.1.2.2.cmml">arg</mi><mo lspace="0.170em" rspace="0em" id="S2.Ex1.m1.3.3.1.1.2.2.1.2.1" xref="S2.Ex1.m1.3.3.1.1.2.2.1.2.1.cmml">​</mo><mi id="S2.Ex1.m1.3.3.1.1.2.2.1.2.3" xref="S2.Ex1.m1.3.3.1.1.2.2.1.2.3.cmml">min</mi></mrow><mrow id="S2.Ex1.m1.3.3.1.1.2.2.1.3" xref="S2.Ex1.m1.3.3.1.1.2.2.1.3.cmml"><mi id="S2.Ex1.m1.3.3.1.1.2.2.1.3.2" xref="S2.Ex1.m1.3.3.1.1.2.2.1.3.2.cmml">w</mi><mo id="S2.Ex1.m1.3.3.1.1.2.2.1.3.1" xref="S2.Ex1.m1.3.3.1.1.2.2.1.3.1.cmml">∈</mo><msup id="S2.Ex1.m1.3.3.1.1.2.2.1.3.3" xref="S2.Ex1.m1.3.3.1.1.2.2.1.3.3.cmml"><mi id="S2.Ex1.m1.3.3.1.1.2.2.1.3.3.2" xref="S2.Ex1.m1.3.3.1.1.2.2.1.3.3.2.cmml">R</mi><mi id="S2.Ex1.m1.3.3.1.1.2.2.1.3.3.3" xref="S2.Ex1.m1.3.3.1.1.2.2.1.3.3.3.cmml">d</mi></msup></mrow></munder><mo lspace="0.167em" id="S2.Ex1.m1.3.3.1.1.2.2a" xref="S2.Ex1.m1.3.3.1.1.2.2.cmml">⁡</mo><mi id="S2.Ex1.m1.3.3.1.1.2.2.2" xref="S2.Ex1.m1.3.3.1.1.2.2.2.cmml">f</mi></mrow><mo lspace="0em" rspace="0em" id="S2.Ex1.m1.3.3.1.1.2.1" xref="S2.Ex1.m1.3.3.1.1.2.1.cmml">​</mo><mrow id="S2.Ex1.m1.3.3.1.1.2.3.2" xref="S2.Ex1.m1.3.3.1.1.2.cmml"><mo stretchy="false" id="S2.Ex1.m1.3.3.1.1.2.3.2.1" xref="S2.Ex1.m1.3.3.1.1.2.cmml">(</mo><mi id="S2.Ex1.m1.1.1" xref="S2.Ex1.m1.1.1.cmml">w</mi><mo stretchy="false" id="S2.Ex1.m1.3.3.1.1.2.3.2.2" xref="S2.Ex1.m1.3.3.1.1.2.cmml">)</mo></mrow></mrow><mo id="S2.Ex1.m1.3.3.1.1.1" xref="S2.Ex1.m1.3.3.1.1.1.cmml">=</mo><mrow id="S2.Ex1.m1.3.3.1.1.3" xref="S2.Ex1.m1.3.3.1.1.3.cmml"><mfrac id="S2.Ex1.m1.3.3.1.1.3.2" xref="S2.Ex1.m1.3.3.1.1.3.2.cmml"><mn id="S2.Ex1.m1.3.3.1.1.3.2.2" xref="S2.Ex1.m1.3.3.1.1.3.2.2.cmml">1</mn><mi id="S2.Ex1.m1.3.3.1.1.3.2.3" xref="S2.Ex1.m1.3.3.1.1.3.2.3.cmml">K</mi></mfrac><mo lspace="0em" rspace="0em" id="S2.Ex1.m1.3.3.1.1.3.1" xref="S2.Ex1.m1.3.3.1.1.3.1.cmml">​</mo><mrow id="S2.Ex1.m1.3.3.1.1.3.3" xref="S2.Ex1.m1.3.3.1.1.3.3.cmml"><munderover id="S2.Ex1.m1.3.3.1.1.3.3.1" xref="S2.Ex1.m1.3.3.1.1.3.3.1.cmml"><mo movablelimits="false" id="S2.Ex1.m1.3.3.1.1.3.3.1.2.2" xref="S2.Ex1.m1.3.3.1.1.3.3.1.2.2.cmml">∑</mo><mrow id="S2.Ex1.m1.3.3.1.1.3.3.1.2.3" xref="S2.Ex1.m1.3.3.1.1.3.3.1.2.3.cmml"><mi id="S2.Ex1.m1.3.3.1.1.3.3.1.2.3.2" xref="S2.Ex1.m1.3.3.1.1.3.3.1.2.3.2.cmml">k</mi><mo id="S2.Ex1.m1.3.3.1.1.3.3.1.2.3.1" xref="S2.Ex1.m1.3.3.1.1.3.3.1.2.3.1.cmml">=</mo><mn id="S2.Ex1.m1.3.3.1.1.3.3.1.2.3.3" xref="S2.Ex1.m1.3.3.1.1.3.3.1.2.3.3.cmml">1</mn></mrow><mi id="S2.Ex1.m1.3.3.1.1.3.3.1.3" xref="S2.Ex1.m1.3.3.1.1.3.3.1.3.cmml">K</mi></munderover><mrow id="S2.Ex1.m1.3.3.1.1.3.3.2" xref="S2.Ex1.m1.3.3.1.1.3.3.2.cmml"><msub id="S2.Ex1.m1.3.3.1.1.3.3.2.2" xref="S2.Ex1.m1.3.3.1.1.3.3.2.2.cmml"><mi id="S2.Ex1.m1.3.3.1.1.3.3.2.2.2" xref="S2.Ex1.m1.3.3.1.1.3.3.2.2.2.cmml">f</mi><mi id="S2.Ex1.m1.3.3.1.1.3.3.2.2.3" xref="S2.Ex1.m1.3.3.1.1.3.3.2.2.3.cmml">k</mi></msub><mo lspace="0em" rspace="0em" id="S2.Ex1.m1.3.3.1.1.3.3.2.1" xref="S2.Ex1.m1.3.3.1.1.3.3.2.1.cmml">​</mo><mrow id="S2.Ex1.m1.3.3.1.1.3.3.2.3.2" xref="S2.Ex1.m1.3.3.1.1.3.3.2.cmml"><mo stretchy="false" id="S2.Ex1.m1.3.3.1.1.3.3.2.3.2.1" xref="S2.Ex1.m1.3.3.1.1.3.3.2.cmml">(</mo><mi id="S2.Ex1.m1.2.2" xref="S2.Ex1.m1.2.2.cmml">w</mi><mo stretchy="false" id="S2.Ex1.m1.3.3.1.1.3.3.2.3.2.2" xref="S2.Ex1.m1.3.3.1.1.3.3.2.cmml">)</mo></mrow></mrow></mrow></mrow></mrow><mo id="S2.Ex1.m1.3.3.1.2" xref="S2.Ex1.m1.3.3.1.1.cmml">,</mo></mrow><annotation-xml encoding="MathML-Content" id="S2.Ex1.m1.3b"><apply id="S2.Ex1.m1.3.3.1.1.cmml" xref="S2.Ex1.m1.3.3.1"><eq id="S2.Ex1.m1.3.3.1.1.1.cmml" xref="S2.Ex1.m1.3.3.1.1.1"></eq><apply id="S2.Ex1.m1.3.3.1.1.2.cmml" xref="S2.Ex1.m1.3.3.1.1.2"><times id="S2.Ex1.m1.3.3.1.1.2.1.cmml" xref="S2.Ex1.m1.3.3.1.1.2.1"></times><apply id="S2.Ex1.m1.3.3.1.1.2.2.cmml" xref="S2.Ex1.m1.3.3.1.1.2.2"><apply id="S2.Ex1.m1.3.3.1.1.2.2.1.cmml" xref="S2.Ex1.m1.3.3.1.1.2.2.1"><csymbol cd="ambiguous" id="S2.Ex1.m1.3.3.1.1.2.2.1.1.cmml" xref="S2.Ex1.m1.3.3.1.1.2.2.1">subscript</csymbol><apply id="S2.Ex1.m1.3.3.1.1.2.2.1.2.cmml" xref="S2.Ex1.m1.3.3.1.1.2.2.1.2"><times id="S2.Ex1.m1.3.3.1.1.2.2.1.2.1.cmml" xref="S2.Ex1.m1.3.3.1.1.2.2.1.2.1"></times><ci id="S2.Ex1.m1.3.3.1.1.2.2.1.2.2.cmml" xref="S2.Ex1.m1.3.3.1.1.2.2.1.2.2">arg</ci><ci id="S2.Ex1.m1.3.3.1.1.2.2.1.2.3.cmml" xref="S2.Ex1.m1.3.3.1.1.2.2.1.2.3">min</ci></apply><apply id="S2.Ex1.m1.3.3.1.1.2.2.1.3.cmml" xref="S2.Ex1.m1.3.3.1.1.2.2.1.3"><in id="S2.Ex1.m1.3.3.1.1.2.2.1.3.1.cmml" xref="S2.Ex1.m1.3.3.1.1.2.2.1.3.1"></in><ci id="S2.Ex1.m1.3.3.1.1.2.2.1.3.2.cmml" xref="S2.Ex1.m1.3.3.1.1.2.2.1.3.2">𝑤</ci><apply id="S2.Ex1.m1.3.3.1.1.2.2.1.3.3.cmml" xref="S2.Ex1.m1.3.3.1.1.2.2.1.3.3"><csymbol cd="ambiguous" id="S2.Ex1.m1.3.3.1.1.2.2.1.3.3.1.cmml" xref="S2.Ex1.m1.3.3.1.1.2.2.1.3.3">superscript</csymbol><ci id="S2.Ex1.m1.3.3.1.1.2.2.1.3.3.2.cmml" xref="S2.Ex1.m1.3.3.1.1.2.2.1.3.3.2">𝑅</ci><ci id="S2.Ex1.m1.3.3.1.1.2.2.1.3.3.3.cmml" xref="S2.Ex1.m1.3.3.1.1.2.2.1.3.3.3">𝑑</ci></apply></apply></apply><ci id="S2.Ex1.m1.3.3.1.1.2.2.2.cmml" xref="S2.Ex1.m1.3.3.1.1.2.2.2">𝑓</ci></apply><ci id="S2.Ex1.m1.1.1.cmml" xref="S2.Ex1.m1.1.1">𝑤</ci></apply><apply id="S2.Ex1.m1.3.3.1.1.3.cmml" xref="S2.Ex1.m1.3.3.1.1.3"><times id="S2.Ex1.m1.3.3.1.1.3.1.cmml" xref="S2.Ex1.m1.3.3.1.1.3.1"></times><apply id="S2.Ex1.m1.3.3.1.1.3.2.cmml" xref="S2.Ex1.m1.3.3.1.1.3.2"><divide id="S2.Ex1.m1.3.3.1.1.3.2.1.cmml" xref="S2.Ex1.m1.3.3.1.1.3.2"></divide><cn type="integer" id="S2.Ex1.m1.3.3.1.1.3.2.2.cmml" xref="S2.Ex1.m1.3.3.1.1.3.2.2">1</cn><ci id="S2.Ex1.m1.3.3.1.1.3.2.3.cmml" xref="S2.Ex1.m1.3.3.1.1.3.2.3">𝐾</ci></apply><apply id="S2.Ex1.m1.3.3.1.1.3.3.cmml" xref="S2.Ex1.m1.3.3.1.1.3.3"><apply id="S2.Ex1.m1.3.3.1.1.3.3.1.cmml" xref="S2.Ex1.m1.3.3.1.1.3.3.1"><csymbol cd="ambiguous" id="S2.Ex1.m1.3.3.1.1.3.3.1.1.cmml" xref="S2.Ex1.m1.3.3.1.1.3.3.1">superscript</csymbol><apply id="S2.Ex1.m1.3.3.1.1.3.3.1.2.cmml" xref="S2.Ex1.m1.3.3.1.1.3.3.1"><csymbol cd="ambiguous" id="S2.Ex1.m1.3.3.1.1.3.3.1.2.1.cmml" xref="S2.Ex1.m1.3.3.1.1.3.3.1">subscript</csymbol><sum id="S2.Ex1.m1.3.3.1.1.3.3.1.2.2.cmml" xref="S2.Ex1.m1.3.3.1.1.3.3.1.2.2"></sum><apply id="S2.Ex1.m1.3.3.1.1.3.3.1.2.3.cmml" xref="S2.Ex1.m1.3.3.1.1.3.3.1.2.3"><eq id="S2.Ex1.m1.3.3.1.1.3.3.1.2.3.1.cmml" xref="S2.Ex1.m1.3.3.1.1.3.3.1.2.3.1"></eq><ci id="S2.Ex1.m1.3.3.1.1.3.3.1.2.3.2.cmml" xref="S2.Ex1.m1.3.3.1.1.3.3.1.2.3.2">𝑘</ci><cn type="integer" id="S2.Ex1.m1.3.3.1.1.3.3.1.2.3.3.cmml" xref="S2.Ex1.m1.3.3.1.1.3.3.1.2.3.3">1</cn></apply></apply><ci id="S2.Ex1.m1.3.3.1.1.3.3.1.3.cmml" xref="S2.Ex1.m1.3.3.1.1.3.3.1.3">𝐾</ci></apply><apply id="S2.Ex1.m1.3.3.1.1.3.3.2.cmml" xref="S2.Ex1.m1.3.3.1.1.3.3.2"><times id="S2.Ex1.m1.3.3.1.1.3.3.2.1.cmml" xref="S2.Ex1.m1.3.3.1.1.3.3.2.1"></times><apply id="S2.Ex1.m1.3.3.1.1.3.3.2.2.cmml" xref="S2.Ex1.m1.3.3.1.1.3.3.2.2"><csymbol cd="ambiguous" id="S2.Ex1.m1.3.3.1.1.3.3.2.2.1.cmml" xref="S2.Ex1.m1.3.3.1.1.3.3.2.2">subscript</csymbol><ci id="S2.Ex1.m1.3.3.1.1.3.3.2.2.2.cmml" xref="S2.Ex1.m1.3.3.1.1.3.3.2.2.2">𝑓</ci><ci id="S2.Ex1.m1.3.3.1.1.3.3.2.2.3.cmml" xref="S2.Ex1.m1.3.3.1.1.3.3.2.2.3">𝑘</ci></apply><ci id="S2.Ex1.m1.2.2.cmml" xref="S2.Ex1.m1.2.2">𝑤</ci></apply></apply></apply></apply></annotation-xml><annotation encoding="application/x-tex" id="S2.Ex1.m1.3c">\operatorname*{arg\,min}_{w\in R^{d}}f(w)=\frac{1}{K}\sum_{k=1}^{K}f_{k}(w),</annotation></semantics></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr></tbody>
</table>
<p id="S2.SS1.p1.3" class="ltx_p">where <math id="S2.SS1.p1.1.m1.1" class="ltx_Math" alttext="f_{k}" display="inline"><semantics id="S2.SS1.p1.1.m1.1a"><msub id="S2.SS1.p1.1.m1.1.1" xref="S2.SS1.p1.1.m1.1.1.cmml"><mi id="S2.SS1.p1.1.m1.1.1.2" xref="S2.SS1.p1.1.m1.1.1.2.cmml">f</mi><mi id="S2.SS1.p1.1.m1.1.1.3" xref="S2.SS1.p1.1.m1.1.1.3.cmml">k</mi></msub><annotation-xml encoding="MathML-Content" id="S2.SS1.p1.1.m1.1b"><apply id="S2.SS1.p1.1.m1.1.1.cmml" xref="S2.SS1.p1.1.m1.1.1"><csymbol cd="ambiguous" id="S2.SS1.p1.1.m1.1.1.1.cmml" xref="S2.SS1.p1.1.m1.1.1">subscript</csymbol><ci id="S2.SS1.p1.1.m1.1.1.2.cmml" xref="S2.SS1.p1.1.m1.1.1.2">𝑓</ci><ci id="S2.SS1.p1.1.m1.1.1.3.cmml" xref="S2.SS1.p1.1.m1.1.1.3">𝑘</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="S2.SS1.p1.1.m1.1c">f_{k}</annotation></semantics></math> is the loss function of k<sup id="S2.SS1.p1.3.1" class="ltx_sup">th</sup> agent. For example, for neural networks, <math id="S2.SS1.p1.2.m2.1" class="ltx_Math" alttext="f_{k}" display="inline"><semantics id="S2.SS1.p1.2.m2.1a"><msub id="S2.SS1.p1.2.m2.1.1" xref="S2.SS1.p1.2.m2.1.1.cmml"><mi id="S2.SS1.p1.2.m2.1.1.2" xref="S2.SS1.p1.2.m2.1.1.2.cmml">f</mi><mi id="S2.SS1.p1.2.m2.1.1.3" xref="S2.SS1.p1.2.m2.1.1.3.cmml">k</mi></msub><annotation-xml encoding="MathML-Content" id="S2.SS1.p1.2.m2.1b"><apply id="S2.SS1.p1.2.m2.1.1.cmml" xref="S2.SS1.p1.2.m2.1.1"><csymbol cd="ambiguous" id="S2.SS1.p1.2.m2.1.1.1.cmml" xref="S2.SS1.p1.2.m2.1.1">subscript</csymbol><ci id="S2.SS1.p1.2.m2.1.1.2.cmml" xref="S2.SS1.p1.2.m2.1.1.2">𝑓</ci><ci id="S2.SS1.p1.2.m2.1.1.3.cmml" xref="S2.SS1.p1.2.m2.1.1.3">𝑘</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="S2.SS1.p1.2.m2.1c">f_{k}</annotation></semantics></math> is typically empirical risk minimization under a loss function <math id="S2.SS1.p1.3.m3.1" class="ltx_Math" alttext="L" display="inline"><semantics id="S2.SS1.p1.3.m3.1a"><mi id="S2.SS1.p1.3.m3.1.1" xref="S2.SS1.p1.3.m3.1.1.cmml">L</mi><annotation-xml encoding="MathML-Content" id="S2.SS1.p1.3.m3.1b"><ci id="S2.SS1.p1.3.m3.1.1.cmml" xref="S2.SS1.p1.3.m3.1.1">𝐿</ci></annotation-xml><annotation encoding="application/x-tex" id="S2.SS1.p1.3.m3.1c">L</annotation></semantics></math> such as cross-entropy, i.e.,</p>
</div>
<div id="S2.SS1.p2" class="ltx_para">
<table id="S2.Ex2" class="ltx_equation ltx_eqn_table">

<tbody><tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math id="S2.Ex2.m1.3" class="ltx_Math" alttext="f_{k}(w)=\frac{1}{n_{k}}\sum_{j=1}^{n_{k}}L(x_{j},y_{j};w)," display="block"><semantics id="S2.Ex2.m1.3a"><mrow id="S2.Ex2.m1.3.3.1" xref="S2.Ex2.m1.3.3.1.1.cmml"><mrow id="S2.Ex2.m1.3.3.1.1" xref="S2.Ex2.m1.3.3.1.1.cmml"><mrow id="S2.Ex2.m1.3.3.1.1.4" xref="S2.Ex2.m1.3.3.1.1.4.cmml"><msub id="S2.Ex2.m1.3.3.1.1.4.2" xref="S2.Ex2.m1.3.3.1.1.4.2.cmml"><mi id="S2.Ex2.m1.3.3.1.1.4.2.2" xref="S2.Ex2.m1.3.3.1.1.4.2.2.cmml">f</mi><mi id="S2.Ex2.m1.3.3.1.1.4.2.3" xref="S2.Ex2.m1.3.3.1.1.4.2.3.cmml">k</mi></msub><mo lspace="0em" rspace="0em" id="S2.Ex2.m1.3.3.1.1.4.1" xref="S2.Ex2.m1.3.3.1.1.4.1.cmml">​</mo><mrow id="S2.Ex2.m1.3.3.1.1.4.3.2" xref="S2.Ex2.m1.3.3.1.1.4.cmml"><mo stretchy="false" id="S2.Ex2.m1.3.3.1.1.4.3.2.1" xref="S2.Ex2.m1.3.3.1.1.4.cmml">(</mo><mi id="S2.Ex2.m1.1.1" xref="S2.Ex2.m1.1.1.cmml">w</mi><mo stretchy="false" id="S2.Ex2.m1.3.3.1.1.4.3.2.2" xref="S2.Ex2.m1.3.3.1.1.4.cmml">)</mo></mrow></mrow><mo id="S2.Ex2.m1.3.3.1.1.3" xref="S2.Ex2.m1.3.3.1.1.3.cmml">=</mo><mrow id="S2.Ex2.m1.3.3.1.1.2" xref="S2.Ex2.m1.3.3.1.1.2.cmml"><mfrac id="S2.Ex2.m1.3.3.1.1.2.4" xref="S2.Ex2.m1.3.3.1.1.2.4.cmml"><mn id="S2.Ex2.m1.3.3.1.1.2.4.2" xref="S2.Ex2.m1.3.3.1.1.2.4.2.cmml">1</mn><msub id="S2.Ex2.m1.3.3.1.1.2.4.3" xref="S2.Ex2.m1.3.3.1.1.2.4.3.cmml"><mi id="S2.Ex2.m1.3.3.1.1.2.4.3.2" xref="S2.Ex2.m1.3.3.1.1.2.4.3.2.cmml">n</mi><mi id="S2.Ex2.m1.3.3.1.1.2.4.3.3" xref="S2.Ex2.m1.3.3.1.1.2.4.3.3.cmml">k</mi></msub></mfrac><mo lspace="0em" rspace="0em" id="S2.Ex2.m1.3.3.1.1.2.3" xref="S2.Ex2.m1.3.3.1.1.2.3.cmml">​</mo><mrow id="S2.Ex2.m1.3.3.1.1.2.2" xref="S2.Ex2.m1.3.3.1.1.2.2.cmml"><munderover id="S2.Ex2.m1.3.3.1.1.2.2.3" xref="S2.Ex2.m1.3.3.1.1.2.2.3.cmml"><mo movablelimits="false" id="S2.Ex2.m1.3.3.1.1.2.2.3.2.2" xref="S2.Ex2.m1.3.3.1.1.2.2.3.2.2.cmml">∑</mo><mrow id="S2.Ex2.m1.3.3.1.1.2.2.3.2.3" xref="S2.Ex2.m1.3.3.1.1.2.2.3.2.3.cmml"><mi id="S2.Ex2.m1.3.3.1.1.2.2.3.2.3.2" xref="S2.Ex2.m1.3.3.1.1.2.2.3.2.3.2.cmml">j</mi><mo id="S2.Ex2.m1.3.3.1.1.2.2.3.2.3.1" xref="S2.Ex2.m1.3.3.1.1.2.2.3.2.3.1.cmml">=</mo><mn id="S2.Ex2.m1.3.3.1.1.2.2.3.2.3.3" xref="S2.Ex2.m1.3.3.1.1.2.2.3.2.3.3.cmml">1</mn></mrow><msub id="S2.Ex2.m1.3.3.1.1.2.2.3.3" xref="S2.Ex2.m1.3.3.1.1.2.2.3.3.cmml"><mi id="S2.Ex2.m1.3.3.1.1.2.2.3.3.2" xref="S2.Ex2.m1.3.3.1.1.2.2.3.3.2.cmml">n</mi><mi id="S2.Ex2.m1.3.3.1.1.2.2.3.3.3" xref="S2.Ex2.m1.3.3.1.1.2.2.3.3.3.cmml">k</mi></msub></munderover><mrow id="S2.Ex2.m1.3.3.1.1.2.2.2" xref="S2.Ex2.m1.3.3.1.1.2.2.2.cmml"><mi id="S2.Ex2.m1.3.3.1.1.2.2.2.4" xref="S2.Ex2.m1.3.3.1.1.2.2.2.4.cmml">L</mi><mo lspace="0em" rspace="0em" id="S2.Ex2.m1.3.3.1.1.2.2.2.3" xref="S2.Ex2.m1.3.3.1.1.2.2.2.3.cmml">​</mo><mrow id="S2.Ex2.m1.3.3.1.1.2.2.2.2.2" xref="S2.Ex2.m1.3.3.1.1.2.2.2.2.3.cmml"><mo stretchy="false" id="S2.Ex2.m1.3.3.1.1.2.2.2.2.2.3" xref="S2.Ex2.m1.3.3.1.1.2.2.2.2.3.cmml">(</mo><msub id="S2.Ex2.m1.3.3.1.1.1.1.1.1.1.1" xref="S2.Ex2.m1.3.3.1.1.1.1.1.1.1.1.cmml"><mi id="S2.Ex2.m1.3.3.1.1.1.1.1.1.1.1.2" xref="S2.Ex2.m1.3.3.1.1.1.1.1.1.1.1.2.cmml">x</mi><mi id="S2.Ex2.m1.3.3.1.1.1.1.1.1.1.1.3" xref="S2.Ex2.m1.3.3.1.1.1.1.1.1.1.1.3.cmml">j</mi></msub><mo id="S2.Ex2.m1.3.3.1.1.2.2.2.2.2.4" xref="S2.Ex2.m1.3.3.1.1.2.2.2.2.3.cmml">,</mo><msub id="S2.Ex2.m1.3.3.1.1.2.2.2.2.2.2" xref="S2.Ex2.m1.3.3.1.1.2.2.2.2.2.2.cmml"><mi id="S2.Ex2.m1.3.3.1.1.2.2.2.2.2.2.2" xref="S2.Ex2.m1.3.3.1.1.2.2.2.2.2.2.2.cmml">y</mi><mi id="S2.Ex2.m1.3.3.1.1.2.2.2.2.2.2.3" xref="S2.Ex2.m1.3.3.1.1.2.2.2.2.2.2.3.cmml">j</mi></msub><mo id="S2.Ex2.m1.3.3.1.1.2.2.2.2.2.5" xref="S2.Ex2.m1.3.3.1.1.2.2.2.2.3.cmml">;</mo><mi id="S2.Ex2.m1.2.2" xref="S2.Ex2.m1.2.2.cmml">w</mi><mo stretchy="false" id="S2.Ex2.m1.3.3.1.1.2.2.2.2.2.6" xref="S2.Ex2.m1.3.3.1.1.2.2.2.2.3.cmml">)</mo></mrow></mrow></mrow></mrow></mrow><mo id="S2.Ex2.m1.3.3.1.2" xref="S2.Ex2.m1.3.3.1.1.cmml">,</mo></mrow><annotation-xml encoding="MathML-Content" id="S2.Ex2.m1.3b"><apply id="S2.Ex2.m1.3.3.1.1.cmml" xref="S2.Ex2.m1.3.3.1"><eq id="S2.Ex2.m1.3.3.1.1.3.cmml" xref="S2.Ex2.m1.3.3.1.1.3"></eq><apply id="S2.Ex2.m1.3.3.1.1.4.cmml" xref="S2.Ex2.m1.3.3.1.1.4"><times id="S2.Ex2.m1.3.3.1.1.4.1.cmml" xref="S2.Ex2.m1.3.3.1.1.4.1"></times><apply id="S2.Ex2.m1.3.3.1.1.4.2.cmml" xref="S2.Ex2.m1.3.3.1.1.4.2"><csymbol cd="ambiguous" id="S2.Ex2.m1.3.3.1.1.4.2.1.cmml" xref="S2.Ex2.m1.3.3.1.1.4.2">subscript</csymbol><ci id="S2.Ex2.m1.3.3.1.1.4.2.2.cmml" xref="S2.Ex2.m1.3.3.1.1.4.2.2">𝑓</ci><ci id="S2.Ex2.m1.3.3.1.1.4.2.3.cmml" xref="S2.Ex2.m1.3.3.1.1.4.2.3">𝑘</ci></apply><ci id="S2.Ex2.m1.1.1.cmml" xref="S2.Ex2.m1.1.1">𝑤</ci></apply><apply id="S2.Ex2.m1.3.3.1.1.2.cmml" xref="S2.Ex2.m1.3.3.1.1.2"><times id="S2.Ex2.m1.3.3.1.1.2.3.cmml" xref="S2.Ex2.m1.3.3.1.1.2.3"></times><apply id="S2.Ex2.m1.3.3.1.1.2.4.cmml" xref="S2.Ex2.m1.3.3.1.1.2.4"><divide id="S2.Ex2.m1.3.3.1.1.2.4.1.cmml" xref="S2.Ex2.m1.3.3.1.1.2.4"></divide><cn type="integer" id="S2.Ex2.m1.3.3.1.1.2.4.2.cmml" xref="S2.Ex2.m1.3.3.1.1.2.4.2">1</cn><apply id="S2.Ex2.m1.3.3.1.1.2.4.3.cmml" xref="S2.Ex2.m1.3.3.1.1.2.4.3"><csymbol cd="ambiguous" id="S2.Ex2.m1.3.3.1.1.2.4.3.1.cmml" xref="S2.Ex2.m1.3.3.1.1.2.4.3">subscript</csymbol><ci id="S2.Ex2.m1.3.3.1.1.2.4.3.2.cmml" xref="S2.Ex2.m1.3.3.1.1.2.4.3.2">𝑛</ci><ci id="S2.Ex2.m1.3.3.1.1.2.4.3.3.cmml" xref="S2.Ex2.m1.3.3.1.1.2.4.3.3">𝑘</ci></apply></apply><apply id="S2.Ex2.m1.3.3.1.1.2.2.cmml" xref="S2.Ex2.m1.3.3.1.1.2.2"><apply id="S2.Ex2.m1.3.3.1.1.2.2.3.cmml" xref="S2.Ex2.m1.3.3.1.1.2.2.3"><csymbol cd="ambiguous" id="S2.Ex2.m1.3.3.1.1.2.2.3.1.cmml" xref="S2.Ex2.m1.3.3.1.1.2.2.3">superscript</csymbol><apply id="S2.Ex2.m1.3.3.1.1.2.2.3.2.cmml" xref="S2.Ex2.m1.3.3.1.1.2.2.3"><csymbol cd="ambiguous" id="S2.Ex2.m1.3.3.1.1.2.2.3.2.1.cmml" xref="S2.Ex2.m1.3.3.1.1.2.2.3">subscript</csymbol><sum id="S2.Ex2.m1.3.3.1.1.2.2.3.2.2.cmml" xref="S2.Ex2.m1.3.3.1.1.2.2.3.2.2"></sum><apply id="S2.Ex2.m1.3.3.1.1.2.2.3.2.3.cmml" xref="S2.Ex2.m1.3.3.1.1.2.2.3.2.3"><eq id="S2.Ex2.m1.3.3.1.1.2.2.3.2.3.1.cmml" xref="S2.Ex2.m1.3.3.1.1.2.2.3.2.3.1"></eq><ci id="S2.Ex2.m1.3.3.1.1.2.2.3.2.3.2.cmml" xref="S2.Ex2.m1.3.3.1.1.2.2.3.2.3.2">𝑗</ci><cn type="integer" id="S2.Ex2.m1.3.3.1.1.2.2.3.2.3.3.cmml" xref="S2.Ex2.m1.3.3.1.1.2.2.3.2.3.3">1</cn></apply></apply><apply id="S2.Ex2.m1.3.3.1.1.2.2.3.3.cmml" xref="S2.Ex2.m1.3.3.1.1.2.2.3.3"><csymbol cd="ambiguous" id="S2.Ex2.m1.3.3.1.1.2.2.3.3.1.cmml" xref="S2.Ex2.m1.3.3.1.1.2.2.3.3">subscript</csymbol><ci id="S2.Ex2.m1.3.3.1.1.2.2.3.3.2.cmml" xref="S2.Ex2.m1.3.3.1.1.2.2.3.3.2">𝑛</ci><ci id="S2.Ex2.m1.3.3.1.1.2.2.3.3.3.cmml" xref="S2.Ex2.m1.3.3.1.1.2.2.3.3.3">𝑘</ci></apply></apply><apply id="S2.Ex2.m1.3.3.1.1.2.2.2.cmml" xref="S2.Ex2.m1.3.3.1.1.2.2.2"><times id="S2.Ex2.m1.3.3.1.1.2.2.2.3.cmml" xref="S2.Ex2.m1.3.3.1.1.2.2.2.3"></times><ci id="S2.Ex2.m1.3.3.1.1.2.2.2.4.cmml" xref="S2.Ex2.m1.3.3.1.1.2.2.2.4">𝐿</ci><vector id="S2.Ex2.m1.3.3.1.1.2.2.2.2.3.cmml" xref="S2.Ex2.m1.3.3.1.1.2.2.2.2.2"><apply id="S2.Ex2.m1.3.3.1.1.1.1.1.1.1.1.cmml" xref="S2.Ex2.m1.3.3.1.1.1.1.1.1.1.1"><csymbol cd="ambiguous" id="S2.Ex2.m1.3.3.1.1.1.1.1.1.1.1.1.cmml" xref="S2.Ex2.m1.3.3.1.1.1.1.1.1.1.1">subscript</csymbol><ci id="S2.Ex2.m1.3.3.1.1.1.1.1.1.1.1.2.cmml" xref="S2.Ex2.m1.3.3.1.1.1.1.1.1.1.1.2">𝑥</ci><ci id="S2.Ex2.m1.3.3.1.1.1.1.1.1.1.1.3.cmml" xref="S2.Ex2.m1.3.3.1.1.1.1.1.1.1.1.3">𝑗</ci></apply><apply id="S2.Ex2.m1.3.3.1.1.2.2.2.2.2.2.cmml" xref="S2.Ex2.m1.3.3.1.1.2.2.2.2.2.2"><csymbol cd="ambiguous" id="S2.Ex2.m1.3.3.1.1.2.2.2.2.2.2.1.cmml" xref="S2.Ex2.m1.3.3.1.1.2.2.2.2.2.2">subscript</csymbol><ci id="S2.Ex2.m1.3.3.1.1.2.2.2.2.2.2.2.cmml" xref="S2.Ex2.m1.3.3.1.1.2.2.2.2.2.2.2">𝑦</ci><ci id="S2.Ex2.m1.3.3.1.1.2.2.2.2.2.2.3.cmml" xref="S2.Ex2.m1.3.3.1.1.2.2.2.2.2.2.3">𝑗</ci></apply><ci id="S2.Ex2.m1.2.2.cmml" xref="S2.Ex2.m1.2.2">𝑤</ci></vector></apply></apply></apply></apply></annotation-xml><annotation encoding="application/x-tex" id="S2.Ex2.m1.3c">f_{k}(w)=\frac{1}{n_{k}}\sum_{j=1}^{n_{k}}L(x_{j},y_{j};w),</annotation></semantics></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr></tbody>
</table>
<p id="S2.SS1.p2.2" class="ltx_p">with <math id="S2.SS1.p2.1.m1.1" class="ltx_Math" alttext="n_{k}" display="inline"><semantics id="S2.SS1.p2.1.m1.1a"><msub id="S2.SS1.p2.1.m1.1.1" xref="S2.SS1.p2.1.m1.1.1.cmml"><mi id="S2.SS1.p2.1.m1.1.1.2" xref="S2.SS1.p2.1.m1.1.1.2.cmml">n</mi><mi id="S2.SS1.p2.1.m1.1.1.3" xref="S2.SS1.p2.1.m1.1.1.3.cmml">k</mi></msub><annotation-xml encoding="MathML-Content" id="S2.SS1.p2.1.m1.1b"><apply id="S2.SS1.p2.1.m1.1.1.cmml" xref="S2.SS1.p2.1.m1.1.1"><csymbol cd="ambiguous" id="S2.SS1.p2.1.m1.1.1.1.cmml" xref="S2.SS1.p2.1.m1.1.1">subscript</csymbol><ci id="S2.SS1.p2.1.m1.1.1.2.cmml" xref="S2.SS1.p2.1.m1.1.1.2">𝑛</ci><ci id="S2.SS1.p2.1.m1.1.1.3.cmml" xref="S2.SS1.p2.1.m1.1.1.3">𝑘</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="S2.SS1.p2.1.m1.1c">n_{k}</annotation></semantics></math> being the total number of samples in agent’s dataset and <math id="S2.SS1.p2.2.m2.2" class="ltx_Math" alttext="(x_{j},y_{j})" display="inline"><semantics id="S2.SS1.p2.2.m2.2a"><mrow id="S2.SS1.p2.2.m2.2.2.2" xref="S2.SS1.p2.2.m2.2.2.3.cmml"><mo stretchy="false" id="S2.SS1.p2.2.m2.2.2.2.3" xref="S2.SS1.p2.2.m2.2.2.3.cmml">(</mo><msub id="S2.SS1.p2.2.m2.1.1.1.1" xref="S2.SS1.p2.2.m2.1.1.1.1.cmml"><mi id="S2.SS1.p2.2.m2.1.1.1.1.2" xref="S2.SS1.p2.2.m2.1.1.1.1.2.cmml">x</mi><mi id="S2.SS1.p2.2.m2.1.1.1.1.3" xref="S2.SS1.p2.2.m2.1.1.1.1.3.cmml">j</mi></msub><mo id="S2.SS1.p2.2.m2.2.2.2.4" xref="S2.SS1.p2.2.m2.2.2.3.cmml">,</mo><msub id="S2.SS1.p2.2.m2.2.2.2.2" xref="S2.SS1.p2.2.m2.2.2.2.2.cmml"><mi id="S2.SS1.p2.2.m2.2.2.2.2.2" xref="S2.SS1.p2.2.m2.2.2.2.2.2.cmml">y</mi><mi id="S2.SS1.p2.2.m2.2.2.2.2.3" xref="S2.SS1.p2.2.m2.2.2.2.2.3.cmml">j</mi></msub><mo stretchy="false" id="S2.SS1.p2.2.m2.2.2.2.5" xref="S2.SS1.p2.2.m2.2.2.3.cmml">)</mo></mrow><annotation-xml encoding="MathML-Content" id="S2.SS1.p2.2.m2.2b"><interval closure="open" id="S2.SS1.p2.2.m2.2.2.3.cmml" xref="S2.SS1.p2.2.m2.2.2.2"><apply id="S2.SS1.p2.2.m2.1.1.1.1.cmml" xref="S2.SS1.p2.2.m2.1.1.1.1"><csymbol cd="ambiguous" id="S2.SS1.p2.2.m2.1.1.1.1.1.cmml" xref="S2.SS1.p2.2.m2.1.1.1.1">subscript</csymbol><ci id="S2.SS1.p2.2.m2.1.1.1.1.2.cmml" xref="S2.SS1.p2.2.m2.1.1.1.1.2">𝑥</ci><ci id="S2.SS1.p2.2.m2.1.1.1.1.3.cmml" xref="S2.SS1.p2.2.m2.1.1.1.1.3">𝑗</ci></apply><apply id="S2.SS1.p2.2.m2.2.2.2.2.cmml" xref="S2.SS1.p2.2.m2.2.2.2.2"><csymbol cd="ambiguous" id="S2.SS1.p2.2.m2.2.2.2.2.1.cmml" xref="S2.SS1.p2.2.m2.2.2.2.2">subscript</csymbol><ci id="S2.SS1.p2.2.m2.2.2.2.2.2.cmml" xref="S2.SS1.p2.2.m2.2.2.2.2.2">𝑦</ci><ci id="S2.SS1.p2.2.m2.2.2.2.2.3.cmml" xref="S2.SS1.p2.2.m2.2.2.2.2.3">𝑗</ci></apply></interval></annotation-xml><annotation encoding="application/x-tex" id="S2.SS1.p2.2.m2.2c">(x_{j},y_{j})</annotation></semantics></math> being the j<sup id="S2.SS1.p2.2.1" class="ltx_sup">th</sup> sample.</p>
</div>
<div id="S2.SS1.p3" class="ltx_para">
<p id="S2.SS1.p3.12" class="ltx_p">Concretely, FL protocol is executed as follows: at round <math id="S2.SS1.p3.1.m1.1" class="ltx_Math" alttext="t" display="inline"><semantics id="S2.SS1.p3.1.m1.1a"><mi id="S2.SS1.p3.1.m1.1.1" xref="S2.SS1.p3.1.m1.1.1.cmml">t</mi><annotation-xml encoding="MathML-Content" id="S2.SS1.p3.1.m1.1b"><ci id="S2.SS1.p3.1.m1.1.1.cmml" xref="S2.SS1.p3.1.m1.1.1">𝑡</ci></annotation-xml><annotation encoding="application/x-tex" id="S2.SS1.p3.1.m1.1c">t</annotation></semantics></math>, server samples a subset of agents <math id="S2.SS1.p3.2.m2.1" class="ltx_Math" alttext="S_{t}" display="inline"><semantics id="S2.SS1.p3.2.m2.1a"><msub id="S2.SS1.p3.2.m2.1.1" xref="S2.SS1.p3.2.m2.1.1.cmml"><mi id="S2.SS1.p3.2.m2.1.1.2" xref="S2.SS1.p3.2.m2.1.1.2.cmml">S</mi><mi id="S2.SS1.p3.2.m2.1.1.3" xref="S2.SS1.p3.2.m2.1.1.3.cmml">t</mi></msub><annotation-xml encoding="MathML-Content" id="S2.SS1.p3.2.m2.1b"><apply id="S2.SS1.p3.2.m2.1.1.cmml" xref="S2.SS1.p3.2.m2.1.1"><csymbol cd="ambiguous" id="S2.SS1.p3.2.m2.1.1.1.cmml" xref="S2.SS1.p3.2.m2.1.1">subscript</csymbol><ci id="S2.SS1.p3.2.m2.1.1.2.cmml" xref="S2.SS1.p3.2.m2.1.1.2">𝑆</ci><ci id="S2.SS1.p3.2.m2.1.1.3.cmml" xref="S2.SS1.p3.2.m2.1.1.3">𝑡</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="S2.SS1.p3.2.m2.1c">S_{t}</annotation></semantics></math>, and sends them <math id="S2.SS1.p3.3.m3.1" class="ltx_Math" alttext="w_{t}" display="inline"><semantics id="S2.SS1.p3.3.m3.1a"><msub id="S2.SS1.p3.3.m3.1.1" xref="S2.SS1.p3.3.m3.1.1.cmml"><mi id="S2.SS1.p3.3.m3.1.1.2" xref="S2.SS1.p3.3.m3.1.1.2.cmml">w</mi><mi id="S2.SS1.p3.3.m3.1.1.3" xref="S2.SS1.p3.3.m3.1.1.3.cmml">t</mi></msub><annotation-xml encoding="MathML-Content" id="S2.SS1.p3.3.m3.1b"><apply id="S2.SS1.p3.3.m3.1.1.cmml" xref="S2.SS1.p3.3.m3.1.1"><csymbol cd="ambiguous" id="S2.SS1.p3.3.m3.1.1.1.cmml" xref="S2.SS1.p3.3.m3.1.1">subscript</csymbol><ci id="S2.SS1.p3.3.m3.1.1.2.cmml" xref="S2.SS1.p3.3.m3.1.1.2">𝑤</ci><ci id="S2.SS1.p3.3.m3.1.1.3.cmml" xref="S2.SS1.p3.3.m3.1.1.3">𝑡</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="S2.SS1.p3.3.m3.1c">w_{t}</annotation></semantics></math>, the model weights for the current round. Upon receiving <math id="S2.SS1.p3.4.m4.1" class="ltx_Math" alttext="w_{t}" display="inline"><semantics id="S2.SS1.p3.4.m4.1a"><msub id="S2.SS1.p3.4.m4.1.1" xref="S2.SS1.p3.4.m4.1.1.cmml"><mi id="S2.SS1.p3.4.m4.1.1.2" xref="S2.SS1.p3.4.m4.1.1.2.cmml">w</mi><mi id="S2.SS1.p3.4.m4.1.1.3" xref="S2.SS1.p3.4.m4.1.1.3.cmml">t</mi></msub><annotation-xml encoding="MathML-Content" id="S2.SS1.p3.4.m4.1b"><apply id="S2.SS1.p3.4.m4.1.1.cmml" xref="S2.SS1.p3.4.m4.1.1"><csymbol cd="ambiguous" id="S2.SS1.p3.4.m4.1.1.1.cmml" xref="S2.SS1.p3.4.m4.1.1">subscript</csymbol><ci id="S2.SS1.p3.4.m4.1.1.2.cmml" xref="S2.SS1.p3.4.m4.1.1.2">𝑤</ci><ci id="S2.SS1.p3.4.m4.1.1.3.cmml" xref="S2.SS1.p3.4.m4.1.1.3">𝑡</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="S2.SS1.p3.4.m4.1c">w_{t}</annotation></semantics></math>, k<sup id="S2.SS1.p3.12.1" class="ltx_sup">th</sup> agent initializes his model with the received weight, and train for some number of iterations, e.g., via stochastic gradient descent (SGD), and ends up with weights <math id="S2.SS1.p3.5.m5.1" class="ltx_Math" alttext="w_{t}^{k}" display="inline"><semantics id="S2.SS1.p3.5.m5.1a"><msubsup id="S2.SS1.p3.5.m5.1.1" xref="S2.SS1.p3.5.m5.1.1.cmml"><mi id="S2.SS1.p3.5.m5.1.1.2.2" xref="S2.SS1.p3.5.m5.1.1.2.2.cmml">w</mi><mi id="S2.SS1.p3.5.m5.1.1.2.3" xref="S2.SS1.p3.5.m5.1.1.2.3.cmml">t</mi><mi id="S2.SS1.p3.5.m5.1.1.3" xref="S2.SS1.p3.5.m5.1.1.3.cmml">k</mi></msubsup><annotation-xml encoding="MathML-Content" id="S2.SS1.p3.5.m5.1b"><apply id="S2.SS1.p3.5.m5.1.1.cmml" xref="S2.SS1.p3.5.m5.1.1"><csymbol cd="ambiguous" id="S2.SS1.p3.5.m5.1.1.1.cmml" xref="S2.SS1.p3.5.m5.1.1">superscript</csymbol><apply id="S2.SS1.p3.5.m5.1.1.2.cmml" xref="S2.SS1.p3.5.m5.1.1"><csymbol cd="ambiguous" id="S2.SS1.p3.5.m5.1.1.2.1.cmml" xref="S2.SS1.p3.5.m5.1.1">subscript</csymbol><ci id="S2.SS1.p3.5.m5.1.1.2.2.cmml" xref="S2.SS1.p3.5.m5.1.1.2.2">𝑤</ci><ci id="S2.SS1.p3.5.m5.1.1.2.3.cmml" xref="S2.SS1.p3.5.m5.1.1.2.3">𝑡</ci></apply><ci id="S2.SS1.p3.5.m5.1.1.3.cmml" xref="S2.SS1.p3.5.m5.1.1.3">𝑘</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="S2.SS1.p3.5.m5.1c">w_{t}^{k}</annotation></semantics></math>. The agent then computes his update as <math id="S2.SS1.p3.6.m6.1" class="ltx_Math" alttext="\Delta_{t}^{k}=w_{t}^{k}-w_{t}" display="inline"><semantics id="S2.SS1.p3.6.m6.1a"><mrow id="S2.SS1.p3.6.m6.1.1" xref="S2.SS1.p3.6.m6.1.1.cmml"><msubsup id="S2.SS1.p3.6.m6.1.1.2" xref="S2.SS1.p3.6.m6.1.1.2.cmml"><mi mathvariant="normal" id="S2.SS1.p3.6.m6.1.1.2.2.2" xref="S2.SS1.p3.6.m6.1.1.2.2.2.cmml">Δ</mi><mi id="S2.SS1.p3.6.m6.1.1.2.2.3" xref="S2.SS1.p3.6.m6.1.1.2.2.3.cmml">t</mi><mi id="S2.SS1.p3.6.m6.1.1.2.3" xref="S2.SS1.p3.6.m6.1.1.2.3.cmml">k</mi></msubsup><mo id="S2.SS1.p3.6.m6.1.1.1" xref="S2.SS1.p3.6.m6.1.1.1.cmml">=</mo><mrow id="S2.SS1.p3.6.m6.1.1.3" xref="S2.SS1.p3.6.m6.1.1.3.cmml"><msubsup id="S2.SS1.p3.6.m6.1.1.3.2" xref="S2.SS1.p3.6.m6.1.1.3.2.cmml"><mi id="S2.SS1.p3.6.m6.1.1.3.2.2.2" xref="S2.SS1.p3.6.m6.1.1.3.2.2.2.cmml">w</mi><mi id="S2.SS1.p3.6.m6.1.1.3.2.2.3" xref="S2.SS1.p3.6.m6.1.1.3.2.2.3.cmml">t</mi><mi id="S2.SS1.p3.6.m6.1.1.3.2.3" xref="S2.SS1.p3.6.m6.1.1.3.2.3.cmml">k</mi></msubsup><mo id="S2.SS1.p3.6.m6.1.1.3.1" xref="S2.SS1.p3.6.m6.1.1.3.1.cmml">−</mo><msub id="S2.SS1.p3.6.m6.1.1.3.3" xref="S2.SS1.p3.6.m6.1.1.3.3.cmml"><mi id="S2.SS1.p3.6.m6.1.1.3.3.2" xref="S2.SS1.p3.6.m6.1.1.3.3.2.cmml">w</mi><mi id="S2.SS1.p3.6.m6.1.1.3.3.3" xref="S2.SS1.p3.6.m6.1.1.3.3.3.cmml">t</mi></msub></mrow></mrow><annotation-xml encoding="MathML-Content" id="S2.SS1.p3.6.m6.1b"><apply id="S2.SS1.p3.6.m6.1.1.cmml" xref="S2.SS1.p3.6.m6.1.1"><eq id="S2.SS1.p3.6.m6.1.1.1.cmml" xref="S2.SS1.p3.6.m6.1.1.1"></eq><apply id="S2.SS1.p3.6.m6.1.1.2.cmml" xref="S2.SS1.p3.6.m6.1.1.2"><csymbol cd="ambiguous" id="S2.SS1.p3.6.m6.1.1.2.1.cmml" xref="S2.SS1.p3.6.m6.1.1.2">superscript</csymbol><apply id="S2.SS1.p3.6.m6.1.1.2.2.cmml" xref="S2.SS1.p3.6.m6.1.1.2"><csymbol cd="ambiguous" id="S2.SS1.p3.6.m6.1.1.2.2.1.cmml" xref="S2.SS1.p3.6.m6.1.1.2">subscript</csymbol><ci id="S2.SS1.p3.6.m6.1.1.2.2.2.cmml" xref="S2.SS1.p3.6.m6.1.1.2.2.2">Δ</ci><ci id="S2.SS1.p3.6.m6.1.1.2.2.3.cmml" xref="S2.SS1.p3.6.m6.1.1.2.2.3">𝑡</ci></apply><ci id="S2.SS1.p3.6.m6.1.1.2.3.cmml" xref="S2.SS1.p3.6.m6.1.1.2.3">𝑘</ci></apply><apply id="S2.SS1.p3.6.m6.1.1.3.cmml" xref="S2.SS1.p3.6.m6.1.1.3"><minus id="S2.SS1.p3.6.m6.1.1.3.1.cmml" xref="S2.SS1.p3.6.m6.1.1.3.1"></minus><apply id="S2.SS1.p3.6.m6.1.1.3.2.cmml" xref="S2.SS1.p3.6.m6.1.1.3.2"><csymbol cd="ambiguous" id="S2.SS1.p3.6.m6.1.1.3.2.1.cmml" xref="S2.SS1.p3.6.m6.1.1.3.2">superscript</csymbol><apply id="S2.SS1.p3.6.m6.1.1.3.2.2.cmml" xref="S2.SS1.p3.6.m6.1.1.3.2"><csymbol cd="ambiguous" id="S2.SS1.p3.6.m6.1.1.3.2.2.1.cmml" xref="S2.SS1.p3.6.m6.1.1.3.2">subscript</csymbol><ci id="S2.SS1.p3.6.m6.1.1.3.2.2.2.cmml" xref="S2.SS1.p3.6.m6.1.1.3.2.2.2">𝑤</ci><ci id="S2.SS1.p3.6.m6.1.1.3.2.2.3.cmml" xref="S2.SS1.p3.6.m6.1.1.3.2.2.3">𝑡</ci></apply><ci id="S2.SS1.p3.6.m6.1.1.3.2.3.cmml" xref="S2.SS1.p3.6.m6.1.1.3.2.3">𝑘</ci></apply><apply id="S2.SS1.p3.6.m6.1.1.3.3.cmml" xref="S2.SS1.p3.6.m6.1.1.3.3"><csymbol cd="ambiguous" id="S2.SS1.p3.6.m6.1.1.3.3.1.cmml" xref="S2.SS1.p3.6.m6.1.1.3.3">subscript</csymbol><ci id="S2.SS1.p3.6.m6.1.1.3.3.2.cmml" xref="S2.SS1.p3.6.m6.1.1.3.3.2">𝑤</ci><ci id="S2.SS1.p3.6.m6.1.1.3.3.3.cmml" xref="S2.SS1.p3.6.m6.1.1.3.3.3">𝑡</ci></apply></apply></apply></annotation-xml><annotation encoding="application/x-tex" id="S2.SS1.p3.6.m6.1c">\Delta_{t}^{k}=w_{t}^{k}-w_{t}</annotation></semantics></math> and sends it back to the server. Upon receiving the update of every agent in <math id="S2.SS1.p3.7.m7.1" class="ltx_Math" alttext="S_{t}" display="inline"><semantics id="S2.SS1.p3.7.m7.1a"><msub id="S2.SS1.p3.7.m7.1.1" xref="S2.SS1.p3.7.m7.1.1.cmml"><mi id="S2.SS1.p3.7.m7.1.1.2" xref="S2.SS1.p3.7.m7.1.1.2.cmml">S</mi><mi id="S2.SS1.p3.7.m7.1.1.3" xref="S2.SS1.p3.7.m7.1.1.3.cmml">t</mi></msub><annotation-xml encoding="MathML-Content" id="S2.SS1.p3.7.m7.1b"><apply id="S2.SS1.p3.7.m7.1.1.cmml" xref="S2.SS1.p3.7.m7.1.1"><csymbol cd="ambiguous" id="S2.SS1.p3.7.m7.1.1.1.cmml" xref="S2.SS1.p3.7.m7.1.1">subscript</csymbol><ci id="S2.SS1.p3.7.m7.1.1.2.cmml" xref="S2.SS1.p3.7.m7.1.1.2">𝑆</ci><ci id="S2.SS1.p3.7.m7.1.1.3.cmml" xref="S2.SS1.p3.7.m7.1.1.3">𝑡</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="S2.SS1.p3.7.m7.1c">S_{t}</annotation></semantics></math>, server computes the weights for the next round by aggregating the updates with an aggregation function <math id="S2.SS1.p3.8.m8.1" class="ltx_Math" alttext="\mathbf{g}\colon R^{|S_{t}|\times d}\rightarrow R^{d}" display="inline"><semantics id="S2.SS1.p3.8.m8.1a"><mrow id="S2.SS1.p3.8.m8.1.2" xref="S2.SS1.p3.8.m8.1.2.cmml"><mi id="S2.SS1.p3.8.m8.1.2.2" xref="S2.SS1.p3.8.m8.1.2.2.cmml">𝐠</mi><mo lspace="0.278em" rspace="0.278em" id="S2.SS1.p3.8.m8.1.2.1" xref="S2.SS1.p3.8.m8.1.2.1.cmml">:</mo><mrow id="S2.SS1.p3.8.m8.1.2.3" xref="S2.SS1.p3.8.m8.1.2.3.cmml"><msup id="S2.SS1.p3.8.m8.1.2.3.2" xref="S2.SS1.p3.8.m8.1.2.3.2.cmml"><mi id="S2.SS1.p3.8.m8.1.2.3.2.2" xref="S2.SS1.p3.8.m8.1.2.3.2.2.cmml">R</mi><mrow id="S2.SS1.p3.8.m8.1.1.1" xref="S2.SS1.p3.8.m8.1.1.1.cmml"><mrow id="S2.SS1.p3.8.m8.1.1.1.1.1" xref="S2.SS1.p3.8.m8.1.1.1.1.2.cmml"><mo stretchy="false" id="S2.SS1.p3.8.m8.1.1.1.1.1.2" xref="S2.SS1.p3.8.m8.1.1.1.1.2.1.cmml">|</mo><msub id="S2.SS1.p3.8.m8.1.1.1.1.1.1" xref="S2.SS1.p3.8.m8.1.1.1.1.1.1.cmml"><mi id="S2.SS1.p3.8.m8.1.1.1.1.1.1.2" xref="S2.SS1.p3.8.m8.1.1.1.1.1.1.2.cmml">S</mi><mi id="S2.SS1.p3.8.m8.1.1.1.1.1.1.3" xref="S2.SS1.p3.8.m8.1.1.1.1.1.1.3.cmml">t</mi></msub><mo rspace="0.055em" stretchy="false" id="S2.SS1.p3.8.m8.1.1.1.1.1.3" xref="S2.SS1.p3.8.m8.1.1.1.1.2.1.cmml">|</mo></mrow><mo rspace="0.222em" id="S2.SS1.p3.8.m8.1.1.1.2" xref="S2.SS1.p3.8.m8.1.1.1.2.cmml">×</mo><mi id="S2.SS1.p3.8.m8.1.1.1.3" xref="S2.SS1.p3.8.m8.1.1.1.3.cmml">d</mi></mrow></msup><mo stretchy="false" id="S2.SS1.p3.8.m8.1.2.3.1" xref="S2.SS1.p3.8.m8.1.2.3.1.cmml">→</mo><msup id="S2.SS1.p3.8.m8.1.2.3.3" xref="S2.SS1.p3.8.m8.1.2.3.3.cmml"><mi id="S2.SS1.p3.8.m8.1.2.3.3.2" xref="S2.SS1.p3.8.m8.1.2.3.3.2.cmml">R</mi><mi id="S2.SS1.p3.8.m8.1.2.3.3.3" xref="S2.SS1.p3.8.m8.1.2.3.3.3.cmml">d</mi></msup></mrow></mrow><annotation-xml encoding="MathML-Content" id="S2.SS1.p3.8.m8.1b"><apply id="S2.SS1.p3.8.m8.1.2.cmml" xref="S2.SS1.p3.8.m8.1.2"><ci id="S2.SS1.p3.8.m8.1.2.1.cmml" xref="S2.SS1.p3.8.m8.1.2.1">:</ci><ci id="S2.SS1.p3.8.m8.1.2.2.cmml" xref="S2.SS1.p3.8.m8.1.2.2">𝐠</ci><apply id="S2.SS1.p3.8.m8.1.2.3.cmml" xref="S2.SS1.p3.8.m8.1.2.3"><ci id="S2.SS1.p3.8.m8.1.2.3.1.cmml" xref="S2.SS1.p3.8.m8.1.2.3.1">→</ci><apply id="S2.SS1.p3.8.m8.1.2.3.2.cmml" xref="S2.SS1.p3.8.m8.1.2.3.2"><csymbol cd="ambiguous" id="S2.SS1.p3.8.m8.1.2.3.2.1.cmml" xref="S2.SS1.p3.8.m8.1.2.3.2">superscript</csymbol><ci id="S2.SS1.p3.8.m8.1.2.3.2.2.cmml" xref="S2.SS1.p3.8.m8.1.2.3.2.2">𝑅</ci><apply id="S2.SS1.p3.8.m8.1.1.1.cmml" xref="S2.SS1.p3.8.m8.1.1.1"><times id="S2.SS1.p3.8.m8.1.1.1.2.cmml" xref="S2.SS1.p3.8.m8.1.1.1.2"></times><apply id="S2.SS1.p3.8.m8.1.1.1.1.2.cmml" xref="S2.SS1.p3.8.m8.1.1.1.1.1"><abs id="S2.SS1.p3.8.m8.1.1.1.1.2.1.cmml" xref="S2.SS1.p3.8.m8.1.1.1.1.1.2"></abs><apply id="S2.SS1.p3.8.m8.1.1.1.1.1.1.cmml" xref="S2.SS1.p3.8.m8.1.1.1.1.1.1"><csymbol cd="ambiguous" id="S2.SS1.p3.8.m8.1.1.1.1.1.1.1.cmml" xref="S2.SS1.p3.8.m8.1.1.1.1.1.1">subscript</csymbol><ci id="S2.SS1.p3.8.m8.1.1.1.1.1.1.2.cmml" xref="S2.SS1.p3.8.m8.1.1.1.1.1.1.2">𝑆</ci><ci id="S2.SS1.p3.8.m8.1.1.1.1.1.1.3.cmml" xref="S2.SS1.p3.8.m8.1.1.1.1.1.1.3">𝑡</ci></apply></apply><ci id="S2.SS1.p3.8.m8.1.1.1.3.cmml" xref="S2.SS1.p3.8.m8.1.1.1.3">𝑑</ci></apply></apply><apply id="S2.SS1.p3.8.m8.1.2.3.3.cmml" xref="S2.SS1.p3.8.m8.1.2.3.3"><csymbol cd="ambiguous" id="S2.SS1.p3.8.m8.1.2.3.3.1.cmml" xref="S2.SS1.p3.8.m8.1.2.3.3">superscript</csymbol><ci id="S2.SS1.p3.8.m8.1.2.3.3.2.cmml" xref="S2.SS1.p3.8.m8.1.2.3.3.2">𝑅</ci><ci id="S2.SS1.p3.8.m8.1.2.3.3.3.cmml" xref="S2.SS1.p3.8.m8.1.2.3.3.3">𝑑</ci></apply></apply></apply></annotation-xml><annotation encoding="application/x-tex" id="S2.SS1.p3.8.m8.1c">\mathbf{g}\colon R^{|S_{t}|\times d}\rightarrow R^{d}</annotation></semantics></math> and adding the result to <math id="S2.SS1.p3.9.m9.1" class="ltx_Math" alttext="w_{t}" display="inline"><semantics id="S2.SS1.p3.9.m9.1a"><msub id="S2.SS1.p3.9.m9.1.1" xref="S2.SS1.p3.9.m9.1.1.cmml"><mi id="S2.SS1.p3.9.m9.1.1.2" xref="S2.SS1.p3.9.m9.1.1.2.cmml">w</mi><mi id="S2.SS1.p3.9.m9.1.1.3" xref="S2.SS1.p3.9.m9.1.1.3.cmml">t</mi></msub><annotation-xml encoding="MathML-Content" id="S2.SS1.p3.9.m9.1b"><apply id="S2.SS1.p3.9.m9.1.1.cmml" xref="S2.SS1.p3.9.m9.1.1"><csymbol cd="ambiguous" id="S2.SS1.p3.9.m9.1.1.1.cmml" xref="S2.SS1.p3.9.m9.1.1">subscript</csymbol><ci id="S2.SS1.p3.9.m9.1.1.2.cmml" xref="S2.SS1.p3.9.m9.1.1.2">𝑤</ci><ci id="S2.SS1.p3.9.m9.1.1.3.cmml" xref="S2.SS1.p3.9.m9.1.1.3">𝑡</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="S2.SS1.p3.9.m9.1c">w_{t}</annotation></semantics></math>. That is,
<math id="S2.SS1.p3.10.m10.2" class="ltx_Math" alttext="w_{t+1}=w_{t}+\eta\cdot\operatorname*{\textbf{g}}(\{\Delta_{t}\})" display="inline"><semantics id="S2.SS1.p3.10.m10.2a"><mrow id="S2.SS1.p3.10.m10.2.2" xref="S2.SS1.p3.10.m10.2.2.cmml"><msub id="S2.SS1.p3.10.m10.2.2.3" xref="S2.SS1.p3.10.m10.2.2.3.cmml"><mi id="S2.SS1.p3.10.m10.2.2.3.2" xref="S2.SS1.p3.10.m10.2.2.3.2.cmml">w</mi><mrow id="S2.SS1.p3.10.m10.2.2.3.3" xref="S2.SS1.p3.10.m10.2.2.3.3.cmml"><mi id="S2.SS1.p3.10.m10.2.2.3.3.2" xref="S2.SS1.p3.10.m10.2.2.3.3.2.cmml">t</mi><mo id="S2.SS1.p3.10.m10.2.2.3.3.1" xref="S2.SS1.p3.10.m10.2.2.3.3.1.cmml">+</mo><mn id="S2.SS1.p3.10.m10.2.2.3.3.3" xref="S2.SS1.p3.10.m10.2.2.3.3.3.cmml">1</mn></mrow></msub><mo id="S2.SS1.p3.10.m10.2.2.2" xref="S2.SS1.p3.10.m10.2.2.2.cmml">=</mo><mrow id="S2.SS1.p3.10.m10.2.2.1" xref="S2.SS1.p3.10.m10.2.2.1.cmml"><msub id="S2.SS1.p3.10.m10.2.2.1.3" xref="S2.SS1.p3.10.m10.2.2.1.3.cmml"><mi id="S2.SS1.p3.10.m10.2.2.1.3.2" xref="S2.SS1.p3.10.m10.2.2.1.3.2.cmml">w</mi><mi id="S2.SS1.p3.10.m10.2.2.1.3.3" xref="S2.SS1.p3.10.m10.2.2.1.3.3.cmml">t</mi></msub><mo id="S2.SS1.p3.10.m10.2.2.1.2" xref="S2.SS1.p3.10.m10.2.2.1.2.cmml">+</mo><mrow id="S2.SS1.p3.10.m10.2.2.1.1" xref="S2.SS1.p3.10.m10.2.2.1.1.cmml"><mi id="S2.SS1.p3.10.m10.2.2.1.1.3" xref="S2.SS1.p3.10.m10.2.2.1.1.3.cmml">η</mi><mo lspace="0.222em" rspace="0.222em" id="S2.SS1.p3.10.m10.2.2.1.1.2" xref="S2.SS1.p3.10.m10.2.2.1.1.2.cmml">⋅</mo><mrow id="S2.SS1.p3.10.m10.2.2.1.1.1.1" xref="S2.SS1.p3.10.m10.2.2.1.1.1.2.cmml"><mtext class="ltx_mathvariant_bold" id="S2.SS1.p3.10.m10.1.1" xref="S2.SS1.p3.10.m10.1.1a.cmml">g</mtext><mo id="S2.SS1.p3.10.m10.2.2.1.1.1.1a" xref="S2.SS1.p3.10.m10.2.2.1.1.1.2.cmml">⁡</mo><mrow id="S2.SS1.p3.10.m10.2.2.1.1.1.1.1" xref="S2.SS1.p3.10.m10.2.2.1.1.1.2.cmml"><mo stretchy="false" id="S2.SS1.p3.10.m10.2.2.1.1.1.1.1.2" xref="S2.SS1.p3.10.m10.2.2.1.1.1.2.cmml">(</mo><mrow id="S2.SS1.p3.10.m10.2.2.1.1.1.1.1.1.1" xref="S2.SS1.p3.10.m10.2.2.1.1.1.1.1.1.2.cmml"><mo stretchy="false" id="S2.SS1.p3.10.m10.2.2.1.1.1.1.1.1.1.2" xref="S2.SS1.p3.10.m10.2.2.1.1.1.1.1.1.2.cmml">{</mo><msub id="S2.SS1.p3.10.m10.2.2.1.1.1.1.1.1.1.1" xref="S2.SS1.p3.10.m10.2.2.1.1.1.1.1.1.1.1.cmml"><mi mathvariant="normal" id="S2.SS1.p3.10.m10.2.2.1.1.1.1.1.1.1.1.2" xref="S2.SS1.p3.10.m10.2.2.1.1.1.1.1.1.1.1.2.cmml">Δ</mi><mi id="S2.SS1.p3.10.m10.2.2.1.1.1.1.1.1.1.1.3" xref="S2.SS1.p3.10.m10.2.2.1.1.1.1.1.1.1.1.3.cmml">t</mi></msub><mo stretchy="false" id="S2.SS1.p3.10.m10.2.2.1.1.1.1.1.1.1.3" xref="S2.SS1.p3.10.m10.2.2.1.1.1.1.1.1.2.cmml">}</mo></mrow><mo stretchy="false" id="S2.SS1.p3.10.m10.2.2.1.1.1.1.1.3" xref="S2.SS1.p3.10.m10.2.2.1.1.1.2.cmml">)</mo></mrow></mrow></mrow></mrow></mrow><annotation-xml encoding="MathML-Content" id="S2.SS1.p3.10.m10.2b"><apply id="S2.SS1.p3.10.m10.2.2.cmml" xref="S2.SS1.p3.10.m10.2.2"><eq id="S2.SS1.p3.10.m10.2.2.2.cmml" xref="S2.SS1.p3.10.m10.2.2.2"></eq><apply id="S2.SS1.p3.10.m10.2.2.3.cmml" xref="S2.SS1.p3.10.m10.2.2.3"><csymbol cd="ambiguous" id="S2.SS1.p3.10.m10.2.2.3.1.cmml" xref="S2.SS1.p3.10.m10.2.2.3">subscript</csymbol><ci id="S2.SS1.p3.10.m10.2.2.3.2.cmml" xref="S2.SS1.p3.10.m10.2.2.3.2">𝑤</ci><apply id="S2.SS1.p3.10.m10.2.2.3.3.cmml" xref="S2.SS1.p3.10.m10.2.2.3.3"><plus id="S2.SS1.p3.10.m10.2.2.3.3.1.cmml" xref="S2.SS1.p3.10.m10.2.2.3.3.1"></plus><ci id="S2.SS1.p3.10.m10.2.2.3.3.2.cmml" xref="S2.SS1.p3.10.m10.2.2.3.3.2">𝑡</ci><cn type="integer" id="S2.SS1.p3.10.m10.2.2.3.3.3.cmml" xref="S2.SS1.p3.10.m10.2.2.3.3.3">1</cn></apply></apply><apply id="S2.SS1.p3.10.m10.2.2.1.cmml" xref="S2.SS1.p3.10.m10.2.2.1"><plus id="S2.SS1.p3.10.m10.2.2.1.2.cmml" xref="S2.SS1.p3.10.m10.2.2.1.2"></plus><apply id="S2.SS1.p3.10.m10.2.2.1.3.cmml" xref="S2.SS1.p3.10.m10.2.2.1.3"><csymbol cd="ambiguous" id="S2.SS1.p3.10.m10.2.2.1.3.1.cmml" xref="S2.SS1.p3.10.m10.2.2.1.3">subscript</csymbol><ci id="S2.SS1.p3.10.m10.2.2.1.3.2.cmml" xref="S2.SS1.p3.10.m10.2.2.1.3.2">𝑤</ci><ci id="S2.SS1.p3.10.m10.2.2.1.3.3.cmml" xref="S2.SS1.p3.10.m10.2.2.1.3.3">𝑡</ci></apply><apply id="S2.SS1.p3.10.m10.2.2.1.1.cmml" xref="S2.SS1.p3.10.m10.2.2.1.1"><ci id="S2.SS1.p3.10.m10.2.2.1.1.2.cmml" xref="S2.SS1.p3.10.m10.2.2.1.1.2">⋅</ci><ci id="S2.SS1.p3.10.m10.2.2.1.1.3.cmml" xref="S2.SS1.p3.10.m10.2.2.1.1.3">𝜂</ci><apply id="S2.SS1.p3.10.m10.2.2.1.1.1.2.cmml" xref="S2.SS1.p3.10.m10.2.2.1.1.1.1"><ci id="S2.SS1.p3.10.m10.1.1a.cmml" xref="S2.SS1.p3.10.m10.1.1"><mtext class="ltx_mathvariant_bold" id="S2.SS1.p3.10.m10.1.1.cmml" xref="S2.SS1.p3.10.m10.1.1">g</mtext></ci><set id="S2.SS1.p3.10.m10.2.2.1.1.1.1.1.1.2.cmml" xref="S2.SS1.p3.10.m10.2.2.1.1.1.1.1.1.1"><apply id="S2.SS1.p3.10.m10.2.2.1.1.1.1.1.1.1.1.cmml" xref="S2.SS1.p3.10.m10.2.2.1.1.1.1.1.1.1.1"><csymbol cd="ambiguous" id="S2.SS1.p3.10.m10.2.2.1.1.1.1.1.1.1.1.1.cmml" xref="S2.SS1.p3.10.m10.2.2.1.1.1.1.1.1.1.1">subscript</csymbol><ci id="S2.SS1.p3.10.m10.2.2.1.1.1.1.1.1.1.1.2.cmml" xref="S2.SS1.p3.10.m10.2.2.1.1.1.1.1.1.1.1.2">Δ</ci><ci id="S2.SS1.p3.10.m10.2.2.1.1.1.1.1.1.1.1.3.cmml" xref="S2.SS1.p3.10.m10.2.2.1.1.1.1.1.1.1.1.3">𝑡</ci></apply></set></apply></apply></apply></apply></annotation-xml><annotation encoding="application/x-tex" id="S2.SS1.p3.10.m10.2c">w_{t+1}=w_{t}+\eta\cdot\operatorname*{\textbf{g}}(\{\Delta_{t}\})</annotation></semantics></math> where <math id="S2.SS1.p3.11.m11.1" class="ltx_Math" alttext="\{\Delta_{t}\}=\bigcup_{k\in S_{t}}\Delta_{t}^{k}" display="inline"><semantics id="S2.SS1.p3.11.m11.1a"><mrow id="S2.SS1.p3.11.m11.1.1" xref="S2.SS1.p3.11.m11.1.1.cmml"><mrow id="S2.SS1.p3.11.m11.1.1.1.1" xref="S2.SS1.p3.11.m11.1.1.1.2.cmml"><mo stretchy="false" id="S2.SS1.p3.11.m11.1.1.1.1.2" xref="S2.SS1.p3.11.m11.1.1.1.2.cmml">{</mo><msub id="S2.SS1.p3.11.m11.1.1.1.1.1" xref="S2.SS1.p3.11.m11.1.1.1.1.1.cmml"><mi mathvariant="normal" id="S2.SS1.p3.11.m11.1.1.1.1.1.2" xref="S2.SS1.p3.11.m11.1.1.1.1.1.2.cmml">Δ</mi><mi id="S2.SS1.p3.11.m11.1.1.1.1.1.3" xref="S2.SS1.p3.11.m11.1.1.1.1.1.3.cmml">t</mi></msub><mo stretchy="false" id="S2.SS1.p3.11.m11.1.1.1.1.3" xref="S2.SS1.p3.11.m11.1.1.1.2.cmml">}</mo></mrow><mo rspace="0.111em" id="S2.SS1.p3.11.m11.1.1.2" xref="S2.SS1.p3.11.m11.1.1.2.cmml">=</mo><mrow id="S2.SS1.p3.11.m11.1.1.3" xref="S2.SS1.p3.11.m11.1.1.3.cmml"><msub id="S2.SS1.p3.11.m11.1.1.3.1" xref="S2.SS1.p3.11.m11.1.1.3.1.cmml"><mo id="S2.SS1.p3.11.m11.1.1.3.1.2" xref="S2.SS1.p3.11.m11.1.1.3.1.2.cmml">⋃</mo><mrow id="S2.SS1.p3.11.m11.1.1.3.1.3" xref="S2.SS1.p3.11.m11.1.1.3.1.3.cmml"><mi id="S2.SS1.p3.11.m11.1.1.3.1.3.2" xref="S2.SS1.p3.11.m11.1.1.3.1.3.2.cmml">k</mi><mo id="S2.SS1.p3.11.m11.1.1.3.1.3.1" xref="S2.SS1.p3.11.m11.1.1.3.1.3.1.cmml">∈</mo><msub id="S2.SS1.p3.11.m11.1.1.3.1.3.3" xref="S2.SS1.p3.11.m11.1.1.3.1.3.3.cmml"><mi id="S2.SS1.p3.11.m11.1.1.3.1.3.3.2" xref="S2.SS1.p3.11.m11.1.1.3.1.3.3.2.cmml">S</mi><mi id="S2.SS1.p3.11.m11.1.1.3.1.3.3.3" xref="S2.SS1.p3.11.m11.1.1.3.1.3.3.3.cmml">t</mi></msub></mrow></msub><msubsup id="S2.SS1.p3.11.m11.1.1.3.2" xref="S2.SS1.p3.11.m11.1.1.3.2.cmml"><mi mathvariant="normal" id="S2.SS1.p3.11.m11.1.1.3.2.2.2" xref="S2.SS1.p3.11.m11.1.1.3.2.2.2.cmml">Δ</mi><mi id="S2.SS1.p3.11.m11.1.1.3.2.2.3" xref="S2.SS1.p3.11.m11.1.1.3.2.2.3.cmml">t</mi><mi id="S2.SS1.p3.11.m11.1.1.3.2.3" xref="S2.SS1.p3.11.m11.1.1.3.2.3.cmml">k</mi></msubsup></mrow></mrow><annotation-xml encoding="MathML-Content" id="S2.SS1.p3.11.m11.1b"><apply id="S2.SS1.p3.11.m11.1.1.cmml" xref="S2.SS1.p3.11.m11.1.1"><eq id="S2.SS1.p3.11.m11.1.1.2.cmml" xref="S2.SS1.p3.11.m11.1.1.2"></eq><set id="S2.SS1.p3.11.m11.1.1.1.2.cmml" xref="S2.SS1.p3.11.m11.1.1.1.1"><apply id="S2.SS1.p3.11.m11.1.1.1.1.1.cmml" xref="S2.SS1.p3.11.m11.1.1.1.1.1"><csymbol cd="ambiguous" id="S2.SS1.p3.11.m11.1.1.1.1.1.1.cmml" xref="S2.SS1.p3.11.m11.1.1.1.1.1">subscript</csymbol><ci id="S2.SS1.p3.11.m11.1.1.1.1.1.2.cmml" xref="S2.SS1.p3.11.m11.1.1.1.1.1.2">Δ</ci><ci id="S2.SS1.p3.11.m11.1.1.1.1.1.3.cmml" xref="S2.SS1.p3.11.m11.1.1.1.1.1.3">𝑡</ci></apply></set><apply id="S2.SS1.p3.11.m11.1.1.3.cmml" xref="S2.SS1.p3.11.m11.1.1.3"><apply id="S2.SS1.p3.11.m11.1.1.3.1.cmml" xref="S2.SS1.p3.11.m11.1.1.3.1"><csymbol cd="ambiguous" id="S2.SS1.p3.11.m11.1.1.3.1.1.cmml" xref="S2.SS1.p3.11.m11.1.1.3.1">subscript</csymbol><union id="S2.SS1.p3.11.m11.1.1.3.1.2.cmml" xref="S2.SS1.p3.11.m11.1.1.3.1.2"></union><apply id="S2.SS1.p3.11.m11.1.1.3.1.3.cmml" xref="S2.SS1.p3.11.m11.1.1.3.1.3"><in id="S2.SS1.p3.11.m11.1.1.3.1.3.1.cmml" xref="S2.SS1.p3.11.m11.1.1.3.1.3.1"></in><ci id="S2.SS1.p3.11.m11.1.1.3.1.3.2.cmml" xref="S2.SS1.p3.11.m11.1.1.3.1.3.2">𝑘</ci><apply id="S2.SS1.p3.11.m11.1.1.3.1.3.3.cmml" xref="S2.SS1.p3.11.m11.1.1.3.1.3.3"><csymbol cd="ambiguous" id="S2.SS1.p3.11.m11.1.1.3.1.3.3.1.cmml" xref="S2.SS1.p3.11.m11.1.1.3.1.3.3">subscript</csymbol><ci id="S2.SS1.p3.11.m11.1.1.3.1.3.3.2.cmml" xref="S2.SS1.p3.11.m11.1.1.3.1.3.3.2">𝑆</ci><ci id="S2.SS1.p3.11.m11.1.1.3.1.3.3.3.cmml" xref="S2.SS1.p3.11.m11.1.1.3.1.3.3.3">𝑡</ci></apply></apply></apply><apply id="S2.SS1.p3.11.m11.1.1.3.2.cmml" xref="S2.SS1.p3.11.m11.1.1.3.2"><csymbol cd="ambiguous" id="S2.SS1.p3.11.m11.1.1.3.2.1.cmml" xref="S2.SS1.p3.11.m11.1.1.3.2">superscript</csymbol><apply id="S2.SS1.p3.11.m11.1.1.3.2.2.cmml" xref="S2.SS1.p3.11.m11.1.1.3.2"><csymbol cd="ambiguous" id="S2.SS1.p3.11.m11.1.1.3.2.2.1.cmml" xref="S2.SS1.p3.11.m11.1.1.3.2">subscript</csymbol><ci id="S2.SS1.p3.11.m11.1.1.3.2.2.2.cmml" xref="S2.SS1.p3.11.m11.1.1.3.2.2.2">Δ</ci><ci id="S2.SS1.p3.11.m11.1.1.3.2.2.3.cmml" xref="S2.SS1.p3.11.m11.1.1.3.2.2.3">𝑡</ci></apply><ci id="S2.SS1.p3.11.m11.1.1.3.2.3.cmml" xref="S2.SS1.p3.11.m11.1.1.3.2.3">𝑘</ci></apply></apply></apply></annotation-xml><annotation encoding="application/x-tex" id="S2.SS1.p3.11.m11.1c">\{\Delta_{t}\}=\bigcup_{k\in S_{t}}\Delta_{t}^{k}</annotation></semantics></math>, and <math id="S2.SS1.p3.12.m12.1" class="ltx_Math" alttext="\eta" display="inline"><semantics id="S2.SS1.p3.12.m12.1a"><mi id="S2.SS1.p3.12.m12.1.1" xref="S2.SS1.p3.12.m12.1.1.cmml">η</mi><annotation-xml encoding="MathML-Content" id="S2.SS1.p3.12.m12.1b"><ci id="S2.SS1.p3.12.m12.1.1.cmml" xref="S2.SS1.p3.12.m12.1.1">𝜂</ci></annotation-xml><annotation encoding="application/x-tex" id="S2.SS1.p3.12.m12.1c">\eta</annotation></semantics></math> is the server’s learning rate.</p>
</div>
<div id="S2.SS1.p4" class="ltx_para">
<p id="S2.SS1.p4.1" class="ltx_p">For example, original FL paper <cite class="ltx_cite ltx_citemacro_citep">(McMahan et al<span class="ltx_text">.</span>, <a href="#bib.bib22" title="" class="ltx_ref">2016b</a>)</cite> and many subsequent papers on FL <cite class="ltx_cite ltx_citemacro_citep">(Bhagoji et al<span class="ltx_text">.</span>, <a href="#bib.bib6" title="" class="ltx_ref">2019</a>; Bagdasaryan et al<span class="ltx_text">.</span>, <a href="#bib.bib4" title="" class="ltx_ref">2020</a>; Sun
et al<span class="ltx_text">.</span>, <a href="#bib.bib33" title="" class="ltx_ref">2019</a>; Bonawitz et al<span class="ltx_text">.</span>, <a href="#bib.bib8" title="" class="ltx_ref">2017</a>; Geyer
et al<span class="ltx_text">.</span>, <a href="#bib.bib13" title="" class="ltx_ref">2017</a>)</cite> consider weighted averaging to aggregate updates. In this context, this aggregation is referred as Federated Averaging (FedAvg), and yields the following update rule,</p>
<table id="S2.E1" class="ltx_equation ltx_eqn_table">

<tbody><tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td rowspan="1" class="ltx_eqn_cell ltx_eqn_eqno ltx_align_middle ltx_align_left"><span class="ltx_tag ltx_tag_equation ltx_align_left">(1)</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math id="S2.E1.m1.1" class="ltx_Math" alttext="w_{t+1}=w_{t}+\eta\frac{\sum_{k\in S_{t}}n_{k}\cdot\Delta_{t}^{k}}{\sum_{k\in S_{t}}n_{k}}." display="block"><semantics id="S2.E1.m1.1a"><mrow id="S2.E1.m1.1.1.1" xref="S2.E1.m1.1.1.1.1.cmml"><mrow id="S2.E1.m1.1.1.1.1" xref="S2.E1.m1.1.1.1.1.cmml"><msub id="S2.E1.m1.1.1.1.1.2" xref="S2.E1.m1.1.1.1.1.2.cmml"><mi id="S2.E1.m1.1.1.1.1.2.2" xref="S2.E1.m1.1.1.1.1.2.2.cmml">w</mi><mrow id="S2.E1.m1.1.1.1.1.2.3" xref="S2.E1.m1.1.1.1.1.2.3.cmml"><mi id="S2.E1.m1.1.1.1.1.2.3.2" xref="S2.E1.m1.1.1.1.1.2.3.2.cmml">t</mi><mo id="S2.E1.m1.1.1.1.1.2.3.1" xref="S2.E1.m1.1.1.1.1.2.3.1.cmml">+</mo><mn id="S2.E1.m1.1.1.1.1.2.3.3" xref="S2.E1.m1.1.1.1.1.2.3.3.cmml">1</mn></mrow></msub><mo id="S2.E1.m1.1.1.1.1.1" xref="S2.E1.m1.1.1.1.1.1.cmml">=</mo><mrow id="S2.E1.m1.1.1.1.1.3" xref="S2.E1.m1.1.1.1.1.3.cmml"><msub id="S2.E1.m1.1.1.1.1.3.2" xref="S2.E1.m1.1.1.1.1.3.2.cmml"><mi id="S2.E1.m1.1.1.1.1.3.2.2" xref="S2.E1.m1.1.1.1.1.3.2.2.cmml">w</mi><mi id="S2.E1.m1.1.1.1.1.3.2.3" xref="S2.E1.m1.1.1.1.1.3.2.3.cmml">t</mi></msub><mo id="S2.E1.m1.1.1.1.1.3.1" xref="S2.E1.m1.1.1.1.1.3.1.cmml">+</mo><mrow id="S2.E1.m1.1.1.1.1.3.3" xref="S2.E1.m1.1.1.1.1.3.3.cmml"><mi id="S2.E1.m1.1.1.1.1.3.3.2" xref="S2.E1.m1.1.1.1.1.3.3.2.cmml">η</mi><mo lspace="0em" rspace="0em" id="S2.E1.m1.1.1.1.1.3.3.1" xref="S2.E1.m1.1.1.1.1.3.3.1.cmml">​</mo><mfrac id="S2.E1.m1.1.1.1.1.3.3.3" xref="S2.E1.m1.1.1.1.1.3.3.3.cmml"><mrow id="S2.E1.m1.1.1.1.1.3.3.3.2" xref="S2.E1.m1.1.1.1.1.3.3.3.2.cmml"><msub id="S2.E1.m1.1.1.1.1.3.3.3.2.1" xref="S2.E1.m1.1.1.1.1.3.3.3.2.1.cmml"><mo id="S2.E1.m1.1.1.1.1.3.3.3.2.1.2" xref="S2.E1.m1.1.1.1.1.3.3.3.2.1.2.cmml">∑</mo><mrow id="S2.E1.m1.1.1.1.1.3.3.3.2.1.3" xref="S2.E1.m1.1.1.1.1.3.3.3.2.1.3.cmml"><mi id="S2.E1.m1.1.1.1.1.3.3.3.2.1.3.2" xref="S2.E1.m1.1.1.1.1.3.3.3.2.1.3.2.cmml">k</mi><mo id="S2.E1.m1.1.1.1.1.3.3.3.2.1.3.1" xref="S2.E1.m1.1.1.1.1.3.3.3.2.1.3.1.cmml">∈</mo><msub id="S2.E1.m1.1.1.1.1.3.3.3.2.1.3.3" xref="S2.E1.m1.1.1.1.1.3.3.3.2.1.3.3.cmml"><mi id="S2.E1.m1.1.1.1.1.3.3.3.2.1.3.3.2" xref="S2.E1.m1.1.1.1.1.3.3.3.2.1.3.3.2.cmml">S</mi><mi id="S2.E1.m1.1.1.1.1.3.3.3.2.1.3.3.3" xref="S2.E1.m1.1.1.1.1.3.3.3.2.1.3.3.3.cmml">t</mi></msub></mrow></msub><mrow id="S2.E1.m1.1.1.1.1.3.3.3.2.2" xref="S2.E1.m1.1.1.1.1.3.3.3.2.2.cmml"><msub id="S2.E1.m1.1.1.1.1.3.3.3.2.2.2" xref="S2.E1.m1.1.1.1.1.3.3.3.2.2.2.cmml"><mi id="S2.E1.m1.1.1.1.1.3.3.3.2.2.2.2" xref="S2.E1.m1.1.1.1.1.3.3.3.2.2.2.2.cmml">n</mi><mi id="S2.E1.m1.1.1.1.1.3.3.3.2.2.2.3" xref="S2.E1.m1.1.1.1.1.3.3.3.2.2.2.3.cmml">k</mi></msub><mo lspace="0.222em" rspace="0.222em" id="S2.E1.m1.1.1.1.1.3.3.3.2.2.1" xref="S2.E1.m1.1.1.1.1.3.3.3.2.2.1.cmml">⋅</mo><msubsup id="S2.E1.m1.1.1.1.1.3.3.3.2.2.3" xref="S2.E1.m1.1.1.1.1.3.3.3.2.2.3.cmml"><mi mathvariant="normal" id="S2.E1.m1.1.1.1.1.3.3.3.2.2.3.2.2" xref="S2.E1.m1.1.1.1.1.3.3.3.2.2.3.2.2.cmml">Δ</mi><mi id="S2.E1.m1.1.1.1.1.3.3.3.2.2.3.2.3" xref="S2.E1.m1.1.1.1.1.3.3.3.2.2.3.2.3.cmml">t</mi><mi id="S2.E1.m1.1.1.1.1.3.3.3.2.2.3.3" xref="S2.E1.m1.1.1.1.1.3.3.3.2.2.3.3.cmml">k</mi></msubsup></mrow></mrow><mrow id="S2.E1.m1.1.1.1.1.3.3.3.3" xref="S2.E1.m1.1.1.1.1.3.3.3.3.cmml"><msub id="S2.E1.m1.1.1.1.1.3.3.3.3.1" xref="S2.E1.m1.1.1.1.1.3.3.3.3.1.cmml"><mo id="S2.E1.m1.1.1.1.1.3.3.3.3.1.2" xref="S2.E1.m1.1.1.1.1.3.3.3.3.1.2.cmml">∑</mo><mrow id="S2.E1.m1.1.1.1.1.3.3.3.3.1.3" xref="S2.E1.m1.1.1.1.1.3.3.3.3.1.3.cmml"><mi id="S2.E1.m1.1.1.1.1.3.3.3.3.1.3.2" xref="S2.E1.m1.1.1.1.1.3.3.3.3.1.3.2.cmml">k</mi><mo id="S2.E1.m1.1.1.1.1.3.3.3.3.1.3.1" xref="S2.E1.m1.1.1.1.1.3.3.3.3.1.3.1.cmml">∈</mo><msub id="S2.E1.m1.1.1.1.1.3.3.3.3.1.3.3" xref="S2.E1.m1.1.1.1.1.3.3.3.3.1.3.3.cmml"><mi id="S2.E1.m1.1.1.1.1.3.3.3.3.1.3.3.2" xref="S2.E1.m1.1.1.1.1.3.3.3.3.1.3.3.2.cmml">S</mi><mi id="S2.E1.m1.1.1.1.1.3.3.3.3.1.3.3.3" xref="S2.E1.m1.1.1.1.1.3.3.3.3.1.3.3.3.cmml">t</mi></msub></mrow></msub><msub id="S2.E1.m1.1.1.1.1.3.3.3.3.2" xref="S2.E1.m1.1.1.1.1.3.3.3.3.2.cmml"><mi id="S2.E1.m1.1.1.1.1.3.3.3.3.2.2" xref="S2.E1.m1.1.1.1.1.3.3.3.3.2.2.cmml">n</mi><mi id="S2.E1.m1.1.1.1.1.3.3.3.3.2.3" xref="S2.E1.m1.1.1.1.1.3.3.3.3.2.3.cmml">k</mi></msub></mrow></mfrac></mrow></mrow></mrow><mo lspace="0em" id="S2.E1.m1.1.1.1.2" xref="S2.E1.m1.1.1.1.1.cmml">.</mo></mrow><annotation-xml encoding="MathML-Content" id="S2.E1.m1.1b"><apply id="S2.E1.m1.1.1.1.1.cmml" xref="S2.E1.m1.1.1.1"><eq id="S2.E1.m1.1.1.1.1.1.cmml" xref="S2.E1.m1.1.1.1.1.1"></eq><apply id="S2.E1.m1.1.1.1.1.2.cmml" xref="S2.E1.m1.1.1.1.1.2"><csymbol cd="ambiguous" id="S2.E1.m1.1.1.1.1.2.1.cmml" xref="S2.E1.m1.1.1.1.1.2">subscript</csymbol><ci id="S2.E1.m1.1.1.1.1.2.2.cmml" xref="S2.E1.m1.1.1.1.1.2.2">𝑤</ci><apply id="S2.E1.m1.1.1.1.1.2.3.cmml" xref="S2.E1.m1.1.1.1.1.2.3"><plus id="S2.E1.m1.1.1.1.1.2.3.1.cmml" xref="S2.E1.m1.1.1.1.1.2.3.1"></plus><ci id="S2.E1.m1.1.1.1.1.2.3.2.cmml" xref="S2.E1.m1.1.1.1.1.2.3.2">𝑡</ci><cn type="integer" id="S2.E1.m1.1.1.1.1.2.3.3.cmml" xref="S2.E1.m1.1.1.1.1.2.3.3">1</cn></apply></apply><apply id="S2.E1.m1.1.1.1.1.3.cmml" xref="S2.E1.m1.1.1.1.1.3"><plus id="S2.E1.m1.1.1.1.1.3.1.cmml" xref="S2.E1.m1.1.1.1.1.3.1"></plus><apply id="S2.E1.m1.1.1.1.1.3.2.cmml" xref="S2.E1.m1.1.1.1.1.3.2"><csymbol cd="ambiguous" id="S2.E1.m1.1.1.1.1.3.2.1.cmml" xref="S2.E1.m1.1.1.1.1.3.2">subscript</csymbol><ci id="S2.E1.m1.1.1.1.1.3.2.2.cmml" xref="S2.E1.m1.1.1.1.1.3.2.2">𝑤</ci><ci id="S2.E1.m1.1.1.1.1.3.2.3.cmml" xref="S2.E1.m1.1.1.1.1.3.2.3">𝑡</ci></apply><apply id="S2.E1.m1.1.1.1.1.3.3.cmml" xref="S2.E1.m1.1.1.1.1.3.3"><times id="S2.E1.m1.1.1.1.1.3.3.1.cmml" xref="S2.E1.m1.1.1.1.1.3.3.1"></times><ci id="S2.E1.m1.1.1.1.1.3.3.2.cmml" xref="S2.E1.m1.1.1.1.1.3.3.2">𝜂</ci><apply id="S2.E1.m1.1.1.1.1.3.3.3.cmml" xref="S2.E1.m1.1.1.1.1.3.3.3"><divide id="S2.E1.m1.1.1.1.1.3.3.3.1.cmml" xref="S2.E1.m1.1.1.1.1.3.3.3"></divide><apply id="S2.E1.m1.1.1.1.1.3.3.3.2.cmml" xref="S2.E1.m1.1.1.1.1.3.3.3.2"><apply id="S2.E1.m1.1.1.1.1.3.3.3.2.1.cmml" xref="S2.E1.m1.1.1.1.1.3.3.3.2.1"><csymbol cd="ambiguous" id="S2.E1.m1.1.1.1.1.3.3.3.2.1.1.cmml" xref="S2.E1.m1.1.1.1.1.3.3.3.2.1">subscript</csymbol><sum id="S2.E1.m1.1.1.1.1.3.3.3.2.1.2.cmml" xref="S2.E1.m1.1.1.1.1.3.3.3.2.1.2"></sum><apply id="S2.E1.m1.1.1.1.1.3.3.3.2.1.3.cmml" xref="S2.E1.m1.1.1.1.1.3.3.3.2.1.3"><in id="S2.E1.m1.1.1.1.1.3.3.3.2.1.3.1.cmml" xref="S2.E1.m1.1.1.1.1.3.3.3.2.1.3.1"></in><ci id="S2.E1.m1.1.1.1.1.3.3.3.2.1.3.2.cmml" xref="S2.E1.m1.1.1.1.1.3.3.3.2.1.3.2">𝑘</ci><apply id="S2.E1.m1.1.1.1.1.3.3.3.2.1.3.3.cmml" xref="S2.E1.m1.1.1.1.1.3.3.3.2.1.3.3"><csymbol cd="ambiguous" id="S2.E1.m1.1.1.1.1.3.3.3.2.1.3.3.1.cmml" xref="S2.E1.m1.1.1.1.1.3.3.3.2.1.3.3">subscript</csymbol><ci id="S2.E1.m1.1.1.1.1.3.3.3.2.1.3.3.2.cmml" xref="S2.E1.m1.1.1.1.1.3.3.3.2.1.3.3.2">𝑆</ci><ci id="S2.E1.m1.1.1.1.1.3.3.3.2.1.3.3.3.cmml" xref="S2.E1.m1.1.1.1.1.3.3.3.2.1.3.3.3">𝑡</ci></apply></apply></apply><apply id="S2.E1.m1.1.1.1.1.3.3.3.2.2.cmml" xref="S2.E1.m1.1.1.1.1.3.3.3.2.2"><ci id="S2.E1.m1.1.1.1.1.3.3.3.2.2.1.cmml" xref="S2.E1.m1.1.1.1.1.3.3.3.2.2.1">⋅</ci><apply id="S2.E1.m1.1.1.1.1.3.3.3.2.2.2.cmml" xref="S2.E1.m1.1.1.1.1.3.3.3.2.2.2"><csymbol cd="ambiguous" id="S2.E1.m1.1.1.1.1.3.3.3.2.2.2.1.cmml" xref="S2.E1.m1.1.1.1.1.3.3.3.2.2.2">subscript</csymbol><ci id="S2.E1.m1.1.1.1.1.3.3.3.2.2.2.2.cmml" xref="S2.E1.m1.1.1.1.1.3.3.3.2.2.2.2">𝑛</ci><ci id="S2.E1.m1.1.1.1.1.3.3.3.2.2.2.3.cmml" xref="S2.E1.m1.1.1.1.1.3.3.3.2.2.2.3">𝑘</ci></apply><apply id="S2.E1.m1.1.1.1.1.3.3.3.2.2.3.cmml" xref="S2.E1.m1.1.1.1.1.3.3.3.2.2.3"><csymbol cd="ambiguous" id="S2.E1.m1.1.1.1.1.3.3.3.2.2.3.1.cmml" xref="S2.E1.m1.1.1.1.1.3.3.3.2.2.3">superscript</csymbol><apply id="S2.E1.m1.1.1.1.1.3.3.3.2.2.3.2.cmml" xref="S2.E1.m1.1.1.1.1.3.3.3.2.2.3"><csymbol cd="ambiguous" id="S2.E1.m1.1.1.1.1.3.3.3.2.2.3.2.1.cmml" xref="S2.E1.m1.1.1.1.1.3.3.3.2.2.3">subscript</csymbol><ci id="S2.E1.m1.1.1.1.1.3.3.3.2.2.3.2.2.cmml" xref="S2.E1.m1.1.1.1.1.3.3.3.2.2.3.2.2">Δ</ci><ci id="S2.E1.m1.1.1.1.1.3.3.3.2.2.3.2.3.cmml" xref="S2.E1.m1.1.1.1.1.3.3.3.2.2.3.2.3">𝑡</ci></apply><ci id="S2.E1.m1.1.1.1.1.3.3.3.2.2.3.3.cmml" xref="S2.E1.m1.1.1.1.1.3.3.3.2.2.3.3">𝑘</ci></apply></apply></apply><apply id="S2.E1.m1.1.1.1.1.3.3.3.3.cmml" xref="S2.E1.m1.1.1.1.1.3.3.3.3"><apply id="S2.E1.m1.1.1.1.1.3.3.3.3.1.cmml" xref="S2.E1.m1.1.1.1.1.3.3.3.3.1"><csymbol cd="ambiguous" id="S2.E1.m1.1.1.1.1.3.3.3.3.1.1.cmml" xref="S2.E1.m1.1.1.1.1.3.3.3.3.1">subscript</csymbol><sum id="S2.E1.m1.1.1.1.1.3.3.3.3.1.2.cmml" xref="S2.E1.m1.1.1.1.1.3.3.3.3.1.2"></sum><apply id="S2.E1.m1.1.1.1.1.3.3.3.3.1.3.cmml" xref="S2.E1.m1.1.1.1.1.3.3.3.3.1.3"><in id="S2.E1.m1.1.1.1.1.3.3.3.3.1.3.1.cmml" xref="S2.E1.m1.1.1.1.1.3.3.3.3.1.3.1"></in><ci id="S2.E1.m1.1.1.1.1.3.3.3.3.1.3.2.cmml" xref="S2.E1.m1.1.1.1.1.3.3.3.3.1.3.2">𝑘</ci><apply id="S2.E1.m1.1.1.1.1.3.3.3.3.1.3.3.cmml" xref="S2.E1.m1.1.1.1.1.3.3.3.3.1.3.3"><csymbol cd="ambiguous" id="S2.E1.m1.1.1.1.1.3.3.3.3.1.3.3.1.cmml" xref="S2.E1.m1.1.1.1.1.3.3.3.3.1.3.3">subscript</csymbol><ci id="S2.E1.m1.1.1.1.1.3.3.3.3.1.3.3.2.cmml" xref="S2.E1.m1.1.1.1.1.3.3.3.3.1.3.3.2">𝑆</ci><ci id="S2.E1.m1.1.1.1.1.3.3.3.3.1.3.3.3.cmml" xref="S2.E1.m1.1.1.1.1.3.3.3.3.1.3.3.3">𝑡</ci></apply></apply></apply><apply id="S2.E1.m1.1.1.1.1.3.3.3.3.2.cmml" xref="S2.E1.m1.1.1.1.1.3.3.3.3.2"><csymbol cd="ambiguous" id="S2.E1.m1.1.1.1.1.3.3.3.3.2.1.cmml" xref="S2.E1.m1.1.1.1.1.3.3.3.3.2">subscript</csymbol><ci id="S2.E1.m1.1.1.1.1.3.3.3.3.2.2.cmml" xref="S2.E1.m1.1.1.1.1.3.3.3.3.2.2">𝑛</ci><ci id="S2.E1.m1.1.1.1.1.3.3.3.3.2.3.cmml" xref="S2.E1.m1.1.1.1.1.3.3.3.3.2.3">𝑘</ci></apply></apply></apply></apply></apply></apply></annotation-xml><annotation encoding="application/x-tex" id="S2.E1.m1.1c">w_{t+1}=w_{t}+\eta\frac{\sum_{k\in S_{t}}n_{k}\cdot\Delta_{t}^{k}}{\sum_{k\in S_{t}}n_{k}}.</annotation></semantics></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr></tbody>
</table>
</div>
<div id="S2.SS1.p5" class="ltx_para">
<p id="S2.SS1.p5.2" class="ltx_p">Another prominent aggregation method is presented in <cite class="ltx_cite ltx_citemacro_citep">(Bernstein et al<span class="ltx_text">.</span>, <a href="#bib.bib5" title="" class="ltx_ref">2018</a>)</cite>. In this work, authors develop a communication efficient, distributed SGD protocol in which agents only communicate the signs of their gradients. In this case, server aggregates the received signs and returns the sign of aggregation to the agents who locally update their models using it. We refer their aggregation technique as <em id="S2.SS1.p5.2.1" class="ltx_emph ltx_font_italic">sign aggregation</em>, and in FL setting, it yields the following update rule,</p>
<table id="S2.E2" class="ltx_equation ltx_eqn_table">

<tbody><tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td rowspan="1" class="ltx_eqn_cell ltx_eqn_eqno ltx_align_middle ltx_align_left"><span class="ltx_tag ltx_tag_equation ltx_align_left">(2)</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math id="S2.E2.m1.2" class="ltx_Math" alttext="w_{t+1}=w_{t}+\eta\big{(}\operatorname{sgn}\sum_{k\in S_{t}}\operatorname{sgn}(\Delta_{t}^{k})\big{)}," display="block"><semantics id="S2.E2.m1.2a"><mrow id="S2.E2.m1.2.2.1" xref="S2.E2.m1.2.2.1.1.cmml"><mrow id="S2.E2.m1.2.2.1.1" xref="S2.E2.m1.2.2.1.1.cmml"><msub id="S2.E2.m1.2.2.1.1.3" xref="S2.E2.m1.2.2.1.1.3.cmml"><mi id="S2.E2.m1.2.2.1.1.3.2" xref="S2.E2.m1.2.2.1.1.3.2.cmml">w</mi><mrow id="S2.E2.m1.2.2.1.1.3.3" xref="S2.E2.m1.2.2.1.1.3.3.cmml"><mi id="S2.E2.m1.2.2.1.1.3.3.2" xref="S2.E2.m1.2.2.1.1.3.3.2.cmml">t</mi><mo id="S2.E2.m1.2.2.1.1.3.3.1" xref="S2.E2.m1.2.2.1.1.3.3.1.cmml">+</mo><mn id="S2.E2.m1.2.2.1.1.3.3.3" xref="S2.E2.m1.2.2.1.1.3.3.3.cmml">1</mn></mrow></msub><mo id="S2.E2.m1.2.2.1.1.2" xref="S2.E2.m1.2.2.1.1.2.cmml">=</mo><mrow id="S2.E2.m1.2.2.1.1.1" xref="S2.E2.m1.2.2.1.1.1.cmml"><msub id="S2.E2.m1.2.2.1.1.1.3" xref="S2.E2.m1.2.2.1.1.1.3.cmml"><mi id="S2.E2.m1.2.2.1.1.1.3.2" xref="S2.E2.m1.2.2.1.1.1.3.2.cmml">w</mi><mi id="S2.E2.m1.2.2.1.1.1.3.3" xref="S2.E2.m1.2.2.1.1.1.3.3.cmml">t</mi></msub><mo id="S2.E2.m1.2.2.1.1.1.2" xref="S2.E2.m1.2.2.1.1.1.2.cmml">+</mo><mrow id="S2.E2.m1.2.2.1.1.1.1" xref="S2.E2.m1.2.2.1.1.1.1.cmml"><mi id="S2.E2.m1.2.2.1.1.1.1.3" xref="S2.E2.m1.2.2.1.1.1.1.3.cmml">η</mi><mo lspace="0em" rspace="0em" id="S2.E2.m1.2.2.1.1.1.1.2" xref="S2.E2.m1.2.2.1.1.1.1.2.cmml">​</mo><mrow id="S2.E2.m1.2.2.1.1.1.1.1.1" xref="S2.E2.m1.2.2.1.1.1.1.1.1.1.cmml"><mo maxsize="120%" minsize="120%" id="S2.E2.m1.2.2.1.1.1.1.1.1.2" xref="S2.E2.m1.2.2.1.1.1.1.1.1.1.cmml">(</mo><mrow id="S2.E2.m1.2.2.1.1.1.1.1.1.1" xref="S2.E2.m1.2.2.1.1.1.1.1.1.1.cmml"><mi id="S2.E2.m1.2.2.1.1.1.1.1.1.1.3" xref="S2.E2.m1.2.2.1.1.1.1.1.1.1.3.cmml">sgn</mi><mo lspace="0em" rspace="0em" id="S2.E2.m1.2.2.1.1.1.1.1.1.1.2" xref="S2.E2.m1.2.2.1.1.1.1.1.1.1.2.cmml">​</mo><mrow id="S2.E2.m1.2.2.1.1.1.1.1.1.1.1" xref="S2.E2.m1.2.2.1.1.1.1.1.1.1.1.cmml"><munder id="S2.E2.m1.2.2.1.1.1.1.1.1.1.1.2" xref="S2.E2.m1.2.2.1.1.1.1.1.1.1.1.2.cmml"><mo movablelimits="false" id="S2.E2.m1.2.2.1.1.1.1.1.1.1.1.2.2" xref="S2.E2.m1.2.2.1.1.1.1.1.1.1.1.2.2.cmml">∑</mo><mrow id="S2.E2.m1.2.2.1.1.1.1.1.1.1.1.2.3" xref="S2.E2.m1.2.2.1.1.1.1.1.1.1.1.2.3.cmml"><mi id="S2.E2.m1.2.2.1.1.1.1.1.1.1.1.2.3.2" xref="S2.E2.m1.2.2.1.1.1.1.1.1.1.1.2.3.2.cmml">k</mi><mo id="S2.E2.m1.2.2.1.1.1.1.1.1.1.1.2.3.1" xref="S2.E2.m1.2.2.1.1.1.1.1.1.1.1.2.3.1.cmml">∈</mo><msub id="S2.E2.m1.2.2.1.1.1.1.1.1.1.1.2.3.3" xref="S2.E2.m1.2.2.1.1.1.1.1.1.1.1.2.3.3.cmml"><mi id="S2.E2.m1.2.2.1.1.1.1.1.1.1.1.2.3.3.2" xref="S2.E2.m1.2.2.1.1.1.1.1.1.1.1.2.3.3.2.cmml">S</mi><mi id="S2.E2.m1.2.2.1.1.1.1.1.1.1.1.2.3.3.3" xref="S2.E2.m1.2.2.1.1.1.1.1.1.1.1.2.3.3.3.cmml">t</mi></msub></mrow></munder><mrow id="S2.E2.m1.2.2.1.1.1.1.1.1.1.1.1.1" xref="S2.E2.m1.2.2.1.1.1.1.1.1.1.1.1.2.cmml"><mi id="S2.E2.m1.1.1" xref="S2.E2.m1.1.1.cmml">sgn</mi><mo id="S2.E2.m1.2.2.1.1.1.1.1.1.1.1.1.1a" xref="S2.E2.m1.2.2.1.1.1.1.1.1.1.1.1.2.cmml">⁡</mo><mrow id="S2.E2.m1.2.2.1.1.1.1.1.1.1.1.1.1.1" xref="S2.E2.m1.2.2.1.1.1.1.1.1.1.1.1.2.cmml"><mo stretchy="false" id="S2.E2.m1.2.2.1.1.1.1.1.1.1.1.1.1.1.2" xref="S2.E2.m1.2.2.1.1.1.1.1.1.1.1.1.2.cmml">(</mo><msubsup id="S2.E2.m1.2.2.1.1.1.1.1.1.1.1.1.1.1.1" xref="S2.E2.m1.2.2.1.1.1.1.1.1.1.1.1.1.1.1.cmml"><mi mathvariant="normal" id="S2.E2.m1.2.2.1.1.1.1.1.1.1.1.1.1.1.1.2.2" xref="S2.E2.m1.2.2.1.1.1.1.1.1.1.1.1.1.1.1.2.2.cmml">Δ</mi><mi id="S2.E2.m1.2.2.1.1.1.1.1.1.1.1.1.1.1.1.2.3" xref="S2.E2.m1.2.2.1.1.1.1.1.1.1.1.1.1.1.1.2.3.cmml">t</mi><mi id="S2.E2.m1.2.2.1.1.1.1.1.1.1.1.1.1.1.1.3" xref="S2.E2.m1.2.2.1.1.1.1.1.1.1.1.1.1.1.1.3.cmml">k</mi></msubsup><mo stretchy="false" id="S2.E2.m1.2.2.1.1.1.1.1.1.1.1.1.1.1.3" xref="S2.E2.m1.2.2.1.1.1.1.1.1.1.1.1.2.cmml">)</mo></mrow></mrow></mrow></mrow><mo maxsize="120%" minsize="120%" id="S2.E2.m1.2.2.1.1.1.1.1.1.3" xref="S2.E2.m1.2.2.1.1.1.1.1.1.1.cmml">)</mo></mrow></mrow></mrow></mrow><mo id="S2.E2.m1.2.2.1.2" xref="S2.E2.m1.2.2.1.1.cmml">,</mo></mrow><annotation-xml encoding="MathML-Content" id="S2.E2.m1.2b"><apply id="S2.E2.m1.2.2.1.1.cmml" xref="S2.E2.m1.2.2.1"><eq id="S2.E2.m1.2.2.1.1.2.cmml" xref="S2.E2.m1.2.2.1.1.2"></eq><apply id="S2.E2.m1.2.2.1.1.3.cmml" xref="S2.E2.m1.2.2.1.1.3"><csymbol cd="ambiguous" id="S2.E2.m1.2.2.1.1.3.1.cmml" xref="S2.E2.m1.2.2.1.1.3">subscript</csymbol><ci id="S2.E2.m1.2.2.1.1.3.2.cmml" xref="S2.E2.m1.2.2.1.1.3.2">𝑤</ci><apply id="S2.E2.m1.2.2.1.1.3.3.cmml" xref="S2.E2.m1.2.2.1.1.3.3"><plus id="S2.E2.m1.2.2.1.1.3.3.1.cmml" xref="S2.E2.m1.2.2.1.1.3.3.1"></plus><ci id="S2.E2.m1.2.2.1.1.3.3.2.cmml" xref="S2.E2.m1.2.2.1.1.3.3.2">𝑡</ci><cn type="integer" id="S2.E2.m1.2.2.1.1.3.3.3.cmml" xref="S2.E2.m1.2.2.1.1.3.3.3">1</cn></apply></apply><apply id="S2.E2.m1.2.2.1.1.1.cmml" xref="S2.E2.m1.2.2.1.1.1"><plus id="S2.E2.m1.2.2.1.1.1.2.cmml" xref="S2.E2.m1.2.2.1.1.1.2"></plus><apply id="S2.E2.m1.2.2.1.1.1.3.cmml" xref="S2.E2.m1.2.2.1.1.1.3"><csymbol cd="ambiguous" id="S2.E2.m1.2.2.1.1.1.3.1.cmml" xref="S2.E2.m1.2.2.1.1.1.3">subscript</csymbol><ci id="S2.E2.m1.2.2.1.1.1.3.2.cmml" xref="S2.E2.m1.2.2.1.1.1.3.2">𝑤</ci><ci id="S2.E2.m1.2.2.1.1.1.3.3.cmml" xref="S2.E2.m1.2.2.1.1.1.3.3">𝑡</ci></apply><apply id="S2.E2.m1.2.2.1.1.1.1.cmml" xref="S2.E2.m1.2.2.1.1.1.1"><times id="S2.E2.m1.2.2.1.1.1.1.2.cmml" xref="S2.E2.m1.2.2.1.1.1.1.2"></times><ci id="S2.E2.m1.2.2.1.1.1.1.3.cmml" xref="S2.E2.m1.2.2.1.1.1.1.3">𝜂</ci><apply id="S2.E2.m1.2.2.1.1.1.1.1.1.1.cmml" xref="S2.E2.m1.2.2.1.1.1.1.1.1"><times id="S2.E2.m1.2.2.1.1.1.1.1.1.1.2.cmml" xref="S2.E2.m1.2.2.1.1.1.1.1.1.1.2"></times><ci id="S2.E2.m1.2.2.1.1.1.1.1.1.1.3.cmml" xref="S2.E2.m1.2.2.1.1.1.1.1.1.1.3">sgn</ci><apply id="S2.E2.m1.2.2.1.1.1.1.1.1.1.1.cmml" xref="S2.E2.m1.2.2.1.1.1.1.1.1.1.1"><apply id="S2.E2.m1.2.2.1.1.1.1.1.1.1.1.2.cmml" xref="S2.E2.m1.2.2.1.1.1.1.1.1.1.1.2"><csymbol cd="ambiguous" id="S2.E2.m1.2.2.1.1.1.1.1.1.1.1.2.1.cmml" xref="S2.E2.m1.2.2.1.1.1.1.1.1.1.1.2">subscript</csymbol><sum id="S2.E2.m1.2.2.1.1.1.1.1.1.1.1.2.2.cmml" xref="S2.E2.m1.2.2.1.1.1.1.1.1.1.1.2.2"></sum><apply id="S2.E2.m1.2.2.1.1.1.1.1.1.1.1.2.3.cmml" xref="S2.E2.m1.2.2.1.1.1.1.1.1.1.1.2.3"><in id="S2.E2.m1.2.2.1.1.1.1.1.1.1.1.2.3.1.cmml" xref="S2.E2.m1.2.2.1.1.1.1.1.1.1.1.2.3.1"></in><ci id="S2.E2.m1.2.2.1.1.1.1.1.1.1.1.2.3.2.cmml" xref="S2.E2.m1.2.2.1.1.1.1.1.1.1.1.2.3.2">𝑘</ci><apply id="S2.E2.m1.2.2.1.1.1.1.1.1.1.1.2.3.3.cmml" xref="S2.E2.m1.2.2.1.1.1.1.1.1.1.1.2.3.3"><csymbol cd="ambiguous" id="S2.E2.m1.2.2.1.1.1.1.1.1.1.1.2.3.3.1.cmml" xref="S2.E2.m1.2.2.1.1.1.1.1.1.1.1.2.3.3">subscript</csymbol><ci id="S2.E2.m1.2.2.1.1.1.1.1.1.1.1.2.3.3.2.cmml" xref="S2.E2.m1.2.2.1.1.1.1.1.1.1.1.2.3.3.2">𝑆</ci><ci id="S2.E2.m1.2.2.1.1.1.1.1.1.1.1.2.3.3.3.cmml" xref="S2.E2.m1.2.2.1.1.1.1.1.1.1.1.2.3.3.3">𝑡</ci></apply></apply></apply><apply id="S2.E2.m1.2.2.1.1.1.1.1.1.1.1.1.2.cmml" xref="S2.E2.m1.2.2.1.1.1.1.1.1.1.1.1.1"><ci id="S2.E2.m1.1.1.cmml" xref="S2.E2.m1.1.1">sgn</ci><apply id="S2.E2.m1.2.2.1.1.1.1.1.1.1.1.1.1.1.1.cmml" xref="S2.E2.m1.2.2.1.1.1.1.1.1.1.1.1.1.1.1"><csymbol cd="ambiguous" id="S2.E2.m1.2.2.1.1.1.1.1.1.1.1.1.1.1.1.1.cmml" xref="S2.E2.m1.2.2.1.1.1.1.1.1.1.1.1.1.1.1">superscript</csymbol><apply id="S2.E2.m1.2.2.1.1.1.1.1.1.1.1.1.1.1.1.2.cmml" xref="S2.E2.m1.2.2.1.1.1.1.1.1.1.1.1.1.1.1"><csymbol cd="ambiguous" id="S2.E2.m1.2.2.1.1.1.1.1.1.1.1.1.1.1.1.2.1.cmml" xref="S2.E2.m1.2.2.1.1.1.1.1.1.1.1.1.1.1.1">subscript</csymbol><ci id="S2.E2.m1.2.2.1.1.1.1.1.1.1.1.1.1.1.1.2.2.cmml" xref="S2.E2.m1.2.2.1.1.1.1.1.1.1.1.1.1.1.1.2.2">Δ</ci><ci id="S2.E2.m1.2.2.1.1.1.1.1.1.1.1.1.1.1.1.2.3.cmml" xref="S2.E2.m1.2.2.1.1.1.1.1.1.1.1.1.1.1.1.2.3">𝑡</ci></apply><ci id="S2.E2.m1.2.2.1.1.1.1.1.1.1.1.1.1.1.1.3.cmml" xref="S2.E2.m1.2.2.1.1.1.1.1.1.1.1.1.1.1.1.3">𝑘</ci></apply></apply></apply></apply></apply></apply></apply></annotation-xml><annotation encoding="application/x-tex" id="S2.E2.m1.2c">w_{t+1}=w_{t}+\eta\big{(}\operatorname{sgn}\sum_{k\in S_{t}}\operatorname{sgn}(\Delta_{t}^{k})\big{)},</annotation></semantics></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr></tbody>
</table>
<p id="S2.SS1.p5.1" class="ltx_p">where <math id="S2.SS1.p5.1.m1.1" class="ltx_Math" alttext="\operatorname{sgn}" display="inline"><semantics id="S2.SS1.p5.1.m1.1a"><mi id="S2.SS1.p5.1.m1.1.1" xref="S2.SS1.p5.1.m1.1.1.cmml">sgn</mi><annotation-xml encoding="MathML-Content" id="S2.SS1.p5.1.m1.1b"><ci id="S2.SS1.p5.1.m1.1.1.cmml" xref="S2.SS1.p5.1.m1.1.1">sgn</ci></annotation-xml><annotation encoding="application/x-tex" id="S2.SS1.p5.1.m1.1c">\operatorname{sgn}</annotation></semantics></math> is the element-wise sign operation.</p>
</div>
<div id="S2.SS1.p6" class="ltx_para">
<p id="S2.SS1.p6.1" class="ltx_p">In practice, rounds in FL can go on indefinitely, as new agents can keep joining the protocol, or until the model reaches some desired performance metric (e.g., accuracy) on a validation dataset maintained by the server.</p>
</div>
</section>
<section id="S2.SS2" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">2.2. </span>Backdoor Attacks and Model Poisoning</h3>

<div id="S2.SS2.p1" class="ltx_para">
<p id="S2.SS2.p1.1" class="ltx_p">Training time attacks against machine learning models can roughly be classified into two categories: targeted <cite class="ltx_cite ltx_citemacro_citep">(Bhagoji et al<span class="ltx_text">.</span>, <a href="#bib.bib6" title="" class="ltx_ref">2019</a>; Bagdasaryan et al<span class="ltx_text">.</span>, <a href="#bib.bib4" title="" class="ltx_ref">2020</a>; Chen
et al<span class="ltx_text">.</span>, <a href="#bib.bib10" title="" class="ltx_ref">2017</a>; Liu et al<span class="ltx_text">.</span>, <a href="#bib.bib20" title="" class="ltx_ref">2018</a>)</cite>, and untargeted attacks <cite class="ltx_cite ltx_citemacro_citep">(Blanchard et al<span class="ltx_text">.</span>, <a href="#bib.bib7" title="" class="ltx_ref">2017</a>; Bernstein et al<span class="ltx_text">.</span>, <a href="#bib.bib5" title="" class="ltx_ref">2018</a>)</cite>.
In untargeted attacks, the adversarial task is to make the model converge to a sub-optimal minima, or to make the model completely diverge. Such attacks have been also referred as <em id="S2.SS2.p1.1.1" class="ltx_emph ltx_font_italic">convergence attacks</em>, and to some extend, they are easily detectable by observing the model’s accuracy on a validation data.</p>
</div>
<div id="S2.SS2.p2" class="ltx_para">
<p id="S2.SS2.p2.1" class="ltx_p">On the other hand, in targeted attacks, adversary wants the model to misclassify only a set of chosen samples while minimally affecting its performance on the main task. Such targeted attacks are also known as <em id="S2.SS2.p2.1.1" class="ltx_emph ltx_font_italic">backdoor attacks</em>. A prominent way of carrying backdoor attacks is through <em id="S2.SS2.p2.1.2" class="ltx_emph ltx_font_italic">trojans</em> <cite class="ltx_cite ltx_citemacro_citep">(Chen
et al<span class="ltx_text">.</span>, <a href="#bib.bib10" title="" class="ltx_ref">2017</a>; Liu et al<span class="ltx_text">.</span>, <a href="#bib.bib20" title="" class="ltx_ref">2018</a>)</cite>. A trojan is a carefully crafted pattern that is leveraged to cause the desired misclassification. For example, consider a classification task over cars and planes and let the adversarial task be making the model classify blue cars as planes. Then, adversary could craft a brand logo, put it on <em id="S2.SS2.p2.1.3" class="ltx_emph ltx_font_italic">some</em> of the blue car samples in the training dataset, and only mislabel those as plane. Then, potentially, model would learn to classify blue cars with the brand logo as plane. At the inference time, adversary can present a blue car sample with the logo to the model to activate the backdoor. Ideally, since the model would behave correctly on blue cars that do not have the trojan, it would not be easy to detect the backdoor on a clean validation dataset.</p>
</div>
<div id="S2.SS2.p3" class="ltx_para">
<p id="S2.SS2.p3.1" class="ltx_p">In FL, the training data is decentralized and the aggregation server is only exposed to model updates. Given that, backdoor attacks are typically carried by constructing malicious updates. That is, adversary tries to create an update that encodes the backdoor in a way such that, when it is aggregated with other updates, the aggregated model exhibits the backdoor. This has been referred as <em id="S2.SS2.p3.1.1" class="ltx_emph ltx_font_italic">model poisoning</em> attack <cite class="ltx_cite ltx_citemacro_citep">(Bhagoji et al<span class="ltx_text">.</span>, <a href="#bib.bib6" title="" class="ltx_ref">2019</a>; Bagdasaryan et al<span class="ltx_text">.</span>, <a href="#bib.bib4" title="" class="ltx_ref">2020</a>; Sun
et al<span class="ltx_text">.</span>, <a href="#bib.bib33" title="" class="ltx_ref">2019</a>)</cite>. For example, an adversary could control some of the participating agents in a FL instance, and train their local models on trojaned datasets to construct malicious updates.</p>
</div>
</section>
<section id="S2.SS3" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">2.3. </span>Blockchain</h3>

<div id="S2.SS3.p1" class="ltx_para">
<p id="S2.SS3.p1.1" class="ltx_p">Blockchain was first introduced by Nakamato as the underlying ledger of the now famous Bitcoin cryptocurrency <cite class="ltx_cite ltx_citemacro_citep">(Nakamoto, <a href="#bib.bib26" title="" class="ltx_ref">2009</a>)</cite>. Briefly, a blockchain is an append-only, distributed and replicated database. It allows the participants of a network to collectively maintain a sequence of data in a tamper-resilient way. More importantly, it does so without a requirement for a trusted third party by invoking a consensus mechanism.</p>
</div>
<div id="S2.SS3.p2" class="ltx_para">
<p id="S2.SS3.p2.1" class="ltx_p">Informally, a blockchain network operates as follows: participants broadcast their data, and certain nodes called <em id="S2.SS3.p2.1.1" class="ltx_emph ltx_font_italic">miners</em> (or <em id="S2.SS3.p2.1.2" class="ltx_emph ltx_font_italic">validators</em>) gather, and store the data they receive in wrapper structures called <em id="S2.SS3.p2.1.3" class="ltx_emph ltx_font_italic">blocks</em>. Through a consensus mechanism, the network elects a leader miner in a decentralized fashion for a sequence of epochs. The epoch leader broadcast his block to the network and, having received the leaders block, other nodes store it in their local memory where each block maintains a hash-link to the previous block.</p>
</div>
<div id="S2.SS3.p3" class="ltx_para">
<p id="S2.SS3.p3.1" class="ltx_p">The consensus algorithm that the blockchain network deploys may depend on whether or not the network is <em id="S2.SS3.p3.1.1" class="ltx_emph ltx_font_italic">public</em>.
For example, Bitcoin operates on a public network, where anyone is free to join and there is no uniform view of the network across participants. It utilizes a cryptographic puzzle called Proof-of-Work <cite class="ltx_cite ltx_citemacro_citep">(Jakobsson and
Juels, <a href="#bib.bib16" title="" class="ltx_ref">1999</a>)</cite> to achieve consensus. This makes tampering with the order of blocks computationally infeasible when the majority of the network participants follow the protocol honestly. In <em id="S2.SS3.p3.1.2" class="ltx_emph ltx_font_italic">private</em> networks however, participants can employ more efficient consensus algorithms, such as PBFT <cite class="ltx_cite ltx_citemacro_citep">(Castro and Liskov, <a href="#bib.bib9" title="" class="ltx_ref">2002</a>)</cite>. This is because the identity and number of participants are known to every party, as access to the such networks can be arbitrarily restricted.</p>
</div>
<div id="S2.SS3.p4" class="ltx_para">
<p id="S2.SS3.p4.1" class="ltx_p">We provide examples for a private, and a public blockchain below, and note that there exists also hybrid architectures (as in this work), that combine both public, and private blockchains.</p>
</div>
<section id="S2.SS3.SSS1" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">2.3.1. </span>Private Blockchain: Hyperledger Fabric</h4>

<div id="S2.SS3.SSS1.p1" class="ltx_para">
<p id="S2.SS3.SSS1.p1.1" class="ltx_p">Hyperledger <cite class="ltx_cite ltx_citemacro_citep">(Androulaki et al<span class="ltx_text">.</span>, <a href="#bib.bib3" title="" class="ltx_ref">2018</a>)</cite> is the umbrella project for many open source blockchains. Hyperledger Fabric, a permissioned blockchain is one amongst many blockchains that holds properties like identifiable participants, high transaction throughput performance <cite class="ltx_cite ltx_citemacro_citep">(Hao
et al<span class="ltx_text">.</span>, <a href="#bib.bib15" title="" class="ltx_ref">2018</a>)</cite>, low latency of transaction <cite class="ltx_cite ltx_citemacro_citep">(Pongnumkul et al<span class="ltx_text">.</span>, <a href="#bib.bib29" title="" class="ltx_ref">2017</a>)</cite> confirmation alongside privacy and confidentiality of transactions. Hyperledger promotes the usage of smart contracts called chaincode and pluggable consensus models for the confirmation of the underlying transactions committed on the ledger. The transaction orders are maintained and are visible to all peers participating on the network.</p>
</div>
</section>
<section id="S2.SS3.SSS2" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">2.3.2. </span>Public Blockchain: Ethereum</h4>

<div id="S2.SS3.SSS2.p1" class="ltx_para">
<p id="S2.SS3.SSS2.p1.1" class="ltx_p">Ethereum <cite class="ltx_cite ltx_citemacro_citep">(Wood, <a href="#bib.bib34" title="" class="ltx_ref">[n.d.]</a>)</cite>, also possess the capability to host smart contracts. However, the smart contracts published are public due to the permissionless nature of the blockchain making every transaction transparent. Each ethereum smart contract and participant have an account of its own. Ether, being the hosted cryptocurrency on the ethereum chain is required to publish contracts, call functions and send transactions over the chain. This currency is stored in a wallet possessed by every participant on the blockchain and is spent in the form of Gas to make smart contract calls. Ethereum, however, offers low transaction throughput and high latency on transaction confirmation.</p>
</div>
</section>
</section>
</section>
<section id="S3" class="ltx_section">
<h2 class="ltx_title ltx_title_section">
<span class="ltx_tag ltx_tag_section">3. </span>System Architecture</h2>

<div id="S3.p1" class="ltx_para">
<p id="S3.p1.1" class="ltx_p">In this paper, we propose a practical system architecture that allows any Federated Learning algorithm to run efficiently and securely while enabling auditability. Our solution maintains a multi-factor approach to securely detect the potential trojan introduced in the model over time and penalize the offending parties. There are many components to the system, each playing a critical role to accomplish the comprehensive goal.
</p>
</div>
<section id="S3.SS1" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">3.1. </span>Framework Setup</h3>

<div id="S3.SS1.p1" class="ltx_para">
<p id="S3.SS1.p1.1" class="ltx_p">The overall <span id="S3.SS1.p1.1.1" class="ltx_text ltx_font_sansserif">BlockFLA</span> framework assumes each participant trains the model on their local machine or on a separate Virtual Machine in the cloud. This assumption eliminates the expense of training the model on the chain and enhances data privacy. Alongside training the model locally, we consider the network to be an established TCP connection between the participants and the aggregation server, thus eliminating the overhead for establishing a connection every time an event happens.
Furthermore, the number of parameters sent by each mini-batch gradient epoch is an arbitrary number.
There is no trusted server to perform any operations locally. All operations pertaining to inter-blockchain transactions are performed from any node that hosts the private blockchain and that could be either a worker node or an endorser node.
</p>
</div>
</section>
<section id="S3.SS2" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">3.2. </span>On-Chain Aggregation</h3>

<div id="S3.SS2.p1" class="ltx_para">
<p id="S3.SS2.p1.1" class="ltx_p">In order to attain a true distributed nature of the Federated Learning algorithms, we allow the training of the model to happen off the chain by individual worker nodes participating in the convergence process.
The primary advantage to execute the model training process off the chain is that individual worker nodes can provision their own computing power to dispatch the deep learning parameters to the server. We treat each worker node as individual entities sharing the common interest to get rewarded for training the model.
</p>
</div>
<div id="S3.SS2.p2" class="ltx_para">
<p id="S3.SS2.p2.1" class="ltx_p">The server in the Federated Learning setting is represented by the Private Blockchain that performs the aggregation and sends the global updates back to the worker.
As mentioned earlier, we perform all worker-blockchain communication with the help of a smart contract deployed on the private blockchain. The private blockchain is hosted on the same network as each worker node. Since this is a private blockchain, each account is issued by an authority.
In this case, the node that sets up the private blockchain behaves as the ultimate authority providing membership to each worker node. Certificates are issued which are signed by the sever Certificate Authority (CA) for the worker nodes to send and receive parameters from the server by maintaining a TLS connection over SSL.
The worker will then wait post upload of the parameter to the private blockchain until it receives a response from the chaincode in the form of aggregated parameters.
On collection of the aggregated parameters, the worker moves to the next iteration to retrain its model and resend the updated parameters.
</p>
</div>
<div id="S3.SS2.p3" class="ltx_para">
<p id="S3.SS2.p3.1" class="ltx_p">The server being the on chain entity will wait until each worker node has sent the model parameters. Once an update is received from every worker node, the server/private blockchain will confirm the integrity of each instance of the parameters received. The main factors checked would include the size of the update, the type of the update received and whether the sender has used the appropriate credentials to send the update.</p>
</div>
<div id="S3.SS2.p4" class="ltx_para">
<p id="S3.SS2.p4.1" class="ltx_p">This ends up in the server/private blockchain to conduct formation of the aggregated parameter and the blockchain will send the update to each worker node, triggering an event on the worker node to initiate the next iteration using the updated aggregate.</p>
</div>
<div id="S3.SS2.p5" class="ltx_para">
<p id="S3.SS2.p5.1" class="ltx_p">The system architecture illustrated in Figure <a href="#S3.F1" title="Figure 1 ‣ 3.2. On-Chain Aggregation ‣ 3. System Architecture ‣ BlockFLA: Accountable Federated Learning via Hybrid Blockchain Architecture" class="ltx_ref"><span class="ltx_text ltx_ref_tag">1</span></a> shows 4 worker nodes as an example participating in the Federated Learning process and generating updates in the form of parameters locally. Step 1A involves sending the local updates/parameters to the private chain and are also being logged to the secure cloud simultaneously. Logging of local updates to the secure cloud is discussed in section <a href="#S3.SS5" title="3.5. Log Scheme in Secure Cloud ‣ 3. System Architecture ‣ BlockFLA: Accountable Federated Learning via Hybrid Blockchain Architecture" class="ltx_ref"><span class="ltx_text ltx_ref_tag">3.5</span></a>. Step 1B includes sending the corresponding generated SHA256 hashes of the local updates to the public blockchain for verification purposes and the motivation for this is discussed in section <a href="#S3.SS3" title="3.3. Verification over Public Ledger ‣ 3. System Architecture ‣ BlockFLA: Accountable Federated Learning via Hybrid Blockchain Architecture" class="ltx_ref"><span class="ltx_text ltx_ref_tag">3.3</span></a>. Aggregation of all the local updates are being done in the private blockchain to generate a global model. Finally in Step 3, the global update in the form of aggregated parameters are being sent back to each worker node for the next epoch.</p>
</div>
<figure id="S3.F1" class="ltx_figure"><img src="/html/2010.07427/assets/signSGD.png" id="S3.F1.g1" class="ltx_graphics ltx_centering ltx_img_square" width="299" height="268" alt="Refer to caption">
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure"><span id="S3.F1.3.1.1" class="ltx_text" style="font-size:90%;">Figure 1</span>. </span><span id="S3.F1.4.2" class="ltx_text ltx_font_bold" style="font-size:90%;">Federated Learning over Blockchain: Architecture Diagram <span id="S3.F1.4.2.1" class="ltx_text ltx_font_medium"> </span></span></figcaption>
</figure>
</section>
<section id="S3.SS3" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">3.3. </span>Verification over Public Ledger</h3>

<div id="S3.SS3.p1" class="ltx_para">
<p id="S3.SS3.p1.1" class="ltx_p">The other crucial component of the <span id="S3.SS3.p1.1.1" class="ltx_text ltx_font_sansserif">BlockFLA</span> system is the involvement of the public blockchain. Our verification system over the public blockchain is in the form of a smart contract visible to all.
Every worker node on the private chain has an account on the public chain. The private blockchain maintains a one-to-one mapping of accounts on the private chain to their corresponding accounts on the public chain. Each worker must possess a wallet on the public chain with sufficient crypto-currency or transaction money to call the smart contract functions when sending updates.</p>
</div>
<div id="S3.SS3.p2" class="ltx_para">
<p id="S3.SS3.p2.1" class="ltx_p">The purpose of the smart contract deployed on the public ledger is three fold.</p>
<ol id="S3.I1" class="ltx_enumerate">
<li id="S3.I1.i1" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">a)</span> 
<div id="S3.I1.i1.p1" class="ltx_para">
<p id="S3.I1.i1.p1.1" class="ltx_p">Storage of SHA256 Hashes of sent parameters</p>
</div>
</li>
<li id="S3.I1.i2" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">b)</span> 
<div id="S3.I1.i2.p1" class="ltx_para">
<p id="S3.I1.i2.p1.1" class="ltx_p">Verification function to validate whether a participant or a subset of participants have cheated in any fashion.</p>
</div>
</li>
<li id="S3.I1.i3" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">c)</span> 
<div id="S3.I1.i3.p1" class="ltx_para">
<p id="S3.I1.i3.p1.1" class="ltx_p">Deposit and penalty orchestration</p>
</div>
</li>
</ol>
</div>
<div id="S3.SS3.p3" class="ltx_para">
<p id="S3.SS3.p3.1" class="ltx_p">The smart contract hosts an array per worker node to store the cryptographic (i.e., SHA256) hashes of <span id="S3.SS3.p3.1.1" class="ltx_text ltx_font_italic">each parameter set</span> sent to the private blockchain based server.
The hash value is calculated individually by each worker node off the chain on their own local machine and sent to the public smart contract as shown in Step 1B of Figure <a href="#S3.F1" title="Figure 1 ‣ 3.2. On-Chain Aggregation ‣ 3. System Architecture ‣ BlockFLA: Accountable Federated Learning via Hybrid Blockchain Architecture" class="ltx_ref"><span class="ltx_text ltx_ref_tag">1</span></a>. The primary purpose served here is for any worker to hold any offending worker nodes accountable in the case a trojan is detected. As the public chain is transparent and immutable, the worker node can merely download the SHA256, retrieve a recreated SHA256 from the parameter store on the private chain and verify if the SHA256 stored on the public chain matches the private chain created SHA256.</p>
</div>
<div id="S3.SS3.p4" class="ltx_para">
<p id="S3.SS3.p4.1" class="ltx_p">As shown in Figure <a href="#S3.F2" title="Figure 2 ‣ 3.3. Verification over Public Ledger ‣ 3. System Architecture ‣ BlockFLA: Accountable Federated Learning via Hybrid Blockchain Architecture" class="ltx_ref"><span class="ltx_text ltx_ref_tag">2</span></a>, If in case, the SHA256 does not match, then a penalty is administered based on the penalty structure illustrated in the following section.</p>
</div>
<figure id="S3.F2" class="ltx_figure"><img src="/html/2010.07427/assets/signSGD_Penalty.png" id="S3.F2.g1" class="ltx_graphics ltx_centering ltx_img_square" width="299" height="261" alt="Refer to caption">
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure"><span id="S3.F2.3.1.1" class="ltx_text" style="font-size:90%;">Figure 2</span>. </span><span id="S3.F2.4.2" class="ltx_text ltx_font_bold" style="font-size:90%;">Breach Adjudications and Penalty Concept of Operations <span id="S3.F2.4.2.1" class="ltx_text ltx_font_medium"> </span></span></figcaption>
</figure>
</section>
<section id="S3.SS4" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">3.4. </span>Penalty structure</h3>

<div id="S3.SS4.p1" class="ltx_para">
<p id="S3.SS4.p1.1" class="ltx_p">The main incentive for worker nodes for participating as a model trainer in any Federated Learning algorithm is monetary <cite class="ltx_cite ltx_citemacro_citep">(Desai et al<span class="ltx_text">.</span>, <a href="#bib.bib11" title="" class="ltx_ref">2018</a>)</cite>. This monetary benefit is fulfilled in the form of crypto-currency. For the purpose of participating as a worker in the Federated Learning process, each node must possess a crypto wallet and submit a deposit over the public chain. This deposit is returned to the worker at completion when convergence of the model is attained. An award is also dispatched to each worker for participating honestly. This award is coupled with a variable reimbursement to each worker that depends on the average time taken to send the model parameters to the server for aggregation. The faster the parameters are sent, the greater the award.</p>
</div>
<div id="S3.SS4.p2" class="ltx_para">
<p id="S3.SS4.p2.1" class="ltx_p">Although, if a worker is caught sending an update to introduce trojan by any other worker node as discussed in section <a href="#S3.SS5.SSS2" title="3.5.2. Anomaly alert policy ‣ 3.5. Log Scheme in Secure Cloud ‣ 3. System Architecture ‣ BlockFLA: Accountable Federated Learning via Hybrid Blockchain Architecture" class="ltx_ref"><span class="ltx_text ltx_ref_tag">3.5.2</span></a>, the deposit is lost and redistributed to the remaining worker nodes. For that reason, every worker node also has the opportunity to raise an alarm if a breach has occurred. On suspecting a breach over the public chain, a new verification contract is created and checks whether the accused actually has breached the terms of contract as shown in Figure <a href="#S3.F2" title="Figure 2 ‣ 3.3. Verification over Public Ledger ‣ 3. System Architecture ‣ BlockFLA: Accountable Federated Learning via Hybrid Blockchain Architecture" class="ltx_ref"><span class="ltx_text ltx_ref_tag">2</span></a>. If the breach is confirmed, then the suspect loses their deposit. If no violation is confirmed, the accuser loses their deposit. This prevents unnecessary breach violation claims which may lock funds on the public chain indefinitely.</p>
</div>
</section>
<section id="S3.SS5" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">3.5. </span>Log Scheme in Secure Cloud</h3>

<div id="S3.SS5.p1" class="ltx_para">
<p id="S3.SS5.p1.1" class="ltx_p">Logs are necessary to ensure / reinforce trojan detection.
There are two important aspects with which the logging mechanism may be able to catch the perpetrator early in the process.
</p>
</div>
<section id="S3.SS5.SSS1" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">3.5.1. </span>Log Publication</h4>

<div id="S3.SS5.SSS1.p1" class="ltx_para">
<p id="S3.SS5.SSS1.p1.1" class="ltx_p">Logs are published to the secure cloud after every epoch by each worker node as shown in Figure <a href="#S3.F1" title="Figure 1 ‣ 3.2. On-Chain Aggregation ‣ 3. System Architecture ‣ BlockFLA: Accountable Federated Learning via Hybrid Blockchain Architecture" class="ltx_ref"><span class="ltx_text ltx_ref_tag">1</span></a>.
The logs are stored in a filesystem based on a secure cloud infrastructure where each worker has its own unique location to publish and after every epoch, the location will have the test classification results from the aggregated parameters excluding that worker node. The logs include the following data:</p>
<ol id="S3.I2" class="ltx_enumerate">
<li id="S3.I2.i1" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">a)</span> 
<div id="S3.I2.i1.p1" class="ltx_para">
<p id="S3.I2.i1.p1.1" class="ltx_p">Uploaded parameters of each worker node</p>
</div>
</li>
<li id="S3.I2.i2" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">b)</span> 
<div id="S3.I2.i2.p1" class="ltx_para">
<p id="S3.I2.i2.p1.1" class="ltx_p">Test classification results at each epoch after aggregating parameters by excluding the parameters uploaded by that worker.</p>
</div>
</li>
</ol>
</div>
</section>
<section id="S3.SS5.SSS2" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">3.5.2. </span>Anomaly alert policy</h4>

<div id="S3.SS5.SSS2.p1" class="ltx_para">
<p id="S3.SS5.SSS2.p1.1" class="ltx_p">Whenever a participant suspects a breach, he/she will suspect by calling the public smart contract that holds the SHA256 Hashes of every local update made by every worker. Depending on the input of confirmation from the private blockchain, if the private blockchain is able to generate the SHA256 hashes from the local updates that match the one on the public smart contract, then the suspect was honest in uploading the parameters.
</p>
</div>
<div id="S3.SS5.SSS2.p2" class="ltx_para">
<p id="S3.SS5.SSS2.p2.1" class="ltx_p"><em id="S3.SS5.SSS2.p2.1.1" class="ltx_emph ltx_font_italic">Now, for trojan detection, the private blockchain will provide a one-time link access to the location of the logs for the suspect on the secure cloud. The participant will be allowed to download the logs that contain the local parameter updates of the accused party and run the trojan detection algorithm as discussed in section <a href="#S3.SS6" title="3.6. An Attacker Detection Algorithm for Trojaning Attacks ‣ 3. System Architecture ‣ BlockFLA: Accountable Federated Learning via Hybrid Blockchain Architecture" class="ltx_ref"><span class="ltx_text ltx_ref_tag">3.6</span></a>. If the trojan is detected, then the suspect will be penalized according to the penalty structure as discussed in section <a href="#S3.SS4" title="3.4. Penalty structure ‣ 3. System Architecture ‣ BlockFLA: Accountable Federated Learning via Hybrid Blockchain Architecture" class="ltx_ref"><span class="ltx_text ltx_ref_tag">3.4</span></a>.</em></p>
</div>
</section>
</section>
<section id="S3.SS6" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">3.6. </span>An Attacker Detection Algorithm for Trojaning Attacks</h3>

<div id="S3.SS6.p1" class="ltx_para">
<p id="S3.SS6.p1.1" class="ltx_p">We now describe a sample attacker detection algorithm, particularly designed for detecting adversaries who run pixel-pattern backdoor attacks, i.e., trojaning (cf. Figure <a href="#S6.F6" title="Figure 6 ‣ 6.3. Performance of our Attacker Detection Algorithm ‣ 6. Experimental Evaluation ‣ BlockFLA: Accountable Federated Learning via Hybrid Blockchain Architecture" class="ltx_ref"><span class="ltx_text ltx_ref_tag">6</span></a>). However, recall that, <span id="S3.SS6.p1.1.1" class="ltx_text ltx_font_italic"> our framework allows a developer to plug any kind of detection algorithm, or even multiple detection algorithms against different types of attacks, into his system</span>. <em id="S3.SS6.p1.1.2" class="ltx_emph ltx_font_italic">We developed this algorithm for sake of completeness, and to highlight what kind of detection algorithms can be used with our framework.</em>
Recall that, in trojaning attacks, the adversarial task is to make the model misclassify instances from a <em id="S3.SS6.p1.1.3" class="ltx_emph ltx_font_italic">base class</em> as <em id="S3.SS6.p1.1.4" class="ltx_emph ltx_font_italic">target class</em> by using trojan patterns. To do so, an adversarial agent can simply corrupt his dataset by adding the trojan pattern to his base class instances, relabel them as the target class, and construct malicious updates by training on the corrupted dataset.</p>
</div>
<div id="S3.SS6.p2" class="ltx_para">
<p id="S3.SS6.p2.1" class="ltx_p">In what follows, we assume that the honest participants (i.e., verifiers) has access to <em id="S3.SS6.p2.1.1" class="ltx_emph ltx_font_italic">the backdoored model</em>, <em id="S3.SS6.p2.1.2" class="ltx_emph ltx_font_italic">the trojan pattern</em>, and the information of <em id="S3.SS6.p2.1.3" class="ltx_emph ltx_font_italic">base and the target class</em> used by the adversary. Also verifiers have access to the updates of agents that are sent during the execution of FL, as the updates are logged in the secure cloud (cf. Figure <a href="#S3.F1" title="Figure 1 ‣ 3.2. On-Chain Aggregation ‣ 3. System Architecture ‣ BlockFLA: Accountable Federated Learning via Hybrid Blockchain Architecture" class="ltx_ref"><span class="ltx_text ltx_ref_tag">1</span></a>).</p>
</div>
<div id="S3.SS6.p3" class="ltx_para">
<p id="S3.SS6.p3.4" class="ltx_p">The key idea behind our detection algorithm is to do <em id="S3.SS6.p3.4.1" class="ltx_emph ltx_font_italic">parameter attribution</em> by computing the empirical Fisher Information Matrix (FIM) as done  <cite class="ltx_cite ltx_citemacro_citep">(Shoham et al<span class="ltx_text">.</span>, <a href="#bib.bib32" title="" class="ltx_ref">2019</a>; Ozdayi
et al<span class="ltx_text">.</span>, <a href="#bib.bib27" title="" class="ltx_ref">2020</a>)</cite>. At a high level, a verifier first creates a poisoned validation set using the trojan pattern of the adversary. That is, he extracts base class instances from a clean validation dataset, adds them the trojan pattern and relabels them as the target class. He then replays the training process using the logged updates. After each round, he computes the backdoor loss on the poisoned validation dataset using the aggregated model. Then, for rounds in which backdoor loss decreases, the verifier does parameter attribution via FIM on the aggregated model using the poisoned validation dataset. This allows the verifier to list the parameters of the model in order of importance for the backdoor task, so she can identify the top-<math id="S3.SS6.p3.1.m1.1" class="ltx_Math" alttext="\kappa" display="inline"><semantics id="S3.SS6.p3.1.m1.1a"><mi id="S3.SS6.p3.1.m1.1.1" xref="S3.SS6.p3.1.m1.1.1.cmml">κ</mi><annotation-xml encoding="MathML-Content" id="S3.SS6.p3.1.m1.1b"><ci id="S3.SS6.p3.1.m1.1.1.cmml" xref="S3.SS6.p3.1.m1.1.1">𝜅</ci></annotation-xml><annotation encoding="application/x-tex" id="S3.SS6.p3.1.m1.1c">\kappa</annotation></semantics></math> most important parameters for the backdoor task (where <math id="S3.SS6.p3.2.m2.1" class="ltx_Math" alttext="\kappa" display="inline"><semantics id="S3.SS6.p3.2.m2.1a"><mi id="S3.SS6.p3.2.m2.1.1" xref="S3.SS6.p3.2.m2.1.1.cmml">κ</mi><annotation-xml encoding="MathML-Content" id="S3.SS6.p3.2.m2.1b"><ci id="S3.SS6.p3.2.m2.1.1.cmml" xref="S3.SS6.p3.2.m2.1.1">𝜅</ci></annotation-xml><annotation encoding="application/x-tex" id="S3.SS6.p3.2.m2.1c">\kappa</annotation></semantics></math> is a hyperparameter). Finally, the developer then measures and records the <math id="S3.SS6.p3.3.m3.1" class="ltx_Math" alttext="L_{2}" display="inline"><semantics id="S3.SS6.p3.3.m3.1a"><msub id="S3.SS6.p3.3.m3.1.1" xref="S3.SS6.p3.3.m3.1.1.cmml"><mi id="S3.SS6.p3.3.m3.1.1.2" xref="S3.SS6.p3.3.m3.1.1.2.cmml">L</mi><mn id="S3.SS6.p3.3.m3.1.1.3" xref="S3.SS6.p3.3.m3.1.1.3.cmml">2</mn></msub><annotation-xml encoding="MathML-Content" id="S3.SS6.p3.3.m3.1b"><apply id="S3.SS6.p3.3.m3.1.1.cmml" xref="S3.SS6.p3.3.m3.1.1"><csymbol cd="ambiguous" id="S3.SS6.p3.3.m3.1.1.1.cmml" xref="S3.SS6.p3.3.m3.1.1">subscript</csymbol><ci id="S3.SS6.p3.3.m3.1.1.2.cmml" xref="S3.SS6.p3.3.m3.1.1.2">𝐿</ci><cn type="integer" id="S3.SS6.p3.3.m3.1.1.3.cmml" xref="S3.SS6.p3.3.m3.1.1.3">2</cn></apply></annotation-xml><annotation encoding="application/x-tex" id="S3.SS6.p3.3.m3.1c">L_{2}</annotation></semantics></math> norm of each agent’s update for these <math id="S3.SS6.p3.4.m4.1" class="ltx_Math" alttext="\kappa" display="inline"><semantics id="S3.SS6.p3.4.m4.1a"><mi id="S3.SS6.p3.4.m4.1.1" xref="S3.SS6.p3.4.m4.1.1.cmml">κ</mi><annotation-xml encoding="MathML-Content" id="S3.SS6.p3.4.m4.1b"><ci id="S3.SS6.p3.4.m4.1.1.cmml" xref="S3.SS6.p3.4.m4.1.1">𝜅</ci></annotation-xml><annotation encoding="application/x-tex" id="S3.SS6.p3.4.m4.1c">\kappa</annotation></semantics></math> parameters.</p>
</div>
<div id="S3.SS6.p4" class="ltx_para">
<p id="S3.SS6.p4.2" class="ltx_p">The intuition is, <em id="S3.SS6.p4.2.1" class="ltx_emph ltx_font_italic">when backdoor loss decreases, we would expect the attackers contribution to be larger than contribution of honest agents for the most important backdoor task parameters.</em> Then, by looking at the average of recorded <math id="S3.SS6.p4.1.m1.1" class="ltx_Math" alttext="L_{2}" display="inline"><semantics id="S3.SS6.p4.1.m1.1a"><msub id="S3.SS6.p4.1.m1.1.1" xref="S3.SS6.p4.1.m1.1.1.cmml"><mi id="S3.SS6.p4.1.m1.1.1.2" xref="S3.SS6.p4.1.m1.1.1.2.cmml">L</mi><mn id="S3.SS6.p4.1.m1.1.1.3" xref="S3.SS6.p4.1.m1.1.1.3.cmml">2</mn></msub><annotation-xml encoding="MathML-Content" id="S3.SS6.p4.1.m1.1b"><apply id="S3.SS6.p4.1.m1.1.1.cmml" xref="S3.SS6.p4.1.m1.1.1"><csymbol cd="ambiguous" id="S3.SS6.p4.1.m1.1.1.1.cmml" xref="S3.SS6.p4.1.m1.1.1">subscript</csymbol><ci id="S3.SS6.p4.1.m1.1.1.2.cmml" xref="S3.SS6.p4.1.m1.1.1.2">𝐿</ci><cn type="integer" id="S3.SS6.p4.1.m1.1.1.3.cmml" xref="S3.SS6.p4.1.m1.1.1.3">2</cn></apply></annotation-xml><annotation encoding="application/x-tex" id="S3.SS6.p4.1.m1.1c">L_{2}</annotation></semantics></math> norms over the rounds, and making an assumption on the number of adversarial agents, the verifier can attempt to distinguish attackers. That is, the agents that contribute most on the top-<math id="S3.SS6.p4.2.m2.1" class="ltx_Math" alttext="\kappa" display="inline"><semantics id="S3.SS6.p4.2.m2.1a"><mi id="S3.SS6.p4.2.m2.1.1" xref="S3.SS6.p4.2.m2.1.1.cmml">κ</mi><annotation-xml encoding="MathML-Content" id="S3.SS6.p4.2.m2.1b"><ci id="S3.SS6.p4.2.m2.1.1.cmml" xref="S3.SS6.p4.2.m2.1.1">𝜅</ci></annotation-xml><annotation encoding="application/x-tex" id="S3.SS6.p4.2.m2.1c">\kappa</annotation></semantics></math> important parameters for the backdoor task are likely to be adversarial. We illustrate the performance of our algorithm in Section <a href="#S3.SS6" title="3.6. An Attacker Detection Algorithm for Trojaning Attacks ‣ 3. System Architecture ‣ BlockFLA: Accountable Federated Learning via Hybrid Blockchain Architecture" class="ltx_ref"><span class="ltx_text ltx_ref_tag">3.6</span></a> via experiments.</p>
</div>
</section>
</section>
<section id="S4" class="ltx_section">
<h2 class="ltx_title ltx_title_section">
<span class="ltx_tag ltx_tag_section">4. </span>Implementation</h2>

<div id="S4.p1" class="ltx_para">
<p id="S4.p1.1" class="ltx_p">Hyperledger Fabric is a permissioned blockchain infrastructure, providing a modular architecture with a delineation of roles between the nodes in the infrastructure, execution of Smart Contracts (called ”chaincode” in Fabric) and configurable consensus and membership services <cite class="ltx_cite ltx_citemacro_citep">(Androulaki et al<span class="ltx_text">.</span>, <a href="#bib.bib3" title="" class="ltx_ref">2018</a>)</cite>. Therefore, for our implementation, the choice of private blockchain is Hyperledger fabric. The fabric infrastructure is set up on docker containers hosted on a virtual machine inside Amazon Web Services(AWS).</p>
</div>
<div id="S4.p2" class="ltx_para">
<p id="S4.p2.1" class="ltx_p">We have one top level organization in the fabric implementation that is controlled by the node that sets up the private blockchain. The organization acts as the membership service provider to issue client certificates to the participants. The chaincode written in golang incorporates the logic to accept deep learning(DL) parameters in the form of batches and store them in a key-value store on the ledger. The data structure for each worker stores the deep learning parameters in a json-based tree structure. For example, in order to store the DL parameters of worker A, we divide the parameters into N parts and store them on the chain with keys A01, A02, <math id="S4.p2.1.m1.1" class="ltx_Math" alttext="\dots" display="inline"><semantics id="S4.p2.1.m1.1a"><mi mathvariant="normal" id="S4.p2.1.m1.1.1" xref="S4.p2.1.m1.1.1.cmml">…</mi><annotation-xml encoding="MathML-Content" id="S4.p2.1.m1.1b"><ci id="S4.p2.1.m1.1.1.cmml" xref="S4.p2.1.m1.1.1">…</ci></annotation-xml><annotation encoding="application/x-tex" id="S4.p2.1.m1.1c">\dots</annotation></semantics></math> AN etc.</p>
</div>
<div id="S4.p3" class="ltx_para">
<p id="S4.p3.1" class="ltx_p">Ethereum is one the most popular public blockchain, being the second largest cryptocurrency features a smart contract functionality formed around the principle of consensus thus eliminating the possibilities of fraud, corruption and makes the network tamper-proof. Therefore, the choice of public blockchain is Ethereum Ropsten <cite class="ltx_cite ltx_citemacro_citep">(Kim et al<span class="ltx_text">.</span>, <a href="#bib.bib17" title="" class="ltx_ref">2018</a>)</cite>. We use go-ethereum node to deploy our solidity based smart contract on the public chain. Our wallet is controlled by metamask and each participant has an account inside the wallet. The server deploys the contract making it the owner. The SHA256 hashes on the smart contract is stored in the form of arrays. Each worker has their own array and each element of the array constitutes the SHA256 hash of the DL parameters uploaded to the private chain in a particular epoch.</p>
</div>
<div id="S4.p4" class="ltx_para">
<p id="S4.p4.1" class="ltx_p">We set up the hyperledger fabric framework on EBS(Elastic Block Storage) backed m5.12xlarge EC2(Elastic Cloud Compute) instances. The specification of the EC2 instance is 24 cores, 192 GiB RAM and a network bandwidth of 10 Gbps. The number of threads per core being 2, the number of vCPUs allotted for processing amounts to 48.</p>
</div>
<div id="S4.p5" class="ltx_para">
<p id="S4.p5.1" class="ltx_p">We set up parallel loading of parameters into the private chain, and parallel aggregation of parameters on the chaincode. The SHA256 converter is set up locally on all the worker nodes.</p>
</div>
<div id="S4.p6" class="ltx_para">
<p id="S4.p6.1" class="ltx_p">In this work, we implemented two of the most commonly used federated learning averaging techniques: 1) <em id="S4.p6.1.1" class="ltx_emph ltx_font_italic">signSGD</em> 2) <em id="S4.p6.1.2" class="ltx_emph ltx_font_italic">FedAvg</em> (see section <a href="#S2" title="2. Background ‣ BlockFLA: Accountable Federated Learning via Hybrid Blockchain Architecture" class="ltx_ref"><span class="ltx_text ltx_ref_tag">2</span></a> for more details).
The client application that computes the parameters for the <em id="S4.p6.1.3" class="ltx_emph ltx_font_italic">signSGD</em> or <em id="S4.p6.1.4" class="ltx_emph ltx_font_italic">FedAvg</em> alogrithm is implemented in Javascript with the help of Mxnet library. We create nodejs subroutines on the worker nodes to upload DL parameters in batches to the chaincode. A counter is implemented in the chaincode to increment its value whenever an the chaincode accepts the parameters from all the participants. No participant can upload the parameters twice in the same epoch. Once the counter’s value becomes equal to the number of participants, the aggregation function is triggered calculating the aggregation based on all the participants’ inputs.
Another nodejs subroutine is implemented to upload the SHA256 hashes generated by the converter to the Ropsten.</p>
</div>
<div id="S4.p7" class="ltx_para">
<p id="S4.p7.1" class="ltx_p">In the case of <em id="S4.p7.1.1" class="ltx_emph ltx_font_italic">signSGD</em>, each worker node trains their model locally and sending the sign of each parameter in binary form to the smart contract. For the sake of simplicity, we map a negative sign to the bit 0 and the positive sign to bit 1. In the case of <em id="S4.p7.1.2" class="ltx_emph ltx_font_italic">FedAvg</em>, each worker node trains their model locally and sends the 32 bit float/real number of each parameter in float32 form to the smart contract.</p>
</div>
<div id="S4.p8" class="ltx_para">
<p id="S4.p8.1" class="ltx_p">For <em id="S4.p8.1.1" class="ltx_emph ltx_font_italic">signSGD</em> again, the Hyperledger Fabric chain code based server then computes the majority bit received from all the workers at each i<sup id="S4.p8.1.2" class="ltx_sup">th</sup> position of the parameter. In the case of <em id="S4.p8.1.3" class="ltx_emph ltx_font_italic">FedAvg</em>, the chaincode computes the average of the parameters received from all the workers at each i<sup id="S4.p8.1.4" class="ltx_sup">th</sup> parameter.</p>
</div>
</section>
<section id="S5" class="ltx_section">
<h2 class="ltx_title ltx_title_section">
<span class="ltx_tag ltx_tag_section">5. </span>Optimization Techniques</h2>

<div id="S5.p1" class="ltx_para">
<p id="S5.p1.1" class="ltx_p">Maximizing throughput and minimizing communication overhead necessitates for the following optimization strategies we have implemented for a more reliable, practical and efficient execution of the averaging algorithm used for FL over blockchain to reach algorithmic convergence faster.
To achieve this goal, we created Nodejs subroutines to convert binary parameters to base64 parameters as a compression technique. Also, we implemented a variable thread spawning mechanism to create new chaincode to perform the upload and aggregation of parameters in parallel for optimization purposes. We discuss the details of these optimizations below.</p>
</div>
<section id="S5.SS1" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">5.1. </span>Binary compression using base64</h3>

<div id="S5.SS1.p1" class="ltx_para">
<p id="S5.SS1.p1.1" class="ltx_p">Hyperledger Fabric does not accept inputs in a binary format when workers are sending binary based models in signSGD. The binary parameters have to be sent to the fabric chaincode in a text format. Therefore to send binary input as is, the DL parameters must be sent as characters in a string.</p>
</div>
<div id="S5.SS1.p2" class="ltx_para">
<p id="S5.SS1.p2.1" class="ltx_p">For example, in signSGD, for model updates involving a DL model that has 300 million parameters, if the binary representation is converted to byte format and sent to the chaincode, we send 37.5 million bytes in the form of 75 million characters achieving a compression of 75%. This however could be improved by compressing the byte representation of the parameters into a base64 representation and decoding the base64 characters into binary on the chaincode. We use golang provided base64 decoding functions to decode the base64 inputted text into binary format. Base64 encodes 3 bytes (6 characters in a string) on 4 characters. Therefore, 37.5 million bytes (75 million characters) can be sent as 50 million base64 characters thus achieving a cumulative compression of 83.33%.
</p>
</div>
<div id="S5.SS1.p3" class="ltx_para">
<p id="S5.SS1.p3.1" class="ltx_p">With this compression, we send fewer bytes to the Hyperledger Fabric chaincode, thus reducing communication and improving efficiency for signSGD.</p>
</div>
</section>
<section id="S5.SS2" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">5.2. </span>Preventing key collisions</h3>

<div id="S5.SS2.p1" class="ltx_para">
<p id="S5.SS2.p1.1" class="ltx_p">Hyperledger Fabric’s underlying database uses Multiversion Concurrency Control(MVCC) to guarantee no double spending or inconsistency in the data occur. Therefore, an attempt to update the same state will result in a new version of the existing state being created to overwrite the old one.</p>
</div>
<div id="S5.SS2.p2" class="ltx_para">
<p id="S5.SS2.p2.1" class="ltx_p">Due to the size of the parameters being uploaded into the hyperledger fabric chaincode, we divide the input into smaller batches to avoid any throughput related errors. Hence, there is a need to parallelize sending input to the Fabric chaincode. If the uploader is not parallelized, then sequential sending of the batches will result in frequent update of the Hyperledger state. Therefore, roughly half of the transactions executed during the upload phase fail due to an MVCC related error
and the Federated Learning algorithm implementation will be in an inconsistent state.</p>
</div>
<div id="S5.SS2.p3" class="ltx_para">
<p id="S5.SS2.p3.1" class="ltx_p">Hyperledger Fabric currently has the limitation of not being able to handle MVCC conflicts and will allow the transaction to happen resulting in an error being thrown when it tries to execute. Therefore, we design our chaincode data model so that MVCC conflicts are avoided. We separate the read operations from write operations so that we can implement them as queries and invokes respectively. We modified our data model so that every new transaction writes to a completely different key, thus mitigating the problem only to a certain extent. However, we have to record deltas and as a result our updates over key A (A being a participant) would be stored by transactions in independent keys such as A01, A02, A03. The updates implemented in this approach then get aggregated and the current state of A is reflected in the next query.</p>
</div>
</section>
<section id="S5.SS3" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">5.3. </span>Architectural Improvements</h3>

<section id="S5.SS3.SSS1" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">5.3.1. </span>Increase Endorsers and Channels</h4>

<div id="S5.SS3.SSS1.p1" class="ltx_para">
<p id="S5.SS3.SSS1.p1.1" class="ltx_p">Due to usage of cloud based infrastructure and the ability to scale vCPUs, we increased the number of channels and endorsers to increase transaction throughput. We deployed multiple chaincodes on multiple channels to accept and aggregate parameters in parallel. Merely increasing the number of endorser peers do not improve efficiency. The peers are CPU-intensive and as a result have to be placed on separate VMs.</p>
</div>
</section>
<section id="S5.SS3.SSS2" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">5.3.2. </span>Usage of LevelDB</h4>

<div id="S5.SS3.SSS2.p1" class="ltx_para">
<p id="S5.SS3.SSS2.p1.1" class="ltx_p">Hyperledger Fabric deploys with LevelDB in its default setting. However, in order to have a highly available setting, CouchDB is used to maintain the state database. Although, there are benefits in using CouchDB to store binary data modeled in a chaincode and having CouchDB as an external database for resiliency, the performance of LevelDB implementation of the chaincode is significantly better than the CouchDB implementation. LevelDB is a key-value store and practical implementations of it demonstrate significant performance improvement.</p>
</div>
</section>
<section id="S5.SS3.SSS3" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">5.3.3. </span>Deploying Peers on separate nodes</h4>

<div id="S5.SS3.SSS3.p1" class="ltx_para">
<p id="S5.SS3.SSS3.p1.1" class="ltx_p">In Hyperledger Fabric, endorser peers are CPU intensive processes. If deployed in large numbers, they may significantly affect the transaction throughput performance. Orderers and Membership Service Providers / Organizations on the other hand are non-CPU intensive processes. Thus, the peers are deployed on separate Virtual Machines instead of all on one to improve the throughput. We set network bandwidth on the order of 10 Gbps in order for the transaction throughput to remain high.</p>
</div>
</section>
</section>
<section id="S5.SS4" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">5.4. </span>Cache Chaincode</h3>

<div id="S5.SS4.p1" class="ltx_para">
<p id="S5.SS4.p1.1" class="ltx_p">Cache chaincode are solely designed to terminate MVCC conflicts to avoid impairing the performance of the network. On uploading inputs to the chaincode, if an MVCC conflict occurs, the parameters can be cached onto this cache chaincode, so that it can be re-uploaded when the execution is complete.
That way, if the database goes into an inconsistent state due to an error, the cache chaincode will be used to restore the state to maintain consistency. Thus, the worker only has to upload the parameters once and rely on the chaincode architecture to maintain persistence.
</p>
</div>
<figure id="S5.F3" class="ltx_figure">
<div class="ltx_flex_figure">
<div class="ltx_flex_cell ltx_flex_size_2">
<figure id="S5.F3.sf1" class="ltx_figure ltx_figure_panel ltx_align_center"><img src="/html/2010.07427/assets/Gas_Analysis.png" id="S5.F3.sf1.g1" class="ltx_graphics ltx_centering ltx_img_landscape" width="598" height="370" alt="Refer to caption">
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure"><span id="S5.F3.sf1.3.1.1" class="ltx_text" style="font-size:90%;">(a)</span> </span><span id="S5.F3.sf1.4.2" class="ltx_text ltx_font_bold" style="font-size:90%;">Gas Analysis for SHA256 Loading over Ethereum <span id="S5.F3.sf1.4.2.1" class="ltx_text ltx_font_medium"> </span></span></figcaption>
</figure>
</div>
<div class="ltx_flex_cell ltx_flex_size_2">
<figure id="S5.F3.sf2" class="ltx_figure ltx_figure_panel ltx_align_center"><img src="/html/2010.07427/assets/Time_Analysis.png" id="S5.F3.sf2.g1" class="ltx_graphics ltx_centering ltx_img_landscape" width="598" height="370" alt="Refer to caption">
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure"><span id="S5.F3.sf2.3.1.1" class="ltx_text" style="font-size:90%;">(b)</span> </span><span id="S5.F3.sf2.4.2" class="ltx_text ltx_font_bold" style="font-size:90%;">Time Analysis for SHA256 Loading over Ethereum </span></figcaption>
</figure>
</div>
</div>
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure"><span id="S5.F3.3.1.1" class="ltx_text" style="font-size:90%;">Figure 3</span>. </span><em id="S5.F3.4.2" class="ltx_emph ltx_font_italic" style="font-size:90%;">Experimental results of Cost Analysis over Public Blockchain Ethereum.</em><span id="S5.F3.5.3" class="ltx_text" style="font-size:90%;"> </span></figcaption>
</figure>
</section>
</section>
<section id="S6" class="ltx_section">
<h2 class="ltx_title ltx_title_section">
<span class="ltx_tag ltx_tag_section">6. </span>Experimental Evaluation</h2>

<div id="S6.p1" class="ltx_para">
<p id="S6.p1.1" class="ltx_p">To assess the the <span id="S6.p1.1.1" class="ltx_text ltx_font_sansserif">BlockFLA</span> system, we experiment multiple facets of the system under different scenarios. Our experimentation is pertinent to testing the impact of integrating a hybrid blockchain setting with the Federated Averaging algorithm and SignSGD algorithm, evaluating the penalty structure and security assessment of the system. We examine the effects of parallelism, deploying multiple contracts, using disparate data structures, swapping the underlying blockchain and fiscal impacts on implementing the system.</p>
</div>
<section id="S6.SS1" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">6.1. </span>Experiment Setup</h3>

<div id="S6.SS1.p1" class="ltx_para">
<p id="S6.SS1.p1.1" class="ltx_p">We use hyperledger provided fabric docker containers to be deployed on the m5.12xlarge EC2 instance. We have metamask installed on our browsers with the connection network pointing to the Ropsten Test Network. Our Ethereum version of smart contract is published to Ropsten at address:</p>
</div>
<div id="S6.SS1.p2" class="ltx_para">
<p id="S6.SS1.p2.1" class="ltx_p">0x304095B3Af015DB179CADD70dF4BC9D1fDc1aDbc</p>
</div>
<div id="S6.SS1.p3" class="ltx_para">
<p id="S6.SS1.p3.1" class="ltx_p">We use openssl to generate self-signed Certificate Authorities (CA) and issue client certificates to the peer nodes signed by the CAs. Nodejs scripts are written to control the deployment of chaincodes and creation of channels in a command-driven routine. A nodejs script is implemented to act as the liaison between the hyperledger fabric and ethereum networks. We use etheruem smart contract auto-generation technique for penalty payments on the public chain. Appropriate security groups are implemented for the endorsing peer based EC2 instances to communicate with each other. Each account on the Ropsten Ethereum chain are given 10 Ether to begin with and are requested from the Ropsten Ethereum faucet available on the internet. Binary to base64 converter is implemented for signSGD to convert participant provided parameters into base64 to upload to the chaincode. We use the peer binary provided by Hyperledger Fabric to upload parameters in a repeatable fashion.</p>
</div>
<div id="S6.SS1.p4" class="ltx_para">
<p id="S6.SS1.p4.1" class="ltx_p">Since our framework implements FL algorithms as it is, <span id="S6.SS1.p4.1.1" class="ltx_text ltx_font_italic">our implementation does not result in any difference with respect to the accuracy of the generic FL models</span>. Hence we do not report any accuracy results here. On the other hand, at each epoch, depending on the DL model learned and the averaging scheme used, the performance may greatly change due to blockchain based smart contract characteristics. To understand the factors that impact the overall performance, we experimented with a single round of update under different aggregation schemes with varying DL model sizes. In order to set up our experiments, we adjusted the DL model sizes (i.e., the number of trainable parameters used by DL model) based on the commonly used DL models <cite class="ltx_cite ltx_citemacro_citep">(the, <a href="#bib.bib2" title="" class="ltx_ref">[n.d.]</a>)</cite>. For example, classic DL architecture such as AlexNet has around 60 million trainable parameters. On the other hand, newer architectures such as VGG16 has around 160 million trainable parameters. In our experiments, we measure the performance by varying the number of parameters updated at each epoch ranging from 50 million to 300 million. This range covers most of the commonly used DL models <cite class="ltx_cite ltx_citemacro_citep">(the, <a href="#bib.bib2" title="" class="ltx_ref">[n.d.]</a>)</cite>.</p>
</div>
<figure id="S6.T1" class="ltx_table">

<figcaption class="ltx_caption"><span class="ltx_tag ltx_tag_table"><span id="S6.T1.2.1.1" class="ltx_text" style="font-size:90%;">Table 1</span>. </span><span id="S6.T1.3.2" class="ltx_text" style="font-size:90%;">Deploy and Aggregation Time Analysis over Contract Variation</span></figcaption><div class="ltx_flex_figure">
<div class="ltx_flex_cell ltx_flex_size_2">
<figure id="S6.T1.st1" class="ltx_table ltx_figure_panel">
<table id="S6.T1.st1.2" class="ltx_tabular ltx_centering ltx_guessed_headers ltx_align_middle">
<thead class="ltx_thead">
<tr id="S6.T1.st1.2.1.1" class="ltx_tr">
<th id="S6.T1.st1.2.1.1.1" class="ltx_td ltx_align_center ltx_th ltx_th_column ltx_border_tt"># Contracts</th>
<th id="S6.T1.st1.2.1.1.2" class="ltx_td ltx_align_center ltx_th ltx_th_column ltx_border_tt">Contract Deploy</th>
<th id="S6.T1.st1.2.1.1.3" class="ltx_td ltx_align_left ltx_th ltx_th_column ltx_border_tt">Parameter Aggregate</th>
</tr>
<tr id="S6.T1.st1.2.2.2" class="ltx_tr">
<th id="S6.T1.st1.2.2.2.1" class="ltx_td ltx_align_center ltx_th ltx_th_column">Deployed</th>
<th id="S6.T1.st1.2.2.2.2" class="ltx_td ltx_align_center ltx_th ltx_th_column">Time</th>
<th id="S6.T1.st1.2.2.2.3" class="ltx_td ltx_align_left ltx_th ltx_th_column">Time</th>
</tr>
</thead>
<tbody class="ltx_tbody">
<tr id="S6.T1.st1.2.3.1" class="ltx_tr">
<td id="S6.T1.st1.2.3.1.1" class="ltx_td ltx_align_center ltx_border_t">1</td>
<td id="S6.T1.st1.2.3.1.2" class="ltx_td ltx_align_center ltx_border_t">45 seconds</td>
<td id="S6.T1.st1.2.3.1.3" class="ltx_td ltx_align_left ltx_border_t">4 seconds</td>
</tr>
<tr id="S6.T1.st1.2.4.2" class="ltx_tr">
<td id="S6.T1.st1.2.4.2.1" class="ltx_td ltx_align_center">2</td>
<td id="S6.T1.st1.2.4.2.2" class="ltx_td ltx_align_center">71 seconds</td>
<td id="S6.T1.st1.2.4.2.3" class="ltx_td ltx_align_left">3.5 seconds</td>
</tr>
<tr id="S6.T1.st1.2.5.3" class="ltx_tr">
<td id="S6.T1.st1.2.5.3.1" class="ltx_td ltx_align_center">4</td>
<td id="S6.T1.st1.2.5.3.2" class="ltx_td ltx_align_center">93 seconds</td>
<td id="S6.T1.st1.2.5.3.3" class="ltx_td ltx_align_left">3.5 seconds</td>
</tr>
<tr id="S6.T1.st1.2.6.4" class="ltx_tr">
<td id="S6.T1.st1.2.6.4.1" class="ltx_td ltx_align_center">8</td>
<td id="S6.T1.st1.2.6.4.2" class="ltx_td ltx_align_center">144 seconds</td>
<td id="S6.T1.st1.2.6.4.3" class="ltx_td ltx_align_left">3 seconds</td>
</tr>
<tr id="S6.T1.st1.2.7.5" class="ltx_tr">
<td id="S6.T1.st1.2.7.5.1" class="ltx_td ltx_align_center">16</td>
<td id="S6.T1.st1.2.7.5.2" class="ltx_td ltx_align_center">243 seconds</td>
<td id="S6.T1.st1.2.7.5.3" class="ltx_td ltx_align_left">2.8 seconds</td>
</tr>
<tr id="S6.T1.st1.2.8.6" class="ltx_tr">
<td id="S6.T1.st1.2.8.6.1" class="ltx_td ltx_align_center">32</td>
<td id="S6.T1.st1.2.8.6.2" class="ltx_td ltx_align_center">443 seconds</td>
<td id="S6.T1.st1.2.8.6.3" class="ltx_td ltx_align_left">2.5 seconds</td>
</tr>
<tr id="S6.T1.st1.2.9.7" class="ltx_tr">
<td id="S6.T1.st1.2.9.7.1" class="ltx_td ltx_align_center ltx_border_bb">48</td>
<td id="S6.T1.st1.2.9.7.2" class="ltx_td ltx_align_center ltx_border_bb">503 seconds</td>
<td id="S6.T1.st1.2.9.7.3" class="ltx_td ltx_align_left ltx_border_bb">2.3 seconds</td>
</tr>
</tbody>
</table>
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_table"><span id="S6.T1.st1.3.1.1" class="ltx_text" style="font-size:90%;">(a)</span> </span><span id="S6.T1.st1.4.2" class="ltx_text" style="font-size:90%;">signSGD</span></figcaption>
</figure>
</div>
<div class="ltx_flex_cell ltx_flex_size_2">
<figure id="S6.T1.st2" class="ltx_table ltx_figure_panel">
</figure>
</div>
</div>
</figure>
</section>
<section id="S6.SS2" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">6.2. </span>Results</h3>

<figure id="S6.F4" class="ltx_figure"><img src="/html/2010.07427/assets/results_contractVariation.png" id="S6.F4.g1" class="ltx_graphics ltx_centering ltx_img_landscape" width="299" height="156" alt="Refer to caption">
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure"><span id="S6.F4.3.1.1" class="ltx_text" style="font-size:90%;">Figure 4</span>. </span><span id="S6.F4.4.2" class="ltx_text ltx_font_bold" style="font-size:90%;">Upload Time Analysis over Contract Variation <span id="S6.F4.4.2.1" class="ltx_text ltx_font_medium"> </span></span></figcaption>
</figure>
<figure id="S6.F5" class="ltx_figure"><img src="/html/2010.07427/assets/results_parameterVariation.png" id="S6.F5.g1" class="ltx_graphics ltx_centering ltx_img_landscape" width="299" height="138" alt="Refer to caption">
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure"><span id="S6.F5.3.1.1" class="ltx_text" style="font-size:90%;">Figure 5</span>. </span><span id="S6.F5.4.2" class="ltx_text ltx_font_bold" style="font-size:90%;">Upload Time Analysis over Parameter Variation </span></figcaption>
</figure>
<section id="S6.SS2.SSS1" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">6.2.1. </span>1 contract vs N contracts (SignSGD)</h4>

<div id="S6.SS2.SSS1.p1" class="ltx_para">
<p id="S6.SS2.SSS1.p1.1" class="ltx_p">Each client loads upto 10 KB (20,000 characters) of parameters in every iteration of uploading the DL parameters per epoch. That means per function call the clients are loading up to 13,300 base64 characters. With both, our local and AWS setup, we have compared the cases of using a single contract versus multiple contracts to upload the parameters and subsequently perform aggregation. Parameter loading to the hyperledger fabric framework is done in parallel in case there are multiple contracts. Each series of uploads to the smart contract will have its own thread running in the background.
For a single thread / single contract system, the parameters are loaded in at the maximum 350 transactions with an event update post each update to give the client application the notification to send another update.
Since the parameters are uploaded sequentially, the amount of time taken to upload the parameters is up to 5 minutes in both the local setup and AWS setup. This seems to be a reasonable time considering that we are using only a single contract for uploading the parameters sequentially. There is no monetary/gas cost analysis provided since it is a private blockchain and there are no wallets in a private blockchain. We then increased the number of contracts by a factor of 2 and compared the time taken for uploading the parameters to the framework. With our setup, we were able to upload all parameters within 60 seconds.
</p>
</div>
<div id="S6.SS2.SSS1.p2" class="ltx_para">
<p id="S6.SS2.SSS1.p2.1" class="ltx_p">On further increasing the number of contracts, the time to upload improved significantly. With 32 parallel contracts, we were able to achieve upload time of 9 seconds for any signSGD setting. And if we push the system to its limits by uploading all the parameters in 48 parallel contracts, then the upload time is 5 seconds. This is the primary advantage of using a private blockchain instead of a public one simply because the transaction throughput is so high. Having achieved 20,000 transactions per second <cite class="ltx_cite ltx_citemacro_citep">(Gorenflo
et al<span class="ltx_text">.</span>, <a href="#bib.bib14" title="" class="ltx_ref">2019</a>)</cite>, in the event we have better processing power, we can potentially upload all the parameters within a fraction of a second.</p>
</div>
<div id="S6.SS2.SSS1.p3" class="ltx_para">
<p id="S6.SS2.SSS1.p3.1" class="ltx_p">The system we were using was a 48 vCPU system. As a result, even if we use more than 48 threads to upload all the parameters, it will have a negligible impact on the performance simply because all the vCPUs have been taken up by the 48 threads earlier.</p>
</div>
<div id="S6.SS2.SSS1.p4" class="ltx_para">
<p id="S6.SS2.SSS1.p4.1" class="ltx_p">The aggregation time as seen in Table <a href="#S6.T1.st1" title="In Table 1 ‣ 6.1. Experiment Setup ‣ 6. Experimental Evaluation ‣ BlockFLA: Accountable Federated Learning via Hybrid Blockchain Architecture" class="ltx_ref"><span class="ltx_text ltx_ref_tag">1(a)</span></a>, for any Federated Learning signSGD setting is always less than 5 seconds. The results shown in Table <a href="#S6.T1.st1" title="In Table 1 ‣ 6.1. Experiment Setup ‣ 6. Experimental Evaluation ‣ BlockFLA: Accountable Federated Learning via Hybrid Blockchain Architecture" class="ltx_ref"><span class="ltx_text ltx_ref_tag">1(a)</span></a> are recorded to demonstrate the worst case timing. Realistically, the parameters sent by each worker node would not be above 300 million parameters. Therefore, we have shown that even in the worst case scenario, aggregation happens within 5 seconds.</p>
</div>
<div id="S6.SS2.SSS1.p5" class="ltx_para">
<p id="S6.SS2.SSS1.p5.1" class="ltx_p">Thus, if we add up the results seen in Table <a href="#S6.T1.st1" title="In Table 1 ‣ 6.1. Experiment Setup ‣ 6. Experimental Evaluation ‣ BlockFLA: Accountable Federated Learning via Hybrid Blockchain Architecture" class="ltx_ref"><span class="ltx_text ltx_ref_tag">1(a)</span></a> and Figure <a href="#S6.F4" title="Figure 4 ‣ 6.2. Results ‣ 6. Experimental Evaluation ‣ BlockFLA: Accountable Federated Learning via Hybrid Blockchain Architecture" class="ltx_ref"><span class="ltx_text ltx_ref_tag">4</span></a>, for each worker node, with the current system, for 5-10 epochs, the total time taken for the aggregation and parameter loading to run takes less than 1.5 minute.</p>
</div>
</section>
<section id="S6.SS2.SSS2" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">6.2.2. </span>1 contract vs N contracts (FedAvg)</h4>

<div id="S6.SS2.SSS2.p1" class="ltx_para">
<p id="S6.SS2.SSS2.p1.1" class="ltx_p">Each client loads 130 KB (33000 float32) in every iteration of uploading all Federated Averaging parameters per epoch.
We use the same experimental setup used for <em id="S6.SS2.SSS2.p1.1.1" class="ltx_emph ltx_font_italic">signSGD</em>. For a sequential upload of parameters, the amount of time taken to upload the parameters is 25 minutes in both the local setup and AWS setup. This drastic increase in time is again, due to the usage of events, that means we will not make another upload until the previous upload is complete.</p>
</div>
<div id="S6.SS2.SSS2.p2" class="ltx_para">
<p id="S6.SS2.SSS2.p2.1" class="ltx_p">On gradually increasing the number of contracts as seen in Figure <a href="#S6.F4" title="Figure 4 ‣ 6.2. Results ‣ 6. Experimental Evaluation ‣ BlockFLA: Accountable Federated Learning via Hybrid Blockchain Architecture" class="ltx_ref"><span class="ltx_text ltx_ref_tag">4</span></a>, the time to upload improved significantly. With 16 parallel contracts, we were able to achieve upload time of under 3 minutes for any Federated Averaging setting. And if we push the system to its limits by uploading all 330 million parameters in 48 parallel contracts, then the upload time is under 1.5 minutes. Being a private blockchain instead of a public one implies the transaction throughput is so high.</p>
</div>
<div id="S6.SS2.SSS2.p3" class="ltx_para">
<p id="S6.SS2.SSS2.p3.1" class="ltx_p">The aggregation time as seen in Table <span class="ltx_ref ltx_missing_label ltx_ref_self">LABEL:tab:FedAvg</span>, for any Federated Averaging setting is less than 10 seconds constantly because it is being done on the ledger and will consume only one transaction to return the results. Similar to Table <a href="#S6.T1.st1" title="In Table 1 ‣ 6.1. Experiment Setup ‣ 6. Experimental Evaluation ‣ BlockFLA: Accountable Federated Learning via Hybrid Blockchain Architecture" class="ltx_ref"><span class="ltx_text ltx_ref_tag">1(a)</span></a>, the results shown in Table <span class="ltx_ref ltx_missing_label ltx_ref_self">LABEL:tab:FedAvg</span> demonstrate the worst case timing for aggregating 300 million parameters.</p>
</div>
<div id="S6.SS2.SSS2.p4" class="ltx_para">
<p id="S6.SS2.SSS2.p4.1" class="ltx_p">Thus, if we add up the results seen in Table <span class="ltx_ref ltx_missing_label ltx_ref_self">LABEL:tab:FedAvg</span> and Figure <a href="#S6.F4" title="Figure 4 ‣ 6.2. Results ‣ 6. Experimental Evaluation ‣ BlockFLA: Accountable Federated Learning via Hybrid Blockchain Architecture" class="ltx_ref"><span class="ltx_text ltx_ref_tag">4</span></a>, for each worker node, with the current system, for 5-10 epochs, the total time taken for the complete <em id="S6.SS2.SSS2.p4.1.1" class="ltx_emph ltx_font_italic">FedAvg</em> algorithm to run takes less than 12 minutes.</p>
</div>
</section>
<section id="S6.SS2.SSS3" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">6.2.3. </span>Performance Analysis on Parameter Variation</h4>

<div id="S6.SS2.SSS3.p1" class="ltx_para">
<p id="S6.SS2.SSS3.p1.1" class="ltx_p">As shown in Figure <a href="#S6.F5" title="Figure 5 ‣ 6.2. Results ‣ 6. Experimental Evaluation ‣ BlockFLA: Accountable Federated Learning via Hybrid Blockchain Architecture" class="ltx_ref"><span class="ltx_text ltx_ref_tag">5</span></a>, on increasing the number of parameters to be uploaded by each Federated Learning algorithm by keeping the number of parallel contracts deployed constant(her 16 parallel contracts), the time required to upload all parameters into the private blockchain increases gradually. For signSGD, it takes about 4 seconds to upload 50 million parameters to the private chain and 12 seconds to upload 300 million parameters to the private chain. Similarly, for Federated Averaging, it takes 27 seconds to upload 50 million parameters to the private chain and 163 seconds to upload 300 million parameters to the public chain. This tells us that with the current optimizations in place, we are able to achieve communication efficient Federated Learning over the Hybrid Blockchain setting.</p>
</div>
</section>
<section id="S6.SS2.SSS4" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">6.2.4. </span>Hybrid chain vs all Public chain</h4>

<div id="S6.SS2.SSS4.p1" class="ltx_para">
<p id="S6.SS2.SSS4.p1.1" class="ltx_p">We also deployed a parallel solidity smart contract that performs the same operations as the golang hyperledger chaincode and deployed it on the ethereum private blockchain. There was a drastic slowness observed when performing Federated Averaging operations over Ethereum. The throughput attained when inputting parameters to the ethereum smart contract more than 1300 seconds for <em id="S6.SS2.SSS4.p1.1.1" class="ltx_emph ltx_font_italic">FedAvg</em> versus 64 seconds per 300 million parameters for <em id="S6.SS2.SSS4.p1.1.2" class="ltx_emph ltx_font_italic">FedAvg</em> for the hyperledger fabric framework.
The time taken to perform aggregation was also of the order of 450 seconds for ethereum versus less than 10 seconds for hyperledger fabric. Since a private deployment of the Ethereum blockchain was set up, there are no incurred transaction costs incurred to any worker node.</p>
</div>
</section>
<section id="S6.SS2.SSS5" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">6.2.5. </span>Gas and Time Analysis over Public Chain</h4>

<div id="S6.SS2.SSS5.p1" class="ltx_para">
<p id="S6.SS2.SSS5.p1.1" class="ltx_p">The price of 1 Ethereum Gas is 0.02 <math id="S6.SS2.SSS5.p1.1.m1.1" class="ltx_Math" alttext="\mu" display="inline"><semantics id="S6.SS2.SSS5.p1.1.m1.1a"><mi id="S6.SS2.SSS5.p1.1.m1.1.1" xref="S6.SS2.SSS5.p1.1.m1.1.1.cmml">μ</mi><annotation-xml encoding="MathML-Content" id="S6.SS2.SSS5.p1.1.m1.1b"><ci id="S6.SS2.SSS5.p1.1.m1.1.1.cmml" xref="S6.SS2.SSS5.p1.1.m1.1.1">𝜇</ci></annotation-xml><annotation encoding="application/x-tex" id="S6.SS2.SSS5.p1.1.m1.1c">\mu</annotation></semantics></math> Ether. The amount of gas it takes to upload the SHA256 Hashes to the Ropsten Ethereum public chain is nearly 95000 Gas (.0019 Ether) for the first call of the first epoch. On subsequent epochs, each call takes nearly 25000 Gas(0.0005 Ether) to upload the SHA256 Hashes as shown in Figure <a href="#S5.F3.sf1" title="In Figure 3 ‣ 5.4. Cache Chaincode ‣ 5. Optimization Techniques ‣ BlockFLA: Accountable Federated Learning via Hybrid Blockchain Architecture" class="ltx_ref"><span class="ltx_text ltx_ref_tag">3(a)</span></a>. Cost to upload the Hash value is more for the first call because it initializes the data structure on the smart contract, thereby being more expensive than merely updating and appending values to the array that is already created. As seen in Figure <a href="#S5.F3.sf2" title="In Figure 3 ‣ 5.4. Cache Chaincode ‣ 5. Optimization Techniques ‣ BlockFLA: Accountable Federated Learning via Hybrid Blockchain Architecture" class="ltx_ref"><span class="ltx_text ltx_ref_tag">3(b)</span></a>, the SHA256 Hash upload from the client is variant between 35 seconds to 75 seconds. This means each transaction confirmation over the public chain is independent of size of the hash and therefore unreliable to store the real parameters on the public chain if performance is taken into consideration.</p>
</div>
</section>
</section>
<section id="S6.SS3" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">6.3. </span>Performance of our Attacker Detection Algorithm</h3>

<div id="S6.SS3.p1" class="ltx_para">
<p id="S6.SS3.p1.7" class="ltx_p">We now illustrate the performance of the attacker detection algorithm we described in Section <a href="#S3.SS6" title="3.6. An Attacker Detection Algorithm for Trojaning Attacks ‣ 3. System Architecture ‣ BlockFLA: Accountable Federated Learning via Hybrid Blockchain Architecture" class="ltx_ref"><span class="ltx_text ltx_ref_tag">3.6</span></a> via experiments. The general setting of our experiments are as follows: we simulate FL for <math id="S6.SS3.p1.1.m1.1" class="ltx_Math" alttext="R" display="inline"><semantics id="S6.SS3.p1.1.m1.1a"><mi id="S6.SS3.p1.1.m1.1.1" xref="S6.SS3.p1.1.m1.1.1.cmml">R</mi><annotation-xml encoding="MathML-Content" id="S6.SS3.p1.1.m1.1b"><ci id="S6.SS3.p1.1.m1.1.1.cmml" xref="S6.SS3.p1.1.m1.1.1">𝑅</ci></annotation-xml><annotation encoding="application/x-tex" id="S6.SS3.p1.1.m1.1c">R</annotation></semantics></math> rounds among <math id="S6.SS3.p1.2.m2.1" class="ltx_Math" alttext="K" display="inline"><semantics id="S6.SS3.p1.2.m2.1a"><mi id="S6.SS3.p1.2.m2.1.1" xref="S6.SS3.p1.2.m2.1.1.cmml">K</mi><annotation-xml encoding="MathML-Content" id="S6.SS3.p1.2.m2.1b"><ci id="S6.SS3.p1.2.m2.1.1.cmml" xref="S6.SS3.p1.2.m2.1.1">𝐾</ci></annotation-xml><annotation encoding="application/x-tex" id="S6.SS3.p1.2.m2.1c">K</annotation></semantics></math> agents where <math id="S6.SS3.p1.3.m3.1" class="ltx_Math" alttext="F" display="inline"><semantics id="S6.SS3.p1.3.m3.1a"><mi id="S6.SS3.p1.3.m3.1.1" xref="S6.SS3.p1.3.m3.1.1.cmml">F</mi><annotation-xml encoding="MathML-Content" id="S6.SS3.p1.3.m3.1b"><ci id="S6.SS3.p1.3.m3.1.1.cmml" xref="S6.SS3.p1.3.m3.1.1">𝐹</ci></annotation-xml><annotation encoding="application/x-tex" id="S6.SS3.p1.3.m3.1c">F</annotation></semantics></math> fraction of them are corrupt. The backdoor task is to make the model misclassify instances from a <em id="S6.SS3.p1.7.1" class="ltx_emph ltx_font_italic">base class</em> as <em id="S6.SS3.p1.7.2" class="ltx_emph ltx_font_italic">target class</em> by using trojan patterns. That is, a model having the backdoor classifies instances from base class with trojan pattern as target class (see Figure <a href="#S6.F6" title="Figure 6 ‣ 6.3. Performance of our Attacker Detection Algorithm ‣ 6. Experimental Evaluation ‣ BlockFLA: Accountable Federated Learning via Hybrid Blockchain Architecture" class="ltx_ref"><span class="ltx_text ltx_ref_tag">6</span></a>). To do so, we assume an adversary who corrupts the local datasets of corrupt agents by adding a trojan pattern to base class instances, and relabeling them as target class. Other than that, adversary cannot view and modify updates of honest agents, or cannot influence the computation done by honest agents and the aggregation server. At each round, the server uniformly samples <math id="S6.SS3.p1.4.m4.1" class="ltx_Math" alttext="C\cdot K" display="inline"><semantics id="S6.SS3.p1.4.m4.1a"><mrow id="S6.SS3.p1.4.m4.1.1" xref="S6.SS3.p1.4.m4.1.1.cmml"><mi id="S6.SS3.p1.4.m4.1.1.2" xref="S6.SS3.p1.4.m4.1.1.2.cmml">C</mi><mo lspace="0.222em" rspace="0.222em" id="S6.SS3.p1.4.m4.1.1.1" xref="S6.SS3.p1.4.m4.1.1.1.cmml">⋅</mo><mi id="S6.SS3.p1.4.m4.1.1.3" xref="S6.SS3.p1.4.m4.1.1.3.cmml">K</mi></mrow><annotation-xml encoding="MathML-Content" id="S6.SS3.p1.4.m4.1b"><apply id="S6.SS3.p1.4.m4.1.1.cmml" xref="S6.SS3.p1.4.m4.1.1"><ci id="S6.SS3.p1.4.m4.1.1.1.cmml" xref="S6.SS3.p1.4.m4.1.1.1">⋅</ci><ci id="S6.SS3.p1.4.m4.1.1.2.cmml" xref="S6.SS3.p1.4.m4.1.1.2">𝐶</ci><ci id="S6.SS3.p1.4.m4.1.1.3.cmml" xref="S6.SS3.p1.4.m4.1.1.3">𝐾</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="S6.SS3.p1.4.m4.1c">C\cdot K</annotation></semantics></math> agents for training where <math id="S6.SS3.p1.5.m5.1" class="ltx_Math" alttext="C\leq 1" display="inline"><semantics id="S6.SS3.p1.5.m5.1a"><mrow id="S6.SS3.p1.5.m5.1.1" xref="S6.SS3.p1.5.m5.1.1.cmml"><mi id="S6.SS3.p1.5.m5.1.1.2" xref="S6.SS3.p1.5.m5.1.1.2.cmml">C</mi><mo id="S6.SS3.p1.5.m5.1.1.1" xref="S6.SS3.p1.5.m5.1.1.1.cmml">≤</mo><mn id="S6.SS3.p1.5.m5.1.1.3" xref="S6.SS3.p1.5.m5.1.1.3.cmml">1</mn></mrow><annotation-xml encoding="MathML-Content" id="S6.SS3.p1.5.m5.1b"><apply id="S6.SS3.p1.5.m5.1.1.cmml" xref="S6.SS3.p1.5.m5.1.1"><leq id="S6.SS3.p1.5.m5.1.1.1.cmml" xref="S6.SS3.p1.5.m5.1.1.1"></leq><ci id="S6.SS3.p1.5.m5.1.1.2.cmml" xref="S6.SS3.p1.5.m5.1.1.2">𝐶</ci><cn type="integer" id="S6.SS3.p1.5.m5.1.1.3.cmml" xref="S6.SS3.p1.5.m5.1.1.3">1</cn></apply></annotation-xml><annotation encoding="application/x-tex" id="S6.SS3.p1.5.m5.1c">C\leq 1</annotation></semantics></math>. Those agents locally train for <math id="S6.SS3.p1.6.m6.1" class="ltx_Math" alttext="E" display="inline"><semantics id="S6.SS3.p1.6.m6.1a"><mi id="S6.SS3.p1.6.m6.1.1" xref="S6.SS3.p1.6.m6.1.1.cmml">E</mi><annotation-xml encoding="MathML-Content" id="S6.SS3.p1.6.m6.1b"><ci id="S6.SS3.p1.6.m6.1.1.cmml" xref="S6.SS3.p1.6.m6.1.1">𝐸</ci></annotation-xml><annotation encoding="application/x-tex" id="S6.SS3.p1.6.m6.1c">E</annotation></semantics></math> epochs with a batch size of <math id="S6.SS3.p1.7.m7.1" class="ltx_Math" alttext="B" display="inline"><semantics id="S6.SS3.p1.7.m7.1a"><mi id="S6.SS3.p1.7.m7.1.1" xref="S6.SS3.p1.7.m7.1.1.cmml">B</mi><annotation-xml encoding="MathML-Content" id="S6.SS3.p1.7.m7.1b"><ci id="S6.SS3.p1.7.m7.1.1.cmml" xref="S6.SS3.p1.7.m7.1.1">𝐵</ci></annotation-xml><annotation encoding="application/x-tex" id="S6.SS3.p1.7.m7.1c">B</annotation></semantics></math> before sending their updates.</p>
</div>
<figure id="S6.F6" class="ltx_figure">
<div class="ltx_flex_figure">
<div class="ltx_flex_cell ltx_flex_size_2"><img src="/html/2010.07427/assets/trojan_figs/cifar10_base_trojaned.png" id="S6.F6.g1" class="ltx_graphics ltx_figure_panel ltx_img_square" width="66" height="66" alt="Refer to caption"></div>
<div class="ltx_flex_cell ltx_flex_size_2"><img src="/html/2010.07427/assets/trojan_figs/cifar10_target_clean.png" id="S6.F6.g2" class="ltx_graphics ltx_figure_panel ltx_img_square" width="66" height="66" alt="Refer to caption"></div>
</div>
<figcaption class="ltx_caption"><span class="ltx_tag ltx_tag_figure"><span id="S6.F6.2.1.1" class="ltx_text" style="font-size:90%;">Figure 6</span>. </span><span id="S6.F6.3.2" class="ltx_text" style="font-size:90%;">Samples from trojaned base class, and target class.
The trojan pattern is a 5-by-5 plus pattern that is put to the top-left of base class instances. The goal of adversary is to make the model classify instances of dog class with the trojan pattern (left) as a horse (right).</span></figcaption>
</figure>
<div id="S6.SS3.p2" class="ltx_para">
<p id="S6.SS3.p2.1" class="ltx_p">We tested our detection algorithm on CIFAR10 <cite class="ltx_cite ltx_citemacro_citep">(Krizhevsky
et al<span class="ltx_text">.</span>, <a href="#bib.bib19" title="" class="ltx_ref">2009</a>)</cite> dataset by using a 5-layer convolutional neural network consisting of about 1.2M parameters with the following architecture: two layers of convolution, followed by a layer of max-pooling, followed by two fully-connected layers with dropout. Hyperparameters used in all experiments can be found in Appendix <a href="#A1" title="Appendix A Hyperparameters of Experiments ‣ BlockFLA: Accountable Federated Learning via Hybrid Blockchain Architecture" class="ltx_ref"><span class="ltx_text ltx_ref_tag">A</span></a>. We were able to detect the adversarial agents perfectly in three out of these four settings. We briefly summarize our results below.</p>
</div>
<div id="S6.SS3.p3" class="ltx_para">
<p id="S6.SS3.p3.2" class="ltx_p">In the first two settings, we have a rather small setup of 10 agents, where one of them is adversary. We plot the <math id="S6.SS3.p3.1.m1.1" class="ltx_Math" alttext="L_{2}" display="inline"><semantics id="S6.SS3.p3.1.m1.1a"><msub id="S6.SS3.p3.1.m1.1.1" xref="S6.SS3.p3.1.m1.1.1.cmml"><mi id="S6.SS3.p3.1.m1.1.1.2" xref="S6.SS3.p3.1.m1.1.1.2.cmml">L</mi><mn id="S6.SS3.p3.1.m1.1.1.3" xref="S6.SS3.p3.1.m1.1.1.3.cmml">2</mn></msub><annotation-xml encoding="MathML-Content" id="S6.SS3.p3.1.m1.1b"><apply id="S6.SS3.p3.1.m1.1.1.cmml" xref="S6.SS3.p3.1.m1.1.1"><csymbol cd="ambiguous" id="S6.SS3.p3.1.m1.1.1.1.cmml" xref="S6.SS3.p3.1.m1.1.1">subscript</csymbol><ci id="S6.SS3.p3.1.m1.1.1.2.cmml" xref="S6.SS3.p3.1.m1.1.1.2">𝐿</ci><cn type="integer" id="S6.SS3.p3.1.m1.1.1.3.cmml" xref="S6.SS3.p3.1.m1.1.1.3">2</cn></apply></annotation-xml><annotation encoding="application/x-tex" id="S6.SS3.p3.1.m1.1c">L_{2}</annotation></semantics></math> of adversarial contribution for the rounds in which backdoor loss decreases in Figure <a href="#S6.F7" title="Figure 7 ‣ 6.3. Performance of our Attacker Detection Algorithm ‣ 6. Experimental Evaluation ‣ BlockFLA: Accountable Federated Learning via Hybrid Blockchain Architecture" class="ltx_ref"><span class="ltx_text ltx_ref_tag">7</span></a>. The attacker is Agent 0, and as can be seen, he stands out from the rest by having the largest <math id="S6.SS3.p3.2.m2.1" class="ltx_Math" alttext="L_{2}" display="inline"><semantics id="S6.SS3.p3.2.m2.1a"><msub id="S6.SS3.p3.2.m2.1.1" xref="S6.SS3.p3.2.m2.1.1.cmml"><mi id="S6.SS3.p3.2.m2.1.1.2" xref="S6.SS3.p3.2.m2.1.1.2.cmml">L</mi><mn id="S6.SS3.p3.2.m2.1.1.3" xref="S6.SS3.p3.2.m2.1.1.3.cmml">2</mn></msub><annotation-xml encoding="MathML-Content" id="S6.SS3.p3.2.m2.1b"><apply id="S6.SS3.p3.2.m2.1.1.cmml" xref="S6.SS3.p3.2.m2.1.1"><csymbol cd="ambiguous" id="S6.SS3.p3.2.m2.1.1.1.cmml" xref="S6.SS3.p3.2.m2.1.1">subscript</csymbol><ci id="S6.SS3.p3.2.m2.1.1.2.cmml" xref="S6.SS3.p3.2.m2.1.1.2">𝐿</ci><cn type="integer" id="S6.SS3.p3.2.m2.1.1.3.cmml" xref="S6.SS3.p3.2.m2.1.1.3">2</cn></apply></annotation-xml><annotation encoding="application/x-tex" id="S6.SS3.p3.2.m2.1c">L_{2}</annotation></semantics></math> contribution to most important backdoor parameters.</p>
</div>
<figure id="S6.F7" class="ltx_figure">
<div class="ltx_flex_figure">
<div class="ltx_flex_cell ltx_flex_size_1"><img src="/html/2010.07427/assets/trojan_figs/cifar_iid_small.png" id="S6.F7.g1" class="ltx_graphics ltx_centering ltx_figure_panel ltx_img_landscape" width="1200" height="800" alt="Refer to caption"></div>
<div class="ltx_flex_break"></div>
<div class="ltx_flex_cell ltx_flex_size_1"><img src="/html/2010.07427/assets/trojan_figs/cifar_niid_small.png" id="S6.F7.g2" class="ltx_graphics ltx_centering ltx_figure_panel ltx_img_landscape" width="1200" height="800" alt="Refer to caption"></div>
</div>
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure"><span id="S6.F7.12.6.1" class="ltx_text" style="font-size:90%;">Figure 7</span>. </span><span id="S6.F7.10.5" class="ltx_text" style="font-size:90%;">Results of trojan detection algorithm in iid (top), and non-iid (bottom) settings. In iid setting, the adversarial agent (Agent 0) stands out very clearly. In non-iid setting, the variance of contribution of agents’ seem to be higher. Yet, if we compute the average <math id="S6.F7.6.1.m1.1" class="ltx_Math" alttext="L_{2}" display="inline"><semantics id="S6.F7.6.1.m1.1b"><msub id="S6.F7.6.1.m1.1.1" xref="S6.F7.6.1.m1.1.1.cmml"><mi id="S6.F7.6.1.m1.1.1.2" xref="S6.F7.6.1.m1.1.1.2.cmml">L</mi><mn id="S6.F7.6.1.m1.1.1.3" xref="S6.F7.6.1.m1.1.1.3.cmml">2</mn></msub><annotation-xml encoding="MathML-Content" id="S6.F7.6.1.m1.1c"><apply id="S6.F7.6.1.m1.1.1.cmml" xref="S6.F7.6.1.m1.1.1"><csymbol cd="ambiguous" id="S6.F7.6.1.m1.1.1.1.cmml" xref="S6.F7.6.1.m1.1.1">subscript</csymbol><ci id="S6.F7.6.1.m1.1.1.2.cmml" xref="S6.F7.6.1.m1.1.1.2">𝐿</ci><cn type="integer" id="S6.F7.6.1.m1.1.1.3.cmml" xref="S6.F7.6.1.m1.1.1.3">2</cn></apply></annotation-xml><annotation encoding="application/x-tex" id="S6.F7.6.1.m1.1d">L_{2}</annotation></semantics></math> contribution over the rounds, Agent 0 is at the top with a value of <math id="S6.F7.7.2.m2.1" class="ltx_Math" alttext="0.78" display="inline"><semantics id="S6.F7.7.2.m2.1b"><mn id="S6.F7.7.2.m2.1.1" xref="S6.F7.7.2.m2.1.1.cmml">0.78</mn><annotation-xml encoding="MathML-Content" id="S6.F7.7.2.m2.1c"><cn type="float" id="S6.F7.7.2.m2.1.1.cmml" xref="S6.F7.7.2.m2.1.1">0.78</cn></annotation-xml><annotation encoding="application/x-tex" id="S6.F7.7.2.m2.1d">0.78</annotation></semantics></math>, followed by Agent 9 (<math id="S6.F7.8.3.m3.1" class="ltx_Math" alttext="0.67" display="inline"><semantics id="S6.F7.8.3.m3.1b"><mn id="S6.F7.8.3.m3.1.1" xref="S6.F7.8.3.m3.1.1.cmml">0.67</mn><annotation-xml encoding="MathML-Content" id="S6.F7.8.3.m3.1c"><cn type="float" id="S6.F7.8.3.m3.1.1.cmml" xref="S6.F7.8.3.m3.1.1">0.67</cn></annotation-xml><annotation encoding="application/x-tex" id="S6.F7.8.3.m3.1d">0.67</annotation></semantics></math>) and Agent 6 (<math id="S6.F7.9.4.m4.1" class="ltx_Math" alttext="0.65" display="inline"><semantics id="S6.F7.9.4.m4.1b"><mn id="S6.F7.9.4.m4.1.1" xref="S6.F7.9.4.m4.1.1.cmml">0.65</mn><annotation-xml encoding="MathML-Content" id="S6.F7.9.4.m4.1c"><cn type="float" id="S6.F7.9.4.m4.1.1.cmml" xref="S6.F7.9.4.m4.1.1">0.65</cn></annotation-xml><annotation encoding="application/x-tex" id="S6.F7.9.4.m4.1d">0.65</annotation></semantics></math>). In iid setting, data is distributed uniformly between agents, and in non-iid setting, we distribute each class by sampling from a Dirichlet distribution with a concentration of <math id="S6.F7.10.5.m5.1" class="ltx_Math" alttext="0.5" display="inline"><semantics id="S6.F7.10.5.m5.1b"><mn id="S6.F7.10.5.m5.1.1" xref="S6.F7.10.5.m5.1.1.cmml">0.5</mn><annotation-xml encoding="MathML-Content" id="S6.F7.10.5.m5.1c"><cn type="float" id="S6.F7.10.5.m5.1.1.cmml" xref="S6.F7.10.5.m5.1.1">0.5</cn></annotation-xml><annotation encoding="application/x-tex" id="S6.F7.10.5.m5.1d">0.5</annotation></semantics></math></span></figcaption>
</figure>
<div id="S6.SS3.p4" class="ltx_para">
<p id="S6.SS3.p4.1" class="ltx_p">Our last two settings are somewhat more realistic for FL. We have a setup of 100 agents, where 10 of them are corrupt, and where in each round, the aggregation server uniformly samples 10 agent out of 100. Our detection algorithm were able to perfectly distinguish adversarial agents for iid case. That is, <span id="S6.SS3.p4.1.1" class="ltx_text ltx_font_italic">when we list agents by adversarial contribution, the top-10 consisted of solely adversarial agents</span>. However, for non-iid setting, it included some non-adversarial agents. For that case, in top-5, we had 4 adversarial agents, but the places between 6-10 were non-adversarial agents.
We suspect this is because the variance of adversarial contributions are relatively higher in larger, and non-iid settings.
Again,<em id="S6.SS3.p4.1.2" class="ltx_emph ltx_font_italic">we stress that our framework could be used with other detection algorithms</em>.</p>
</div>
</section>
</section>
<section id="S7" class="ltx_section">
<h2 class="ltx_title ltx_title_section">
<span class="ltx_tag ltx_tag_section">7. </span>Security and Privacy Analysis</h2>

<div id="S7.p1" class="ltx_para">
<p id="S7.p1.1" class="ltx_p">In this section, we provide an overview of the security and privacy assurances of the proposed system. Especially, we discuss how the <span id="S7.p1.1.1" class="ltx_text ltx_font_sansserif">BlockFLA</span> system handles attacks from the adversaries discussed in section 2.4.</p>
</div>
<section id="S7.SS0.SSS1" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">7.0.1. </span>Security Analysis</h4>

<div id="S7.SS0.SSS1.p1" class="ltx_para">
<p id="S7.SS0.SSS1.p1.1" class="ltx_p">Since aggregation done on the private blockchain, as long as the 51% of the participants are honest (needed for convergence of the consensus algorithm used), the averaging needed for the FL will be correctly executed. Therefore, the aggregation will be done according to the specified protocol. Therefore, any single attacker cannot change the aggregation process.</p>
</div>
<div id="S7.SS0.SSS1.p2" class="ltx_para">
<p id="S7.SS0.SSS1.p2.1" class="ltx_p">On the other hand, a malicious worker node can try to attack the system by introducing a backdoor /trojan. Assuming the detection technique work with high probability, the participants may be held accountable for an attack.
Since all participants commit the SHA256 Hashes of their parametric updates to the public smart contract, we can easily detect incorrect disclosure of updates. If for any reason, the participant introduces a backdoor, then the federated learning algorithm can be re-simulated on the private chain using the updates as the test data using the appropriate off-chain detection technique.</p>
</div>
</section>
<section id="S7.SS0.SSS2" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">7.0.2. </span>Privacy Analysis</h4>

<div id="S7.SS0.SSS2.p1" class="ltx_para">
<p id="S7.SS0.SSS2.p1.1" class="ltx_p">The privacy protection of parameters sent over the private blockchain is achieved with the help of channels. Each worker is connected to the server by a separate channel thus maintaining strict access control on the parametric data being shared between the worker node and the server over the private chain. Since each participant can join the hyperledger framework only with authorization from the membership service provider, the data parameter updates sent between the worker nodes and the server node remain on the chain concealed from those who have no account on the private chain. Moreover, for the participant to access their own data, TLS (Transport Layer Security) over the private blockchain is used for granting access to the data. Thus, each participant’s privacy over the public blockchain is achieved with the help of hashing (i.e., single hash of millions of model parameters shared at each round). An external user or adversary can only retrieve the SHA256 hash of the parameters being exchanged over the private chain. Log files over the public cloud is encrypted and accessible only by the server.</p>
</div>
</section>
</section>
<section id="S8" class="ltx_section">
<h2 class="ltx_title ltx_title_section">
<span class="ltx_tag ltx_tag_section">8. </span>Related Work</h2>

<div id="S8.p1" class="ltx_para">
<p id="S8.p1.1" class="ltx_p">A privacy-preserving solution for federated learning has been proposed in BlockFlow <cite class="ltx_cite ltx_citemacro_citep">(Mugunthan
et al<span class="ltx_text">.</span>, <a href="#bib.bib25" title="" class="ltx_ref">2020</a>)</cite>, they consider differential privacy utilizing Laplacian noise to avoid disclosing client information to other other clients. Still, this does not address the possibility of detection of an anomaly based trojan being introduced during the learning process.
Moreover, BlockFlow performs aggregation and evaluation of client models over the ethereum blockchain which is a public chain.
However, implementing both the aggregation and penalty mechanism over the public chain drastically slows down the federated learning process. Moreover, sending models over the public chain results in expensive cost in terms of gas/ether incurred by both the client and the server which is not beneficial to the algorithm.
This issue is addressed by our system. Since federated learning is eminently reliant on communication between the worker and server nodes, we have proposed and implemented a hybrid blockchain architecture to perform the aggregation over the private chain and the penalty mechanism over the public chain. Also having a separate smart contract between each client and server by the auto contract generation will keep the penalty mechanism more structured and robust.
</p>
</div>
<div id="S8.p2" class="ltx_para">
<p id="S8.p2.1" class="ltx_p">The BC-FL framework proposed in <cite class="ltx_cite ltx_citemacro_citep">(Ma
et al<span class="ltx_text">.</span>, <a href="#bib.bib21" title="" class="ltx_ref">2020</a>)</cite> discusses the integration of a public blockchain with federated learning to prevent malicious worker nodes or UEs (User Equipment) as they call it from poisoning the learning process. They identify the issue that federated learning aggregation being conducted on a central server is a single point of failure in the federated learning process. The agenda of their system primarily involves model recording and publishing over the public chain and an incentive mechanism to motivate miners and discourage lazy nodes. To improve security while maintaining efficiency, they propose a Digital Signature system to recognize malicious clients by verifying learning results and a reputation system to reduce verification delay of a high-reputation miner. Although, the proposal makes an attempt, the system itself discourages efficiency since the federated learning aggregation is being conducted solely on the public chain. As we have seen in <cite class="ltx_cite ltx_citemacro_citep">(Konečný et al<span class="ltx_text">.</span>, <a href="#bib.bib18" title="" class="ltx_ref">2017</a>)</cite>, Federated learning without a communication-efficient framework will take a considerable amount of time to reach convergence. Public blockchains like ethereum are inherently slow to commit transactions and this will cause a significant impact to Federated Learning performance. The <span id="S8.p2.1.1" class="ltx_text ltx_font_sansserif">BlockFLA</span> framework, however, addresses this issue by implementing a hybrid blockchain framework. Secondly, the Digital Signature and the reputation system only prevents external attackers from introducing bad models. For internal attackers, it relies on input from the rest of the participants. Moreover, if a backdoor is introduced, it is not possible to be detected by the participants themselves. As we discussed, we can detect a backdoor introduced with the help of our framework.</p>
</div>
</section>
<section id="S9" class="ltx_section">
<h2 class="ltx_title ltx_title_section">
<span class="ltx_tag ltx_tag_section">9. </span>Conclusions and Future Work</h2>

<div id="S9.p1" class="ltx_para">
<p id="S9.p1.1" class="ltx_p">Federated Learning is an upcoming communication-efficient machine learning technique that trains a global model while maintaining data local. However, due to an existing risk of backdoor attacks, the poisoning of the global model can yield ineffective results in terms of classification and prediction which defeats the purpose of the overall goal of FL.</p>
</div>
<div id="S9.p2" class="ltx_para">
<p id="S9.p2.1" class="ltx_p">In order to address this aforementioned problem, we have proposed a general blockchain framework that integrates both public and private blockchains to achieve decentralization, immutability and transparency to discourage backdoor attacks on federated learning algorithms by holding the responsible parties accountable. We have shown that our framework facilitates the adaptation to any federated learning algorithm rendering a plug-and-play setting. We have presented the implementation of the Federated Averaging and signSGD algorithm
over our general blockchain framework and based on our empirical results, conclude that our proposed approach maintains the communication-efficient nature of these algorithms.</p>
</div>
<div id="S9.p3" class="ltx_para">
<p id="S9.p3.1" class="ltx_p">We have also proposed and implemented an algorithm that runs off the chain server-side to successfully detect the attacker who introduced the trojan for the Federated Averaging algorithm. Our experiments show that we are able to effectively detect the participant who has introduced the model poisoning attack. Furthermore, the blockchain-based penalty system proves to be an efficient deterrent for an attacker to carry out any model poisoning attacks by injecting backdoors/trojan.</p>
</div>
<div id="S9.p4" class="ltx_para">
<p id="S9.p4.1" class="ltx_p">As a future work, we plan to develop a trojan detection algorithm for signSGD. This seems to be challenging due to the communication involving only bits instead of real numbers. Still, we believe this is feasible by using more trojan examples. In addition, we will look into integrating other federated learning aggregation algorithms in our system.</p>
</div>
<div class="ltx_pagination ltx_role_newpage"></div>
</section>
<section id="bib" class="ltx_bibliography">
<h2 class="ltx_title ltx_title_bibliography">References</h2>

<ul class="ltx_biblist">
<li id="bib.bib1" class="ltx_bibitem">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">(1)</span>
<span class="ltx_bibblock">        




</span>
</li>
<li id="bib.bib2" class="ltx_bibitem">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">the ([n.d.])</span>
<span class="ltx_bibblock">
[n.d.].

</span>
<span class="ltx_bibblock">Common architectures in convolutional neural
networks.

</span>
<span class="ltx_bibblock">
</span>
<span class="ltx_bibblock">
<a target="_blank" href="https://www.jeremyjordan.me/convnet-architectures/" title="" class="ltx_ref ltx_url ltx_font_typewriter">https://www.jeremyjordan.me/convnet-architectures/</a>

</span>
</li>
<li id="bib.bib3" class="ltx_bibitem">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">Androulaki et al<span id="bib.bib3.2.2.1" class="ltx_text">.</span> (2018)</span>
<span class="ltx_bibblock">
Elli Androulaki, Artem
Barger, Vita Bortnikov, Christian
Cachin, Konstantinos Christidis, Angelo
De Caro, David Enyeart, Christopher
Ferris, Gennady Laventman, Yacov
Manevich, Srinivasan Muralidharan, Chet
Murthy, Binh Nguyen, Manish Sethi,
Gari Singh, Keith Smith,
Alessandro Sorniotti, Chrysoula
Stathakopoulou, Marko Vukolić,
Sharon Weed Cocco, and Jason Yellick.
2018.

</span>
<span class="ltx_bibblock">Hyperledger Fabric: A Distributed Operating System
for Permissioned Blockchains. In <em id="bib.bib3.3.1" class="ltx_emph ltx_font_italic">Proceedings of
the Thirteenth EuroSys Conference</em> (Porto, Portugal)
<em id="bib.bib3.4.2" class="ltx_emph ltx_font_italic">(EuroSys ’18)</em>. Association for
Computing Machinery, New York, NY, USA, Article
30, 15 pages.

</span>
<span class="ltx_bibblock">

<a target="_blank" href="https://doi.org/10.1145/3190508.3190538" title="" class="ltx_ref ltx_url ltx_font_typewriter">https://doi.org/10.1145/3190508.3190538</a>

</span>
</li>
<li id="bib.bib4" class="ltx_bibitem">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">Bagdasaryan et al<span id="bib.bib4.2.2.1" class="ltx_text">.</span> (2020)</span>
<span class="ltx_bibblock">
Eugene Bagdasaryan,
Andreas Veit, Yiqing Hua,
Deborah Estrin, and Vitaly Shmatikov.
2020.

</span>
<span class="ltx_bibblock">How to backdoor federated learning. In
<em id="bib.bib4.3.1" class="ltx_emph ltx_font_italic">International Conference on Artificial Intelligence
and Statistics</em>. 2938–2948.

</span>
<span class="ltx_bibblock">
</span>
</li>
<li id="bib.bib5" class="ltx_bibitem">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">Bernstein et al<span id="bib.bib5.2.2.1" class="ltx_text">.</span> (2018)</span>
<span class="ltx_bibblock">
Jeremy Bernstein, Yu-Xiang
Wang, Kamyar Azizzadenesheli, and Anima
Anandkumar. 2018.

</span>
<span class="ltx_bibblock">signSGD: Compressed Optimisation for Non-Convex
Problems.

</span>
<span class="ltx_bibblock">
</span>
<span class="ltx_bibblock">arXiv:1802.04434 [cs.LG]

</span>
</li>
<li id="bib.bib6" class="ltx_bibitem">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">Bhagoji et al<span id="bib.bib6.2.2.1" class="ltx_text">.</span> (2019)</span>
<span class="ltx_bibblock">
Arjun Nitin Bhagoji,
Supriyo Chakraborty, Prateek Mittal,
and Seraphin Calo. 2019.

</span>
<span class="ltx_bibblock">Analyzing federated learning through an adversarial
lens. In <em id="bib.bib6.3.1" class="ltx_emph ltx_font_italic">International Conference on Machine
Learning</em>. 634–643.

</span>
<span class="ltx_bibblock">
</span>
</li>
<li id="bib.bib7" class="ltx_bibitem">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">Blanchard et al<span id="bib.bib7.3.3.1" class="ltx_text">.</span> (2017)</span>
<span class="ltx_bibblock">
Peva Blanchard, Rachid
Guerraoui, Julien Stainer, et al<span id="bib.bib7.4.1" class="ltx_text">.</span>
2017.

</span>
<span class="ltx_bibblock">Machine learning with adversaries: Byzantine
tolerant gradient descent. In <em id="bib.bib7.5.1" class="ltx_emph ltx_font_italic">Advances in Neural
Information Processing Systems</em>. 119–129.

</span>
<span class="ltx_bibblock">
</span>
</li>
<li id="bib.bib8" class="ltx_bibitem">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">Bonawitz et al<span id="bib.bib8.2.2.1" class="ltx_text">.</span> (2017)</span>
<span class="ltx_bibblock">
Keith Bonawitz, Vladimir
Ivanov, Ben Kreuter, Antonio Marcedone,
H Brendan McMahan, Sarvar Patel,
Daniel Ramage, Aaron Segal, and
Karn Seth. 2017.

</span>
<span class="ltx_bibblock">Practical secure aggregation for privacy-preserving
machine learning. In <em id="bib.bib8.3.1" class="ltx_emph ltx_font_italic">Proceedings of the 2017 ACM
SIGSAC Conference on Computer and Communications Security</em>.
1175–1191.

</span>
<span class="ltx_bibblock">
</span>
</li>
<li id="bib.bib9" class="ltx_bibitem">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">Castro and Liskov (2002)</span>
<span class="ltx_bibblock">
Miguel Castro and
Barbara Liskov. 2002.

</span>
<span class="ltx_bibblock">Practical Byzantine Fault Tolerance and Proactive
Recovery.

</span>
<span class="ltx_bibblock"><em id="bib.bib9.1.1" class="ltx_emph ltx_font_italic">ACM Trans. Comput. Syst.</em>
20, 4 (Nov.
2002), 398–461.

</span>
<span class="ltx_bibblock">

<a target="_blank" href="https://doi.org/10.1145/571637.571640" title="" class="ltx_ref ltx_url ltx_font_typewriter">https://doi.org/10.1145/571637.571640</a>

</span>
</li>
<li id="bib.bib10" class="ltx_bibitem">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">Chen
et al<span id="bib.bib10.2.2.1" class="ltx_text">.</span> (2017)</span>
<span class="ltx_bibblock">
Xinyun Chen, Chang Liu,
Bo Li, Kimberly Lu, and
Dawn Song. 2017.

</span>
<span class="ltx_bibblock">Targeted backdoor attacks on deep learning systems
using data poisoning.

</span>
<span class="ltx_bibblock"><em id="bib.bib10.3.1" class="ltx_emph ltx_font_italic">arXiv preprint arXiv:1712.05526</em>
(2017).

</span>
<span class="ltx_bibblock">
</span>
</li>
<li id="bib.bib11" class="ltx_bibitem">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">Desai et al<span id="bib.bib11.2.2.1" class="ltx_text">.</span> (2018)</span>
<span class="ltx_bibblock">
H. Desai, K. Liu,
M. Kantarcioglu, and L. Kagal.
2018.

</span>
<span class="ltx_bibblock">Adjudicating Violations in Data Sharing Agreements
Using Smart Contracts. In <em id="bib.bib11.3.1" class="ltx_emph ltx_font_italic">2018 IEEE International
Conference on Internet of Things (iThings) and IEEE Green Computing and
Communications (GreenCom) and IEEE Cyber, Physical and Social Computing
(CPSCom) and IEEE Smart Data (SmartData)</em>. 1553–1560.

</span>
<span class="ltx_bibblock">
</span>
</li>
<li id="bib.bib12" class="ltx_bibitem">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">Fung
et al<span id="bib.bib12.2.2.1" class="ltx_text">.</span> (2020)</span>
<span class="ltx_bibblock">
Clement Fung, Chris J. M.
Yoon, and Ivan Beschastnikh.
2020.

</span>
<span class="ltx_bibblock">Mitigating Sybils in Federated Learning Poisoning.

</span>
<span class="ltx_bibblock"><em id="bib.bib12.3.1" class="ltx_emph ltx_font_italic">arXiv preprint arXiv:1808.04866</em>
(2020).

</span>
<span class="ltx_bibblock">
</span>
</li>
<li id="bib.bib13" class="ltx_bibitem">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">Geyer
et al<span id="bib.bib13.2.2.1" class="ltx_text">.</span> (2017)</span>
<span class="ltx_bibblock">
Robin C Geyer, Tassilo
Klein, and Moin Nabi. 2017.

</span>
<span class="ltx_bibblock">Differentially private federated learning: A client
level perspective.

</span>
<span class="ltx_bibblock"><em id="bib.bib13.3.1" class="ltx_emph ltx_font_italic">arXiv preprint arXiv:1712.07557</em>
(2017).

</span>
<span class="ltx_bibblock">
</span>
</li>
<li id="bib.bib14" class="ltx_bibitem">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">Gorenflo
et al<span id="bib.bib14.2.2.1" class="ltx_text">.</span> (2019)</span>
<span class="ltx_bibblock">
Christian Gorenflo,
Stephen Lee, Lukasz Golab, and
Srinivasan Keshav. 2019.

</span>
<span class="ltx_bibblock">Fastfabric: Scaling hyperledger fabric to 20,000
transactions per second. In <em id="bib.bib14.3.1" class="ltx_emph ltx_font_italic">2019 IEEE
International Conference on Blockchain and Cryptocurrency (ICBC)</em>. IEEE,
455–463.

</span>
<span class="ltx_bibblock">
</span>
</li>
<li id="bib.bib15" class="ltx_bibitem">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">Hao
et al<span id="bib.bib15.2.2.1" class="ltx_text">.</span> (2018)</span>
<span class="ltx_bibblock">
Y. Hao, Y. Li,
X. Dong, L. Fang, and
P. Chen. 2018.

</span>
<span class="ltx_bibblock">Performance Analysis of Consensus Algorithm in
Private Blockchain. In <em id="bib.bib15.3.1" class="ltx_emph ltx_font_italic">2018 IEEE Intelligent
Vehicles Symposium (IV)</em>. 280–285.

</span>
<span class="ltx_bibblock">
</span>
</li>
<li id="bib.bib16" class="ltx_bibitem">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">Jakobsson and
Juels (1999)</span>
<span class="ltx_bibblock">
Markus Jakobsson and Ari
Juels. 1999.

</span>
<span class="ltx_bibblock"><em id="bib.bib16.1.1" class="ltx_emph ltx_font_italic">Proofs of Work and Bread Pudding
Protocols(Extended Abstract)</em>.

</span>
<span class="ltx_bibblock">Springer US, Boston, MA,
258–272.

</span>
<span class="ltx_bibblock">
</span>
</li>
<li id="bib.bib17" class="ltx_bibitem">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">Kim et al<span id="bib.bib17.2.2.1" class="ltx_text">.</span> (2018)</span>
<span class="ltx_bibblock">
Seoung Kyun Kim, Zane Ma,
Siddharth Murali, Joshua Mason,
Andrew Miller, and Michael Bailey.
2018.

</span>
<span class="ltx_bibblock">Measuring ethereum network peers. In
<em id="bib.bib17.3.1" class="ltx_emph ltx_font_italic">Proceedings of the Internet Measurement Conference
2018</em>. 91–104.

</span>
<span class="ltx_bibblock">
</span>
</li>
<li id="bib.bib18" class="ltx_bibitem">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">Konečný et al<span id="bib.bib18.2.2.1" class="ltx_text">.</span> (2017)</span>
<span class="ltx_bibblock">
Jakub Konečný,
H. Brendan McMahan, Felix X. Yu,
Peter Richtárik, Ananda Theertha Suresh,
and Dave Bacon. 2017.

</span>
<span class="ltx_bibblock">Federated Learning: Strategies for Improving
Communication Efficiency.

</span>
<span class="ltx_bibblock">
</span>
<span class="ltx_bibblock">arXiv:1610.05492 [cs.LG]

</span>
</li>
<li id="bib.bib19" class="ltx_bibitem">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">Krizhevsky
et al<span id="bib.bib19.2.2.1" class="ltx_text">.</span> (2009)</span>
<span class="ltx_bibblock">
Alex Krizhevsky, Vinod
Nair, and Geoffrey Hinton.
2009.

</span>
<span class="ltx_bibblock">CIFAR-10 (Canadian Institute for Advanced
Research).

</span>
<span class="ltx_bibblock">(2009).

</span>
<span class="ltx_bibblock">
<a target="_blank" href="http://www.cs.toronto.edu/~kriz/cifar.html" title="" class="ltx_ref ltx_url ltx_font_typewriter">http://www.cs.toronto.edu/~kriz/cifar.html</a>

</span>
</li>
<li id="bib.bib20" class="ltx_bibitem">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">Liu et al<span id="bib.bib20.2.2.1" class="ltx_text">.</span> (2018)</span>
<span class="ltx_bibblock">
Yingqi Liu, Shiqing Ma,
Yousra Aafer, Wen-Chuan Lee,
Juan Zhai, Weihang Wang, and
Xiangyu Zhang. 2018.

</span>
<span class="ltx_bibblock">Trojaning Attack on Neural Networks. In
<em id="bib.bib20.3.1" class="ltx_emph ltx_font_italic">25nd Annual Network and Distributed System Security
Symposium, NDSS 2018, San Diego, California, USA, February 18-221, 2018</em>.
The Internet Society.

</span>
<span class="ltx_bibblock">
</span>
</li>
<li id="bib.bib21" class="ltx_bibitem">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">Ma
et al<span id="bib.bib21.2.2.1" class="ltx_text">.</span> (2020)</span>
<span class="ltx_bibblock">
Chuan Ma, Jun Li,
Ming Ding, Long Shi,
Taotao Wang, Zhu Han, and
H. Vincent Poor. 2020.

</span>
<span class="ltx_bibblock">When Federated Learning Meets Blockchain: A New
Distributed Learning Paradigm.

</span>
<span class="ltx_bibblock">
</span>
<span class="ltx_bibblock">arXiv:2009.09338 [cs.NI]

</span>
</li>
<li id="bib.bib22" class="ltx_bibitem">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">McMahan et al<span id="bib.bib22.3.3.1" class="ltx_text">.</span> (2016b)</span>
<span class="ltx_bibblock">
H Brendan McMahan, Eider
Moore, Daniel Ramage, Seth Hampson,
et al<span id="bib.bib22.4.1" class="ltx_text">.</span> 2016b.

</span>
<span class="ltx_bibblock">Communication-efficient learning of deep networks
from decentralized data.

</span>
<span class="ltx_bibblock"><em id="bib.bib22.5.1" class="ltx_emph ltx_font_italic">arXiv preprint arXiv:1602.05629</em>
(2016).

</span>
<span class="ltx_bibblock">
</span>
</li>
<li id="bib.bib23" class="ltx_bibitem">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">McMahan et al<span id="bib.bib23.2.2.1" class="ltx_text">.</span> (2016a)</span>
<span class="ltx_bibblock">
H. Brendan McMahan, Eider
Moore, Daniel Ramage, Seth Hampson,
and Blaise Agüera y Arcas.
2016a.

</span>
<span class="ltx_bibblock">Communication-Efficient Learning of Deep Networks
from Decentralized Data.

</span>
<span class="ltx_bibblock">
</span>
<span class="ltx_bibblock">arXiv:1602.05629 [cs.LG]

</span>
</li>
<li id="bib.bib24" class="ltx_bibitem">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">Mhamdi
et al<span id="bib.bib24.2.2.1" class="ltx_text">.</span> (2018)</span>
<span class="ltx_bibblock">
El Mahdi El Mhamdi, Rachid
Guerraoui, and Sébastien Rouault.
2018.

</span>
<span class="ltx_bibblock">The hidden vulnerability of distributed learning in
byzantium.

</span>
<span class="ltx_bibblock"><em id="bib.bib24.3.1" class="ltx_emph ltx_font_italic">arXiv preprint arXiv:1802.07927</em>
(2018).

</span>
<span class="ltx_bibblock">
</span>
</li>
<li id="bib.bib25" class="ltx_bibitem">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">Mugunthan
et al<span id="bib.bib25.2.2.1" class="ltx_text">.</span> (2020)</span>
<span class="ltx_bibblock">
Vaikkunth Mugunthan, Ravi
Rahman, and Lalana Kagal.
2020.

</span>
<span class="ltx_bibblock">BlockFLow: An Accountable and Privacy-Preserving
Solution for Federated Learning.

</span>
<span class="ltx_bibblock">
</span>
<span class="ltx_bibblock">arXiv:2007.03856 [cs.LG]

</span>
</li>
<li id="bib.bib26" class="ltx_bibitem">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">Nakamoto (2009)</span>
<span class="ltx_bibblock">
Satoshi Nakamoto.
2009.

</span>
<span class="ltx_bibblock">Bitcoin: A Peer-to-Peer Electronic Cash System.

</span>
<span class="ltx_bibblock"><em id="bib.bib26.1.1" class="ltx_emph ltx_font_italic">Cryptography Mailing list at
https://metzdowd.com</em> (03 2009).

</span>
<span class="ltx_bibblock">
</span>
</li>
<li id="bib.bib27" class="ltx_bibitem">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">Ozdayi
et al<span id="bib.bib27.2.2.1" class="ltx_text">.</span> (2020)</span>
<span class="ltx_bibblock">
Mustafa Safa Ozdayi, Murat
Kantarcioglu, and Yulia R Gel.
2020.

</span>
<span class="ltx_bibblock">Defending Against Backdoors in Federated Learning
with Robust Learning Rate.

</span>
<span class="ltx_bibblock"><em id="bib.bib27.3.1" class="ltx_emph ltx_font_italic">arXiv preprint arXiv:2007.03767</em>
(2020).

</span>
<span class="ltx_bibblock">
</span>
</li>
<li id="bib.bib28" class="ltx_bibitem">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">Pillutla
et al<span id="bib.bib28.2.2.1" class="ltx_text">.</span> (2019)</span>
<span class="ltx_bibblock">
Krishna Pillutla, Sham M
Kakade, and Zaid Harchaoui.
2019.

</span>
<span class="ltx_bibblock">Robust aggregation for federated learning.

</span>
<span class="ltx_bibblock"><em id="bib.bib28.3.1" class="ltx_emph ltx_font_italic">arXiv preprint arXiv:1912.13445</em>
(2019).

</span>
<span class="ltx_bibblock">
</span>
</li>
<li id="bib.bib29" class="ltx_bibitem">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">Pongnumkul et al<span id="bib.bib29.2.2.1" class="ltx_text">.</span> (2017)</span>
<span class="ltx_bibblock">
S. Pongnumkul, C.
Siripanpornchana, and S. Thajchayapong.
2017.

</span>
<span class="ltx_bibblock">Performance Analysis of Private Blockchain
Platforms in Varying Workloads. In <em id="bib.bib29.3.1" class="ltx_emph ltx_font_italic">2017 26th
International Conference on Computer Communication and Networks (ICCCN)</em>.
1–6.

</span>
<span class="ltx_bibblock">
</span>
</li>
<li id="bib.bib30" class="ltx_bibitem">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">Sattler et al<span id="bib.bib30.2.2.1" class="ltx_text">.</span> (2019)</span>
<span class="ltx_bibblock">
Felix Sattler, Simon
Wiedemann, Klaus-Robert Müller, and
Wojciech Samek. 2019.

</span>
<span class="ltx_bibblock">Robust and communication-efficient federated
learning from non-iid data.

</span>
<span class="ltx_bibblock"><em id="bib.bib30.3.1" class="ltx_emph ltx_font_italic">IEEE transactions on neural networks and
learning systems</em> (2019).

</span>
<span class="ltx_bibblock">
</span>
</li>
<li id="bib.bib31" class="ltx_bibitem">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">Shafahi et al<span id="bib.bib31.2.2.1" class="ltx_text">.</span> (2018)</span>
<span class="ltx_bibblock">
Ali Shafahi, W Ronny
Huang, Mahyar Najibi, Octavian Suciu,
Christoph Studer, Tudor Dumitras, and
Tom Goldstein. 2018.

</span>
<span class="ltx_bibblock">Poison frogs! targeted clean-label poisoning
attacks on neural networks. In <em id="bib.bib31.3.1" class="ltx_emph ltx_font_italic">Advances in Neural
Information Processing Systems</em>. 6103–6113.

</span>
<span class="ltx_bibblock">
</span>
</li>
<li id="bib.bib32" class="ltx_bibitem">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">Shoham et al<span id="bib.bib32.2.2.1" class="ltx_text">.</span> (2019)</span>
<span class="ltx_bibblock">
Neta Shoham, Tomer
Avidor, Aviv Keren, Nadav Israel,
Daniel Benditkis, Liron Mor-Yosef, and
Itai Zeitak. 2019.

</span>
<span class="ltx_bibblock">Overcoming Forgetting in Federated Learning on
Non-IID Data.

</span>
<span class="ltx_bibblock"><em id="bib.bib32.3.1" class="ltx_emph ltx_font_italic">arXiv preprint arXiv:1910.07796</em>
(2019).

</span>
<span class="ltx_bibblock">
</span>
</li>
<li id="bib.bib33" class="ltx_bibitem">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">Sun
et al<span id="bib.bib33.2.2.1" class="ltx_text">.</span> (2019)</span>
<span class="ltx_bibblock">
Ziteng Sun, Peter
Kairouz, Ananda Theertha Suresh, and
H Brendan McMahan. 2019.

</span>
<span class="ltx_bibblock">Can you really backdoor federated learning?

</span>
<span class="ltx_bibblock"><em id="bib.bib33.3.1" class="ltx_emph ltx_font_italic">arXiv preprint arXiv:1911.07963</em>
(2019).

</span>
<span class="ltx_bibblock">
</span>
</li>
<li id="bib.bib34" class="ltx_bibitem">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">Wood ([n.d.])</span>
<span class="ltx_bibblock">
Gavin Wood.
[n.d.].

</span>
<span class="ltx_bibblock">Ethereum: A secure decentralised generalised
transaction ledger.

</span>
<span class="ltx_bibblock">([n. d.]).

</span>
<span class="ltx_bibblock">
</span>
</li>
<li id="bib.bib35" class="ltx_bibitem">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">Yin
et al<span id="bib.bib35.2.2.1" class="ltx_text">.</span> (2018)</span>
<span class="ltx_bibblock">
Dong Yin, Yudong Chen,
Ramchandran Kannan, and Peter
Bartlett. 2018.

</span>
<span class="ltx_bibblock">Byzantine-Robust Distributed Learning: Towards
Optimal Statistical Rates. In <em id="bib.bib35.3.1" class="ltx_emph ltx_font_italic">International
Conference on Machine Learning</em>. 5650–5659.

</span>
<span class="ltx_bibblock">
</span>
</li>
</ul>
</section>
<section id="A1" class="ltx_appendix">
<h2 class="ltx_title ltx_title_appendix">
<span class="ltx_tag ltx_tag_appendix">Appendix A </span>Hyperparameters of Experiments</h2>

<div id="A1.p1" class="ltx_para">
<p id="A1.p1.1" class="ltx_p">We remind the notation we used for our experiments, and report the hyperparameters accordingly.</p>
<ul id="A1.I1" class="ltx_itemize">
<li id="A1.I1.i1" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">•</span> 
<div id="A1.I1.i1.p1" class="ltx_para">
<p id="A1.I1.i1.p1.1" class="ltx_p">R: Number of rounds</p>
</div>
</li>
<li id="A1.I1.i2" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">•</span> 
<div id="A1.I1.i2.p1" class="ltx_para">
<p id="A1.I1.i2.p1.1" class="ltx_p">K: Total number of agents</p>
</div>
</li>
<li id="A1.I1.i3" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">•</span> 
<div id="A1.I1.i3.p1" class="ltx_para">
<p id="A1.I1.i3.p1.1" class="ltx_p">F: Fraction of corrupt agents</p>
</div>
</li>
<li id="A1.I1.i4" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">•</span> 
<div id="A1.I1.i4.p1" class="ltx_para">
<p id="A1.I1.i4.p1.1" class="ltx_p">C: Fraction of selected agents for training in a round</p>
</div>
</li>
<li id="A1.I1.i5" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">•</span> 
<div id="A1.I1.i5.p1" class="ltx_para">
<p id="A1.I1.i5.p1.1" class="ltx_p">E: Number of epochs in local training</p>
</div>
</li>
<li id="A1.I1.i6" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">•</span> 
<div id="A1.I1.i6.p1" class="ltx_para">
<p id="A1.I1.i6.p1.1" class="ltx_p">B: Batch size of local training</p>
</div>
</li>
<li id="A1.I1.i7" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">•</span> 
<div id="A1.I1.i7.p1" class="ltx_para">
<p id="A1.I1.i7.p1.1" class="ltx_p"><math id="A1.I1.i7.p1.1.m1.1" class="ltx_Math" alttext="\eta" display="inline"><semantics id="A1.I1.i7.p1.1.m1.1a"><mi id="A1.I1.i7.p1.1.m1.1.1" xref="A1.I1.i7.p1.1.m1.1.1.cmml">η</mi><annotation-xml encoding="MathML-Content" id="A1.I1.i7.p1.1.m1.1b"><ci id="A1.I1.i7.p1.1.m1.1.1.cmml" xref="A1.I1.i7.p1.1.m1.1.1">𝜂</ci></annotation-xml><annotation encoding="application/x-tex" id="A1.I1.i7.p1.1.m1.1c">\eta</annotation></semantics></math>: Server’s learning rate</p>
</div>
</li>
<li id="A1.I1.i8" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">•</span> 
<div id="A1.I1.i8.p1" class="ltx_para">
<p id="A1.I1.i8.p1.2" class="ltx_p"><math id="A1.I1.i8.p1.1.m1.1" class="ltx_Math" alttext="\kappa" display="inline"><semantics id="A1.I1.i8.p1.1.m1.1a"><mi id="A1.I1.i8.p1.1.m1.1.1" xref="A1.I1.i8.p1.1.m1.1.1.cmml">κ</mi><annotation-xml encoding="MathML-Content" id="A1.I1.i8.p1.1.m1.1b"><ci id="A1.I1.i8.p1.1.m1.1.1.cmml" xref="A1.I1.i8.p1.1.m1.1.1">𝜅</ci></annotation-xml><annotation encoding="application/x-tex" id="A1.I1.i8.p1.1.m1.1c">\kappa</annotation></semantics></math>: Number of parameter to compute <math id="A1.I1.i8.p1.2.m2.1" class="ltx_Math" alttext="L_{2}" display="inline"><semantics id="A1.I1.i8.p1.2.m2.1a"><msub id="A1.I1.i8.p1.2.m2.1.1" xref="A1.I1.i8.p1.2.m2.1.1.cmml"><mi id="A1.I1.i8.p1.2.m2.1.1.2" xref="A1.I1.i8.p1.2.m2.1.1.2.cmml">L</mi><mn id="A1.I1.i8.p1.2.m2.1.1.3" xref="A1.I1.i8.p1.2.m2.1.1.3.cmml">2</mn></msub><annotation-xml encoding="MathML-Content" id="A1.I1.i8.p1.2.m2.1b"><apply id="A1.I1.i8.p1.2.m2.1.1.cmml" xref="A1.I1.i8.p1.2.m2.1.1"><csymbol cd="ambiguous" id="A1.I1.i8.p1.2.m2.1.1.1.cmml" xref="A1.I1.i8.p1.2.m2.1.1">subscript</csymbol><ci id="A1.I1.i8.p1.2.m2.1.1.2.cmml" xref="A1.I1.i8.p1.2.m2.1.1.2">𝐿</ci><cn type="integer" id="A1.I1.i8.p1.2.m2.1.1.3.cmml" xref="A1.I1.i8.p1.2.m2.1.1.3">2</cn></apply></annotation-xml><annotation encoding="application/x-tex" id="A1.I1.i8.p1.2.m2.1c">L_{2}</annotation></semantics></math> norm for (cf. Section <a href="#S3.SS6" title="3.6. An Attacker Detection Algorithm for Trojaning Attacks ‣ 3. System Architecture ‣ BlockFLA: Accountable Federated Learning via Hybrid Blockchain Architecture" class="ltx_ref"><span class="ltx_text ltx_ref_tag">3.6</span></a>.)</p>
</div>
</li>
</ul>
</div>
<figure id="A1.T2" class="ltx_table">
<div id="A1.T2.2" class="ltx_inline-block ltx_align_center ltx_transformed_outer" style="width:303.5pt;height:58.2pt;vertical-align:-0.0pt;"><span class="ltx_transformed_inner" style="transform:translate(57.9pt,-11.1pt) scale(1.6162048358301,1.6162048358301) ;">
<table id="A1.T2.2.2" class="ltx_tabular ltx_guessed_headers ltx_align_middle">
<thead class="ltx_thead">
<tr id="A1.T2.2.2.2" class="ltx_tr">
<th id="A1.T2.2.2.2.3" class="ltx_td ltx_align_center ltx_th ltx_th_column ltx_border_tt">R</th>
<th id="A1.T2.2.2.2.4" class="ltx_td ltx_align_center ltx_th ltx_th_column ltx_border_tt">K</th>
<th id="A1.T2.2.2.2.5" class="ltx_td ltx_align_center ltx_th ltx_th_column ltx_border_tt">F</th>
<th id="A1.T2.2.2.2.6" class="ltx_td ltx_align_center ltx_th ltx_th_column ltx_border_tt">C</th>
<th id="A1.T2.2.2.2.7" class="ltx_td ltx_align_center ltx_th ltx_th_column ltx_border_tt">E</th>
<th id="A1.T2.2.2.2.8" class="ltx_td ltx_align_center ltx_th ltx_th_column ltx_border_tt">B</th>
<th id="A1.T2.1.1.1.1" class="ltx_td ltx_align_center ltx_th ltx_th_column ltx_border_tt"><math id="A1.T2.1.1.1.1.m1.1" class="ltx_Math" alttext="\eta" display="inline"><semantics id="A1.T2.1.1.1.1.m1.1a"><mi id="A1.T2.1.1.1.1.m1.1.1" xref="A1.T2.1.1.1.1.m1.1.1.cmml">η</mi><annotation-xml encoding="MathML-Content" id="A1.T2.1.1.1.1.m1.1b"><ci id="A1.T2.1.1.1.1.m1.1.1.cmml" xref="A1.T2.1.1.1.1.m1.1.1">𝜂</ci></annotation-xml><annotation encoding="application/x-tex" id="A1.T2.1.1.1.1.m1.1c">\eta</annotation></semantics></math></th>
<th id="A1.T2.2.2.2.2" class="ltx_td ltx_align_center ltx_th ltx_th_column ltx_border_tt"><math id="A1.T2.2.2.2.2.m1.1" class="ltx_Math" alttext="\kappa" display="inline"><semantics id="A1.T2.2.2.2.2.m1.1a"><mi id="A1.T2.2.2.2.2.m1.1.1" xref="A1.T2.2.2.2.2.m1.1.1.cmml">κ</mi><annotation-xml encoding="MathML-Content" id="A1.T2.2.2.2.2.m1.1b"><ci id="A1.T2.2.2.2.2.m1.1.1.cmml" xref="A1.T2.2.2.2.2.m1.1.1">𝜅</ci></annotation-xml><annotation encoding="application/x-tex" id="A1.T2.2.2.2.2.m1.1c">\kappa</annotation></semantics></math></th>
</tr>
</thead>
<tbody class="ltx_tbody">
<tr id="A1.T2.2.2.3.1" class="ltx_tr">
<td id="A1.T2.2.2.3.1.1" class="ltx_td ltx_align_center ltx_border_bb ltx_border_t">100</td>
<td id="A1.T2.2.2.3.1.2" class="ltx_td ltx_align_center ltx_border_bb ltx_border_t">10</td>
<td id="A1.T2.2.2.3.1.3" class="ltx_td ltx_align_center ltx_border_bb ltx_border_t">0.1</td>
<td id="A1.T2.2.2.3.1.4" class="ltx_td ltx_align_center ltx_border_bb ltx_border_t">1</td>
<td id="A1.T2.2.2.3.1.5" class="ltx_td ltx_align_center ltx_border_bb ltx_border_t">2</td>
<td id="A1.T2.2.2.3.1.6" class="ltx_td ltx_align_center ltx_border_bb ltx_border_t">256</td>
<td id="A1.T2.2.2.3.1.7" class="ltx_td ltx_align_center ltx_border_bb ltx_border_t">1</td>
<td id="A1.T2.2.2.3.1.8" class="ltx_td ltx_align_center ltx_border_bb ltx_border_t">1000</td>
</tr>
</tbody>
</table>
</span></div>
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_table"><span id="A1.T2.4.1.1" class="ltx_text" style="font-size:90%;">Table 2</span>. </span><span id="A1.T2.5.2" class="ltx_text" style="font-size:90%;">Hyperparameters for small setting.</span></figcaption>
</figure>
<figure id="A1.T3" class="ltx_table">
<div id="A1.T3.2" class="ltx_inline-block ltx_align_center ltx_transformed_outer" style="width:303.5pt;height:56.5pt;vertical-align:-0.0pt;"><span class="ltx_transformed_inner" style="transform:translate(55.1pt,-10.3pt) scale(1.56976864115931,1.56976864115931) ;">
<table id="A1.T3.2.2" class="ltx_tabular ltx_guessed_headers ltx_align_middle">
<thead class="ltx_thead">
<tr id="A1.T3.2.2.2" class="ltx_tr">
<th id="A1.T3.2.2.2.3" class="ltx_td ltx_align_center ltx_th ltx_th_column ltx_border_tt">R</th>
<th id="A1.T3.2.2.2.4" class="ltx_td ltx_align_center ltx_th ltx_th_column ltx_border_tt">K</th>
<th id="A1.T3.2.2.2.5" class="ltx_td ltx_align_center ltx_th ltx_th_column ltx_border_tt">F</th>
<th id="A1.T3.2.2.2.6" class="ltx_td ltx_align_center ltx_th ltx_th_column ltx_border_tt">C</th>
<th id="A1.T3.2.2.2.7" class="ltx_td ltx_align_center ltx_th ltx_th_column ltx_border_tt">E</th>
<th id="A1.T3.2.2.2.8" class="ltx_td ltx_align_center ltx_th ltx_th_column ltx_border_tt">B</th>
<th id="A1.T3.1.1.1.1" class="ltx_td ltx_align_center ltx_th ltx_th_column ltx_border_tt"><math id="A1.T3.1.1.1.1.m1.1" class="ltx_Math" alttext="\eta" display="inline"><semantics id="A1.T3.1.1.1.1.m1.1a"><mi id="A1.T3.1.1.1.1.m1.1.1" xref="A1.T3.1.1.1.1.m1.1.1.cmml">η</mi><annotation-xml encoding="MathML-Content" id="A1.T3.1.1.1.1.m1.1b"><ci id="A1.T3.1.1.1.1.m1.1.1.cmml" xref="A1.T3.1.1.1.1.m1.1.1">𝜂</ci></annotation-xml><annotation encoding="application/x-tex" id="A1.T3.1.1.1.1.m1.1c">\eta</annotation></semantics></math></th>
<th id="A1.T3.2.2.2.2" class="ltx_td ltx_align_center ltx_th ltx_th_column ltx_border_tt"><math id="A1.T3.2.2.2.2.m1.1" class="ltx_Math" alttext="\kappa" display="inline"><semantics id="A1.T3.2.2.2.2.m1.1a"><mi id="A1.T3.2.2.2.2.m1.1.1" xref="A1.T3.2.2.2.2.m1.1.1.cmml">κ</mi><annotation-xml encoding="MathML-Content" id="A1.T3.2.2.2.2.m1.1b"><ci id="A1.T3.2.2.2.2.m1.1.1.cmml" xref="A1.T3.2.2.2.2.m1.1.1">𝜅</ci></annotation-xml><annotation encoding="application/x-tex" id="A1.T3.2.2.2.2.m1.1c">\kappa</annotation></semantics></math></th>
</tr>
</thead>
<tbody class="ltx_tbody">
<tr id="A1.T3.2.2.3.1" class="ltx_tr">
<td id="A1.T3.2.2.3.1.1" class="ltx_td ltx_align_center ltx_border_bb ltx_border_t">200</td>
<td id="A1.T3.2.2.3.1.2" class="ltx_td ltx_align_center ltx_border_bb ltx_border_t">100</td>
<td id="A1.T3.2.2.3.1.3" class="ltx_td ltx_align_center ltx_border_bb ltx_border_t">0.1</td>
<td id="A1.T3.2.2.3.1.4" class="ltx_td ltx_align_center ltx_border_bb ltx_border_t">0.1</td>
<td id="A1.T3.2.2.3.1.5" class="ltx_td ltx_align_center ltx_border_bb ltx_border_t">5</td>
<td id="A1.T3.2.2.3.1.6" class="ltx_td ltx_align_center ltx_border_bb ltx_border_t">32</td>
<td id="A1.T3.2.2.3.1.7" class="ltx_td ltx_align_center ltx_border_bb ltx_border_t">1</td>
<td id="A1.T3.2.2.3.1.8" class="ltx_td ltx_align_center ltx_border_bb ltx_border_t">1000</td>
</tr>
</tbody>
</table>
</span></div>
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_table"><span id="A1.T3.4.1.1" class="ltx_text" style="font-size:90%;">Table 3</span>. </span><span id="A1.T3.5.2" class="ltx_text" style="font-size:90%;">Hyperparameters for large setting.</span></figcaption>
</figure>
</section>
</article>
</div>
<div class="ar5iv-footer"><a href="/html/2010.07426" class="ar5iv-nav-button ar5iv-nav-button-prev">◄</a>
    <a class="ar5iv-home-button" href="/"><img height="40" alt="ar5iv homepage" src="/assets/ar5iv.png"></a>
    <a href="/feeling_lucky" class="ar5iv-text-button">Feeling<br>lucky?</a>
    <a href="/log/2010.07427" class="ar5iv-text-button ar5iv-severity-warning">Conversion<br>report</a>
    <a class="ar5iv-text-button" target="_blank" href="https://github.com/dginev/ar5iv/issues/new?template=improve-article--arxiv-id-.md&title=Improve+article+2010.07427">Report<br>an issue</a>
    <a href="https://arxiv.org/abs/2010.07427" class="ar5iv-text-button arxiv-ui-theme">View&nbsp;original<br>on&nbsp;arXiv</a><a href="/html/2010.07428" class="ar5iv-nav-button ar5iv-nav-button-next">►</a>
</div><footer class="ltx_page_footer">
<a class="ar5iv-toggle-color-scheme" href="javascript:toggleColorScheme()" title="Toggle ar5iv color scheme"><span class="color-scheme-icon"></span></a>
<a class="ar5iv-footer-button" href="https://arxiv.org/help/license" target="_blank">Copyright</a>
<a class="ar5iv-footer-button" href="https://arxiv.org/help/policies/privacy_policy" target="_blank">Privacy Policy</a>

<div class="ltx_page_logo">Generated  on Sat Mar  2 09:06:32 2024 by <a target="_blank" href="http://dlmf.nist.gov/LaTeXML/" class="ltx_LaTeXML_logo"><span style="letter-spacing:-0.2em; margin-right:0.1em;">L<span class="ltx_font_smallcaps" style="position:relative; bottom:2.2pt;">a</span>T<span class="ltx_font_smallcaps" style="font-size:120%;position:relative; bottom:-0.2ex;">e</span></span><span style="font-size:90%; position:relative; bottom:-0.2ex;">XML</span><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAAOCAYAAAD5YeaVAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9wKExQZLWTEaOUAAAAddEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIFRoZSBHSU1Q72QlbgAAAdpJREFUKM9tkL+L2nAARz9fPZNCKFapUn8kyI0e4iRHSR1Kb8ng0lJw6FYHFwv2LwhOpcWxTjeUunYqOmqd6hEoRDhtDWdA8ApRYsSUCDHNt5ul13vz4w0vWCgUnnEc975arX6ORqN3VqtVZbfbTQC4uEHANM3jSqXymFI6yWazP2KxWAXAL9zCUa1Wy2tXVxheKA9YNoR8Pt+aTqe4FVVVvz05O6MBhqUIBGk8Hn8HAOVy+T+XLJfLS4ZhTiRJgqIoVBRFIoric47jPnmeB1mW/9rr9ZpSSn3Lsmir1fJZlqWlUonKsvwWwD8ymc/nXwVBeLjf7xEKhdBut9Hr9WgmkyGEkJwsy5eHG5vN5g0AKIoCAEgkEkin0wQAfN9/cXPdheu6P33fBwB4ngcAcByHJpPJl+fn54mD3Gg0NrquXxeLRQAAwzAYj8cwTZPwPH9/sVg8PXweDAauqqr2cDjEer1GJBLBZDJBs9mE4zjwfZ85lAGg2+06hmGgXq+j3+/DsixYlgVN03a9Xu8jgCNCyIegIAgx13Vfd7vdu+FweG8YRkjXdWy329+dTgeSJD3ieZ7RNO0VAXAPwDEAO5VKndi2fWrb9jWl9Esul6PZbDY9Go1OZ7PZ9z/lyuD3OozU2wAAAABJRU5ErkJggg==" alt="Mascot Sammy"></a>
</div></footer>
</div>

    <script>
      var canMathML = typeof(MathMLElement) == "function";
      if (!canMathML) {
        var body = document.querySelector("body");
        body.firstElementChild.setAttribute('style', 'opacity: 0;');
        var loading = document.createElement("div");
        loading.setAttribute("id", "mathjax-loading-spinner");
        var message = document.createElement("div");
        message.setAttribute("id", "mathjax-loading-message");
        message.innerText = "Typesetting Equations...";
        body.prepend(loading);
        body.prepend(message);

        var el = document.createElement("script");
        el.src = "https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js";
        document.querySelector("head").appendChild(el);

        window.MathJax = {
          startup: {
            pageReady: () => {
              return MathJax.startup.defaultPageReady().then(() => {
                body.removeChild(loading);
                body.removeChild(message);
                body.firstElementChild.removeAttribute('style');
              }); } } };
      }
    </script>
    <script>
    // Auxiliary function, building the preview feature when
    // an inline citation is clicked
    function clicked_cite(e) {
      e.preventDefault();
      let cite = this.closest('.ltx_cite');
      let next = cite.nextSibling;
      if (next && next.nodeType == Node.ELEMENT_NODE && next.getAttribute('class') == "ar5iv-bibitem-preview") {
        next.remove();
        return; }
      // Before adding a preview modal,
      // cleanup older previews, in case they're still open
      document.querySelectorAll('span.ar5iv-bibitem-preview').forEach(function(node) {
        node.remove();
      })

      // Create the preview
      preview = document.createElement('span');
      preview.setAttribute('class','ar5iv-bibitem-preview');
      let target = document.getElementById(this.getAttribute('href').slice(1));
      target.childNodes.forEach(function (child) {
        preview.append(child.cloneNode(true));
      });
      let close_x = document.createElement('button');
      close_x.setAttribute("aria-label","Close modal for bibliography item preview");
      close_x.textContent = "×";
      close_x.setAttribute('class', 'ar5iv-button-close-preview');
      close_x.setAttribute('onclick','this.parentNode.remove()');
      preview.append(close_x);
      preview.querySelectorAll('.ltx_tag_bibitem').forEach(function(node) {
        node.remove();
      });
      cite.parentNode.insertBefore(preview, cite.nextSibling);
      return;
    }
    // Global Document initialization:
    // - assign the preview feature to all inline citation links
    document.querySelectorAll(".ltx_cite .ltx_ref").forEach(function (link) {
      link.addEventListener("click", clicked_cite);
    });
    </script>
    </body>
</html>
