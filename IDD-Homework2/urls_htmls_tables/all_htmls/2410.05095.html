<!DOCTYPE html>
<html lang="en">
<head>
<meta content="text/html; charset=utf-8" http-equiv="content-type"/>
<title>Towards a Modern and Lightweight Rendering Engine for Dynamic Robotic Simulations</title>
<!--Generated on Mon Oct  7 14:01:25 2024 by LaTeXML (version 0.8.8) http://dlmf.nist.gov/LaTeXML/.-->
<meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport"/>
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" type="text/css"/>
<link href="/static/browse/0.3.4/css/ar5iv.0.7.9.min.css" rel="stylesheet" type="text/css"/>
<link href="/static/browse/0.3.4/css/ar5iv-fonts.0.7.9.min.css" rel="stylesheet" type="text/css"/>
<link href="/static/browse/0.3.4/css/latexml_styles.css" rel="stylesheet" type="text/css"/>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.3.3/html2canvas.min.js"></script>
<script src="/static/browse/0.3.4/js/addons_new.js"></script>
<script src="/static/browse/0.3.4/js/feedbackOverlay.js"></script>
<base href="/html/2410.05095v1/"/></head>
<body>
<nav class="ltx_page_navbar">
<nav class="ltx_TOC">
<ol class="ltx_toclist">
<li class="ltx_tocentry ltx_tocentry_section"><a class="ltx_ref" href="https://arxiv.org/html/2410.05095v1#S1" title="In Towards a Modern and Lightweight Rendering Engine for Dynamic Robotic Simulations"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">I </span><span class="ltx_text ltx_font_smallcaps">Introduction</span></span></a></li>
<li class="ltx_tocentry ltx_tocentry_section"><a class="ltx_ref" href="https://arxiv.org/html/2410.05095v1#S2" title="In Towards a Modern and Lightweight Rendering Engine for Dynamic Robotic Simulations"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">II </span><span class="ltx_text ltx_font_smallcaps">Related Work</span></span></a></li>
<li class="ltx_tocentry ltx_tocentry_section">
<a class="ltx_ref" href="https://arxiv.org/html/2410.05095v1#S3" title="In Towards a Modern and Lightweight Rendering Engine for Dynamic Robotic Simulations"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">III </span><span class="ltx_text ltx_font_smallcaps">Background</span></span></a>
<ol class="ltx_toclist ltx_toclist_section">
<li class="ltx_tocentry ltx_tocentry_subsection"><a class="ltx_ref" href="https://arxiv.org/html/2410.05095v1#S3.SS1" title="In III Background ‣ Towards a Modern and Lightweight Rendering Engine for Dynamic Robotic Simulations"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref"><span class="ltx_text">III-A</span> </span><span class="ltx_text ltx_font_italic">Overview of graphics APIs and OpenGL</span></span></a></li>
<li class="ltx_tocentry ltx_tocentry_subsection"><a class="ltx_ref" href="https://arxiv.org/html/2410.05095v1#S3.SS2" title="In III Background ‣ Towards a Modern and Lightweight Rendering Engine for Dynamic Robotic Simulations"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref"><span class="ltx_text">III-B</span> </span><span class="ltx_text ltx_font_italic">Overview of the Vulkan Graphics API</span></span></a></li>
<li class="ltx_tocentry ltx_tocentry_subsection"><a class="ltx_ref" href="https://arxiv.org/html/2410.05095v1#S3.SS3" title="In III Background ‣ Towards a Modern and Lightweight Rendering Engine for Dynamic Robotic Simulations"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref"><span class="ltx_text">III-C</span> </span><span class="ltx_text ltx_font_italic">Overview of AMBF</span></span></a></li>
</ol>
</li>
<li class="ltx_tocentry ltx_tocentry_section">
<a class="ltx_ref" href="https://arxiv.org/html/2410.05095v1#S4" title="In Towards a Modern and Lightweight Rendering Engine for Dynamic Robotic Simulations"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">IV </span><span class="ltx_text ltx_font_smallcaps">Methodology</span></span></a>
<ol class="ltx_toclist ltx_toclist_section">
<li class="ltx_tocentry ltx_tocentry_subsection">
<a class="ltx_ref" href="https://arxiv.org/html/2410.05095v1#S4.SS1" title="In IV Methodology ‣ Towards a Modern and Lightweight Rendering Engine for Dynamic Robotic Simulations"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref"><span class="ltx_text">IV-A</span> </span><span class="ltx_text ltx_font_italic">AMBF-Vulkan engine rendering architecture</span></span></a>
<ol class="ltx_toclist ltx_toclist_subsection">
<li class="ltx_tocentry ltx_tocentry_subsubsection"><a class="ltx_ref" href="https://arxiv.org/html/2410.05095v1#S4.SS1.SSS1" title="In IV-A AMBF-Vulkan engine rendering architecture ‣ IV Methodology ‣ Towards a Modern and Lightweight Rendering Engine for Dynamic Robotic Simulations"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref"><span class="ltx_text">IV-A</span>1 </span>Render Loop Overview</span></a></li>
<li class="ltx_tocentry ltx_tocentry_subsubsection"><a class="ltx_ref" href="https://arxiv.org/html/2410.05095v1#S4.SS1.SSS2" title="In IV-A AMBF-Vulkan engine rendering architecture ‣ IV Methodology ‣ Towards a Modern and Lightweight Rendering Engine for Dynamic Robotic Simulations"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref"><span class="ltx_text">IV-A</span>2 </span>System Improvements</span></a></li>
</ol>
</li>
<li class="ltx_tocentry ltx_tocentry_subsection">
<a class="ltx_ref" href="https://arxiv.org/html/2410.05095v1#S4.SS2" title="In IV Methodology ‣ Towards a Modern and Lightweight Rendering Engine for Dynamic Robotic Simulations"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref"><span class="ltx_text">IV-B</span> </span><span class="ltx_text ltx_font_italic">AMBF-Vulkan graphical features</span></span></a>
<ol class="ltx_toclist ltx_toclist_subsection">
<li class="ltx_tocentry ltx_tocentry_subsubsection"><a class="ltx_ref" href="https://arxiv.org/html/2410.05095v1#S4.SS2.SSS1" title="In IV-B AMBF-Vulkan graphical features ‣ IV Methodology ‣ Towards a Modern and Lightweight Rendering Engine for Dynamic Robotic Simulations"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref"><span class="ltx_text">IV-B</span>1 </span>Physically Based Rendering</span></a></li>
<li class="ltx_tocentry ltx_tocentry_subsubsection"><a class="ltx_ref" href="https://arxiv.org/html/2410.05095v1#S4.SS2.SSS2" title="In IV-B AMBF-Vulkan graphical features ‣ IV Methodology ‣ Towards a Modern and Lightweight Rendering Engine for Dynamic Robotic Simulations"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref"><span class="ltx_text">IV-B</span>2 </span>Anti-Aliasing</span></a></li>
<li class="ltx_tocentry ltx_tocentry_subsubsection"><a class="ltx_ref" href="https://arxiv.org/html/2410.05095v1#S4.SS2.SSS3" title="In IV-B AMBF-Vulkan graphical features ‣ IV Methodology ‣ Towards a Modern and Lightweight Rendering Engine for Dynamic Robotic Simulations"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref"><span class="ltx_text">IV-B</span>3 </span>Ray-traced shadows</span></a></li>
</ol>
</li>
<li class="ltx_tocentry ltx_tocentry_subsection"><a class="ltx_ref" href="https://arxiv.org/html/2410.05095v1#S4.SS3" title="In IV Methodology ‣ Towards a Modern and Lightweight Rendering Engine for Dynamic Robotic Simulations"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref"><span class="ltx_text">IV-C</span> </span><span class="ltx_text ltx_font_italic">Plugin communication between AMBF and AMBF-Vulkan</span></span></a></li>
</ol>
</li>
<li class="ltx_tocentry ltx_tocentry_section">
<a class="ltx_ref" href="https://arxiv.org/html/2410.05095v1#S5" title="In Towards a Modern and Lightweight Rendering Engine for Dynamic Robotic Simulations"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">V </span><span class="ltx_text ltx_font_smallcaps">Experimental results</span></span></a>
<ol class="ltx_toclist ltx_toclist_section">
<li class="ltx_tocentry ltx_tocentry_subsection"><a class="ltx_ref" href="https://arxiv.org/html/2410.05095v1#S5.SS1" title="In V Experimental results ‣ Towards a Modern and Lightweight Rendering Engine for Dynamic Robotic Simulations"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref"><span class="ltx_text">V-A</span> </span><span class="ltx_text ltx_font_italic">AMBF-Vulkan computational performance</span></span></a></li>
<li class="ltx_tocentry ltx_tocentry_subsection"><a class="ltx_ref" href="https://arxiv.org/html/2410.05095v1#S5.SS2" title="In V Experimental results ‣ Towards a Modern and Lightweight Rendering Engine for Dynamic Robotic Simulations"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref"><span class="ltx_text">V-B</span> </span><span class="ltx_text ltx_font_italic">Quantitative comparisons between AMBF-Vulkan and AMBF</span></span></a></li>
<li class="ltx_tocentry ltx_tocentry_subsection"><a class="ltx_ref" href="https://arxiv.org/html/2410.05095v1#S5.SS3" title="In V Experimental results ‣ Towards a Modern and Lightweight Rendering Engine for Dynamic Robotic Simulations"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref"><span class="ltx_text">V-C</span> </span><span class="ltx_text ltx_font_italic">Qualitative comparisons between AMBF-Vulkan and AMBF</span></span></a></li>
</ol>
</li>
<li class="ltx_tocentry ltx_tocentry_section"><a class="ltx_ref" href="https://arxiv.org/html/2410.05095v1#S6" title="In Towards a Modern and Lightweight Rendering Engine for Dynamic Robotic Simulations"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">VI </span><span class="ltx_text ltx_font_smallcaps">Discussion and Future Work</span></span></a></li>
</ol></nav>
</nav>
<div class="ltx_page_main">
<div class="ltx_page_content">
<article class="ltx_document ltx_authors_1line">
<h1 class="ltx_title ltx_title_document">Towards a Modern and Lightweight Rendering Engine for Dynamic Robotic Simulations </h1>
<div class="ltx_authors">
<span class="ltx_creator ltx_role_author">
<span class="ltx_personname">Christopher John Allison<sup class="ltx_sup" id="id9.9.id1"><span class="ltx_text ltx_font_italic" id="id9.9.id1.1">1</span></sup>, Haoying Zhou<sup class="ltx_sup" id="id10.10.id2"><span class="ltx_text ltx_font_italic" id="id10.10.id2.1">3</span></sup>, Adnan Munawar<sup class="ltx_sup" id="id11.11.id3">2</sup>, Peter Kazanzides<sup class="ltx_sup" id="id12.12.id4">2</sup>, and Juan Antonio Barragan<sup class="ltx_sup" id="id13.13.id5"><span class="ltx_text ltx_font_italic" id="id13.13.id5.1">2</span></sup>
</span><span class="ltx_author_notes"><sup class="ltx_sup" id="id14.14.id1">1</sup>Khoury College of Computer Sciences, Northeastern University, Boston, MA 02115, USA.
Email: <span class="ltx_text ltx_font_typewriter" id="id15.15.id2">allison.ch@northeastern.edu</span><sup class="ltx_sup" id="id16.16.id1">2</sup> Department of Computer Science, Johns Hopkins University, Baltimore, MD 21218, USA.
Email: <span class="ltx_text ltx_font_typewriter" id="id17.17.id2">jbarrag3@jhu.edu</span><sup class="ltx_sup" id="id18.18.id1">3</sup> Department of Robotics Engineering, Worcester Polytechnic Institute, Worcester, MA 01608, USA.</span></span>
</div>
<div class="ltx_abstract">
<h6 class="ltx_title ltx_title_abstract">Abstract</h6>
<p class="ltx_p" id="id19.id1">Interactive dynamic simulators are an accelerator for developing novel robotic control algorithms and complex systems involving humans and robots. In user training and synthetic data generation applications, a high-fidelity visualization of the simulation is essential. Visual fidelity is dependent on the quality of the computer graphics algorithms used to render the simulated scene. Furthermore, the rendering algorithms must be implemented on the graphics processing unit (GPU) to achieve real-time performance, requiring the use of a graphics application programming interface (API). This paper presents a performance-focused and lightweight rendering engine supporting the Vulkan graphics API. The engine is designed to modernize the legacy rendering pipeline of Asynchronous Multi-Body Framework (AMBF), a dynamic simulation framework used extensively for interactive robotics simulation development. This new rendering engine implements graphical features such as physically based rendering (PBR), anti-aliasing, and ray-traced shadows, significantly improving the image quality of AMBF. Computational experiments show that the engine can render a simulated scene with over seven million triangles while maintaining GPU computation times within two milliseconds.</p>
</div>
<section class="ltx_section" id="S1">
<h2 class="ltx_title ltx_title_section">
<span class="ltx_tag ltx_tag_section">I </span><span class="ltx_text ltx_font_smallcaps" id="S1.1.1">Introduction</span>
</h2>
<div class="ltx_para" id="S1.p1">
<p class="ltx_p" id="S1.p1.1">Interactive dynamic simulators are an accelerator for developing novel robotic control algorithms and complex systems involving humans and robots. Specifically, dynamic simulators are cost-effective solutions to train human operators and machine learning algorithms in a wide range of domains.
Effective simulation frameworks for robotics are required to produce realistic visualizations of the workspace while maintaining real-time performance. In previous work, the Asynchronous Multi-body framework (AMBF) <cite class="ltx_cite ltx_citemacro_cite">[<a class="ltx_ref" href="https://arxiv.org/html/2410.05095v1#bib.bib1" title="">1</a>]</cite> was introduced as a general real-time dynamic simulator for robots and free bodies. This framework was developed by integrating several external tools, such as an extended version of CHAI-3D, BULLET-Physics, and OpenGL. With its flexible description format, AMBF has enabled the development of complex interactive simulations, such as an environment for learning robot-assisted surgical suturing <cite class="ltx_cite ltx_citemacro_cite">[<a class="ltx_ref" href="https://arxiv.org/html/2410.05095v1#bib.bib2" title="">2</a>]</cite> and a volumetric simulation for skull base surgery <cite class="ltx_cite ltx_citemacro_cite">[<a class="ltx_ref" href="https://arxiv.org/html/2410.05095v1#bib.bib3" title="">3</a>]</cite>.</p>
</div>
<div class="ltx_para" id="S1.p2">
<p class="ltx_p" id="S1.p2.1">Currently, AMBF rendering and computing capabilities are limited by the legacy OpenGL graphics application programming interface (API) at the core of its rendering pipeline. AMBF relies on OpenGL version 2.1, which was released in 2006, to perform graphics operations. This is significant because it severely limits AMBF’s access to new developments in GPU hardware and real-time rendering that improve performance and visual fidelity <cite class="ltx_cite ltx_citemacro_cite">[<a class="ltx_ref" href="https://arxiv.org/html/2410.05095v1#bib.bib4" title="">4</a>, <a class="ltx_ref" href="https://arxiv.org/html/2410.05095v1#bib.bib5" title="">5</a>]</cite>. A particular limiting factor of legacy OpenGL is the lack of support for general-purpose computing on the GPU, a groundbreaking development that can greatly accelerate computationally intensive processes, such as soft-body physics simulation, ray tracing, and deep learning <cite class="ltx_cite ltx_citemacro_cite">[<a class="ltx_ref" href="https://arxiv.org/html/2410.05095v1#bib.bib6" title="">6</a>]</cite>.</p>
</div>
<div class="ltx_para" id="S1.p3">
<p class="ltx_p" id="S1.p3.1">To address these limitations, this work presents a new standalone rendering engine supporting the Vulkan graphics API to modernize AMBF, which may be applicable to other simulators limited by legacy rendering engines. We chose Vulkan, OpenGL’s successor, due to its cross-platform support and low-level design, allowing for significant performance improvements. Given the substantial architectural differences between legacy OpenGL and Vulkan, it was decided to develop the renderer as a standalone program and, therefore, integrate both processes via a plugin in AMBF. As such, support for interface devices, physics computations, and plugin architecture is maintained in AMBF, while the proposed engine renders the geometry of the scene (see Figure <a class="ltx_ref" href="https://arxiv.org/html/2410.05095v1#S1.F1" title="Figure 1 ‣ I Introduction ‣ Towards a Modern and Lightweight Rendering Engine for Dynamic Robotic Simulations"><span class="ltx_text ltx_ref_tag">1</span></a>). Overall, the full system enables access to all AMBF features while significantly improving rendering quality.</p>
</div>
<div class="ltx_para" id="S1.p4">
<p class="ltx_p" id="S1.p4.1">While developing this newer engine, efforts were concentrated on improving the computational performance of the rendering pipeline compared to the previous version of AMBF. Additionally, several additional features, such as support for physically-based rendering (PBR) materials, anti-aliasing, and ray-traced shadows, were co-developed to improve the visual fidelity of the engine. Overall, this paper summarizes some of the main design principles and challenges faced while developing this system, as well as opportunities for using a modern graphics API in developing advanced dynamic simulations. In summary, our key contributions are:</p>
</div>
<div class="ltx_para" id="S1.p5">
<ol class="ltx_enumerate" id="S1.I1">
<li class="ltx_item" id="S1.I1.i1" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">1.</span>
<div class="ltx_para" id="S1.I1.i1.p1">
<p class="ltx_p" id="S1.I1.i1.p1.1">A standalone and open-source rendering engine supporting the Vulkan graphics API.</p>
</div>
</li>
<li class="ltx_item" id="S1.I1.i2" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">2.</span>
<div class="ltx_para" id="S1.I1.i2.p1">
<p class="ltx_p" id="S1.I1.i2.p1.1">Integration between the AMBF dynamic simulation engine and the standalone rendering engine, as an illustration of how this approach could be used with other simulators.</p>
</div>
</li>
</ol>
</div>
<figure class="ltx_figure" id="S1.F1"><img alt="Refer to caption" class="ltx_graphics ltx_centering ltx_img_landscape" height="195" id="S1.F1.g1" src="x1.png" width="399"/>
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure">Figure 1: </span>Overview of the proposed dynamic simulation framework. User input is communicated to AMBF through interface devices. AMBF Simulator runs physics simulations on the scene and records scene updates in shared memory. AMBF-Vulkan reads the scene updates from shared memory and renders the result with high visual quality.</figcaption>
</figure>
</section>
<section class="ltx_section" id="S2">
<h2 class="ltx_title ltx_title_section">
<span class="ltx_tag ltx_tag_section">II </span><span class="ltx_text ltx_font_smallcaps" id="S2.1.1">Related Work</span>
</h2>
<div class="ltx_para" id="S2.p1">
<p class="ltx_p" id="S2.p1.1">Several commercial and open-source dynamic robotic simulators use a modular software design that enables integration with different rendering engines. For instance, Gazebo<cite class="ltx_cite ltx_citemacro_cite">[<a class="ltx_ref" href="https://arxiv.org/html/2410.05095v1#bib.bib7" title="">7</a>]</cite> uses the OGRE rendering engine by default but also provides experimental support for Nvidia Optix. Similarly, the SOFA simulator <cite class="ltx_cite ltx_citemacro_cite">[<a class="ltx_ref" href="https://arxiv.org/html/2410.05095v1#bib.bib8" title="">8</a>]</cite> supports several rendering options such as Unity, Godot, and Unreal engine. In this work, it was decided to build a customized rendering engine rather than using available all-purpose rendering engines to upgrade the AMBF simulation. Some advantages of creating a new engine instead of using existing ones are optimized rendering performance as the render only needs to support material models relevant to AMBF simulations, application-specific optimizations such as disabling frustum culling in low geometry scenes, and simplified development of application-specific features.</p>
</div>
<div class="ltx_para" id="S2.p2">
<p class="ltx_p" id="S2.p2.1">For AMBF, our previous work <cite class="ltx_cite ltx_citemacro_cite">[<a class="ltx_ref" href="https://arxiv.org/html/2410.05095v1#bib.bib9" title="">9</a>]</cite> presented a plugin that enabled rendering AMBF scenes using Blender’s built-in rendering engines, EEVEE and Cycles<cite class="ltx_cite ltx_citemacro_cite">[<a class="ltx_ref" href="https://arxiv.org/html/2410.05095v1#bib.bib10" title="">10</a>]</cite>, and using ROS <cite class="ltx_cite ltx_citemacro_cite">[<a class="ltx_ref" href="https://arxiv.org/html/2410.05095v1#bib.bib11" title="">11</a>]</cite> as a communication layer. This plugin permitted AMBF to use all rendering features provided by Blender; however, it could not render scenes at interactive rates due to communication latency and the processing overhead of Blender’s interface. Compared to our previous work, the proposed simulation framework presents several optimizations that simultaneously improve visual fidelity and rendering speed. The framework’s overall performance can be attributed to the use of a modern graphics API and a lightweight communication layer between AMBF and the rendering engine.</p>
</div>
<div class="ltx_para" id="S2.p3">
<p class="ltx_p" id="S2.p3.1">The Vulkan API caught our attention due to its great performance on ray tracing <cite class="ltx_cite ltx_citemacro_cite">[<a class="ltx_ref" href="https://arxiv.org/html/2410.05095v1#bib.bib12" title="">12</a>, <a class="ltx_ref" href="https://arxiv.org/html/2410.05095v1#bib.bib13" title="">13</a>]</cite>, and complex shading advancements <cite class="ltx_cite ltx_citemacro_cite">[<a class="ltx_ref" href="https://arxiv.org/html/2410.05095v1#bib.bib14" title="">14</a>]</cite> that could facilitate advanced visual effects such as light reflection and detailed material textures. Furthermore, the Vulkan API is cross-platform <cite class="ltx_cite ltx_citemacro_cite">[<a class="ltx_ref" href="https://arxiv.org/html/2410.05095v1#bib.bib15" title="">15</a>, <a class="ltx_ref" href="https://arxiv.org/html/2410.05095v1#bib.bib16" title="">16</a>]</cite> and facilitates the use of ray tracing acceleration units<cite class="ltx_cite ltx_citemacro_cite">[<a class="ltx_ref" href="https://arxiv.org/html/2410.05095v1#bib.bib17" title="">17</a>]</cite>. Vulkan has been increasingly implemented in recent academic research <cite class="ltx_cite ltx_citemacro_cite">[<a class="ltx_ref" href="https://arxiv.org/html/2410.05095v1#bib.bib18" title="">18</a>]</cite>. Taking advantage of the low-level API and integration compatibility, Vulkan has been deployed into various domains: physics particle simulation <cite class="ltx_cite ltx_citemacro_cite">[<a class="ltx_ref" href="https://arxiv.org/html/2410.05095v1#bib.bib19" title="">19</a>, <a class="ltx_ref" href="https://arxiv.org/html/2410.05095v1#bib.bib20" title="">20</a>]</cite>, efficient data visualization <cite class="ltx_cite ltx_citemacro_cite">[<a class="ltx_ref" href="https://arxiv.org/html/2410.05095v1#bib.bib21" title="">21</a>]</cite>, deformable body simulation <cite class="ltx_cite ltx_citemacro_cite">[<a class="ltx_ref" href="https://arxiv.org/html/2410.05095v1#bib.bib22" title="">22</a>]</cite>, and surgical simulations <cite class="ltx_cite ltx_citemacro_cite">[<a class="ltx_ref" href="https://arxiv.org/html/2410.05095v1#bib.bib23" title="">23</a>, <a class="ltx_ref" href="https://arxiv.org/html/2410.05095v1#bib.bib24" title="">24</a>]</cite>. Given all the advantages presented, Vulkan is an excellent option for modern rendering engines.</p>
</div>
<figure class="ltx_figure" id="S2.F2"><img alt="Refer to caption" class="ltx_graphics ltx_centering ltx_img_landscape" height="295" id="S2.F2.g1" src="x2.png" width="830"/>
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure">Figure 2: </span>Overview of Vulkan’s render loop from the scene update to the presentation of the image to the screen. The scene geometry is rendered in the Main Pass, and its resulting image is used as a sampled texture by the Post-Processing Pass. The ImGui pass renders the GUI overtop the image and the result is presented to the screen.</figcaption>
</figure>
</section>
<section class="ltx_section" id="S3">
<h2 class="ltx_title ltx_title_section">
<span class="ltx_tag ltx_tag_section">III </span><span class="ltx_text ltx_font_smallcaps" id="S3.1.1">Background</span>
</h2>
<section class="ltx_subsection" id="S3.SS1">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection"><span class="ltx_text" id="S3.SS1.5.1.1">III-A</span> </span><span class="ltx_text ltx_font_italic" id="S3.SS1.6.2">Overview of graphics APIs and OpenGL</span>
</h3>
<div class="ltx_para" id="S3.SS1.p1">
<p class="ltx_p" id="S3.SS1.p1.1">A graphics API provides a set of standardized commands and functions that allow developers to communicate with a computer’s GPU. OpenGL is a graphics API created by the Khronos Group that has had a rich history of development since 1992. Pertinent to this paper is the fact that OpenGL versions lower than 3.0 are referred to as legacy OpenGL <cite class="ltx_cite ltx_citemacro_cite">[<a class="ltx_ref" href="https://arxiv.org/html/2410.05095v1#bib.bib25" title="">25</a>]</cite>, as they use a deprecated fixed function pipeline. Legacy OpenGL was designed before the advent of programmable shaders and is characterized by computationally expensive CPU operations, e.g., immediate mode vertex attribute specification. In addition to reduced performance due to CPU overhead, legacy OpenGL has limited support for modern graphics debuggers and profilers, such as RenderDoc <cite class="ltx_cite ltx_citemacro_cite">[<a class="ltx_ref" href="https://arxiv.org/html/2410.05095v1#bib.bib26" title="">26</a>]</cite> and NVIDIA Nsight Graphics <cite class="ltx_cite ltx_citemacro_cite">[<a class="ltx_ref" href="https://arxiv.org/html/2410.05095v1#bib.bib27" title="">27</a>]</cite>.</p>
</div>
<div class="ltx_para" id="S3.SS1.p2">
<p class="ltx_p" id="S3.SS1.p2.1">Modern OpenGL (versions 3.0 to 4.6) progressively shifted towards a more programmable graphics pipeline, adding support for features like programmable shaders, compute shaders, and multi-threaded command buffer submission, among others. In 2017, active development of OpenGL was ceased in favor of the newer Vulkan API, making OpenGL 4.6 the final version.
This is relevant as dynamic simulators relying on OpenGL will never receive support for new GPU features, such as hardware-accelerated ray tracing. Moreover, GPU manufacturers and driver developers may decide to stop supporting the OpenGL specification, as seen by Apple deprecating OpenGL on all of their platforms in 2018. Overall, it was decided to migrate AMBF directly to Vulkan instead of a newer OpenGL version to ensure long-term support for the simulator in modern systems.</p>
</div>
</section>
<section class="ltx_subsection" id="S3.SS2">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection"><span class="ltx_text" id="S3.SS2.5.1.1">III-B</span> </span><span class="ltx_text ltx_font_italic" id="S3.SS2.6.2">Overview of the Vulkan Graphics API</span>
</h3>
<div class="ltx_para" id="S3.SS2.p1">
<p class="ltx_p" id="S3.SS2.p1.1">Modern graphics APIs, such as Vulkan, DirectX12, and Metal, choose to put more control in the hands of the user rather than the driver. This leads to performance improvements at the cost of a more verbose and complex API. Vulkan requires explicit management of GPU memory resources, synchronization objects, debug messaging, context initialization, and more. An additional benefit of this low level of abstraction over the GPU is that modern graphics APIs are more similar, and therefore, rendering engines can more easily support additional APIs. Overall, Vulkan and other modern graphics APIs allow for programming performant programs tailored to the application’s specific needs.</p>
</div>
</section>
<section class="ltx_subsection" id="S3.SS3">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection"><span class="ltx_text" id="S3.SS3.5.1.1">III-C</span> </span><span class="ltx_text ltx_font_italic" id="S3.SS3.6.2">Overview of AMBF</span>
</h3>
<div class="ltx_para" id="S3.SS3.p1">
<p class="ltx_p" id="S3.SS3.p1.1">AMBF integrates several external tools to enable interactive dynamic simulations. Rendering is enabled in AMBF by an extended version of CHAI-3D <cite class="ltx_cite ltx_citemacro_cite">[<a class="ltx_ref" href="https://arxiv.org/html/2410.05095v1#bib.bib28" title="">28</a>]</cite> (actively developed along with AMBF) that uses the legacy OpenGL version 2.1 at its core. CHAI-3D is also utilized to interface with haptic devices. Dynamic computations are performed by BULLET-Physics <cite class="ltx_cite ltx_citemacro_cite">[<a class="ltx_ref" href="https://arxiv.org/html/2410.05095v1#bib.bib29" title="">29</a>]</cite>. Assets in AMBF are specified using AMBF description files (ADF), which define the properties of simulated bodies in a human-readable format. Lastly, AMBF facilitates the creation of ADF files by using the AMBF Blender-addon <cite class="ltx_cite ltx_citemacro_cite">[<a class="ltx_ref" href="https://arxiv.org/html/2410.05095v1#bib.bib30" title="">30</a>]</cite>, a plugin that permits Blender to export objects into ADFs.</p>
</div>
</section>
</section>
<section class="ltx_section" id="S4">
<h2 class="ltx_title ltx_title_section">
<span class="ltx_tag ltx_tag_section">IV </span><span class="ltx_text ltx_font_smallcaps" id="S4.1.1">Methodology</span>
</h2>
<div class="ltx_para" id="S4.p1">
<p class="ltx_p" id="S4.p1.1">The complete dynamic simulation framework is composed of three different components (see Fig. <a class="ltx_ref" href="https://arxiv.org/html/2410.05095v1#S1.F1" title="Figure 1 ‣ I Introduction ‣ Towards a Modern and Lightweight Rendering Engine for Dynamic Robotic Simulations"><span class="ltx_text ltx_ref_tag">1</span></a>). Firstly, we have the standalone rendering engine built for the Vulkan API, which we will refer to from this point on as AMBF-Vulkan. By itself, the AMBF-Vulkan engine only renders the loaded objects and provides the option to move the virtual cameras and adjust visual parameters via a GUI. Secondly, we have AMBF running in headless mode to perform physics computations and communicate with user input devices. Thirdly, we have the communication plugin that enables AMBF to update the pose of all the objects inside the AMBF-Vulkan engine via shared memory between both processes. Overall, these three components work together to enable the user to access the full set of features from the dynamic simulator AMBF, while also obtaining high-quality renderings from the Vulkan rendering engine. The rest of the methodology is divided as follows. Subsection <a class="ltx_ref" href="https://arxiv.org/html/2410.05095v1#S4.SS1" title="IV-A AMBF-Vulkan engine rendering architecture ‣ IV Methodology ‣ Towards a Modern and Lightweight Rendering Engine for Dynamic Robotic Simulations"><span class="ltx_text ltx_ref_tag"><span class="ltx_text">IV-A</span></span></a> describes the software design of the renderer AMBF-Vulkan. Subsection <a class="ltx_ref" href="https://arxiv.org/html/2410.05095v1#S4.SS2" title="IV-B AMBF-Vulkan graphical features ‣ IV Methodology ‣ Towards a Modern and Lightweight Rendering Engine for Dynamic Robotic Simulations"><span class="ltx_text ltx_ref_tag"><span class="ltx_text">IV-B</span></span></a> presents the graphical features that were implemented in AMBF-Vulkan to improve visual fidelity. Lastly, subsection <a class="ltx_ref" href="https://arxiv.org/html/2410.05095v1#S4.SS3" title="IV-C Plugin communication between AMBF and AMBF-Vulkan ‣ IV Methodology ‣ Towards a Modern and Lightweight Rendering Engine for Dynamic Robotic Simulations"><span class="ltx_text ltx_ref_tag"><span class="ltx_text">IV-C</span></span></a> describes the communication plugin between AMBF and AMBF-Vulkan.</p>
</div>
<section class="ltx_subsection" id="S4.SS1">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection"><span class="ltx_text" id="S4.SS1.5.1.1">IV-A</span> </span><span class="ltx_text ltx_font_italic" id="S4.SS1.6.2">AMBF-Vulkan engine rendering architecture</span>
</h3>
<figure class="ltx_figure" id="S4.F3">
<div class="ltx_flex_figure">
<div class="ltx_flex_cell ltx_flex_size_many">
<figure class="ltx_figure ltx_figure_panel ltx_align_center" id="S4.F3.sf1"><img alt="Refer to caption" class="ltx_graphics ltx_img_square" height="90" id="S4.F3.sf1.g1" src="extracted/5907392/PBR_aluminum.png" width="99"/>
<figcaption class="ltx_caption"><span class="ltx_tag ltx_tag_figure">(a) </span>Aluminum</figcaption>
</figure>
</div>
<div class="ltx_flex_cell ltx_flex_size_many">
<figure class="ltx_figure ltx_figure_panel ltx_align_center" id="S4.F3.sf2"><img alt="Refer to caption" class="ltx_graphics ltx_img_square" height="90" id="S4.F3.sf2.g1" src="extracted/5907392/PBR_gold.png" width="99"/>
<figcaption class="ltx_caption"><span class="ltx_tag ltx_tag_figure">(b) </span>Gold</figcaption>
</figure>
</div>
<div class="ltx_flex_cell ltx_flex_size_many">
<figure class="ltx_figure ltx_figure_panel ltx_align_center" id="S4.F3.sf3"><img alt="Refer to caption" class="ltx_graphics ltx_img_square" height="90" id="S4.F3.sf3.g1" src="extracted/5907392/PBR_copper.png" width="99"/>
<figcaption class="ltx_caption"><span class="ltx_tag ltx_tag_figure">(c) </span>Copper</figcaption>
</figure>
</div>
<div class="ltx_flex_cell ltx_flex_size_many">
<figure class="ltx_figure ltx_figure_panel ltx_align_center" id="S4.F3.sf4"><img alt="Refer to caption" class="ltx_graphics ltx_img_square" height="90" id="S4.F3.sf4.g1" src="extracted/5907392/PBR_glossy_plastic.png" width="99"/>
<figcaption class="ltx_caption"><span class="ltx_tag ltx_tag_figure">(d) </span>Glossy Plastic</figcaption>
</figure>
</div>
<div class="ltx_flex_cell ltx_flex_size_many">
<figure class="ltx_figure ltx_figure_panel ltx_align_center" id="S4.F3.sf5"><img alt="Refer to caption" class="ltx_graphics ltx_img_square" height="90" id="S4.F3.sf5.g1" src="extracted/5907392/PBR_matte_plastic.png" width="99"/>
<figcaption class="ltx_caption"><span class="ltx_tag ltx_tag_figure">(e) </span>Matte Plastic</figcaption>
</figure>
</div>
</div>
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure">Figure 3: </span>Material examples using the PBR reflection model. For (a)-(c), normal incidence Fresnel reflectance measurements are used to create physically based metallic materials. For (d)-(e), the roughness parameter allows for distinction between glossy and matte materials.</figcaption>
</figure>
<section class="ltx_subsubsection" id="S4.SS1.SSS1">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection"><span class="ltx_text" id="S4.SS1.SSS1.5.1.1">IV-A</span>1 </span>Render Loop Overview</h4>
<div class="ltx_para" id="S4.SS1.SSS1.p1">
<p class="ltx_p" id="S4.SS1.SSS1.p1.1">Figure <a class="ltx_ref" href="https://arxiv.org/html/2410.05095v1#S2.F2" title="Figure 2 ‣ II Related Work ‣ Towards a Modern and Lightweight Rendering Engine for Dynamic Robotic Simulations"><span class="ltx_text ltx_ref_tag">2</span></a> illustrates a high-level overview of the AMBF-Vulkan engine’s rendering loop. The data flow depicted is as follows: (1) The scene is updated to reflect the changes made from device input and model transformation updates (see <a class="ltx_ref" href="https://arxiv.org/html/2410.05095v1#S4.SS3" title="IV-C Plugin communication between AMBF and AMBF-Vulkan ‣ IV Methodology ‣ Towards a Modern and Lightweight Rendering Engine for Dynamic Robotic Simulations"><span class="ltx_text ltx_ref_tag"><span class="ltx_text">IV-C</span></span></a>), (2) mesh draw commands are sorted and submitted for rendering, (3) post-processing operations are applied to the main pass’s output, (4) the Dear ImGui <cite class="ltx_cite ltx_citemacro_cite">[<a class="ltx_ref" href="https://arxiv.org/html/2410.05095v1#bib.bib31" title="">31</a>]</cite> library renders an immediate-mode Graphical User Interface (GUI) onto the post-processed image, and (5) the final frame is presented to the screen.</p>
</div>
<div class="ltx_para" id="S4.SS1.SSS1.p2">
<p class="ltx_p" id="S4.SS1.SSS1.p2.1">Key to the performance of any rendering engine is its implementation for storing scene assets and submitting GPU draw commands. AMBF-Vulkan opts to store model resource handles in global type-specific containers. The scene is merely a nodal hierarchy, with each node pointing to the resources it uses. This way, we can create a collection of draw command requests containing the necessary resource information and sort the list to optimize draw performance. We accomplish this by sorting by material type and vertex buffer index, which minimizes the amount of descriptor (a modern graphics API term to describe bound shader resources, e.g., textures or uniform buffers) bind commands and vertex buffer cache misses.</p>
</div>
<div class="ltx_para" id="S4.SS1.SSS1.p3">
<p class="ltx_p" id="S4.SS1.SSS1.p3.1">With the draw commands sorted, we can submit the Main Pass command buffer to the GPU. The vertex shader of the main pass is responsible for transforming the vertices into view space and passing shading data to the fragment shader. AMBF-Vulkan uses a performance-improving technique called vertex pulling: rather than additionally binding vertex buffers for each draw, we store the vertex information in a buffer and index into it, like an array. The fragment shader is responsible for lighting calculations discussed in detail in <a class="ltx_ref" href="https://arxiv.org/html/2410.05095v1#S4.SS2" title="IV-B AMBF-Vulkan graphical features ‣ IV Methodology ‣ Towards a Modern and Lightweight Rendering Engine for Dynamic Robotic Simulations"><span class="ltx_text ltx_ref_tag"><span class="ltx_text">IV-B</span></span></a>. Additionally, the fragment shader converts color data from sRGB gamma space to linear space to perform lighting calculations. Afterward, we apply Reinhard tone mapping to map color values greater than 1.0 to a value between 0.0 and 1.0. Otherwise, they will be clamped to 1.0 automatically. Finally, we invert the aforementioned linear space conversion to bring the colors back into sRGB gamma space, an operation known as gamma correction.</p>
</div>
<div class="ltx_para" id="S4.SS1.SSS1.p4">
<p class="ltx_p" id="S4.SS1.SSS1.p4.1">The image result of the Main Pass is then converted for use as a texture image in the following pass, the Post-Processing Pass. This render pass is typically used to perform image processing techniques on a rendered image. In AMBF-Vulkan, we currently use the Post-Processing Pass to perform a screen-space anti-aliasing algorithm discussed in <a class="ltx_ref" href="https://arxiv.org/html/2410.05095v1#S4.SS2.SSS2" title="IV-B2 Anti-Aliasing ‣ IV-B AMBF-Vulkan graphical features ‣ IV Methodology ‣ Towards a Modern and Lightweight Rendering Engine for Dynamic Robotic Simulations"><span class="ltx_text ltx_ref_tag"><span class="ltx_text">IV-B</span>2</span></a>. The vertex shader creates a screen-sized quad and passes its UV indices to the fragment shader. The fragment shader samples the Main Pass resulting texture and performs the anti-aliasing algorithm.</p>
</div>
<div class="ltx_para" id="S4.SS1.SSS1.p5">
<p class="ltx_p" id="S4.SS1.SSS1.p5.1">Lastly, the result of the Post-Processing Pass is converted into an image format matching that of the display device. The blitted image is then used to render a GUI over the scene using the Dear ImGui library. Rather than a retained mode GUI, which can add a lot of unnecessary complexity due to state management, we opted for an immediate mode GUI. While this choice adds unnecessary drawing of unchanged GUI state, the cost is negligible for our purposes, as seen in Figure <a class="ltx_ref" href="https://arxiv.org/html/2410.05095v1#S5.F7" title="Figure 7 ‣ V-A AMBF-Vulkan computational performance ‣ V Experimental results ‣ Towards a Modern and Lightweight Rendering Engine for Dynamic Robotic Simulations"><span class="ltx_text ltx_ref_tag">7</span></a>. In return, we get the flexibility and simplicity of the Dear ImGui library for our debugging and scene customization needs. Currently, the GUI displays a window listing basic debugging and profiling information, e.g., frame time and camera coordinates. With the ImGui Pass finished, the final image is ready to be presented to the screen.</p>
</div>
</section>
<section class="ltx_subsubsection" id="S4.SS1.SSS2">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection"><span class="ltx_text" id="S4.SS1.SSS2.5.1.1">IV-A</span>2 </span>System Improvements</h4>
<div class="ltx_para" id="S4.SS1.SSS2.p1">
<p class="ltx_p" id="S4.SS1.SSS2.p1.1">Rather than an uncapped frame rate, the system synchronizes with the display device, limiting the frame rate to the refresh rate of the display device. This prevents unnecessary computation while allowing the rate cap to be display-dependent, which can be beneficial if the simulation is displayed via a virtual reality headset. AMBF-Vulkan uses a double-buffered swapchain, i.e., while one frame is rendered by the GPU, the other is prepared for rendering by the CPU. As shown in Figure <a class="ltx_ref" href="https://arxiv.org/html/2410.05095v1#S2.F2" title="Figure 2 ‣ II Related Work ‣ Towards a Modern and Lightweight Rendering Engine for Dynamic Robotic Simulations"><span class="ltx_text ltx_ref_tag">2</span></a>, render attachments, the resources that the render pass writes to, are recycled from the previous frame. In actuality, this means two frames prior due to the double buffer.</p>
</div>
<div class="ltx_para" id="S4.SS1.SSS2.p2">
<p class="ltx_p" id="S4.SS1.SSS2.p2.1">The system uses deletion queues to manage resource lifetimes. There are three deletion queues in total: the main deletion queue and one queue for each frame of the double-buffered swapchain. The main deletion queue is flushed during application shutdown, freeing objects that persist over the entire duration of the program. Frame-specific deletion queues are flushed after the corresponding swapchain image is finished presenting to the screen. These deletion queues trivialize resource lifetime management, reducing it down to pushing back a lambda function to the necessary queue.</p>
</div>
</section>
</section>
<section class="ltx_subsection" id="S4.SS2">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection"><span class="ltx_text" id="S4.SS2.5.1.1">IV-B</span> </span><span class="ltx_text ltx_font_italic" id="S4.SS2.6.2">AMBF-Vulkan graphical features</span>
</h3>
<div class="ltx_para" id="S4.SS2.p1">
<p class="ltx_p" id="S4.SS2.p1.1">A central motivation for building a modernized rendering engine for AMBF was to surpass the graphical quality restrictions of our previous implementation. In the context of surgical simulations, realistic visualizations play an important role in both operator training and machine learning. The following section describes the graphical improvements that were implemented in AMBF-Vulkan.</p>
</div>
<section class="ltx_subsubsection" id="S4.SS2.SSS1">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection"><span class="ltx_text" id="S4.SS2.SSS1.5.1.1">IV-B</span>1 </span>Physically Based Rendering</h4>
<div class="ltx_para" id="S4.SS2.SSS1.p1">
<p class="ltx_p" id="S4.SS2.SSS1.p1.1">Physically Based Rendering (PBR) is a lighting model approach in Computer Graphics that enables photo-realism through approximation of real-world physics<cite class="ltx_cite ltx_citemacro_cite">[<a class="ltx_ref" href="https://arxiv.org/html/2410.05095v1#bib.bib32" title="">32</a>]</cite>. This is especially useful in a simulation environment where real-world measurements can be used to create a more accurate representation. Figures <a class="ltx_ref" href="https://arxiv.org/html/2410.05095v1#S4.F3.sf1" title="In Figure 3 ‣ IV-A AMBF-Vulkan engine rendering architecture ‣ IV Methodology ‣ Towards a Modern and Lightweight Rendering Engine for Dynamic Robotic Simulations"><span class="ltx_text ltx_ref_tag">3a</span></a>, <a class="ltx_ref" href="https://arxiv.org/html/2410.05095v1#S4.F3.sf2" title="In Figure 3 ‣ IV-A AMBF-Vulkan engine rendering architecture ‣ IV Methodology ‣ Towards a Modern and Lightweight Rendering Engine for Dynamic Robotic Simulations"><span class="ltx_text ltx_ref_tag">3b</span></a> and <a class="ltx_ref" href="https://arxiv.org/html/2410.05095v1#S4.F3.sf3" title="In Figure 3 ‣ IV-A AMBF-Vulkan engine rendering architecture ‣ IV Methodology ‣ Towards a Modern and Lightweight Rendering Engine for Dynamic Robotic Simulations"><span class="ltx_text ltx_ref_tag">3c</span></a> demonstrate how we can use normal incidence Fresnel reflectance measurements to shade metallic materials more accurately. Figures <a class="ltx_ref" href="https://arxiv.org/html/2410.05095v1#S4.F3.sf4" title="In Figure 3 ‣ IV-A AMBF-Vulkan engine rendering architecture ‣ IV Methodology ‣ Towards a Modern and Lightweight Rendering Engine for Dynamic Robotic Simulations"><span class="ltx_text ltx_ref_tag">3d</span></a> and <a class="ltx_ref" href="https://arxiv.org/html/2410.05095v1#S4.F3.sf5" title="In Figure 3 ‣ IV-A AMBF-Vulkan engine rendering architecture ‣ IV Methodology ‣ Towards a Modern and Lightweight Rendering Engine for Dynamic Robotic Simulations"><span class="ltx_text ltx_ref_tag">3e</span></a> demonstrate different roughness values on a non-metallic material. AMBF-Vulkan uses a Cook-Torrance specular reflectance model variation that is common in real-time rendering applications <cite class="ltx_cite ltx_citemacro_cite">[<a class="ltx_ref" href="https://arxiv.org/html/2410.05095v1#bib.bib33" title="">33</a>]</cite>:</p>
</div>
<div class="ltx_para" id="S4.SS2.SSS1.p2">
<table class="ltx_equation ltx_eqn_table" id="S4.Ex1">
<tbody><tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math alttext="f_{s}=\frac{D(\mathbf{n},\mathbf{h},\alpha)F(\mathbf{h},\boldsymbol{\omega}_{i%
},F_{0})G(\mathbf{n},\boldsymbol{\omega}_{o},\boldsymbol{\omega}_{i},\alpha)}{%
4(\boldsymbol{\omega}_{o}\cdot\mathbf{n})(\boldsymbol{\omega}_{i}\cdot\mathbf{%
n})}" class="ltx_Math" display="block" id="S4.Ex1.m1.12"><semantics id="S4.Ex1.m1.12a"><mrow id="S4.Ex1.m1.12.13" xref="S4.Ex1.m1.12.13.cmml"><msub id="S4.Ex1.m1.12.13.2" xref="S4.Ex1.m1.12.13.2.cmml"><mi id="S4.Ex1.m1.12.13.2.2" xref="S4.Ex1.m1.12.13.2.2.cmml">f</mi><mi id="S4.Ex1.m1.12.13.2.3" xref="S4.Ex1.m1.12.13.2.3.cmml">s</mi></msub><mo id="S4.Ex1.m1.12.13.1" xref="S4.Ex1.m1.12.13.1.cmml">=</mo><mfrac id="S4.Ex1.m1.12.12" xref="S4.Ex1.m1.12.12.cmml"><mrow id="S4.Ex1.m1.10.10.10" xref="S4.Ex1.m1.10.10.10.cmml"><mi id="S4.Ex1.m1.10.10.10.12" xref="S4.Ex1.m1.10.10.10.12.cmml">D</mi><mo id="S4.Ex1.m1.10.10.10.11" xref="S4.Ex1.m1.10.10.10.11.cmml">⁢</mo><mrow id="S4.Ex1.m1.10.10.10.13.2" xref="S4.Ex1.m1.10.10.10.13.1.cmml"><mo id="S4.Ex1.m1.10.10.10.13.2.1" stretchy="false" xref="S4.Ex1.m1.10.10.10.13.1.cmml">(</mo><mi id="S4.Ex1.m1.1.1.1.1" xref="S4.Ex1.m1.1.1.1.1.cmml">𝐧</mi><mo id="S4.Ex1.m1.10.10.10.13.2.2" xref="S4.Ex1.m1.10.10.10.13.1.cmml">,</mo><mi id="S4.Ex1.m1.2.2.2.2" xref="S4.Ex1.m1.2.2.2.2.cmml">𝐡</mi><mo id="S4.Ex1.m1.10.10.10.13.2.3" xref="S4.Ex1.m1.10.10.10.13.1.cmml">,</mo><mi id="S4.Ex1.m1.3.3.3.3" xref="S4.Ex1.m1.3.3.3.3.cmml">α</mi><mo id="S4.Ex1.m1.10.10.10.13.2.4" stretchy="false" xref="S4.Ex1.m1.10.10.10.13.1.cmml">)</mo></mrow><mo id="S4.Ex1.m1.10.10.10.11a" xref="S4.Ex1.m1.10.10.10.11.cmml">⁢</mo><mi id="S4.Ex1.m1.10.10.10.14" xref="S4.Ex1.m1.10.10.10.14.cmml">F</mi><mo id="S4.Ex1.m1.10.10.10.11b" xref="S4.Ex1.m1.10.10.10.11.cmml">⁢</mo><mrow id="S4.Ex1.m1.8.8.8.8.2" xref="S4.Ex1.m1.8.8.8.8.3.cmml"><mo id="S4.Ex1.m1.8.8.8.8.2.3" stretchy="false" xref="S4.Ex1.m1.8.8.8.8.3.cmml">(</mo><mi id="S4.Ex1.m1.4.4.4.4" xref="S4.Ex1.m1.4.4.4.4.cmml">𝐡</mi><mo id="S4.Ex1.m1.8.8.8.8.2.4" xref="S4.Ex1.m1.8.8.8.8.3.cmml">,</mo><msub id="S4.Ex1.m1.7.7.7.7.1.1" xref="S4.Ex1.m1.7.7.7.7.1.1.cmml"><mi id="S4.Ex1.m1.7.7.7.7.1.1.2" xref="S4.Ex1.m1.7.7.7.7.1.1.2.cmml">𝝎</mi><mi id="S4.Ex1.m1.7.7.7.7.1.1.3" xref="S4.Ex1.m1.7.7.7.7.1.1.3.cmml">i</mi></msub><mo id="S4.Ex1.m1.8.8.8.8.2.5" xref="S4.Ex1.m1.8.8.8.8.3.cmml">,</mo><msub id="S4.Ex1.m1.8.8.8.8.2.2" xref="S4.Ex1.m1.8.8.8.8.2.2.cmml"><mi id="S4.Ex1.m1.8.8.8.8.2.2.2" xref="S4.Ex1.m1.8.8.8.8.2.2.2.cmml">F</mi><mn id="S4.Ex1.m1.8.8.8.8.2.2.3" xref="S4.Ex1.m1.8.8.8.8.2.2.3.cmml">0</mn></msub><mo id="S4.Ex1.m1.8.8.8.8.2.6" stretchy="false" xref="S4.Ex1.m1.8.8.8.8.3.cmml">)</mo></mrow><mo id="S4.Ex1.m1.10.10.10.11c" xref="S4.Ex1.m1.10.10.10.11.cmml">⁢</mo><mi id="S4.Ex1.m1.10.10.10.15" xref="S4.Ex1.m1.10.10.10.15.cmml">G</mi><mo id="S4.Ex1.m1.10.10.10.11d" xref="S4.Ex1.m1.10.10.10.11.cmml">⁢</mo><mrow id="S4.Ex1.m1.10.10.10.10.2" xref="S4.Ex1.m1.10.10.10.10.3.cmml"><mo id="S4.Ex1.m1.10.10.10.10.2.3" stretchy="false" xref="S4.Ex1.m1.10.10.10.10.3.cmml">(</mo><mi id="S4.Ex1.m1.5.5.5.5" xref="S4.Ex1.m1.5.5.5.5.cmml">𝐧</mi><mo id="S4.Ex1.m1.10.10.10.10.2.4" xref="S4.Ex1.m1.10.10.10.10.3.cmml">,</mo><msub id="S4.Ex1.m1.9.9.9.9.1.1" xref="S4.Ex1.m1.9.9.9.9.1.1.cmml"><mi id="S4.Ex1.m1.9.9.9.9.1.1.2" xref="S4.Ex1.m1.9.9.9.9.1.1.2.cmml">𝝎</mi><mi id="S4.Ex1.m1.9.9.9.9.1.1.3" xref="S4.Ex1.m1.9.9.9.9.1.1.3.cmml">o</mi></msub><mo id="S4.Ex1.m1.10.10.10.10.2.5" xref="S4.Ex1.m1.10.10.10.10.3.cmml">,</mo><msub id="S4.Ex1.m1.10.10.10.10.2.2" xref="S4.Ex1.m1.10.10.10.10.2.2.cmml"><mi id="S4.Ex1.m1.10.10.10.10.2.2.2" xref="S4.Ex1.m1.10.10.10.10.2.2.2.cmml">𝝎</mi><mi id="S4.Ex1.m1.10.10.10.10.2.2.3" xref="S4.Ex1.m1.10.10.10.10.2.2.3.cmml">i</mi></msub><mo id="S4.Ex1.m1.10.10.10.10.2.6" xref="S4.Ex1.m1.10.10.10.10.3.cmml">,</mo><mi id="S4.Ex1.m1.6.6.6.6" xref="S4.Ex1.m1.6.6.6.6.cmml">α</mi><mo id="S4.Ex1.m1.10.10.10.10.2.7" stretchy="false" xref="S4.Ex1.m1.10.10.10.10.3.cmml">)</mo></mrow></mrow><mrow id="S4.Ex1.m1.12.12.12" xref="S4.Ex1.m1.12.12.12.cmml"><mn id="S4.Ex1.m1.12.12.12.4" xref="S4.Ex1.m1.12.12.12.4.cmml">4</mn><mo id="S4.Ex1.m1.12.12.12.3" xref="S4.Ex1.m1.12.12.12.3.cmml">⁢</mo><mrow id="S4.Ex1.m1.11.11.11.1.1" xref="S4.Ex1.m1.11.11.11.1.1.1.cmml"><mo id="S4.Ex1.m1.11.11.11.1.1.2" stretchy="false" xref="S4.Ex1.m1.11.11.11.1.1.1.cmml">(</mo><mrow id="S4.Ex1.m1.11.11.11.1.1.1" xref="S4.Ex1.m1.11.11.11.1.1.1.cmml"><msub id="S4.Ex1.m1.11.11.11.1.1.1.2" xref="S4.Ex1.m1.11.11.11.1.1.1.2.cmml"><mi id="S4.Ex1.m1.11.11.11.1.1.1.2.2" xref="S4.Ex1.m1.11.11.11.1.1.1.2.2.cmml">𝝎</mi><mi id="S4.Ex1.m1.11.11.11.1.1.1.2.3" xref="S4.Ex1.m1.11.11.11.1.1.1.2.3.cmml">o</mi></msub><mo id="S4.Ex1.m1.11.11.11.1.1.1.1" lspace="0.222em" rspace="0.222em" xref="S4.Ex1.m1.11.11.11.1.1.1.1.cmml">⋅</mo><mi id="S4.Ex1.m1.11.11.11.1.1.1.3" xref="S4.Ex1.m1.11.11.11.1.1.1.3.cmml">𝐧</mi></mrow><mo id="S4.Ex1.m1.11.11.11.1.1.3" stretchy="false" xref="S4.Ex1.m1.11.11.11.1.1.1.cmml">)</mo></mrow><mo id="S4.Ex1.m1.12.12.12.3a" xref="S4.Ex1.m1.12.12.12.3.cmml">⁢</mo><mrow id="S4.Ex1.m1.12.12.12.2.1" xref="S4.Ex1.m1.12.12.12.2.1.1.cmml"><mo id="S4.Ex1.m1.12.12.12.2.1.2" stretchy="false" xref="S4.Ex1.m1.12.12.12.2.1.1.cmml">(</mo><mrow id="S4.Ex1.m1.12.12.12.2.1.1" xref="S4.Ex1.m1.12.12.12.2.1.1.cmml"><msub id="S4.Ex1.m1.12.12.12.2.1.1.2" xref="S4.Ex1.m1.12.12.12.2.1.1.2.cmml"><mi id="S4.Ex1.m1.12.12.12.2.1.1.2.2" xref="S4.Ex1.m1.12.12.12.2.1.1.2.2.cmml">𝝎</mi><mi id="S4.Ex1.m1.12.12.12.2.1.1.2.3" xref="S4.Ex1.m1.12.12.12.2.1.1.2.3.cmml">i</mi></msub><mo id="S4.Ex1.m1.12.12.12.2.1.1.1" lspace="0.222em" rspace="0.222em" xref="S4.Ex1.m1.12.12.12.2.1.1.1.cmml">⋅</mo><mi id="S4.Ex1.m1.12.12.12.2.1.1.3" xref="S4.Ex1.m1.12.12.12.2.1.1.3.cmml">𝐧</mi></mrow><mo id="S4.Ex1.m1.12.12.12.2.1.3" stretchy="false" xref="S4.Ex1.m1.12.12.12.2.1.1.cmml">)</mo></mrow></mrow></mfrac></mrow><annotation-xml encoding="MathML-Content" id="S4.Ex1.m1.12b"><apply id="S4.Ex1.m1.12.13.cmml" xref="S4.Ex1.m1.12.13"><eq id="S4.Ex1.m1.12.13.1.cmml" xref="S4.Ex1.m1.12.13.1"></eq><apply id="S4.Ex1.m1.12.13.2.cmml" xref="S4.Ex1.m1.12.13.2"><csymbol cd="ambiguous" id="S4.Ex1.m1.12.13.2.1.cmml" xref="S4.Ex1.m1.12.13.2">subscript</csymbol><ci id="S4.Ex1.m1.12.13.2.2.cmml" xref="S4.Ex1.m1.12.13.2.2">𝑓</ci><ci id="S4.Ex1.m1.12.13.2.3.cmml" xref="S4.Ex1.m1.12.13.2.3">𝑠</ci></apply><apply id="S4.Ex1.m1.12.12.cmml" xref="S4.Ex1.m1.12.12"><divide id="S4.Ex1.m1.12.12.13.cmml" xref="S4.Ex1.m1.12.12"></divide><apply id="S4.Ex1.m1.10.10.10.cmml" xref="S4.Ex1.m1.10.10.10"><times id="S4.Ex1.m1.10.10.10.11.cmml" xref="S4.Ex1.m1.10.10.10.11"></times><ci id="S4.Ex1.m1.10.10.10.12.cmml" xref="S4.Ex1.m1.10.10.10.12">𝐷</ci><vector id="S4.Ex1.m1.10.10.10.13.1.cmml" xref="S4.Ex1.m1.10.10.10.13.2"><ci id="S4.Ex1.m1.1.1.1.1.cmml" xref="S4.Ex1.m1.1.1.1.1">𝐧</ci><ci id="S4.Ex1.m1.2.2.2.2.cmml" xref="S4.Ex1.m1.2.2.2.2">𝐡</ci><ci id="S4.Ex1.m1.3.3.3.3.cmml" xref="S4.Ex1.m1.3.3.3.3">𝛼</ci></vector><ci id="S4.Ex1.m1.10.10.10.14.cmml" xref="S4.Ex1.m1.10.10.10.14">𝐹</ci><vector id="S4.Ex1.m1.8.8.8.8.3.cmml" xref="S4.Ex1.m1.8.8.8.8.2"><ci id="S4.Ex1.m1.4.4.4.4.cmml" xref="S4.Ex1.m1.4.4.4.4">𝐡</ci><apply id="S4.Ex1.m1.7.7.7.7.1.1.cmml" xref="S4.Ex1.m1.7.7.7.7.1.1"><csymbol cd="ambiguous" id="S4.Ex1.m1.7.7.7.7.1.1.1.cmml" xref="S4.Ex1.m1.7.7.7.7.1.1">subscript</csymbol><ci id="S4.Ex1.m1.7.7.7.7.1.1.2.cmml" xref="S4.Ex1.m1.7.7.7.7.1.1.2">𝝎</ci><ci id="S4.Ex1.m1.7.7.7.7.1.1.3.cmml" xref="S4.Ex1.m1.7.7.7.7.1.1.3">𝑖</ci></apply><apply id="S4.Ex1.m1.8.8.8.8.2.2.cmml" xref="S4.Ex1.m1.8.8.8.8.2.2"><csymbol cd="ambiguous" id="S4.Ex1.m1.8.8.8.8.2.2.1.cmml" xref="S4.Ex1.m1.8.8.8.8.2.2">subscript</csymbol><ci id="S4.Ex1.m1.8.8.8.8.2.2.2.cmml" xref="S4.Ex1.m1.8.8.8.8.2.2.2">𝐹</ci><cn id="S4.Ex1.m1.8.8.8.8.2.2.3.cmml" type="integer" xref="S4.Ex1.m1.8.8.8.8.2.2.3">0</cn></apply></vector><ci id="S4.Ex1.m1.10.10.10.15.cmml" xref="S4.Ex1.m1.10.10.10.15">𝐺</ci><vector id="S4.Ex1.m1.10.10.10.10.3.cmml" xref="S4.Ex1.m1.10.10.10.10.2"><ci id="S4.Ex1.m1.5.5.5.5.cmml" xref="S4.Ex1.m1.5.5.5.5">𝐧</ci><apply id="S4.Ex1.m1.9.9.9.9.1.1.cmml" xref="S4.Ex1.m1.9.9.9.9.1.1"><csymbol cd="ambiguous" id="S4.Ex1.m1.9.9.9.9.1.1.1.cmml" xref="S4.Ex1.m1.9.9.9.9.1.1">subscript</csymbol><ci id="S4.Ex1.m1.9.9.9.9.1.1.2.cmml" xref="S4.Ex1.m1.9.9.9.9.1.1.2">𝝎</ci><ci id="S4.Ex1.m1.9.9.9.9.1.1.3.cmml" xref="S4.Ex1.m1.9.9.9.9.1.1.3">𝑜</ci></apply><apply id="S4.Ex1.m1.10.10.10.10.2.2.cmml" xref="S4.Ex1.m1.10.10.10.10.2.2"><csymbol cd="ambiguous" id="S4.Ex1.m1.10.10.10.10.2.2.1.cmml" xref="S4.Ex1.m1.10.10.10.10.2.2">subscript</csymbol><ci id="S4.Ex1.m1.10.10.10.10.2.2.2.cmml" xref="S4.Ex1.m1.10.10.10.10.2.2.2">𝝎</ci><ci id="S4.Ex1.m1.10.10.10.10.2.2.3.cmml" xref="S4.Ex1.m1.10.10.10.10.2.2.3">𝑖</ci></apply><ci id="S4.Ex1.m1.6.6.6.6.cmml" xref="S4.Ex1.m1.6.6.6.6">𝛼</ci></vector></apply><apply id="S4.Ex1.m1.12.12.12.cmml" xref="S4.Ex1.m1.12.12.12"><times id="S4.Ex1.m1.12.12.12.3.cmml" xref="S4.Ex1.m1.12.12.12.3"></times><cn id="S4.Ex1.m1.12.12.12.4.cmml" type="integer" xref="S4.Ex1.m1.12.12.12.4">4</cn><apply id="S4.Ex1.m1.11.11.11.1.1.1.cmml" xref="S4.Ex1.m1.11.11.11.1.1"><ci id="S4.Ex1.m1.11.11.11.1.1.1.1.cmml" xref="S4.Ex1.m1.11.11.11.1.1.1.1">⋅</ci><apply id="S4.Ex1.m1.11.11.11.1.1.1.2.cmml" xref="S4.Ex1.m1.11.11.11.1.1.1.2"><csymbol cd="ambiguous" id="S4.Ex1.m1.11.11.11.1.1.1.2.1.cmml" xref="S4.Ex1.m1.11.11.11.1.1.1.2">subscript</csymbol><ci id="S4.Ex1.m1.11.11.11.1.1.1.2.2.cmml" xref="S4.Ex1.m1.11.11.11.1.1.1.2.2">𝝎</ci><ci id="S4.Ex1.m1.11.11.11.1.1.1.2.3.cmml" xref="S4.Ex1.m1.11.11.11.1.1.1.2.3">𝑜</ci></apply><ci id="S4.Ex1.m1.11.11.11.1.1.1.3.cmml" xref="S4.Ex1.m1.11.11.11.1.1.1.3">𝐧</ci></apply><apply id="S4.Ex1.m1.12.12.12.2.1.1.cmml" xref="S4.Ex1.m1.12.12.12.2.1"><ci id="S4.Ex1.m1.12.12.12.2.1.1.1.cmml" xref="S4.Ex1.m1.12.12.12.2.1.1.1">⋅</ci><apply id="S4.Ex1.m1.12.12.12.2.1.1.2.cmml" xref="S4.Ex1.m1.12.12.12.2.1.1.2"><csymbol cd="ambiguous" id="S4.Ex1.m1.12.12.12.2.1.1.2.1.cmml" xref="S4.Ex1.m1.12.12.12.2.1.1.2">subscript</csymbol><ci id="S4.Ex1.m1.12.12.12.2.1.1.2.2.cmml" xref="S4.Ex1.m1.12.12.12.2.1.1.2.2">𝝎</ci><ci id="S4.Ex1.m1.12.12.12.2.1.1.2.3.cmml" xref="S4.Ex1.m1.12.12.12.2.1.1.2.3">𝑖</ci></apply><ci id="S4.Ex1.m1.12.12.12.2.1.1.3.cmml" xref="S4.Ex1.m1.12.12.12.2.1.1.3">𝐧</ci></apply></apply></apply></apply></annotation-xml><annotation encoding="application/x-tex" id="S4.Ex1.m1.12c">f_{s}=\frac{D(\mathbf{n},\mathbf{h},\alpha)F(\mathbf{h},\boldsymbol{\omega}_{i%
},F_{0})G(\mathbf{n},\boldsymbol{\omega}_{o},\boldsymbol{\omega}_{i},\alpha)}{%
4(\boldsymbol{\omega}_{o}\cdot\mathbf{n})(\boldsymbol{\omega}_{i}\cdot\mathbf{%
n})}</annotation><annotation encoding="application/x-llamapun" id="S4.Ex1.m1.12d">italic_f start_POSTSUBSCRIPT italic_s end_POSTSUBSCRIPT = divide start_ARG italic_D ( bold_n , bold_h , italic_α ) italic_F ( bold_h , bold_italic_ω start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT , italic_F start_POSTSUBSCRIPT 0 end_POSTSUBSCRIPT ) italic_G ( bold_n , bold_italic_ω start_POSTSUBSCRIPT italic_o end_POSTSUBSCRIPT , bold_italic_ω start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT , italic_α ) end_ARG start_ARG 4 ( bold_italic_ω start_POSTSUBSCRIPT italic_o end_POSTSUBSCRIPT ⋅ bold_n ) ( bold_italic_ω start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT ⋅ bold_n ) end_ARG</annotation></semantics></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr></tbody>
</table>
</div>
<div class="ltx_para" id="S4.SS2.SSS1.p4">
<p class="ltx_p" id="S4.SS2.SSS1.p4.10">where <math alttext="f_{s}" class="ltx_Math" display="inline" id="S4.SS2.SSS1.p4.1.m1.1"><semantics id="S4.SS2.SSS1.p4.1.m1.1a"><msub id="S4.SS2.SSS1.p4.1.m1.1.1" xref="S4.SS2.SSS1.p4.1.m1.1.1.cmml"><mi id="S4.SS2.SSS1.p4.1.m1.1.1.2" xref="S4.SS2.SSS1.p4.1.m1.1.1.2.cmml">f</mi><mi id="S4.SS2.SSS1.p4.1.m1.1.1.3" xref="S4.SS2.SSS1.p4.1.m1.1.1.3.cmml">s</mi></msub><annotation-xml encoding="MathML-Content" id="S4.SS2.SSS1.p4.1.m1.1b"><apply id="S4.SS2.SSS1.p4.1.m1.1.1.cmml" xref="S4.SS2.SSS1.p4.1.m1.1.1"><csymbol cd="ambiguous" id="S4.SS2.SSS1.p4.1.m1.1.1.1.cmml" xref="S4.SS2.SSS1.p4.1.m1.1.1">subscript</csymbol><ci id="S4.SS2.SSS1.p4.1.m1.1.1.2.cmml" xref="S4.SS2.SSS1.p4.1.m1.1.1.2">𝑓</ci><ci id="S4.SS2.SSS1.p4.1.m1.1.1.3.cmml" xref="S4.SS2.SSS1.p4.1.m1.1.1.3">𝑠</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="S4.SS2.SSS1.p4.1.m1.1c">f_{s}</annotation><annotation encoding="application/x-llamapun" id="S4.SS2.SSS1.p4.1.m1.1d">italic_f start_POSTSUBSCRIPT italic_s end_POSTSUBSCRIPT</annotation></semantics></math> is the specular bidirectional reflectance distribution function, the chosen normal distribution function <math alttext="D" class="ltx_Math" display="inline" id="S4.SS2.SSS1.p4.2.m2.1"><semantics id="S4.SS2.SSS1.p4.2.m2.1a"><mi id="S4.SS2.SSS1.p4.2.m2.1.1" xref="S4.SS2.SSS1.p4.2.m2.1.1.cmml">D</mi><annotation-xml encoding="MathML-Content" id="S4.SS2.SSS1.p4.2.m2.1b"><ci id="S4.SS2.SSS1.p4.2.m2.1.1.cmml" xref="S4.SS2.SSS1.p4.2.m2.1.1">𝐷</ci></annotation-xml><annotation encoding="application/x-tex" id="S4.SS2.SSS1.p4.2.m2.1c">D</annotation><annotation encoding="application/x-llamapun" id="S4.SS2.SSS1.p4.2.m2.1d">italic_D</annotation></semantics></math> is Trowbridge-Reitz GGX<cite class="ltx_cite ltx_citemacro_cite">[<a class="ltx_ref" href="https://arxiv.org/html/2410.05095v1#bib.bib34" title="">34</a>]</cite>, the chosen Fresnel function <math alttext="F" class="ltx_Math" display="inline" id="S4.SS2.SSS1.p4.3.m3.1"><semantics id="S4.SS2.SSS1.p4.3.m3.1a"><mi id="S4.SS2.SSS1.p4.3.m3.1.1" xref="S4.SS2.SSS1.p4.3.m3.1.1.cmml">F</mi><annotation-xml encoding="MathML-Content" id="S4.SS2.SSS1.p4.3.m3.1b"><ci id="S4.SS2.SSS1.p4.3.m3.1.1.cmml" xref="S4.SS2.SSS1.p4.3.m3.1.1">𝐹</ci></annotation-xml><annotation encoding="application/x-tex" id="S4.SS2.SSS1.p4.3.m3.1c">F</annotation><annotation encoding="application/x-llamapun" id="S4.SS2.SSS1.p4.3.m3.1d">italic_F</annotation></semantics></math> is the Schlick approximation<cite class="ltx_cite ltx_citemacro_cite">[<a class="ltx_ref" href="https://arxiv.org/html/2410.05095v1#bib.bib35" title="">35</a>]</cite>, the chosen geometry function <math alttext="G" class="ltx_Math" display="inline" id="S4.SS2.SSS1.p4.4.m4.1"><semantics id="S4.SS2.SSS1.p4.4.m4.1a"><mi id="S4.SS2.SSS1.p4.4.m4.1.1" xref="S4.SS2.SSS1.p4.4.m4.1.1.cmml">G</mi><annotation-xml encoding="MathML-Content" id="S4.SS2.SSS1.p4.4.m4.1b"><ci id="S4.SS2.SSS1.p4.4.m4.1.1.cmml" xref="S4.SS2.SSS1.p4.4.m4.1.1">𝐺</ci></annotation-xml><annotation encoding="application/x-tex" id="S4.SS2.SSS1.p4.4.m4.1c">G</annotation><annotation encoding="application/x-llamapun" id="S4.SS2.SSS1.p4.4.m4.1d">italic_G</annotation></semantics></math> is Schlick-GGX, <cite class="ltx_cite ltx_citemacro_cite">[<a class="ltx_ref" href="https://arxiv.org/html/2410.05095v1#bib.bib36" title="">36</a>]</cite>, <math alttext="\mathbf{n}" class="ltx_Math" display="inline" id="S4.SS2.SSS1.p4.5.m5.1"><semantics id="S4.SS2.SSS1.p4.5.m5.1a"><mi id="S4.SS2.SSS1.p4.5.m5.1.1" xref="S4.SS2.SSS1.p4.5.m5.1.1.cmml">𝐧</mi><annotation-xml encoding="MathML-Content" id="S4.SS2.SSS1.p4.5.m5.1b"><ci id="S4.SS2.SSS1.p4.5.m5.1.1.cmml" xref="S4.SS2.SSS1.p4.5.m5.1.1">𝐧</ci></annotation-xml><annotation encoding="application/x-tex" id="S4.SS2.SSS1.p4.5.m5.1c">\mathbf{n}</annotation><annotation encoding="application/x-llamapun" id="S4.SS2.SSS1.p4.5.m5.1d">bold_n</annotation></semantics></math> is the normal vector, <math alttext="\mathbf{h}" class="ltx_Math" display="inline" id="S4.SS2.SSS1.p4.6.m6.1"><semantics id="S4.SS2.SSS1.p4.6.m6.1a"><mi id="S4.SS2.SSS1.p4.6.m6.1.1" xref="S4.SS2.SSS1.p4.6.m6.1.1.cmml">𝐡</mi><annotation-xml encoding="MathML-Content" id="S4.SS2.SSS1.p4.6.m6.1b"><ci id="S4.SS2.SSS1.p4.6.m6.1.1.cmml" xref="S4.SS2.SSS1.p4.6.m6.1.1">𝐡</ci></annotation-xml><annotation encoding="application/x-tex" id="S4.SS2.SSS1.p4.6.m6.1c">\mathbf{h}</annotation><annotation encoding="application/x-llamapun" id="S4.SS2.SSS1.p4.6.m6.1d">bold_h</annotation></semantics></math> is the halfway vector, <math alttext="\boldsymbol{\omega}_{o}" class="ltx_Math" display="inline" id="S4.SS2.SSS1.p4.7.m7.1"><semantics id="S4.SS2.SSS1.p4.7.m7.1a"><msub id="S4.SS2.SSS1.p4.7.m7.1.1" xref="S4.SS2.SSS1.p4.7.m7.1.1.cmml"><mi id="S4.SS2.SSS1.p4.7.m7.1.1.2" xref="S4.SS2.SSS1.p4.7.m7.1.1.2.cmml">𝝎</mi><mi id="S4.SS2.SSS1.p4.7.m7.1.1.3" xref="S4.SS2.SSS1.p4.7.m7.1.1.3.cmml">o</mi></msub><annotation-xml encoding="MathML-Content" id="S4.SS2.SSS1.p4.7.m7.1b"><apply id="S4.SS2.SSS1.p4.7.m7.1.1.cmml" xref="S4.SS2.SSS1.p4.7.m7.1.1"><csymbol cd="ambiguous" id="S4.SS2.SSS1.p4.7.m7.1.1.1.cmml" xref="S4.SS2.SSS1.p4.7.m7.1.1">subscript</csymbol><ci id="S4.SS2.SSS1.p4.7.m7.1.1.2.cmml" xref="S4.SS2.SSS1.p4.7.m7.1.1.2">𝝎</ci><ci id="S4.SS2.SSS1.p4.7.m7.1.1.3.cmml" xref="S4.SS2.SSS1.p4.7.m7.1.1.3">𝑜</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="S4.SS2.SSS1.p4.7.m7.1c">\boldsymbol{\omega}_{o}</annotation><annotation encoding="application/x-llamapun" id="S4.SS2.SSS1.p4.7.m7.1d">bold_italic_ω start_POSTSUBSCRIPT italic_o end_POSTSUBSCRIPT</annotation></semantics></math> is the normalized incoming light direction, <math alttext="\boldsymbol{\omega}_{i}" class="ltx_Math" display="inline" id="S4.SS2.SSS1.p4.8.m8.1"><semantics id="S4.SS2.SSS1.p4.8.m8.1a"><msub id="S4.SS2.SSS1.p4.8.m8.1.1" xref="S4.SS2.SSS1.p4.8.m8.1.1.cmml"><mi id="S4.SS2.SSS1.p4.8.m8.1.1.2" xref="S4.SS2.SSS1.p4.8.m8.1.1.2.cmml">𝝎</mi><mi id="S4.SS2.SSS1.p4.8.m8.1.1.3" xref="S4.SS2.SSS1.p4.8.m8.1.1.3.cmml">i</mi></msub><annotation-xml encoding="MathML-Content" id="S4.SS2.SSS1.p4.8.m8.1b"><apply id="S4.SS2.SSS1.p4.8.m8.1.1.cmml" xref="S4.SS2.SSS1.p4.8.m8.1.1"><csymbol cd="ambiguous" id="S4.SS2.SSS1.p4.8.m8.1.1.1.cmml" xref="S4.SS2.SSS1.p4.8.m8.1.1">subscript</csymbol><ci id="S4.SS2.SSS1.p4.8.m8.1.1.2.cmml" xref="S4.SS2.SSS1.p4.8.m8.1.1.2">𝝎</ci><ci id="S4.SS2.SSS1.p4.8.m8.1.1.3.cmml" xref="S4.SS2.SSS1.p4.8.m8.1.1.3">𝑖</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="S4.SS2.SSS1.p4.8.m8.1c">\boldsymbol{\omega}_{i}</annotation><annotation encoding="application/x-llamapun" id="S4.SS2.SSS1.p4.8.m8.1d">bold_italic_ω start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT</annotation></semantics></math> is the normalized outgoing light direction, <math alttext="F_{0}" class="ltx_Math" display="inline" id="S4.SS2.SSS1.p4.9.m9.1"><semantics id="S4.SS2.SSS1.p4.9.m9.1a"><msub id="S4.SS2.SSS1.p4.9.m9.1.1" xref="S4.SS2.SSS1.p4.9.m9.1.1.cmml"><mi id="S4.SS2.SSS1.p4.9.m9.1.1.2" xref="S4.SS2.SSS1.p4.9.m9.1.1.2.cmml">F</mi><mn id="S4.SS2.SSS1.p4.9.m9.1.1.3" xref="S4.SS2.SSS1.p4.9.m9.1.1.3.cmml">0</mn></msub><annotation-xml encoding="MathML-Content" id="S4.SS2.SSS1.p4.9.m9.1b"><apply id="S4.SS2.SSS1.p4.9.m9.1.1.cmml" xref="S4.SS2.SSS1.p4.9.m9.1.1"><csymbol cd="ambiguous" id="S4.SS2.SSS1.p4.9.m9.1.1.1.cmml" xref="S4.SS2.SSS1.p4.9.m9.1.1">subscript</csymbol><ci id="S4.SS2.SSS1.p4.9.m9.1.1.2.cmml" xref="S4.SS2.SSS1.p4.9.m9.1.1.2">𝐹</ci><cn id="S4.SS2.SSS1.p4.9.m9.1.1.3.cmml" type="integer" xref="S4.SS2.SSS1.p4.9.m9.1.1.3">0</cn></apply></annotation-xml><annotation encoding="application/x-tex" id="S4.SS2.SSS1.p4.9.m9.1c">F_{0}</annotation><annotation encoding="application/x-llamapun" id="S4.SS2.SSS1.p4.9.m9.1d">italic_F start_POSTSUBSCRIPT 0 end_POSTSUBSCRIPT</annotation></semantics></math> is the normal incidence Fresnel reflectance, and <math alttext="\alpha" class="ltx_Math" display="inline" id="S4.SS2.SSS1.p4.10.m10.1"><semantics id="S4.SS2.SSS1.p4.10.m10.1a"><mi id="S4.SS2.SSS1.p4.10.m10.1.1" xref="S4.SS2.SSS1.p4.10.m10.1.1.cmml">α</mi><annotation-xml encoding="MathML-Content" id="S4.SS2.SSS1.p4.10.m10.1b"><ci id="S4.SS2.SSS1.p4.10.m10.1.1.cmml" xref="S4.SS2.SSS1.p4.10.m10.1.1">𝛼</ci></annotation-xml><annotation encoding="application/x-tex" id="S4.SS2.SSS1.p4.10.m10.1c">\alpha</annotation><annotation encoding="application/x-llamapun" id="S4.SS2.SSS1.p4.10.m10.1d">italic_α</annotation></semantics></math> is the surface roughness value. This variation was chosen due to its computational efficiency in real-time applications and compatibility with glTF’s metallic-roughness workflow.</p>
</div>
<div class="ltx_para" id="S4.SS2.SSS1.p5">
<p class="ltx_p" id="S4.SS2.SSS1.p5.1">Previous reflection models, such as Blinn-Phong<cite class="ltx_cite ltx_citemacro_cite">[<a class="ltx_ref" href="https://arxiv.org/html/2410.05095v1#bib.bib37" title="">37</a>]</cite>, create physically implausible shading due to their inability to conserve energy and represent microscopic surface changes. Additionally, its material parameters, such as “Shininess,” cannot be converted from physical measurements. PBR allows photogrammetric measurements of material properties, such as albedo and surface roughness, to accurately replicate a material’s reflectance in a simulation environment.</p>
</div>
</section>
<section class="ltx_subsubsection" id="S4.SS2.SSS2">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection"><span class="ltx_text" id="S4.SS2.SSS2.5.1.1">IV-B</span>2 </span>Anti-Aliasing</h4>
<div class="ltx_para" id="S4.SS2.SSS2.p1">
<p class="ltx_p" id="S4.SS2.SSS2.p1.1">AMBF-Vulkan employs two techniques to reduce visual artifacts caused by under-sampling the scene (see Figure <a class="ltx_ref" href="https://arxiv.org/html/2410.05095v1#S4.F4" title="Figure 4 ‣ IV-B2 Anti-Aliasing ‣ IV-B AMBF-Vulkan graphical features ‣ IV Methodology ‣ Towards a Modern and Lightweight Rendering Engine for Dynamic Robotic Simulations"><span class="ltx_text ltx_ref_tag">4</span></a>). These techniques differ in the types of aliasing they target, as well as the stage of rendering they are implemented in, and we combine them to improve image quality further.</p>
</div>
<div class="ltx_para" id="S4.SS2.SSS2.p2">
<p class="ltx_p" id="S4.SS2.SSS2.p2.1">Multisample Anti-Aliasing (MSAA) allows for additional sampling per pixel with little performance cost. Rather than shading each additional sample, as with Supersampling Anti-Aliasing, additional samples are only shaded if the triangle they intersect is not oversampled within the pixel. Before beginning the main render pass, AMBF-Vulkan submits a multisample draw and depth image, along with an additional resolve draw and depth image, and the GPU will automatically handle the rest.</p>
</div>
<div class="ltx_para" id="S4.SS2.SSS2.p3">
<p class="ltx_p" id="S4.SS2.SSS2.p3.1">Fast Approximate Anti-Aliasing (FXAA)<cite class="ltx_cite ltx_citemacro_cite">[<a class="ltx_ref" href="https://arxiv.org/html/2410.05095v1#bib.bib38" title="">38</a>]</cite> is a post-processing technique that reduces aliasing without any extra sampling of the scene. Using high changes of luminance from nearby pixels, the algorithm detects edges of geometry and subsequently blends along the edge. Visual improvements are minor compared to MSAA but are still worth including due to the technique’s low computational cost.</p>
</div>
<figure class="ltx_figure" id="S4.F4"><img alt="Refer to caption" class="ltx_graphics ltx_centering ltx_img_square" height="232" id="S4.F4.g1" src="extracted/5907392/anti-aliasing.png" width="240"/>
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure">Figure 4: </span>Comparison between anti-aliasing disabled (left) and enabled (right). Aliasing artifacts are due to undersampling of the scene in high-contrast areas. The top images show an improvement in edge jaggedness. The bottom images show an improvement in specular highlight clarity.</figcaption>
</figure>
</section>
<section class="ltx_subsubsection" id="S4.SS2.SSS3">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection"><span class="ltx_text" id="S4.SS2.SSS3.5.1.1">IV-B</span>3 </span>Ray-traced shadows</h4>
<div class="ltx_para" id="S4.SS2.SSS3.p1">
<p class="ltx_p" id="S4.SS2.SSS3.p1.1">GPU ray tracing support is a clear example of the benefits of moving to a modern graphics API such as Vulkan. Similar to PBR, ray tracing approximates real-world light transport physics, resulting in more photorealistic images. Due to its high computational expense, ray tracing in real-time applications was limited until recent advancements in hardware acceleration and denoising techniques. Using Vulkan’s ray-tracing extensions, we implemented dynamic ray-traced hard shadows as an alternative to shadow mapping techniques (See Figure <a class="ltx_ref" href="https://arxiv.org/html/2410.05095v1#S4.F5" title="Figure 5 ‣ IV-B3 Ray-traced shadows ‣ IV-B AMBF-Vulkan graphical features ‣ IV Methodology ‣ Towards a Modern and Lightweight Rendering Engine for Dynamic Robotic Simulations"><span class="ltx_text ltx_ref_tag">5</span></a>).</p>
</div>
<div class="ltx_para" id="S4.SS2.SSS3.p2">
<p class="ltx_p" id="S4.SS2.SSS3.p2.1">Ray-traced shadow requires the implementation of an acceleration structure build system. In short, acceleration structures enable the computation of ray intersections with scene geometry in logarithmic time complexity and are essential for real-time ray tracing. Once the acceleration structures are set in place, we can use the <span class="ltx_text ltx_font_typewriter" id="S4.SS2.SSS3.p2.1.1">GLSL_EXT_ray_query</span> extension from the fragment shader to ray-trace the scene and get important information, such as whether or not a pixel is in shadow. To determine if a pixel is in shadow, a ray is traced from the fragment’s world space coordinate to the light’s world space coordinate. If the ray hits any opaque geometry during the tracing, then the fragment is in shadow and does not receive direct light.</p>
</div>
<div class="ltx_para" id="S4.SS2.SSS3.p3">
<p class="ltx_p" id="S4.SS2.SSS3.p3.1">To build the acceleration structures in our engine the following steps are performed: (1) on scene initialization, the geometry of each unique mesh is built into a corresponding GPU-side buffer called a Bottom Level Acceleration Structure (BLAS), (2) each BLAS is subsequently compacted for faster traversal and a smaller memory footprint, (3) an Instance object is built for each mesh instance, recording its initial transformation matrix, (4) the transforms are updated on each frame’s scene update, and a single Top Level Acceleration Structure (TLAS) is built, containing each Instance. Because the application does not yet support geometry deformation, updating or rebuilding the BLASs is unnecessary. Furthermore, because TLAS updates deteriorate scene traversal quality, we choose to rebuild the TLAS every frame for a net increase in performance. Additionally, we offload all acceleration structure build tasks to an async compute queue, virtually removing the performance cost.</p>
</div>
<figure class="ltx_figure" id="S4.F5"><img alt="Refer to caption" class="ltx_graphics ltx_centering ltx_img_square" height="212" id="S4.F5.g1" src="extracted/5907392/shadows_v2.png" width="240"/>
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure">Figure 5: </span>Demonstration of the engine’s ray-traced omnidirectional shadows in a scene with two light sources. A ray query traverses the acceleration structure from the fragment shader to determine the light visibility of the sampled point in the scene.</figcaption>
</figure>
</section>
</section>
<section class="ltx_subsection" id="S4.SS3">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection"><span class="ltx_text" id="S4.SS3.5.1.1">IV-C</span> </span><span class="ltx_text ltx_font_italic" id="S4.SS3.6.2">Plugin communication between AMBF and AMBF-Vulkan</span>
</h3>
<div class="ltx_para" id="S4.SS3.p1">
<p class="ltx_p" id="S4.SS3.p1.1">To obtain a complete dynamics simulator, the rendering engine AMBF-Vulkan requires a physics engine that can update the poses of all the bodies in the simulation. In this work, we choose the physics engine inside AMBF, but the software design is flexible enough that other engines could be used. To enable communication between AMBF and the Vulkan engine, we designed the AMBF-Vulkan Interchange (AVI) plugin, which enables AMBF to write the pose of all the bodies at every physics iteration into shared memory. AMBF-Vulkan then uses the poses stored in shared memory before rendering the scene (see Fig. <a class="ltx_ref" href="https://arxiv.org/html/2410.05095v1#S4.F6" title="Figure 6 ‣ IV-C Plugin communication between AMBF and AMBF-Vulkan ‣ IV Methodology ‣ Towards a Modern and Lightweight Rendering Engine for Dynamic Robotic Simulations"><span class="ltx_text ltx_ref_tag">6</span></a>).</p>
</div>
<figure class="ltx_figure" id="S4.F6"><img alt="Refer to caption" class="ltx_graphics ltx_centering ltx_img_square" height="337" id="S4.F6.g1" src="x3.png" width="415"/>
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure">Figure 6: </span>Overview of the engine interchange system. The scene is exported from Blender to a glTF file and, using the AMBF Blender add-on, an ADF file. The ADF file is loaded in AMBF Simulator to communicate with interface devices and simulate physics. The AVI plugin records the model transform matrices into shared memory every frame. AMBF Vulkan loads the glTF file and reads from shared memory every frame to update each model’s pose.</figcaption>
</figure>
<div class="ltx_para" id="S4.SS3.p2">
<p class="ltx_p" id="S4.SS3.p2.1">AVI uses the <span class="ltx_text ltx_font_italic" id="S4.SS3.p2.1.1">boost::interprocess</span> library for a fast, lightweight, and operating-system-agnostic solution for interprocess communication. We simply use AVI to record AMBF’s copy of each mesh node’s world-space transformation matrix in a shared memory region, and AMBF-Vulkan updates its own copy of the mesh node’s matrix. This one-way data transfer approach avoids many of the pitfalls of concurrency. Additionally, the library’s <span class="ltx_text ltx_font_italic" id="S4.SS3.p2.1.2">managed_shared_memory</span> class will internally handle the ownership swapping of the shared memory region using a recursive mutex. Lastly, we chose to simply overwrite each matrix every frame and read each matrix every frame, regardless of whether or not the data has changed. We can afford to use this inefficient but error-resistant implementation because of the relatively low amount of meshes in a typical AMBF simulation environment.</p>
</div>
</section>
</section>
<section class="ltx_section" id="S5">
<h2 class="ltx_title ltx_title_section">
<span class="ltx_tag ltx_tag_section">V </span><span class="ltx_text ltx_font_smallcaps" id="S5.1.1">Experimental results</span>
</h2>
<div class="ltx_para" id="S5.p1">
<p class="ltx_p" id="S5.p1.1">To evaluate the computational performance of the complete simulation framework, AMBF and AMBF-Vulkan were run on an Ubuntu 22.04 workstation with an NVIDIA GeForce RTX 4090 GPU. Two Blender scenes were used to evaluate the frameworks. Scene 1 includes two sets of da Vinci Patient Side Manipulators (PSMs) and a training suturing phantom taken from <cite class="ltx_cite ltx_citemacro_cite">[<a class="ltx_ref" href="https://arxiv.org/html/2410.05095v1#bib.bib2" title="">2</a>, <a class="ltx_ref" href="https://arxiv.org/html/2410.05095v1#bib.bib9" title="">9</a>]</cite>, and has a total of 223K triangles. Scene 2 includes a model of a full da Vinci Si that was acquired from DistroSquid<span class="ltx_note ltx_role_footnote" id="footnote1"><sup class="ltx_note_mark">1</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">1</sup><span class="ltx_tag ltx_tag_note">1</span><a class="ltx_ref ltx_url ltx_font_typewriter" href="https://www.turbosquid.com" title="">https://www.turbosquid.com</a></span></span></span> and has a total of 550K triangles. Each scene was exported from a Blender file into ADF and glTF formats and then loaded to AMBF and AMBF-Vulkan, respectively. For every test, all the geometry was kept within the clipping plane, and no culling operations were applied to reduce the triangle count.</p>
</div>
<section class="ltx_subsection" id="S5.SS1">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection"><span class="ltx_text" id="S5.SS1.5.1.1">V-A</span> </span><span class="ltx_text ltx_font_italic" id="S5.SS1.6.2">AMBF-Vulkan computational performance</span>
</h3>
<div class="ltx_para" id="S5.SS1.p1">
<p class="ltx_p" id="S5.SS1.p1.1">Figure <a class="ltx_ref" href="https://arxiv.org/html/2410.05095v1#S5.F7" title="Figure 7 ‣ V-A AMBF-Vulkan computational performance ‣ V Experimental results ‣ Towards a Modern and Lightweight Rendering Engine for Dynamic Robotic Simulations"><span class="ltx_text ltx_ref_tag">7</span></a> shows the GPU processing time for each stage in the rendering pipeline of AMBF-Vulkan as the total number of triangles increases. To easily augment the number of triangles, we duplicated the objects in Scene 1 so that the number of triangles would grow exponentially at every test. Using NVIDIA Nsight Graphics GPU Trace, five frame captures of each scene were profiled. The computational times for the following tasks were recorded: TLAS building, the main render pass, the post-processing pass, and the ImGui pass.</p>
</div>
<figure class="ltx_figure" id="S5.F7"><img alt="Refer to caption" class="ltx_graphics ltx_centering ltx_img_landscape" height="268" id="S5.F7.g1" src="x4.png" width="415"/>
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure">Figure 7: </span>GPU computation time measurements of segments of Vulkan’s render loop. Measurements were taken from scenes comprised of increasingly greater triangle counts.</figcaption>
</figure>
<div class="ltx_para" id="S5.SS1.p2">
<p class="ltx_p" id="S5.SS1.p2.1">It is observed that GPU computation time for building the TLAS and the main pass increases with the number of triangles. Conversely, the post-processing pass and ImGui pass remain constant throughout the experiment. An increase in TLAS building time is related to the increasing number of instances the TLAS represents, resulting from the rising model count. Similarly, an increase in the main pass is also reasonable as an increasing number of vertices directly relates to the number of vertex shader invocations and triangles to rasterize. The post-processing and the ImGui pass manipulate the resulting image from the main pass and are, therefore, unaffected by an increase in geometry. Post-processing passes would only require more GPU computation time if the screen resolution increases or more complex image processing techniques are used. Overall, even with a scene with more than 7 million triangles, our proposed rendering engine maintains GPU computation times within 2 ms.</p>
</div>
</section>
<section class="ltx_subsection" id="S5.SS2">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection"><span class="ltx_text" id="S5.SS2.5.1.1">V-B</span> </span><span class="ltx_text ltx_font_italic" id="S5.SS2.6.2">Quantitative comparisons between AMBF-Vulkan and AMBF</span>
</h3>
<figure class="ltx_table" id="S5.T1">
<table class="ltx_tabular ltx_centering ltx_guessed_headers ltx_align_middle" id="S5.T1.1">
<thead class="ltx_thead">
<tr class="ltx_tr" id="S5.T1.1.1.1">
<th class="ltx_td ltx_align_center ltx_th ltx_th_column ltx_border_l ltx_border_r ltx_border_t" id="S5.T1.1.1.1.1">Engine</th>
<th class="ltx_td ltx_align_center ltx_th ltx_th_column ltx_border_r ltx_border_t" colspan="2" id="S5.T1.1.1.1.2">AMBF</th>
<th class="ltx_td ltx_align_center ltx_th ltx_th_column ltx_border_r ltx_border_t" colspan="2" id="S5.T1.1.1.1.3">AMBF-Vulkan</th>
</tr>
</thead>
<tbody class="ltx_tbody">
<tr class="ltx_tr" id="S5.T1.1.2.1">
<td class="ltx_td ltx_border_l ltx_border_r ltx_border_t" id="S5.T1.1.2.1.1"></td>
<td class="ltx_td ltx_align_center ltx_border_r ltx_border_t" id="S5.T1.1.2.1.2">mean (ms)</td>
<td class="ltx_td ltx_align_center ltx_border_r ltx_border_t" id="S5.T1.1.2.1.3">std</td>
<td class="ltx_td ltx_align_center ltx_border_r ltx_border_t" id="S5.T1.1.2.1.4">mean (ms)</td>
<td class="ltx_td ltx_align_center ltx_border_r ltx_border_t" id="S5.T1.1.2.1.5">std</td>
</tr>
<tr class="ltx_tr" id="S5.T1.1.3.2">
<td class="ltx_td ltx_align_center ltx_border_l ltx_border_r ltx_border_t" id="S5.T1.1.3.2.1">Scene 1</td>
<td class="ltx_td ltx_align_center ltx_border_r ltx_border_t" id="S5.T1.1.3.2.2">3.34</td>
<td class="ltx_td ltx_align_center ltx_border_r ltx_border_t" id="S5.T1.1.3.2.3">0.68</td>
<td class="ltx_td ltx_align_center ltx_border_r ltx_border_t" id="S5.T1.1.3.2.4"><span class="ltx_text ltx_font_bold" id="S5.T1.1.3.2.4.1">0.55</span></td>
<td class="ltx_td ltx_align_center ltx_border_r ltx_border_t" id="S5.T1.1.3.2.5">0.01</td>
</tr>
<tr class="ltx_tr" id="S5.T1.1.4.3">
<td class="ltx_td ltx_align_center ltx_border_b ltx_border_l ltx_border_r ltx_border_t" id="S5.T1.1.4.3.1">Scene 2</td>
<td class="ltx_td ltx_align_center ltx_border_b ltx_border_r ltx_border_t" id="S5.T1.1.4.3.2">4.74</td>
<td class="ltx_td ltx_align_center ltx_border_b ltx_border_r ltx_border_t" id="S5.T1.1.4.3.3">0.16</td>
<td class="ltx_td ltx_align_center ltx_border_b ltx_border_r ltx_border_t" id="S5.T1.1.4.3.4"><span class="ltx_text ltx_font_bold" id="S5.T1.1.4.3.4.1">0.56</span></td>
<td class="ltx_td ltx_align_center ltx_border_b ltx_border_r ltx_border_t" id="S5.T1.1.4.3.5">0.00</td>
</tr>
</tbody>
</table>
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_table">TABLE I: </span>Mean GPU usage on the render loop’s main pass in
AMBF and AMBF-Vulkan measured in ms.</figcaption>
</figure>
<div class="ltx_para" id="S5.SS2.p1">
<p class="ltx_p" id="S5.SS2.p1.1">Table <a class="ltx_ref" href="https://arxiv.org/html/2410.05095v1#S5.T1" title="TABLE I ‣ V-B Quantitative comparisons between AMBF-Vulkan and AMBF ‣ V Experimental results ‣ Towards a Modern and Lightweight Rendering Engine for Dynamic Robotic Simulations"><span class="ltx_text ltx_ref_tag">I</span></a> shows the main pass GPU computation time of both AMBF-Vulkan and AMBF while rendering scene 1 and scene 2. Similarly to the previous test, NVIDIA Nsight Graphics GPU Trace was used to capture twenty frames of each scene for each engine. For each frame capture, we measured the computational time for the main render pass, which only consists of the drawing and shading of the scene’s geometry.</p>
</div>
<div class="ltx_para" id="S5.SS2.p2">
<p class="ltx_p" id="S5.SS2.p2.1">The results show that AMBF-Vulkan has an average speed increase of 6.1 and 8.5 times over AMBF for scene 1 and scene 2, respectively. Additionally, AMBF-Vulkan’s measurements showed less variance. AMBF’s computation times increased from scene 1 to scene 2, which is expected as scene 2 contains more triangles and more textures to render. On the other hand, AMBF-Vulkan used roughly the same computation time for both scenes. This is likely due to the GPU computation being so fast that the application is CPU-bound.</p>
</div>
</section>
<section class="ltx_subsection" id="S5.SS3">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection"><span class="ltx_text" id="S5.SS3.5.1.1">V-C</span> </span><span class="ltx_text ltx_font_italic" id="S5.SS3.6.2">Qualitative comparisons between AMBF-Vulkan and AMBF</span>
</h3>
<figure class="ltx_figure" id="S5.F8"><img alt="Refer to caption" class="ltx_graphics ltx_centering ltx_img_square" height="282" id="S5.F8.g1" src="extracted/5907392/visual_comparison.png" width="299"/>
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure">Figure 8: </span>Scene 2 rendered from the same viewpoint in AMBF (top) and AMBF-Vulkan (bottom) for qualitative comparison.</figcaption>
</figure>
<div class="ltx_para" id="S5.SS3.p1">
<p class="ltx_p" id="S5.SS3.p1.1">Scene 2 was rendered by both engines from the same viewpoint with two lights and shadows enabled to perform qualitative comparisons (see Fig. <a class="ltx_ref" href="https://arxiv.org/html/2410.05095v1#S5.F8" title="Figure 8 ‣ V-C Qualitative comparisons between AMBF-Vulkan and AMBF ‣ V Experimental results ‣ Towards a Modern and Lightweight Rendering Engine for Dynamic Robotic Simulations"><span class="ltx_text ltx_ref_tag">8</span></a>). Improvements made to the reflection model in AMBF-Vulkan enable an increased visual clarity of the model’s details and an overall more physically realistic image. Additionally, the ray-traced shadows in AMBF-Vulkan are more precise than the AMBF shadows generated with shadow maps. Lastly, the jagged anti-aliasing artifacts at the edges of the geometry in AMBF are virtually non-existent in AMBF-Vulkan.</p>
</div>
</section>
</section>
<section class="ltx_section" id="S6">
<h2 class="ltx_title ltx_title_section">
<span class="ltx_tag ltx_tag_section">VI </span><span class="ltx_text ltx_font_smallcaps" id="S6.1.1">Discussion and Future Work</span>
</h2>
<div class="ltx_para" id="S6.p1">
<p class="ltx_p" id="S6.p1.1">This paper presents the initial infrastructure required to modernize the AMBF simulator with a modern graphics API capable of taking advantage of GPU hardware advancements. Most of the features presented in this paper serve as groundwork for future iterations of the engine. For example, vertex buffer addressing, a PBR reflection model, and the acceleration structure build system are all key preliminaries to a full ray-tracing pipeline. Additionally, incorporating a post-processing render pass will easily enable us to implement more advanced image processing effects, such as depth-of-field and bloom. Lastly, integration with the Dear ImGui library is the first step toward a custom scene editor that can enable modifying scenes at runtime.</p>
</div>
<div class="ltx_para" id="S6.p2">
<p class="ltx_p" id="S6.p2.1">The planned development of the new engine is focused on three major goals. (1) The full migration of existing AMBF capabilities to create a more performant, unified framework for robotics simulation. (2) Further development of the engine’s ray-tracing pipeline to produce physically based and photorealistic simulations. (3) Improvement of the framework’s user experience and tooling to minimize the barrier to entry and increase simulation development productivity.</p>
</div>
<div class="ltx_para" id="S6.p3">
<p class="ltx_p" id="S6.p3.1">Other potential areas of research and development include GPU-accelerated soft-body dynamics, volumetric smoke simulation from cutting tools, fluid simulation for pooling bodily fluids, physically based endoscope lenses, reduced visual clarity from lens condensation, sub-surface scattering material models for realistic tissue rendering, and image-based lighting from 360°  abdomen-interior high-dynamic-range images. Overall, the proposed Vulkan-based simulation engine lays the foundation to produce more performant and physically accurate simulations in multiple research domains.</p>
</div>
</section>
<section class="ltx_section" id="Sx1">
<h2 class="ltx_title ltx_font_smallcaps ltx_title_section">Supplementary information</h2>
<div class="ltx_para" id="Sx1.p1">
<p class="ltx_p" id="Sx1.p1.1">For more information, visit the project repository at <a class="ltx_ref ltx_url ltx_font_typewriter" href="https://github.com/AMBF-Vulkan-repositories/AMBF-Vulkan" title="">https://github.com/AMBF-Vulkan-repositories/AMBF-Vulkan</a></p>
</div>
</section>
<section class="ltx_bibliography" id="bib">
<h2 class="ltx_title ltx_title_bibliography">References</h2>
<ul class="ltx_biblist">
<li class="ltx_bibitem" id="bib.bib1">
<span class="ltx_tag ltx_tag_bibitem">[1]</span>
<span class="ltx_bibblock">
A. Munawar, Y. Wang, R. Gondokaryono, and G. S. Fischer, “A real-time dynamic simulator and an associated front-end representation format for simulating complex robots and environments,” in <em class="ltx_emph ltx_font_italic" id="bib.bib1.1.1">2019 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS)</em>, 2019, pp. 1875–1882.

</span>
</li>
<li class="ltx_bibitem" id="bib.bib2">
<span class="ltx_tag ltx_tag_bibitem">[2]</span>
<span class="ltx_bibblock">
A. Munawar, J. Y. Wu, G. S. Fischer, R. H. Taylor, and P. Kazanzides, “Open simulation environment for learning and practice of robot-assisted surgical suturing,” <em class="ltx_emph ltx_font_italic" id="bib.bib2.1.1">IEEE Robotics and Automation Letters</em>, vol. 7, no. 2, pp. 3843–3850, 2022.

</span>
</li>
<li class="ltx_bibitem" id="bib.bib3">
<span class="ltx_tag ltx_tag_bibitem">[3]</span>
<span class="ltx_bibblock">
A. Munawar, Z. Li, N. Nagururu, D. Trakimas, P. Kazanzides, R. H. Taylor, and F. X. Creighton, “Fully immersive virtual reality for skull-base surgery: surgical training and beyond,” <em class="ltx_emph ltx_font_italic" id="bib.bib3.1.1">Int. J. Comput. Assist. Radiol. Surg.</em>, vol. 19, no. 1, pp. 51–59, Jan. 2024.

</span>
</li>
<li class="ltx_bibitem" id="bib.bib4">
<span class="ltx_tag ltx_tag_bibitem">[4]</span>
<span class="ltx_bibblock">
G. M. Fried, L. S. Feldman, M. C. Vassiliou, S. A. Fraser, D. Stanbridge, G. Ghitulescu, and C. G. Andrew, “Proving the value of simulation in laparoscopic surgery,” <em class="ltx_emph ltx_font_italic" id="bib.bib4.1.1">Annals of Surgery</em>, vol. 240, no. 3, pp. 518–528, 2004.

</span>
</li>
<li class="ltx_bibitem" id="bib.bib5">
<span class="ltx_tag ltx_tag_bibitem">[5]</span>
<span class="ltx_bibblock">
R. A. Agha and A. J. Fowler, “The role and validity of surgical simulation,” <em class="ltx_emph ltx_font_italic" id="bib.bib5.1.1">International Surgery</em>, vol. 100, no. 2, pp. 350–357, 2015.

</span>
</li>
<li class="ltx_bibitem" id="bib.bib6">
<span class="ltx_tag ltx_tag_bibitem">[6]</span>
<span class="ltx_bibblock">
M. Bailey, “Opengl compute shaders,” 2016.

</span>
</li>
<li class="ltx_bibitem" id="bib.bib7">
<span class="ltx_tag ltx_tag_bibitem">[7]</span>
<span class="ltx_bibblock">
N. P. Koeing and A. Howard, “Design and use paradigms for gazebo, an open-source multi-robot simulator,” in <em class="ltx_emph ltx_font_italic" id="bib.bib7.1.1">2004 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS)</em>, vol. 3.   Ieee, 2004, pp. 2149–2154.

</span>
</li>
<li class="ltx_bibitem" id="bib.bib8">
<span class="ltx_tag ltx_tag_bibitem">[8]</span>
<span class="ltx_bibblock">
F. Faure, C. Duriez, H. Delingette, J. Allard, B. Gilles, S. Marchesseau, H. Talbot, H. Courtecuisse, G. Bousquet, I. Peterlik <em class="ltx_emph ltx_font_italic" id="bib.bib8.1.1">et al.</em>, “Sofa: A multi-model framework for interactive physical simulation,” <em class="ltx_emph ltx_font_italic" id="bib.bib8.2.2">Soft Tissue Biomechanical Mdeling for Computer Assisted Surgery</em>, pp. 283–321, 2012.

</span>
</li>
<li class="ltx_bibitem" id="bib.bib9">
<span class="ltx_tag ltx_tag_bibitem">[9]</span>
<span class="ltx_bibblock">
J. A. Barragan, J. Zhang, H. Zhou, A. Munawar, and P. Kazanzides, “Realistic data generation for 6d pose estimation of surgical instruments,” in <em class="ltx_emph ltx_font_italic" id="bib.bib9.1.1">2024 IEEE International Conference on Robotics and Automation (ICRA)</em>, 2024, pp. 13 347–13 353.

</span>
</li>
<li class="ltx_bibitem" id="bib.bib10">
<span class="ltx_tag ltx_tag_bibitem">[10]</span>
<span class="ltx_bibblock">
I. A. Astuti, I. H. Purwanto, T. Hidayat, D. A. Satria, R. Purnama <em class="ltx_emph ltx_font_italic" id="bib.bib10.1.1">et al.</em>, “Comparison of time, size and quality of 3d object rendering using render engine eevee and cycles in blender,” in <em class="ltx_emph ltx_font_italic" id="bib.bib10.2.2">2022 5th International Conference of Computer and Informatics Engineering (IC2IE)</em>.   IEEE, 2022, pp. 54–59.

</span>
</li>
<li class="ltx_bibitem" id="bib.bib11">
<span class="ltx_tag ltx_tag_bibitem">[11]</span>
<span class="ltx_bibblock">
M. Quigley, K. Conley, B. Gerkey, J. Faust, T. Foote, J. Leibs, R. Wheeler, A. Y. Ng <em class="ltx_emph ltx_font_italic" id="bib.bib11.1.1">et al.</em>, “ROS: an open-source robot operating system,” in <em class="ltx_emph ltx_font_italic" id="bib.bib11.2.2">ICRA Workshop on Open Source Software</em>, vol. 3, no. 3.2.   Kobe, Japan, 2009, p. 5.

</span>
</li>
<li class="ltx_bibitem" id="bib.bib12">
<span class="ltx_tag ltx_tag_bibitem">[12]</span>
<span class="ltx_bibblock">
E. C. Souza, “An analysis of real-time ray tracing techniques using the vulkan® explicit api,” Master’s thesis, California Polytechnic State University, 2021.

</span>
</li>
<li class="ltx_bibitem" id="bib.bib13">
<span class="ltx_tag ltx_tag_bibitem">[13]</span>
<span class="ltx_bibblock">
M. Saed, Y. H. Chou, L. Liu, T. Nowicki, and T. M. Aamodt, “Vulkan-Sim: A GPU architecture simulator for ray tracing,” in <em class="ltx_emph ltx_font_italic" id="bib.bib13.1.1">2022 55th IEEE/ACM International Symposium on Microarchitecture (MICRO)</em>.   IEEE, 2022, pp. 263–281.

</span>
</li>
<li class="ltx_bibitem" id="bib.bib14">
<span class="ltx_tag ltx_tag_bibitem">[14]</span>
<span class="ltx_bibblock">
A. Danliden and S. Cederrand, “Multi sub-pass &amp; multi render-target shading in vulkan: Performance based comparison in real-time,” 2020.

</span>
</li>
<li class="ltx_bibitem" id="bib.bib15">
<span class="ltx_tag ltx_tag_bibitem">[15]</span>
<span class="ltx_bibblock">
G. Sellers and J. Kessenich, <em class="ltx_emph ltx_font_italic" id="bib.bib15.1.1">Vulkan programming guide: The official guide to learning vulkan</em>.   Addison-Wesley Professional, 2016.

</span>
</li>
<li class="ltx_bibitem" id="bib.bib16">
<span class="ltx_tag ltx_tag_bibitem">[16]</span>
<span class="ltx_bibblock">
C. Ioannidis and A.-M. Boutsi, “Multithreaded rendering for cross-platform 3d visualization based on vulkan api,” <em class="ltx_emph ltx_font_italic" id="bib.bib16.1.1">The International Archives of the Photogrammetry, Remote Sensing and Spatial Information Sciences</em>, vol. 44, pp. 57–62, 2020.

</span>
</li>
<li class="ltx_bibitem" id="bib.bib17">
<span class="ltx_tag ltx_tag_bibitem">[17]</span>
<span class="ltx_bibblock">
M. Montoto González, “Hands-on study on vulkan and the hardware ray-tracing extensions,” 2021.

</span>
</li>
<li class="ltx_bibitem" id="bib.bib18">
<span class="ltx_tag ltx_tag_bibitem">[18]</span>
<span class="ltx_bibblock">
J. Unterguggenberger, B. Kerbl, and M. Wimmer, “Vulkan all the way: Transitioning to a modern low-level graphics api in academia,” <em class="ltx_emph ltx_font_italic" id="bib.bib18.1.1">Computers &amp; Graphics</em>, vol. 111, pp. 155–165, 2023.

</span>
</li>
<li class="ltx_bibitem" id="bib.bib19">
<span class="ltx_tag ltx_tag_bibitem">[19]</span>
<span class="ltx_bibblock">
A. V. Zverev and D. E. Ipatov, “Development of infrared scene model in a wide wavelength range,” in <em class="ltx_emph ltx_font_italic" id="bib.bib19.1.1">2021 IEEE 22nd International Conference of Young Professionals in Electron Devices and Materials (EDM)</em>.   IEEE, 2021, pp. 37–41.

</span>
</li>
<li class="ltx_bibitem" id="bib.bib20">
<span class="ltx_tag ltx_tag_bibitem">[20]</span>
<span class="ltx_bibblock">
K. Ozvoldik, T. Stockner, B. Rammner, and E. Krieger, “Assembly of biomolecular gigastructures and visualization with the vulkan graphics API,” <em class="ltx_emph ltx_font_italic" id="bib.bib20.1.1">Journal of Chemical Information and Modeling</em>, vol. 61, no. 10, pp. 5293–5303, 2021.

</span>
</li>
<li class="ltx_bibitem" id="bib.bib21">
<span class="ltx_tag ltx_tag_bibitem">[21]</span>
<span class="ltx_bibblock">
C. Rossant and N. P. Rougier, “High-performance interactive scientific visualization with datoviz via the vulkan low-level gpu api,” <em class="ltx_emph ltx_font_italic" id="bib.bib21.1.1">Computing in Science &amp; Engineering</em>, vol. 23, no. 4, pp. 85–90, 2021.

</span>
</li>
<li class="ltx_bibitem" id="bib.bib22">
<span class="ltx_tag ltx_tag_bibitem">[22]</span>
<span class="ltx_bibblock">
W. Kamnert, “Real-time soft body simulation using extended position-based dynamics and tetrahedral deformation,” 2023.

</span>
</li>
<li class="ltx_bibitem" id="bib.bib23">
<span class="ltx_tag ltx_tag_bibitem">[23]</span>
<span class="ltx_bibblock">
J. Xu, B. Li, B. Lu, Y.-H. Liu, Q. Dou, and P.-A. Heng, “SurRoL: An open-source reinforcement learning centered and dvrk compatible platform for surgical robot learning,” in <em class="ltx_emph ltx_font_italic" id="bib.bib23.1.1">2021 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS)</em>.   IEEE, 2021, pp. 1821–1828.

</span>
</li>
<li class="ltx_bibitem" id="bib.bib24">
<span class="ltx_tag ltx_tag_bibitem">[24]</span>
<span class="ltx_bibblock">
J. Maul, S. Said, N. Ruiter, and T. Hopp, “X-ray synthesis based on triangular mesh models using GPU-accelerated ray tracing for multi-modal breast image registration,” in <em class="ltx_emph ltx_font_italic" id="bib.bib24.1.1">Simulation and Synthesis in Medical Imaging: 6th International Workshop, SASHIMI 2021, Held in Conjunction with MICCAI 2021, Strasbourg, France, September 27, 2021, Proceedings 6</em>.   Springer, 2021, pp. 87–96.

</span>
</li>
<li class="ltx_bibitem" id="bib.bib25">
<span class="ltx_tag ltx_tag_bibitem">[25]</span>
<span class="ltx_bibblock">
R. Wright, B. Lipchak, and N. Haemel, <em class="ltx_emph ltx_font_italic" id="bib.bib25.1.1">OpenGL SuperBible: comprehensive tutorial and reference</em>.   Pearson Education, 2007.

</span>
</li>
<li class="ltx_bibitem" id="bib.bib26">
<span class="ltx_tag ltx_tag_bibitem">[26]</span>
<span class="ltx_bibblock">
M. Castorina and G. Sassone, <em class="ltx_emph ltx_font_italic" id="bib.bib26.1.1">Mastering Graphics Programming with Vulkan: Develop a modern rendering engine from first principles to state-of-the-art techniques</em>.   Packt Publishing Ltd, 2023.

</span>
</li>
<li class="ltx_bibitem" id="bib.bib27">
<span class="ltx_tag ltx_tag_bibitem">[27]</span>
<span class="ltx_bibblock">
K. Iyer and J. Kiel, “GPU debugging and profiling with NVIDIA Parallel Nsight,” <em class="ltx_emph ltx_font_italic" id="bib.bib27.1.1">Game Development Tools</em>, pp. 303–324, 2016.

</span>
</li>
<li class="ltx_bibitem" id="bib.bib28">
<span class="ltx_tag ltx_tag_bibitem">[28]</span>
<span class="ltx_bibblock">
F. Conti, “The chai libraries,” <em class="ltx_emph ltx_font_italic" id="bib.bib28.1.1">Eurohaptics’ 03</em>, 2003.

</span>
</li>
<li class="ltx_bibitem" id="bib.bib29">
<span class="ltx_tag ltx_tag_bibitem">[29]</span>
<span class="ltx_bibblock">
E. Coumans, “Bullet physics simulation,” in <em class="ltx_emph ltx_font_italic" id="bib.bib29.1.1">ACM SIGGRAPH 2015 Courses</em>, 2015, p. 1.

</span>
</li>
<li class="ltx_bibitem" id="bib.bib30">
<span class="ltx_tag ltx_tag_bibitem">[30]</span>
<span class="ltx_bibblock">
A. Munawar, “Ambf-blender addon,” Sep. 2024, [Online; accessed 14. Sep. 2024]. [Online]. Available: <a class="ltx_ref ltx_url ltx_font_typewriter" href="https://github.com/WPI-AIM/ambf_addon" title="">https://github.com/WPI-AIM/ambf_addon</a>
</span>
</li>
<li class="ltx_bibitem" id="bib.bib31">
<span class="ltx_tag ltx_tag_bibitem">[31]</span>
<span class="ltx_bibblock">
J. Knoblauch, A. Sethuraman, and J. Hey, “IMGui—a desktop GUI application for isolation with migration analyses,” <em class="ltx_emph ltx_font_italic" id="bib.bib31.1.1">Molecular Biology and Evolution</em>, vol. 34, no. 2, pp. 500–504, 2017.

</span>
</li>
<li class="ltx_bibitem" id="bib.bib32">
<span class="ltx_tag ltx_tag_bibitem">[32]</span>
<span class="ltx_bibblock">
T. Whitted, “An improved illumination model for shaded display,” in <em class="ltx_emph ltx_font_italic" id="bib.bib32.1.1">ACM SIGGRAPH 2005 Courses</em>, ser. SIGGRAPH ’05.   New York, NY, USA: Association for Computing Machinery, 2005, p. 4–es.

</span>
</li>
<li class="ltx_bibitem" id="bib.bib33">
<span class="ltx_tag ltx_tag_bibitem">[33]</span>
<span class="ltx_bibblock">
R. L. Cook and K. E. Torrance, “A reflectance model for computer graphics,” <em class="ltx_emph ltx_font_italic" id="bib.bib33.1.1">ACM Transactions on Graphics (ToG)</em>, vol. 1, no. 1, pp. 7–24, 1982.

</span>
</li>
<li class="ltx_bibitem" id="bib.bib34">
<span class="ltx_tag ltx_tag_bibitem">[34]</span>
<span class="ltx_bibblock">
B. Walter, S. R. Marschner, H. Li, and K. E. Torrance, “Microfacet models for refraction through rough surfaces.” <em class="ltx_emph ltx_font_italic" id="bib.bib34.1.1">Rendering Techniques</em>, vol. 2007, p. 18th, 2007.

</span>
</li>
<li class="ltx_bibitem" id="bib.bib35">
<span class="ltx_tag ltx_tag_bibitem">[35]</span>
<span class="ltx_bibblock">
C. Schlick, “An inexpensive BRDF model for physically-based rendering,” in <em class="ltx_emph ltx_font_italic" id="bib.bib35.1.1">Computer Graphics Forum</em>, vol. 13, no. 3.   Wiley Online Library, 1994, pp. 233–246.

</span>
</li>
<li class="ltx_bibitem" id="bib.bib36">
<span class="ltx_tag ltx_tag_bibitem">[36]</span>
<span class="ltx_bibblock">
B. Karis and E. Games, “Real shading in unreal engine 4,” <em class="ltx_emph ltx_font_italic" id="bib.bib36.1.1">Proc. Physically Based Shading Theory Practice</em>, vol. 4, no. 3, p. 1, 2013.

</span>
</li>
<li class="ltx_bibitem" id="bib.bib37">
<span class="ltx_tag ltx_tag_bibitem">[37]</span>
<span class="ltx_bibblock">
J. F. Blinn, “Models of light reflection for computer synthesized pictures,” in <em class="ltx_emph ltx_font_italic" id="bib.bib37.1.1">Proceedings of the 4th Annual Conference on Computer Graphics and Interactive Techniques</em>, 1977, pp. 192–198.

</span>
</li>
<li class="ltx_bibitem" id="bib.bib38">
<span class="ltx_tag ltx_tag_bibitem">[38]</span>
<span class="ltx_bibblock">
J. Jimenez, D. Gutierrez, J. Yang, A. Reshetov, P. Demoreuille, T. Berghoff, C. Perthuis, H. Yu, M. McGuire, T. Lottes <em class="ltx_emph ltx_font_italic" id="bib.bib38.1.1">et al.</em>, “Filtering approaches for real-time anti-aliasing.” <em class="ltx_emph ltx_font_italic" id="bib.bib38.2.2">SIGGRAPH Courses</em>, vol. 2, no. 3, p. 4, 2011.

</span>
</li>
</ul>
</section>
</article>
</div>
<footer class="ltx_page_footer">
<div class="ltx_page_logo">Generated  on Mon Oct  7 14:01:25 2024 by <a class="ltx_LaTeXML_logo" href="http://dlmf.nist.gov/LaTeXML/"><span style="letter-spacing:-0.2em; margin-right:0.1em;">L<span class="ltx_font_smallcaps" style="position:relative; bottom:2.2pt;">a</span>T<span class="ltx_font_smallcaps" style="font-size:120%;position:relative; bottom:-0.2ex;">e</span></span><span style="font-size:90%; position:relative; bottom:-0.2ex;">XML</span><img alt="Mascot Sammy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAAOCAYAAAD5YeaVAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9wKExQZLWTEaOUAAAAddEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIFRoZSBHSU1Q72QlbgAAAdpJREFUKM9tkL+L2nAARz9fPZNCKFapUn8kyI0e4iRHSR1Kb8ng0lJw6FYHFwv2LwhOpcWxTjeUunYqOmqd6hEoRDhtDWdA8ApRYsSUCDHNt5ul13vz4w0vWCgUnnEc975arX6ORqN3VqtVZbfbTQC4uEHANM3jSqXymFI6yWazP2KxWAXAL9zCUa1Wy2tXVxheKA9YNoR8Pt+aTqe4FVVVvz05O6MBhqUIBGk8Hn8HAOVy+T+XLJfLS4ZhTiRJgqIoVBRFIoric47jPnmeB1mW/9rr9ZpSSn3Lsmir1fJZlqWlUonKsvwWwD8ymc/nXwVBeLjf7xEKhdBut9Hr9WgmkyGEkJwsy5eHG5vN5g0AKIoCAEgkEkin0wQAfN9/cXPdheu6P33fBwB4ngcAcByHJpPJl+fn54mD3Gg0NrquXxeLRQAAwzAYj8cwTZPwPH9/sVg8PXweDAauqqr2cDjEer1GJBLBZDJBs9mE4zjwfZ85lAGg2+06hmGgXq+j3+/DsixYlgVN03a9Xu8jgCNCyIegIAgx13Vfd7vdu+FweG8YRkjXdWy329+dTgeSJD3ieZ7RNO0VAXAPwDEAO5VKndi2fWrb9jWl9Esul6PZbDY9Go1OZ7PZ9z/lyuD3OozU2wAAAABJRU5ErkJggg=="/></a>
</div></footer>
</div>
</body>
</html>
