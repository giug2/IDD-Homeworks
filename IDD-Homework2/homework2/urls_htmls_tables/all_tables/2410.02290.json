{
    "id_table_1": {
        "caption": "Table 1:  Generation of neighbourhoods in  R 2 superscript R 2 \\mathbb{R}^{2} blackboard_R start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT  and  R 3 superscript R 3 \\mathbb{R}^{3} blackboard_R start_POSTSUPERSCRIPT 3 end_POSTSUPERSCRIPT  using different standard probability distributions around a line. The scaling factor is considered to be 1.",
        "table": "S5.T1.22",
        "footnotes": [],
        "references": [
            "The neighbourhoods for the standard probability distributions are shown in Table  1 . As can be seen from Table  1 , the neighbourhoods in  R 3 superscript R 3 \\mathbb{R}^{3} blackboard_R start_POSTSUPERSCRIPT 3 end_POSTSUPERSCRIPT  are simple extensions of what we have as neighbourhoods in  R 2 superscript R 2 \\mathbb{R}^{2} blackboard_R start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT . To illustrate this in depth, it is beneficial to transform the domain of  f l subscript f l f_{l} italic_f start_POSTSUBSCRIPT italic_l end_POSTSUBSCRIPT  from  { P : P  l } conditional-set P P l \\{P:P\\in l\\} { italic_P : italic_P  italic_l }  to a subset of  R R \\mathbb{R} blackboard_R . This makes it easier to define  f l subscript f l f_{l} italic_f start_POSTSUBSCRIPT italic_l end_POSTSUBSCRIPT , thereby making the implementation simpler too. For a line segment  l = ( x , y ) l x y l=(x,y) italic_l = ( italic_x , italic_y ) , where  x , y  R n x y superscript R n x,y\\in\\mathbb{R}^{n} italic_x , italic_y  blackboard_R start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT , the set of points belonging to  l = ( x , y ) l x y l=(x,y) italic_l = ( italic_x , italic_y )  can be written as  { x + ( y  x )  t : t  [ 0 , 1 ] } conditional-set x y x t t 0 1 \\{x+(y-x)t:t\\in[0,1]\\} { italic_x + ( italic_y - italic_x ) italic_t : italic_t  [ 0 , 1 ] } . Similarly, the set of points belonging to a line can be denoted as  { x + ( y  x )  t : t  R } conditional-set x y x t t R \\{x+(y-x)t:t\\in\\mathbb{R}\\} { italic_x + ( italic_y - italic_x ) italic_t : italic_t  blackboard_R } . As there is a bijection, more precisely a linear function, say  g l subscript g l g_{l} italic_g start_POSTSUBSCRIPT italic_l end_POSTSUBSCRIPT   such that  g l  ( 0 ) = x , g l  ( 1 ) = y formulae-sequence subscript g l 0 x subscript g l 1 y g_{l}(0)=x,g_{l}(1)=y italic_g start_POSTSUBSCRIPT italic_l end_POSTSUBSCRIPT ( 0 ) = italic_x , italic_g start_POSTSUBSCRIPT italic_l end_POSTSUBSCRIPT ( 1 ) = italic_y  between the value  t t t italic_t  and the points on the line or line segment,  f l subscript f l f_{l} italic_f start_POSTSUBSCRIPT italic_l end_POSTSUBSCRIPT  may be re-written as a function of  t  [ 0 , 1 ] t 0 1 t\\in[0,1] italic_t  [ 0 , 1 ]  (for line segments) or  R R \\mathbb{R} blackboard_R  (for lines) respectively. In Table  1 , we define  f l subscript f l f_{l} italic_f start_POSTSUBSCRIPT italic_l end_POSTSUBSCRIPT  as a function of  t t t italic_t  for the standard probability distributions, and show the region  N l subscript N l N_{l} italic_N start_POSTSUBSCRIPT italic_l end_POSTSUBSCRIPT  in  R 2 superscript R 2 \\mathbb{R}^{2} blackboard_R start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT  and  R 3 superscript R 3 \\mathbb{R}^{3} blackboard_R start_POSTSUPERSCRIPT 3 end_POSTSUPERSCRIPT . For each of the cases in Table  1 ,  f l subscript f l f_{l} italic_f start_POSTSUBSCRIPT italic_l end_POSTSUBSCRIPT  is defined over  R R \\mathbb{R} blackboard_R .",
            "We formally present the approach in Algorithm  1 . The input to the algorithm is a set of lines / line segments in  U U \\mathcal{U} caligraphic_U  and a set of appropriate parameters in accordance with the desired version (refer to Table  2 ). The algorithm closely mirrors the DBSCAN algorithm [6] for points with the neighbourhood being defined with the help of a probability density function  f l subscript f l f_{l} italic_f start_POSTSUBSCRIPT italic_l end_POSTSUBSCRIPT  instead of a metric. All lines / line segments are declared unvisited. If at least one line / line segment is unvisited, choose any one of them, say  l U subscript l U l_{U} italic_l start_POSTSUBSCRIPT italic_U end_POSTSUBSCRIPT  and run a loop over all lines / line segments to check their inclusions in the neighbourhood. If  l U  R  l i subscript l U R subscript l i l_{U}\\mathcal{R}l_{i} italic_l start_POSTSUBSCRIPT italic_U end_POSTSUBSCRIPT caligraphic_R italic_l start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT  holds (refer to Table  2 ), then add  l i subscript l i l_{i} italic_l start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT  to the list  N U subscript N U N_{U} italic_N start_POSTSUBSCRIPT italic_U end_POSTSUBSCRIPT . To verify whether  l U  R  l i subscript l U R subscript l i l_{U}\\mathcal{R}l_{i} italic_l start_POSTSUBSCRIPT italic_U end_POSTSUBSCRIPT caligraphic_R italic_l start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT  holds, we choose one of the following versions based on the input parameters.",
            "The minimum distance between  l U = ( x U , y U ) subscript l U subscript x U subscript y U l_{U}=(x_{U},y_{U}) italic_l start_POSTSUBSCRIPT italic_U end_POSTSUBSCRIPT = ( italic_x start_POSTSUBSCRIPT italic_U end_POSTSUBSCRIPT , italic_y start_POSTSUBSCRIPT italic_U end_POSTSUBSCRIPT )  and  l i = ( x i , y i ) subscript l i subscript x i subscript y i l_{i}=(x_{i},y_{i}) italic_l start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT = ( italic_x start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT , italic_y start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT )  is strictly less then than   U subscript  U \\alpha_{U} italic_ start_POSTSUBSCRIPT italic_U end_POSTSUBSCRIPT  i.e  m  i  n x  l i , y  l U   x  y  2 2 <  U 2 formulae-sequence x subscript l i y subscript l U m i n superscript subscript norm x y 2 2 superscript subscript  U 2 \\underset{x\\in l_{i},y\\in l_{U}}{min}||x-y||_{2}^{2}<\\alpha_{U}^{2} start_UNDERACCENT italic_x  italic_l start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT , italic_y  italic_l start_POSTSUBSCRIPT italic_U end_POSTSUBSCRIPT end_UNDERACCENT start_ARG italic_m italic_i italic_n end_ARG | | italic_x - italic_y | | start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT < italic_ start_POSTSUBSCRIPT italic_U end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT  that is equivalent to  m  i  n t 1  D 1 , t 2  D 2   g l i  ( t 1 )  g l U  ( t 2 )  2 2 <  U 2 formulae-sequence subscript t 1 subscript D 1 subscript t 2 subscript D 2 m i n superscript subscript norm subscript g subscript l i subscript t 1 subscript g subscript l U subscript t 2 2 2 superscript subscript  U 2 \\underset{t_{1}\\in D_{1},t_{2}\\in D_{2}}{min}||g_{l_{i}}(t_{1})-g_{l_{U}}(t_{2% })||_{2}^{2}<\\alpha_{U}^{2} start_UNDERACCENT italic_t start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT  italic_D start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , italic_t start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT  italic_D start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_UNDERACCENT start_ARG italic_m italic_i italic_n end_ARG | | italic_g start_POSTSUBSCRIPT italic_l start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT end_POSTSUBSCRIPT ( italic_t start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ) - italic_g start_POSTSUBSCRIPT italic_l start_POSTSUBSCRIPT italic_U end_POSTSUBSCRIPT end_POSTSUBSCRIPT ( italic_t start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ) | | start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT < italic_ start_POSTSUBSCRIPT italic_U end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT , where  D 1 , D 2 = R subscript D 1 subscript D 2 R D_{1},D_{2}=\\mathbb{R} italic_D start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , italic_D start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT = blackboard_R  or  [ 0 , 1 ] 0 1 [0,1] [ 0 , 1 ] .  5.1 . Now  g l i , g l U subscript g subscript l i subscript g subscript l U g_{l_{i}},g_{l_{U}} italic_g start_POSTSUBSCRIPT italic_l start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT end_POSTSUBSCRIPT , italic_g start_POSTSUBSCRIPT italic_l start_POSTSUBSCRIPT italic_U end_POSTSUBSCRIPT end_POSTSUBSCRIPT  are linear functions hence the problem reduces to finding out the minimum value of a quadratic equation in two variables.",
            "The results obtained for the different line datasets are reported in Fig.  1 . Notably, we apply only the first version of neighborhood computation of Algorithm  1  in all these cases due to the absence of domain knowledge. Moreover, as all the line segments have equal weightage, we take the scaling factor (  l subscript  l \\alpha_{l} italic_ start_POSTSUBSCRIPT italic_l end_POSTSUBSCRIPT ) to be independent of the line segments. As can be seen from Figs.  1 (a) and (b), the proposed approach is capable of exploring groups from both the convex and non-convex (with a little abuse of notation) orientation of lines. However, the cardinality parameter plays a crucial role in capturing the essence of true clusters in non-convex cases. For example, lowering the cardinality threshold of neighbourhood ( c c c italic_c ), helps to get larger clusters by ignoring small variations in density while increasing it, makes the algorithm sensitive to variation in density (compare Fig.  1 (b) with Fig.  1 (c)). The identification of outliers is also dependent on the cardinality parameter (more outliers in Fig.  1 (c) than Fig.  1 (b)). Note that the scaling factors (  l subscript  l \\alpha_{l} italic_ start_POSTSUBSCRIPT italic_l end_POSTSUBSCRIPT ) were the same for the synthetic datasets because they were generated on a similar scale. However, for the other line datasets prepared from real-word data, we need to set the scaling factor (  l subscript  l \\alpha_{l} italic_ start_POSTSUBSCRIPT italic_l end_POSTSUBSCRIPT ) separately. On carefully examining the real-word datasets (Figs.  1 (d) and (e)), we can see that the algorithm can recognise dense and sparse regions along with outliers."
        ]
    },
    "id_table_2": {
        "caption": "Table 2:  Different versions of the algorithm for the computation of  l 1  R  l 2 subscript l 1 R subscript l 2 l_{1}\\mathcal{R}l_{2} italic_l start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT caligraphic_R italic_l start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT  and the respective output based on the input parameters.",
        "table": "S5.T2.17",
        "footnotes": [],
        "references": [
            "The proposed density based clustering algorithm of lines (termed as DeLi) has three versions differing only in the definition of the neighbourhood relation  R R \\mathcal{R} caligraphic_R . Hence, the definitions of  R R \\mathcal{R} caligraphic_R  along with their associated parameters is concisely presented in Table  2 .",
            "We formally present the approach in Algorithm  1 . The input to the algorithm is a set of lines / line segments in  U U \\mathcal{U} caligraphic_U  and a set of appropriate parameters in accordance with the desired version (refer to Table  2 ). The algorithm closely mirrors the DBSCAN algorithm [6] for points with the neighbourhood being defined with the help of a probability density function  f l subscript f l f_{l} italic_f start_POSTSUBSCRIPT italic_l end_POSTSUBSCRIPT  instead of a metric. All lines / line segments are declared unvisited. If at least one line / line segment is unvisited, choose any one of them, say  l U subscript l U l_{U} italic_l start_POSTSUBSCRIPT italic_U end_POSTSUBSCRIPT  and run a loop over all lines / line segments to check their inclusions in the neighbourhood. If  l U  R  l i subscript l U R subscript l i l_{U}\\mathcal{R}l_{i} italic_l start_POSTSUBSCRIPT italic_U end_POSTSUBSCRIPT caligraphic_R italic_l start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT  holds (refer to Table  2 ), then add  l i subscript l i l_{i} italic_l start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT  to the list  N U subscript N U N_{U} italic_N start_POSTSUBSCRIPT italic_U end_POSTSUBSCRIPT . To verify whether  l U  R  l i subscript l U R subscript l i l_{U}\\mathcal{R}l_{i} italic_l start_POSTSUBSCRIPT italic_U end_POSTSUBSCRIPT caligraphic_R italic_l start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT  holds, we choose one of the following versions based on the input parameters."
        ]
    },
    "id_table_3": {
        "caption": "Table 3:  Statistical and background details of the various dataseets used. Some line segments from some real-world datasets were cropped out to allow forming a realistic cluster.",
        "table": "S6.T3.1",
        "footnotes": [],
        "references": [
            "The datasets considered for experimental analysis were of two types  Line Datasets and Point Datasets with Missing Entries. The Line Datasets are further categorised as Synthetic Datasets and Real-world Datasets. The details about the datasets are provided below (see Table  3  for more details)."
        ]
    },
    "id_table_4": {
        "caption": "Table 4:  Comparison of clustering results obtained by applying the proposed algorithm on the original dataset and the dataset prepared by introducing missing entries.",
        "table": "S6.F1.9",
        "footnotes": [],
        "references": [
            "Clustering results are obtained for the Sporulation dataset (that we prepared by adding missing entries) considering   l = 0.6 subscript  l 0.6 \\alpha_{l}=0.6 italic_ start_POSTSUBSCRIPT italic_l end_POSTSUBSCRIPT = 0.6  and  c = 7 c 7 c=7 italic_c = 7 . The domain knowledge was incorporated to generate the neighbourhood by setting up an appropriate probability distribution. To be precise, we set the function  f l subscript f l f_{l} italic_f start_POSTSUBSCRIPT italic_l end_POSTSUBSCRIPT  as Unif[-4, 4] based the range of the values in respective columns in the dataset. The output yielded 5 clusters of yeast genes from the dataset along with a set of 120 outlier genes. This was similar to the results obtained with the original dataset in which no missing values were present. A detailed comparison of results is reported in the Table  4 . The same algorithm (with the same parameters) applied on the original dataset yielded 4 clusters of yeast genes from the dataset along with a set of 128 outlier genes. There was a significant overlap between the outliers identified from the original dataset and the dataset prepared by introducing missing entries. This demonstrates the effectiveness of the proposed approach when domain knowledge is brought in the model."
        ]
    },
    "id_table_5": {
        "caption": "",
        "table": "S6.T4.3",
        "footnotes": [],
        "references": [
            "The minimum distance between  l U = ( x U , y U ) subscript l U subscript x U subscript y U l_{U}=(x_{U},y_{U}) italic_l start_POSTSUBSCRIPT italic_U end_POSTSUBSCRIPT = ( italic_x start_POSTSUBSCRIPT italic_U end_POSTSUBSCRIPT , italic_y start_POSTSUBSCRIPT italic_U end_POSTSUBSCRIPT )  and  l i = ( x i , y i ) subscript l i subscript x i subscript y i l_{i}=(x_{i},y_{i}) italic_l start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT = ( italic_x start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT , italic_y start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT )  is strictly less then than   U subscript  U \\alpha_{U} italic_ start_POSTSUBSCRIPT italic_U end_POSTSUBSCRIPT  i.e  m  i  n x  l i , y  l U   x  y  2 2 <  U 2 formulae-sequence x subscript l i y subscript l U m i n superscript subscript norm x y 2 2 superscript subscript  U 2 \\underset{x\\in l_{i},y\\in l_{U}}{min}||x-y||_{2}^{2}<\\alpha_{U}^{2} start_UNDERACCENT italic_x  italic_l start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT , italic_y  italic_l start_POSTSUBSCRIPT italic_U end_POSTSUBSCRIPT end_UNDERACCENT start_ARG italic_m italic_i italic_n end_ARG | | italic_x - italic_y | | start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT < italic_ start_POSTSUBSCRIPT italic_U end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT  that is equivalent to  m  i  n t 1  D 1 , t 2  D 2   g l i  ( t 1 )  g l U  ( t 2 )  2 2 <  U 2 formulae-sequence subscript t 1 subscript D 1 subscript t 2 subscript D 2 m i n superscript subscript norm subscript g subscript l i subscript t 1 subscript g subscript l U subscript t 2 2 2 superscript subscript  U 2 \\underset{t_{1}\\in D_{1},t_{2}\\in D_{2}}{min}||g_{l_{i}}(t_{1})-g_{l_{U}}(t_{2% })||_{2}^{2}<\\alpha_{U}^{2} start_UNDERACCENT italic_t start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT  italic_D start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , italic_t start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT  italic_D start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_UNDERACCENT start_ARG italic_m italic_i italic_n end_ARG | | italic_g start_POSTSUBSCRIPT italic_l start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT end_POSTSUBSCRIPT ( italic_t start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ) - italic_g start_POSTSUBSCRIPT italic_l start_POSTSUBSCRIPT italic_U end_POSTSUBSCRIPT end_POSTSUBSCRIPT ( italic_t start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ) | | start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT < italic_ start_POSTSUBSCRIPT italic_U end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT , where  D 1 , D 2 = R subscript D 1 subscript D 2 R D_{1},D_{2}=\\mathbb{R} italic_D start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , italic_D start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT = blackboard_R  or  [ 0 , 1 ] 0 1 [0,1] [ 0 , 1 ] .  5.1 . Now  g l i , g l U subscript g subscript l i subscript g subscript l U g_{l_{i}},g_{l_{U}} italic_g start_POSTSUBSCRIPT italic_l start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT end_POSTSUBSCRIPT , italic_g start_POSTSUBSCRIPT italic_l start_POSTSUBSCRIPT italic_U end_POSTSUBSCRIPT end_POSTSUBSCRIPT  are linear functions hence the problem reduces to finding out the minimum value of a quadratic equation in two variables."
        ]
    }
}