<!DOCTYPE html><html lang="en">
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title>[1802.07975] Options for encoding names for data linking at the Australian Bureau of Statistics</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Options for encoding names for data linking at the Australian Bureau of Statistics">
<meta name="twitter:image:src" content="https://ar5iv.labs.arxiv.org/assets/ar5iv_card.png">
<meta name="twitter:image:alt" content="ar5iv logo">
<meta property="og:title" content="Options for encoding names for data linking at the Australian Bureau of Statistics">
<meta property="og:site_name" content="ar5iv">
<meta property="og:image" content="https://ar5iv.labs.arxiv.org/assets/ar5iv_card.png">
<meta property="og:type" content="article">
<meta property="og:url" content="https://ar5iv.labs.arxiv.org/html/1802.07975">

<!--Generated on Sat Mar  9 04:05:14 2024 by LaTeXML (version 0.8.8) http://dlmf.nist.gov/LaTeXML/.-->
<!--Document created on  %The ABS MAC paper is: Options for Encoding Name 
     %Information for use in Record Linkage .-->
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

<script>
  function detectColorScheme(){
    var theme="light";
    var current_theme = localStorage.getItem("ar5iv_theme");
    if(current_theme){
      if(current_theme == "dark"){
        theme = "dark";
      } }
    else if(!window.matchMedia) { return false; }
    else if(window.matchMedia("(prefers-color-scheme: dark)").matches) {
      theme = "dark"; }
    if (theme=="dark") {
      document.documentElement.setAttribute("data-theme", "dark");
    } else {
      document.documentElement.setAttribute("data-theme", "light"); } }

  detectColorScheme();

  function toggleColorScheme(){
    var current_theme = localStorage.getItem("ar5iv_theme");
    if (current_theme) {
      if (current_theme == "light") {
        localStorage.setItem("ar5iv_theme", "dark"); }
      else {
        localStorage.setItem("ar5iv_theme", "light"); } }
    else {
        localStorage.setItem("ar5iv_theme", "dark"); }
    detectColorScheme(); }
</script>
<link media="all" rel="stylesheet" href="/assets/ar5iv-fonts.0.8.0.min.css"><link media="all" rel="stylesheet" href="/assets/ar5iv.0.8.0.min.css"><link media="all" rel="stylesheet" href="/assets/ar5iv-site.0.2.2.css">
</head>
<body>
<div class="ltx_page_main">
<div class="ltx_page_content">
<article class="ltx_document ltx_authors_1line">
<h1 class="ltx_title ltx_title_document">Options for encoding names for data linking at the Australian Bureau of Statistics</h1>
<div class="ltx_authors">
<span class="ltx_creator ltx_role_author">
<span class="ltx_personname">Chris Culnane, Benjamin I. P. Rubinstein, Vanessa Teague 
<br class="ltx_break">University of Melbourne 
<br class="ltx_break"><span id="id1.1.id1" class="ltx_text ltx_font_typewriter">{vjteague, benjamin.rubinstein, christopher.culnane}@unimelb.edu.au </span>
</span></span>
</div>

<section id="Sx1" class="ltx_section">
<h2 class="ltx_title ltx_title_section">Background and scope</h2>

<div id="Sx1.p1" class="ltx_para">
<p id="Sx1.p1.1" class="ltx_p">Publicly, ABS has said it would use a cryptographic hash function to convert names collected in the 2016 Census of Population and Housing into an unrecognisable value in a way that is not reversible. In 2016, the ABS engaged the University of Melbourne to provide expert advice on cryptographic hash functions to meet this objective.<span id="footnote1" class="ltx_note ltx_role_footnote"><sup class="ltx_note_mark">1</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">1</sup><span class="ltx_tag ltx_tag_note">1</span>University of Melbourne Research Contract 85449779</span></span></span>
After receiving a draft of this report, ABS conducted a further assessment of Options 2 and 3, which will be published on their website.</p>
</div>
</section>
<section id="Sx2" class="ltx_section">
<h2 class="ltx_title ltx_title_section">Summary</h2>

<div id="Sx2.p1" class="ltx_para">
<p id="Sx2.p1.1" class="ltx_p">For complex unit-record level data, including Census data, auxiliary data can be often be used to link individual records, even without names. This is the basis of ABS’s existing bronze linking.
This means that records can probably be re-identified without the encoded name anyway. Protection against re-identification depends on good processes within ABS.</p>
</div>
<div id="Sx2.p2" class="ltx_para">
<p id="Sx2.p2.1" class="ltx_p">The undertaking on the encoding of names should therefore be considered in the full context of auxiliary data and ABS processes. There are several reasonable interpretations:</p>
<ol id="Sx2.I1" class="ltx_enumerate">
<li id="Sx2.I1.i1" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">1.</span> 
<div id="Sx2.I1.i1.p1" class="ltx_para">
<p id="Sx2.I1.i1.p1.1" class="ltx_p">That the encoding cannot be reversed except with a secret key held by ABS. This is the property achieved by encryption (Option 1), if properly implemented;</p>
</div>
</li>
<li id="Sx2.I1.i2" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">2.</span> 
<div id="Sx2.I1.i2.p1" class="ltx_para">
<p id="Sx2.I1.i2.p1.1" class="ltx_p">That the encoding, taken alone without auxiliary data, cannot be reversed to a single value. This is the property achieved by lossy encoding (Option 2), if properly implemented;</p>
</div>
</li>
<li id="Sx2.I1.i3" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">3.</span> 
<div id="Sx2.I1.i3.p1" class="ltx_para">
<p id="Sx2.I1.i3.p1.1" class="ltx_p">That the encoding doesn’t make re-identification easier, or increase the number of records that can be re-identified, except with a secret key held by ABS. This is the property achieved by HMAC-based linkage key derivation using subsets of attributes (Option 3), if properly implemented.</p>
</div>
</li>
</ol>
</div>
<div id="Sx2.p3" class="ltx_para">
<p id="Sx2.p3.1" class="ltx_p">Each option has advantages and disadvantages. In this report, we explain and compare the privacy and accuracy guarantees of five different possible approaches. Options 4 and 5 investigate more sophisticated options for future data linking, though are probably not feasible for this year. We also explain how some commonly-advocated techniques can be reversed, and hence should not be used.</p>
</div>
<div id="Sx2.p4" class="ltx_para">
<p id="Sx2.p4.1" class="ltx_p">We examine the mathematical properties of each technique in order to explain what the assumptions on procedural protections are, for example whether there are keys that must be kept secret and whether the data remains re-identifiable. The security guarantees therefore depend on ABS processes for protecting whatever data remains sensitive, such as re-identifiable linked data. Our aim is to explain clearly what must be protected, for each proposed encoding method. We understand that ABS will be implementing additional IT security measures and processes such as encryption at rest and access control, although these are not within the scope of this report.</p>
</div>
<div class="ltx_pagination ltx_role_newpage"></div>
<nav class="ltx_TOC ltx_list_toc ltx_toc_toc"><h6 class="ltx_title ltx_title_contents">Contents</h6>
<ol class="ltx_toclist">
<li class="ltx_tocentry ltx_tocentry_section">
<a href="#S1" title="In Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">1 </span>Introduction</span></a>
<ol class="ltx_toclist ltx_toclist_section">
<li class="ltx_tocentry ltx_tocentry_subsection"><a href="#S1.SS1" title="In 1 Introduction ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">1.1 </span>Overview of the technical challenges</span></a></li>
<li class="ltx_tocentry ltx_tocentry_subsection"><a href="#S1.SS2" title="In 1 Introduction ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">1.2 </span>The options</span></a></li>
<li class="ltx_tocentry ltx_tocentry_subsection">
<a href="#S1.SS3" title="In 1 Introduction ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">1.3 </span>Why names that can be individually linked from plaintext can also be reversed</span></a>
<ol class="ltx_toclist ltx_toclist_subsection">
<li class="ltx_tocentry ltx_tocentry_subsubsection"><a href="#S1.SS3.SSS1" title="In 1.3 Why names that can be individually linked from plaintext can also be reversed ‣ 1 Introduction ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">1.3.1 </span>Linking by guessing all possible names</span></a></li>
</ol>
</li>
</ol>
</li>
<li class="ltx_tocentry ltx_tocentry_section">
<a href="#S2" title="In Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">2 </span>Background on Cryptography and possible attacks</span></a>
<ol class="ltx_toclist ltx_toclist_section">
<li class="ltx_tocentry ltx_tocentry_subsection">
<a href="#S2.SS1" title="In 2 Background on Cryptography and possible attacks ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">2.1 </span>How cryptographic hashes of names can be reversed</span></a>
<ol class="ltx_toclist ltx_toclist_subsection">
<li class="ltx_tocentry ltx_tocentry_subsubsection"><a href="#S2.SS1.SSS1" title="In 2.1 How cryptographic hashes of names can be reversed ‣ 2 Background on Cryptography and possible attacks ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">2.1.1 </span>Dictionary attacks</span></a></li>
<li class="ltx_tocentry ltx_tocentry_subsubsection"><a href="#S2.SS1.SSS2" title="In 2.1 How cryptographic hashes of names can be reversed ‣ 2 Background on Cryptography and possible attacks ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">2.1.2 </span>Why plain HMACs do not solve the problem</span></a></li>
<li class="ltx_tocentry ltx_tocentry_subsubsection"><a href="#S2.SS1.SSS3" title="In 2.1 How cryptographic hashes of names can be reversed ‣ 2 Background on Cryptography and possible attacks ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">2.1.3 </span>Determinism and frequency attacks</span></a></li>
</ol>
</li>
</ol>
</li>
<li class="ltx_tocentry ltx_tocentry_section">
<a href="#S3" title="In Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">3 </span>ABS requirements</span></a>
<ol class="ltx_toclist ltx_toclist_section">
<li class="ltx_tocentry ltx_tocentry_subsection"><a href="#S3.SS1" title="In 3 ABS requirements ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">3.1 </span>Functional requirements</span></a></li>
<li class="ltx_tocentry ltx_tocentry_subsection"><a href="#S3.SS2" title="In 3 ABS requirements ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">3.2 </span>Security requirements</span></a></li>
</ol>
</li>
<li class="ltx_tocentry ltx_tocentry_section"><a href="#S4" title="In Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">4 </span>Option 1: Encrypting names using public-key encryption</span></a></li>
<li class="ltx_tocentry ltx_tocentry_section">
<a href="#S5" title="In Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">5 </span>Option 2: Lossy encoding for names</span></a>
<ol class="ltx_toclist ltx_toclist_section">
<li class="ltx_tocentry ltx_tocentry_subsection">
<a href="#S5.SS1" title="In 5 Option 2: Lossy encoding for names ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">5.1 </span>An analysis of name frequencies and the implications of incorporating other variables</span></a>
<ol class="ltx_toclist ltx_toclist_subsection">
<li class="ltx_tocentry ltx_tocentry_subsubsection"><a href="#S5.SS1.SSS1" title="In 5.1 An analysis of name frequencies and the implications of incorporating other variables ‣ 5 Option 2: Lossy encoding for names ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">5.1.1 </span>Input distribution equals output distribution</span></a></li>
</ol>
</li>
<li class="ltx_tocentry ltx_tocentry_subsection"><a href="#S5.SS2" title="In 5 Option 2: Lossy encoding for names ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">5.2 </span>Summary</span></a></li>
</ol>
</li>
<li class="ltx_tocentry ltx_tocentry_section">
<a href="#S6" title="In Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">6 </span>Option 3: HMAC-based anonymised linkage identifiers using subsets of attributes</span></a>
<ol class="ltx_toclist ltx_toclist_section">
<li class="ltx_tocentry ltx_tocentry_subsection"><a href="#S6.SS1" title="In 6 Option 3: HMAC-based anonymised linkage identifiers using subsets of attributes ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">6.1 </span>Smoothing the input distribution by including multiple attributes</span></a></li>
<li class="ltx_tocentry ltx_tocentry_subsection"><a href="#S6.SS2" title="In 6 Option 3: HMAC-based anonymised linkage identifiers using subsets of attributes ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">6.2 </span>The cryptographic construction</span></a></li>
<li class="ltx_tocentry ltx_tocentry_subsection"><a href="#S6.SS3" title="In 6 Option 3: HMAC-based anonymised linkage identifiers using subsets of attributes ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">6.3 </span>Defending against frequency attacks</span></a></li>
<li class="ltx_tocentry ltx_tocentry_subsection">
<a href="#S6.SS4" title="In 6 Option 3: HMAC-based anonymised linkage identifiers using subsets of attributes ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">6.4 </span>Deterministic linking - performance advantages</span></a>
<ol class="ltx_toclist ltx_toclist_subsection">
<li class="ltx_tocentry ltx_tocentry_subsubsection"><a href="#S6.SS4.SSS1" title="In 6.4 Deterministic linking - performance advantages ‣ 6 Option 3: HMAC-based anonymised linkage identifiers using subsets of attributes ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">6.4.1 </span>Whole population linking</span></a></li>
</ol>
</li>
</ol>
</li>
<li class="ltx_tocentry ltx_tocentry_section">
<a href="#S7" title="In Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">7 </span>Option 4: Individual IDs</span></a>
<ol class="ltx_toclist ltx_toclist_section">
<li class="ltx_tocentry ltx_tocentry_subsection"><a href="#S7.SS1" title="In 7 Option 4: Individual IDs ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">7.1 </span>Methods for linking records based on exact ID matches</span></a></li>
</ol>
</li>
<li class="ltx_tocentry ltx_tocentry_section"><a href="#S8" title="In Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">8 </span>Option 5: Homomorphic encryption</span></a></li>
<li class="ltx_tocentry ltx_tocentry_section">
<a href="#S9" title="In Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">9 </span>Empirical linking results based on a Synthetic Data Generator</span></a>
<ol class="ltx_toclist ltx_toclist_section">
<li class="ltx_tocentry ltx_tocentry_subsection"><a href="#S9.SS1" title="In 9 Empirical linking results based on a Synthetic Data Generator ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">9.1 </span>Datasets and frequency distributions</span></a></li>
<li class="ltx_tocentry ltx_tocentry_subsection"><a href="#S9.SS2" title="In 9 Empirical linking results based on a Synthetic Data Generator ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">9.2 </span>Distortions</span></a></li>
<li class="ltx_tocentry ltx_tocentry_subsection">
<a href="#S9.SS3" title="In 9 Empirical linking results based on a Synthetic Data Generator ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">9.3 </span>Analysis of HMAC-based anonymised Linking identifiers</span></a>
<ol class="ltx_toclist ltx_toclist_subsection">
<li class="ltx_tocentry ltx_tocentry_subsubsection"><a href="#S9.SS3.SSS1" title="In 9.3 Analysis of HMAC-based anonymised Linking identifiers ‣ 9 Empirical linking results based on a Synthetic Data Generator ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">9.3.1 </span>Determining the best match</span></a></li>
<li class="ltx_tocentry ltx_tocentry_subsubsection"><a href="#S9.SS3.SSS2" title="In 9.3 Analysis of HMAC-based anonymised Linking identifiers ‣ 9 Empirical linking results based on a Synthetic Data Generator ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">9.3.2 </span>Uniqueness</span></a></li>
<li class="ltx_tocentry ltx_tocentry_subsubsection"><a href="#S9.SS3.SSS3" title="In 9.3 Analysis of HMAC-based anonymised Linking identifiers ‣ 9 Empirical linking results based on a Synthetic Data Generator ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">9.3.3 </span>Matching results</span></a></li>
</ol>
</li>
<li class="ltx_tocentry ltx_tocentry_subsection"><a href="#S9.SS4" title="In 9 Empirical linking results based on a Synthetic Data Generator ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">9.4 </span>Direct Bi-gram matching</span></a></li>
</ol>
</li>
<li class="ltx_tocentry ltx_tocentry_section"><a href="#S10" title="In Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">10 </span>Conclusion</span></a></li>
<li class="ltx_tocentry ltx_tocentry_appendix">
<a href="#A1" title="In Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">A </span>Literature Review</span></a>
<ol class="ltx_toclist ltx_toclist_appendix">
<li class="ltx_tocentry ltx_tocentry_subsection">
<a href="#A1.SS1" title="In Appendix A Literature Review ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">A.1 </span>Data Matching: Concepts and Techniques For Record Linkage,Entity Resolution, and Duplicate Detection - Peter Christen</span></a>
<ol class="ltx_toclist ltx_toclist_subsection">
<li class="ltx_tocentry ltx_tocentry_subsubsection"><a href="#A1.SS1.SSS1" title="In A.1 Data Matching: Concepts and Techniques For Record Linkage,Entity Resolution, and Duplicate Detection - Peter Christen [15] ‣ Appendix A Literature Review ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">A.1.1 </span>Framing Privacy Preserving Data Matching</span></a></li>
<li class="ltx_tocentry ltx_tocentry_subsubsection"><a href="#A1.SS1.SSS2" title="In A.1 Data Matching: Concepts and Techniques For Record Linkage,Entity Resolution, and Duplicate Detection - Peter Christen [15] ‣ Appendix A Literature Review ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">A.1.2 </span>Trust and Security Models</span></a></li>
<li class="ltx_tocentry ltx_tocentry_subsubsection"><a href="#A1.SS1.SSS3" title="In A.1 Data Matching: Concepts and Techniques For Record Linkage,Entity Resolution, and Duplicate Detection - Peter Christen [15] ‣ Appendix A Literature Review ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">A.1.3 </span>Exact Matching</span></a></li>
<li class="ltx_tocentry ltx_tocentry_subsubsection"><a href="#A1.SS1.SSS4" title="In A.1 Data Matching: Concepts and Techniques For Record Linkage,Entity Resolution, and Duplicate Detection - Peter Christen [15] ‣ Appendix A Literature Review ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">A.1.4 </span>Approximate Matching</span></a></li>
<li class="ltx_tocentry ltx_tocentry_subsubsection"><a href="#A1.SS1.SSS5" title="In A.1 Data Matching: Concepts and Techniques For Record Linkage,Entity Resolution, and Duplicate Detection - Peter Christen [15] ‣ Appendix A Literature Review ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">A.1.5 </span>Overall</span></a></li>
</ol>
</li>
<li class="ltx_tocentry ltx_tocentry_subsection"><a href="#A1.SS2" title="In Appendix A Literature Review ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">A.2 </span>Hashing and HMACs</span></a></li>
<li class="ltx_tocentry ltx_tocentry_subsection"><a href="#A1.SS3" title="In Appendix A Literature Review ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">A.3 </span>Similarity Tables</span></a></li>
<li class="ltx_tocentry ltx_tocentry_subsection">
<a href="#A1.SS4" title="In Appendix A Literature Review ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">A.4 </span>Security and accuracy of current literature on Bloom Filters</span></a>
<ol class="ltx_toclist ltx_toclist_subsection">
<li class="ltx_tocentry ltx_tocentry_subsubsection"><a href="#A1.SS4.SSS1" title="In A.4 Security and accuracy of current literature on Bloom Filters ‣ Appendix A Literature Review ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">A.4.1 </span>Bloom Filter construction</span></a></li>
<li class="ltx_tocentry ltx_tocentry_subsubsection"><a href="#A1.SS4.SSS2" title="In A.4 Security and accuracy of current literature on Bloom Filters ‣ Appendix A Literature Review ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">A.4.2 </span>Bloom filter analysis</span></a></li>
<li class="ltx_tocentry ltx_tocentry_subsubsection"><a href="#A1.SS4.SSS3" title="In A.4 Security and accuracy of current literature on Bloom Filters ‣ Appendix A Literature Review ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">A.4.3 </span>Use of Bloom filters in linking</span></a></li>
<li class="ltx_tocentry ltx_tocentry_subsubsection"><a href="#A1.SS4.SSS4" title="In A.4 Security and accuracy of current literature on Bloom Filters ‣ Appendix A Literature Review ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">A.4.4 </span>Uniformity of output</span></a></li>
<li class="ltx_tocentry ltx_tocentry_subsubsection"><a href="#A1.SS4.SSS5" title="In A.4 Security and accuracy of current literature on Bloom Filters ‣ Appendix A Literature Review ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">A.4.5 </span>Use of random values</span></a></li>
<li class="ltx_tocentry ltx_tocentry_subsubsection"><a href="#A1.SS4.SSS6" title="In A.4 Security and accuracy of current literature on Bloom Filters ‣ Appendix A Literature Review ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">A.4.6 </span>Similarity score evaluation</span></a></li>
<li class="ltx_tocentry ltx_tocentry_subsubsection"><a href="#A1.SS4.SSS7" title="In A.4 Security and accuracy of current literature on Bloom Filters ‣ Appendix A Literature Review ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">A.4.7 </span>Loss of ordering</span></a></li>
<li class="ltx_tocentry ltx_tocentry_subsubsection"><a href="#A1.SS4.SSS8" title="In A.4 Security and accuracy of current literature on Bloom Filters ‣ Appendix A Literature Review ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">A.4.8 </span>Double hashing: Size of 100, <math class="ltx_Math" alttext="k=3" display="inline"><semantics><mrow><mi>k</mi><mo>=</mo><mn>3</mn></mrow><annotation-xml encoding="MathML-Content"><apply><eq></eq><ci>𝑘</ci><cn type="integer">3</cn></apply></annotation-xml><annotation encoding="application/x-tex">k=3</annotation></semantics></math></span></a></li>
<li class="ltx_tocentry ltx_tocentry_subsubsection"><a href="#A1.SS4.SSS9" title="In A.4 Security and accuracy of current literature on Bloom Filters ‣ Appendix A Literature Review ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">A.4.9 </span>Double hashing: Size of 101, <math class="ltx_Math" alttext="k=3" display="inline"><semantics><mrow><mi>k</mi><mo>=</mo><mn>3</mn></mrow><annotation-xml encoding="MathML-Content"><apply><eq></eq><ci>𝑘</ci><cn type="integer">3</cn></apply></annotation-xml><annotation encoding="application/x-tex">k=3</annotation></semantics></math></span></a></li>
<li class="ltx_tocentry ltx_tocentry_subsubsection"><a href="#A1.SS4.SSS10" title="In A.4 Security and accuracy of current literature on Bloom Filters ‣ Appendix A Literature Review ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">A.4.10 </span>Universal hashing: Size of 101, <math class="ltx_Math" alttext="k=3" display="inline"><semantics><mrow><mi>k</mi><mo>=</mo><mn>3</mn></mrow><annotation-xml encoding="MathML-Content"><apply><eq></eq><ci>𝑘</ci><cn type="integer">3</cn></apply></annotation-xml><annotation encoding="application/x-tex">k=3</annotation></semantics></math></span></a></li>
<li class="ltx_tocentry ltx_tocentry_subsubsection"><a href="#A1.SS4.SSS11" title="In A.4 Security and accuracy of current literature on Bloom Filters ‣ Appendix A Literature Review ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">A.4.11 </span>Importance of filter size to <math class="ltx_Math" alttext="k" display="inline"><semantics><mi>k</mi><annotation-xml encoding="MathML-Content"><ci>𝑘</ci></annotation-xml><annotation encoding="application/x-tex">k</annotation></semantics></math></span></a></li>
</ol>
</li>
<li class="ltx_tocentry ltx_tocentry_subsection"><a href="#A1.SS5" title="In Appendix A Literature Review ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">A.5 </span>Other Approaches</span></a></li>
<li class="ltx_tocentry ltx_tocentry_subsection"><a href="#A1.SS6" title="In Appendix A Literature Review ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">A.6 </span>Secure Multi-Party Computation</span></a></li>
<li class="ltx_tocentry ltx_tocentry_subsection"><a href="#A1.SS7" title="In Appendix A Literature Review ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">A.7 </span>Differential Privacy</span></a></li>
<li class="ltx_tocentry ltx_tocentry_subsection"><a href="#A1.SS8" title="In Appendix A Literature Review ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">A.8 </span>UK Office of National Statistics</span></a></li>
</ol>
</li>
</ol></nav>
<div class="ltx_pagination ltx_role_newpage"></div>
</section>
<section id="S1" class="ltx_section">
<h2 class="ltx_title ltx_title_section">
<span class="ltx_tag ltx_tag_section">1 </span>Introduction</h2>

<div id="S1.p1" class="ltx_para">
<p id="S1.p1.1" class="ltx_p">Cryptographers take great care in defining</p>
<ul id="S1.I1" class="ltx_itemize">
<li id="S1.I1.i1" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">•</span> 
<div id="S1.I1.i1.p1" class="ltx_para">
<p id="S1.I1.i1.p1.1" class="ltx_p">the abilities of an <em id="S1.I1.i1.p1.1.1" class="ltx_emph ltx_font_italic">attacker</em> and</p>
</div>
</li>
<li id="S1.I1.i2" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">•</span> 
<div id="S1.I1.i2.p1" class="ltx_para">
<p id="S1.I1.i2.p1.1" class="ltx_p">the <em id="S1.I1.i2.p1.1.1" class="ltx_emph ltx_font_italic">security guarantees</em> of a protocol.</p>
</div>
</li>
</ul>
</div>
<div id="S1.p2" class="ltx_para">
<p id="S1.p2.1" class="ltx_p">A cryptographic primitive such as hashing, encryption, or digital signatures might provide certain guarantees against a particular kind of attacker, but might not be secure against a stronger attacker or in a different context. For example, digital signatures guarantee the integrity of data (assuming the key is secure) but do not provide privacy; encryption schemes that were secure 30 years ago can be broken using modern cloud computing.</p>
</div>
<div id="S1.p3" class="ltx_para">
<p id="S1.p3.1" class="ltx_p">Our first step is to model carefully the attacker ABS needs to defend against. A technique that defends against trusted parties doesn’t necessarily defend against a motivated external attacker. For example, writing “confidential” on the outside of an envelope is an effective way of telling well-behaved people not to read the contents—it is not an effective way of keeping the contents secure from an adversary who wants to snoop. Much of the Privacy Preserving Record Linkage literature is oriented to defending against well-behaved researchers who don’t actively try to reverse protections, like the people who don’t open “confidential” envelopes.

It is very important not to confuse this level of protection with something that cannot be reversed even by a motivated attacker.</p>
</div>
<div id="S1.p4" class="ltx_para">
<p id="S1.p4.1" class="ltx_p">The world is changing. We see more active and sophisticated attacks against government infrastructure. Espionage is conducted by well-funded nation-state attackers against government and corporate databases. The (allegedly) Russian attacks on the US Democratic National Committee emails were widely publicised. Less well known but even more devastating was an intrusion into the US Office of Personnel Management <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib26" title="" class="ltx_ref">26</a>]</cite>, blamed on China. Exfiltrated data contained details about military and intelligence personnel, including information given for security clearances.
In a separate incident, an employee of the US National Security Agency was reported to have accidentally exposed their collection of powerful hacking tools <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib36" title="" class="ltx_ref">36</a>]</cite>.</p>
</div>
<div id="S1.p5" class="ltx_para">
<p id="S1.p5.1" class="ltx_p">It is also important to consider re-identification of individuals based on the data itself—birthdates and suburbs could uniquely identify many households. Although this report focuses on ways to protect names (and addresses), any solution should be carefully aligned with secure methods for protecting the rest of the data.</p>
</div>
<div id="S1.p6" class="ltx_para">
<p id="S1.p6.1" class="ltx_p">The risk for ABS is that data could be deliberately stolen or accidentally exposed—and would then be subject to deliberate attack. The key is to
assess the security of proposals given a clearly defined and accurate attacker model.</p>
</div>
<section id="S1.SS1" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">1.1 </span>Overview of the technical challenges</h3>

<div id="S1.SS1.p1" class="ltx_para">
<p id="S1.SS1.p1.1" class="ltx_p">There are two quite separate technical problems:</p>
</div>
<div id="S1.SS1.p2" class="ltx_para">
<dl id="S1.I2" class="ltx_description">
<dt id="S1.I2.ix1" class="ltx_item"><span class="ltx_tag ltx_tag_item"><span id="S1.I2.ix1.1.1.1" class="ltx_text ltx_font_bold">The linking problem</span></span></dt>
<dd class="ltx_item">
<div id="S1.I2.ix1.p1" class="ltx_para">
<p id="S1.I2.ix1.p1.1" class="ltx_p">Maximising the accuracy of linking, both for reducing false matches and failures to find a match. The same person might have two different-looking names, due to typos, reading errors, changes of address, <span id="S1.I2.ix1.p1.1.1" class="ltx_text ltx_font_italic">etc.</span> Any solution needs to be robust against these small changes—this is called “fuzzy matching” or “probabilistic matching.”</p>
</div>
</dd>
<dt id="S1.I2.ix2" class="ltx_item"><span class="ltx_tag ltx_tag_item"><span id="S1.I2.ix2.1.1.1" class="ltx_text ltx_font_bold">The cryptographic problem</span></span></dt>
<dd class="ltx_item">
<div id="S1.I2.ix2.p1" class="ltx_para">
<p id="S1.I2.ix2.p1.1" class="ltx_p">Clarifying the assumptions behind techniques for keeping data secure. The key is to be explicit about what the security assumptions are so that ABS can make sure they are valid in practice. linecolor=green,backgroundcolor=green!25,bordercolor=green]VJT:ABS asked for rewording of this—I’ve removed the line about linking implying recovery and just written about the explicit assumptions, but still quite different from what they asked for. Recheck.</p>
</div>
</dd>
</dl>
</div>
<div id="S1.SS1.p3" class="ltx_para">
<p id="S1.SS1.p3.1" class="ltx_p">Each of these problems is challenging on its own and presents tradeoffs among different requirements. For example, solutions to the cryptographic problem involve a tradeoff among the strength of the security guarantees, the computational burden, and the complexity of the cryptographic protocol. Linking policies must slide a scale between false positives and false negatives. The combination of the cryptographic problem with the linking problem is particularly difficult. Along with the tradeoffs within each issue, the security requirements are hard to reconcile with a rich set of linking policies.</p>
</div>
<div id="S1.SS1.p4" class="ltx_para">
<p id="S1.SS1.p4.1" class="ltx_p">Some key themes and questions:</p>
<ul id="S1.I3" class="ltx_itemize">
<li id="S1.I3.i1" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">•</span> 
<div id="S1.I3.i1.p1" class="ltx_para">
<p id="S1.I3.i1.p1.1" class="ltx_p">the separation of roles, and whether those separations could be implemented with cryptography, or by the access control mechanisms to be put in place by the Statistical Business Transformation Project (SBTP),</p>
</div>
</li>
<li id="S1.I3.i2" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">•</span> 
<div id="S1.I3.i2.p1" class="ltx_para">
<p id="S1.I3.i2.p1.1" class="ltx_p">the protection of other data, rather than only names and addresses, perhaps using encryption,</p>
</div>
</li>
<li id="S1.I3.i3" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">•</span> 
<div id="S1.I3.i3.p1" class="ltx_para">
<p id="S1.I3.i3.p1.1" class="ltx_p">the possibility to link using other data (not only names).</p>
</div>
</li>
</ul>
</div>
<div id="S1.SS1.p5" class="ltx_para">
<p id="S1.SS1.p5.1" class="ltx_p">Many published schemes combine techniques for linking with some method of securing data, but the two are conceptually separate. For example, the technique by Schell <span id="S1.SS1.p5.1.1" class="ltx_text ltx_font_italic">et al.</span> <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib43" title="" class="ltx_ref">43</a>]</cite> combines a preprocessing stage of extracting n-grams from names to get nearby or likely alternatives, with a Bloom filter that finds exact matches. (This scheme is also mentioned in various surveys <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib49" title="" class="ltx_ref">49</a>]</cite>.) The overall scheme deals with fuzzy matching, but the two techniques could be analysed and re-used separately. For example, the same preprocessing stage could be used before a more secure way of making exact matches. It is the n-gram treatment, not the Bloom filter, that allows for fuzzy matching.</p>
</div>
<div id="S1.SS1.p6" class="ltx_para">
<p id="S1.SS1.p6.1" class="ltx_p">The choice of method for securing the data does impact on the possibilities for fuzzy matching. Encrypted data can be decrypted (with the right key) so that fuzzy matching can be performed on the decrypted data. Cryptographic hashing will check for exact matches only—a small change in the input causes a very different output of the hash. Some forms of encryption (homomorphic encryption) allow for certain kinds of edits to encrypted data. These schemes are promising for the future, but probably too computationally expensive for use this year.</p>
</div>
<div id="S1.SS1.p7" class="ltx_para">
<p id="S1.SS1.p7.1" class="ltx_p">Public attention before the census focused strongly on the retention of names. However, there are many other important aspects to a thorough protection of privacy, since a person’s date of birth, place of residence and other data could probably be used to identify them in many cases, even without the name. This is beneficial for linking, but it also represents a risk to privacy in the event that the dataset is leaked or attacked.</p>
</div>
<div id="S1.SS1.p8" class="ltx_para">
<p id="S1.SS1.p8.1" class="ltx_p">ABS has an entire governance structure, suite of legislation, policies and practices for managing risks associated with the confidentiality of data releases to external users. All ABS staff sign various legal undertakings upon joining the ABS and at regular intervals of time. The Acts under which ABS operates require them to protect the confidentiality of data when released and the legal undertakings signed by ABS staff give an assurance that ABS staff will abide by the ABS Acts as well other relevant Commonwealth Acts. However, this depends on both good intentions and sound engineering. Not everyone who wants to keep data secure understands the complex interaction of assumptions and protocols needed for security. linecolor=green,backgroundcolor=green!25,bordercolor=green]VJT:Add ref to the Qld scientists who were barred from using ABS.</p>
</div>
<div id="S1.SS1.p9" class="ltx_para">
<p id="S1.SS1.p9.1" class="ltx_p">For example, the recent open publication of re-identifiable MBS-PBS records <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib17" title="" class="ltx_ref">17</a>]</cite> could be attributed to a mismatch between the <em id="S1.SS1.p9.1.1" class="ltx_emph ltx_font_italic">assumptions</em> behind the mathematical protections and the <em id="S1.SS1.p9.1.2" class="ltx_emph ltx_font_italic">access protections</em>, which were non-existent. The mathematical techniques used for that dataset might have been sufficient for a secure research environment, but were not sufficient for open publication.</p>
</div>
<div id="S1.SS1.p10" class="ltx_para">
<p id="S1.SS1.p10.1" class="ltx_p">The purpose of this document is to clarify the assumptions of the cryptographic protocols for protecting data. Then ABS can ensure that the security guarantees of processes at ABS match those assumptions. For example, if a particular method relies on keeping a decryption key secret from the adversary, then ABS must have processes in place for protecting that key. If the data itself is re-identifiable (and detailed unit-record level data generally is) then the data itself must be protected. If security relies on the attacker never having access to the Librarian or Linker, then those computers must be very carefully isolated.</p>
</div>
<div id="S1.SS1.p11" class="ltx_para">
<p id="S1.SS1.p11.1" class="ltx_p">The following suggestions consider the security of the whole process, with an effort to remain consistent with ABS’s existing linking structure.</p>
</div>
<div id="S1.SS1.p12" class="ltx_para">
<p id="S1.SS1.p12.1" class="ltx_p">Some initial suggestions on general security:</p>
<dl id="S1.I4" class="ltx_description">
<dt id="S1.I4.ix1" class="ltx_item"><span class="ltx_tag ltx_tag_item"><span id="S1.I4.ix1.1.1.1" class="ltx_text ltx_font_bold">Encrypt the analysis items</span></span></dt>
<dd class="ltx_item">
<div id="S1.I4.ix1.p1" class="ltx_para">
<p id="S1.I4.ix1.p1.1" class="ltx_p">with a key not known to anyone in the linking process.</p>
</div>
</dd>
<dt id="S1.I4.ix2" class="ltx_item"><span class="ltx_tag ltx_tag_item"><span id="S1.I4.ix2.1.1.1" class="ltx_text ltx_font_bold">Shuffle the output order of the lists.</span></span></dt>
<dd class="ltx_item">
<div id="S1.I4.ix2.p1" class="ltx_para">
<p id="S1.I4.ix2.p1.1" class="ltx_p">Otherwise names and data might be recovered simply using order.</p>
</div>
</dd>
</dl>
</div>
<div id="S1.SS1.p13" class="ltx_para">
<p id="S1.SS1.p13.1" class="ltx_p">We concentrate on privacy, not integrity—an attacker trying to modify the data will generally not be detected or prevented.</p>
</div>
<div id="S1.SS1.p14" class="ltx_para">
<p id="S1.SS1.p14.1" class="ltx_p">None of the techniques in this report are secure against a compromised Linker. We assume that the dataset to be linked arrives in plaintext, so the linker has the information necessary to link by definition. In the future, it would be better to transmit incoming datasets in encrypted form. Then it might be possible to link without the Linker observing any plaintext records, so even a compromised linker could not reverse names. This is the main advantage of Options 4 and 5 (Sections <a href="#S7" title="7 Option 4: Individual IDs ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">7</span></a> and <a href="#S8" title="8 Option 5: Homomorphic encryption ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">8</span></a>), which are promising directions for the future though they are probably too complex to implement this year.</p>
</div>
</section>
<section id="S1.SS2" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">1.2 </span>The options</h3>

<div id="S1.SS2.p1" class="ltx_para">
<p id="S1.SS2.p1.1" class="ltx_p">We have five options, each with some variations.
Since the data could be re-identifiable with some auxiliary information anyway, even without the name,
we concentrate on clarifying what extra information or access is required to perform (authorised or unauthorised) linking or reversing. The choice of a good solution can then focus on which assumptions are valid in the ABS environment and which controls can be put in place.</p>
</div>
<div id="S1.SS2.p2" class="ltx_para">
<p id="S1.SS2.p2.1" class="ltx_p">The options</p>
<ol id="S1.I5" class="ltx_enumerate">
<li id="S1.I5.i1" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">1.</span> 
<div id="S1.I5.i1.p1" class="ltx_para">
<p id="S1.I5.i1.p1.1" class="ltx_p">Encryption. Encrypt the names with the Linker’s key; keep the key carefully secured. Section <a href="#S4" title="4 Option 1: Encrypting names using public-key encryption ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">4</span></a>.</p>
</div>
</li>
<li id="S1.I5.i2" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">2.</span> 
<div id="S1.I5.i2.p1" class="ltx_para">
<p id="S1.I5.i2.p1.1" class="ltx_p">Lossy encoding for names. Section <a href="#S5" title="5 Option 2: Lossy encoding for names ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">5</span></a>.</p>
</div>
</li>
<li id="S1.I5.i3" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">3.</span> 
<div id="S1.I5.i3.p1" class="ltx_para">
<p id="S1.I5.i3.p1.1" class="ltx_p">HMAC-based linkage key derivation using subsets of attributes, like UK ONS. Keep the key carefully secured. Section <a href="#S6" title="6 Option 3: HMAC-based anonymised linkage identifiers using subsets of attributes ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">6</span></a>.</p>
</div>
</li>
<li id="S1.I5.i4" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">4.</span> 
<div id="S1.I5.i4.p1" class="ltx_para">
<p id="S1.I5.i4.p1.1" class="ltx_p">Assign each person a unique ID before linking. Section <a href="#S7" title="7 Option 4: Individual IDs ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">7</span></a>.</p>
</div>
</li>
<li id="S1.I5.i5" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">5.</span> 
<div id="S1.I5.i5.p1" class="ltx_para">
<p id="S1.I5.i5.p1.1" class="ltx_p">Homomorphic encryption / secure computation. Section <a href="#S8" title="8 Option 5: Homomorphic encryption ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">8</span></a>.</p>
</div>
</li>
</ol>
</div>
<div id="S1.SS2.p3" class="ltx_para">
<p id="S1.SS2.p3.1" class="ltx_p">In Section <a href="#A1.SS4" title="A.4 Security and accuracy of current literature on Bloom Filters ‣ Appendix A Literature Review ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">A.4</span></a> we explain why Bloom Filters are not a privacy-preserving data structure, and conduct an empirical investigation of the linking quality of some of the constructions in the literature, including the combination of n-grams and Bloom filters. A broader literature review is included in Appendix <a href="#A1" title="Appendix A Literature Review ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">A</span></a>.</p>
</div>
<div id="S1.SS2.p4" class="ltx_para">
<p id="S1.SS2.p4.1" class="ltx_p">Before describing the options, we describe background cryptography in Section <a href="#S2" title="2 Background on Cryptography and possible attacks ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">2</span></a>, then ABS’s security and functionality requirements in Section <a href="#S3" title="3 ABS requirements ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">3</span></a>. We first explain why names that can be individually linked can also be reversed.</p>
</div>
</section>
<section id="S1.SS3" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">1.3 </span>Why names that can be individually linked from plaintext can also be reversed</h3>

<section id="S1.SS3.SSS1" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">1.3.1 </span>Linking by guessing all possible names</h4>

<div id="S1.SS3.SSS1.p1" class="ltx_para">
<p id="S1.SS3.SSS1.p1.1" class="ltx_p">It is not possible to give each name a unique encoding that allows one-to-one matching with plaintext names, but is not reversible.</p>
</div>
<div id="S1.SS3.SSS1.p2" class="ltx_para">
<p id="S1.SS3.SSS1.p2.1" class="ltx_p">To see why, suppose the ABS holds a database that includes a unique encoding for each name. There must be some process for matching those encodings with the names in a new, incoming database. This process must include, somehow, comparing a plaintext name with an encoded one to see whether they match. But that process clearly implies the capacity to link any individual name to its encoding—an attacker could run through the ABS database checking each encoded name against “Rubinstein” or “Teague” until there was a match. Alternatively, for a given encoded name, the attacker could run through a list of all possible names until there was a match. This allows the attacker to find the name that matches any chosen encoding, regardless of whether that name actually appears in an incoming database.</p>
</div>
<div id="S1.SS3.SSS1.p3" class="ltx_para">
<p id="S1.SS3.SSS1.p3.1" class="ltx_p">This is not a question of hashing vs encryption, but a fundamental limit of the information that is retained. Whenever there is a capacity to do individual linking by name, that capacity also permits the encoding to be reversed. This is true for any way of preserving the name information, including hashing, encryption, HMAC, or simply replacing the names with a random ID and using a lookup table.</p>
</div>
<div id="S1.SS3.SSS1.p4" class="ltx_para">
<p id="S1.SS3.SSS1.p4.1" class="ltx_p">Several options exist for putting procedural and mathematical controls in the way of unauthorised access, while still retaining the ability to link. For example, a cryptographic decryption key could be required for linking—this key could be carefully protected or shared among multiple trustworthy people within ABS, using secret sharing so that multiple people had to work together to decrypt the data. However, the fundamental limit remains: if the key allows linking, it can also be used to recover names. So “not reversible” is an impossibly high bar to set while still being able to perform exact matching to a unique encoded name.</p>
</div>
<div id="S1.SS3.SSS1.p5" class="ltx_para">
<p id="S1.SS3.SSS1.p5.1" class="ltx_p">One way around this is to use lossy encoding, meaning that several different names are mapped to the same encoding so information is truly lost. The ABS already has a technique for doing this, in which names are effectively assigned to bins, creating a level of indistinguishability between names within the same bin. In such systems there is a reduced amount of information preserved, though some still remains. The amount preserved is proportional to the size of the bins and the frequency of the names within those bins. Such approaches can reduce total information held, but at the cost of accuracy of record linking. In particular it would prevent exact matching of names. It also has some other important security limitations, because it reduces the attacker’s information only as much as it reduces the information available for authorised linking—see Section <a href="#S5" title="5 Option 2: Lossy encoding for names ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">5</span></a>.</p>
</div>
</section>
</section>
</section>
<section id="S2" class="ltx_section">
<h2 class="ltx_title ltx_title_section">
<span class="ltx_tag ltx_tag_section">2 </span>Background on Cryptography and possible attacks</h2>

<div id="S2.p1" class="ltx_para">
<p id="S2.p1.1" class="ltx_p">This section presents very brief informal definitions of cryptographic primitives. More formal definitions can be found in <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib11" title="" class="ltx_ref">11</a>]</cite>. We then explain some known attacks applicable in this setting and describe which methods defend against them.</p>
</div>
<div id="S2.p2" class="ltx_para">
<p id="S2.p2.7" class="ltx_p">A <em id="S2.p2.7.3" class="ltx_emph ltx_font_italic">cryptographic hash function</em> <math id="S2.p2.1.m1.1" class="ltx_Math" alttext="H" display="inline"><semantics id="S2.p2.1.m1.1a"><mi id="S2.p2.1.m1.1.1" xref="S2.p2.1.m1.1.1.cmml">H</mi><annotation-xml encoding="MathML-Content" id="S2.p2.1.m1.1b"><ci id="S2.p2.1.m1.1.1.cmml" xref="S2.p2.1.m1.1.1">𝐻</ci></annotation-xml><annotation encoding="application/x-tex" id="S2.p2.1.m1.1c">H</annotation></semantics></math> takes a message <math id="S2.p2.2.m2.1" class="ltx_Math" alttext="m" display="inline"><semantics id="S2.p2.2.m2.1a"><mi id="S2.p2.2.m2.1.1" xref="S2.p2.2.m2.1.1.cmml">m</mi><annotation-xml encoding="MathML-Content" id="S2.p2.2.m2.1b"><ci id="S2.p2.2.m2.1.1.cmml" xref="S2.p2.2.m2.1.1">𝑚</ci></annotation-xml><annotation encoding="application/x-tex" id="S2.p2.2.m2.1c">m</annotation></semantics></math> and outputs a hash <math id="S2.p2.3.m3.1" class="ltx_Math" alttext="h" display="inline"><semantics id="S2.p2.3.m3.1a"><mi id="S2.p2.3.m3.1.1" xref="S2.p2.3.m3.1.1.cmml">h</mi><annotation-xml encoding="MathML-Content" id="S2.p2.3.m3.1b"><ci id="S2.p2.3.m3.1.1.cmml" xref="S2.p2.3.m3.1.1">ℎ</ci></annotation-xml><annotation encoding="application/x-tex" id="S2.p2.3.m3.1c">h</annotation></semantics></math>. It should be infeasible to recover <math id="S2.p2.4.m4.1" class="ltx_Math" alttext="m" display="inline"><semantics id="S2.p2.4.m4.1a"><mi id="S2.p2.4.m4.1.1" xref="S2.p2.4.m4.1.1.cmml">m</mi><annotation-xml encoding="MathML-Content" id="S2.p2.4.m4.1b"><ci id="S2.p2.4.m4.1.1.cmml" xref="S2.p2.4.m4.1.1">𝑚</ci></annotation-xml><annotation encoding="application/x-tex" id="S2.p2.4.m4.1c">m</annotation></semantics></math> given <math id="S2.p2.5.m5.1" class="ltx_Math" alttext="h" display="inline"><semantics id="S2.p2.5.m5.1a"><mi id="S2.p2.5.m5.1.1" xref="S2.p2.5.m5.1.1.cmml">h</mi><annotation-xml encoding="MathML-Content" id="S2.p2.5.m5.1b"><ci id="S2.p2.5.m5.1.1.cmml" xref="S2.p2.5.m5.1.1">ℎ</ci></annotation-xml><annotation encoding="application/x-tex" id="S2.p2.5.m5.1c">h</annotation></semantics></math> <em id="S2.p2.7.2" class="ltx_emph ltx_font_italic">if <math id="S2.p2.6.1.m1.1" class="ltx_Math" alttext="m" display="inline"><semantics id="S2.p2.6.1.m1.1a"><mi id="S2.p2.6.1.m1.1.1" xref="S2.p2.6.1.m1.1.1.cmml">m</mi><annotation-xml encoding="MathML-Content" id="S2.p2.6.1.m1.1b"><ci id="S2.p2.6.1.m1.1.1.cmml" xref="S2.p2.6.1.m1.1.1">𝑚</ci></annotation-xml><annotation encoding="application/x-tex" id="S2.p2.6.1.m1.1c">m</annotation></semantics></math> was randomly chosen from the full input space of <math id="S2.p2.7.2.m2.1" class="ltx_Math" alttext="H" display="inline"><semantics id="S2.p2.7.2.m2.1a"><mi id="S2.p2.7.2.m2.1.1" xref="S2.p2.7.2.m2.1.1.cmml">H</mi><annotation-xml encoding="MathML-Content" id="S2.p2.7.2.m2.1b"><ci id="S2.p2.7.2.m2.1.1.cmml" xref="S2.p2.7.2.m2.1.1">𝐻</ci></annotation-xml><annotation encoding="application/x-tex" id="S2.p2.7.2.m2.1c">H</annotation></semantics></math>.</em></p>
</div>
<div id="S2.p3" class="ltx_para">
<p id="S2.p3.2" class="ltx_p">A <em id="S2.p3.2.1" class="ltx_emph ltx_font_italic">message authentication code (MAC)</em> is similar to a hash function, but requires a secret key <math id="S2.p3.1.m1.1" class="ltx_Math" alttext="k" display="inline"><semantics id="S2.p3.1.m1.1a"><mi id="S2.p3.1.m1.1.1" xref="S2.p3.1.m1.1.1.cmml">k</mi><annotation-xml encoding="MathML-Content" id="S2.p3.1.m1.1b"><ci id="S2.p3.1.m1.1.1.cmml" xref="S2.p3.1.m1.1.1">𝑘</ci></annotation-xml><annotation encoding="application/x-tex" id="S2.p3.1.m1.1c">k</annotation></semantics></math> to compute the hash. It should be infeasible to compute the correct hash without knowledge of <math id="S2.p3.2.m2.1" class="ltx_Math" alttext="k" display="inline"><semantics id="S2.p3.2.m2.1a"><mi id="S2.p3.2.m2.1.1" xref="S2.p3.2.m2.1.1.cmml">k</mi><annotation-xml encoding="MathML-Content" id="S2.p3.2.m2.1b"><ci id="S2.p3.2.m2.1.1.cmml" xref="S2.p3.2.m2.1.1">𝑘</ci></annotation-xml><annotation encoding="application/x-tex" id="S2.p3.2.m2.1c">k</annotation></semantics></math>.</p>
</div>
<div id="S2.p4" class="ltx_para">
<p id="S2.p4.1" class="ltx_p">An <em id="S2.p4.1.1" class="ltx_emph ltx_font_italic">HMAC</em> <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib33" title="" class="ltx_ref">33</a>]</cite> is a particular kind of MAC. Under certain assumptions, an HMAC’s output cannot be distinguished from random without knowing the key <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib6" title="" class="ltx_ref">6</a>]</cite>.</p>
</div>
<div id="S2.p5" class="ltx_para">
<p id="S2.p5.7" class="ltx_p">A <em id="S2.p5.7.1" class="ltx_emph ltx_font_italic">secret-key encryption function</em> takes a key <math id="S2.p5.1.m1.1" class="ltx_Math" alttext="k" display="inline"><semantics id="S2.p5.1.m1.1a"><mi id="S2.p5.1.m1.1.1" xref="S2.p5.1.m1.1.1.cmml">k</mi><annotation-xml encoding="MathML-Content" id="S2.p5.1.m1.1b"><ci id="S2.p5.1.m1.1.1.cmml" xref="S2.p5.1.m1.1.1">𝑘</ci></annotation-xml><annotation encoding="application/x-tex" id="S2.p5.1.m1.1c">k</annotation></semantics></math> and message <math id="S2.p5.2.m2.1" class="ltx_Math" alttext="m" display="inline"><semantics id="S2.p5.2.m2.1a"><mi id="S2.p5.2.m2.1.1" xref="S2.p5.2.m2.1.1.cmml">m</mi><annotation-xml encoding="MathML-Content" id="S2.p5.2.m2.1b"><ci id="S2.p5.2.m2.1.1.cmml" xref="S2.p5.2.m2.1.1">𝑚</ci></annotation-xml><annotation encoding="application/x-tex" id="S2.p5.2.m2.1c">m</annotation></semantics></math> (called the “plaintext”) and produces a ciphertext <math id="S2.p5.3.m3.1" class="ltx_Math" alttext="c" display="inline"><semantics id="S2.p5.3.m3.1a"><mi id="S2.p5.3.m3.1.1" xref="S2.p5.3.m3.1.1.cmml">c</mi><annotation-xml encoding="MathML-Content" id="S2.p5.3.m3.1b"><ci id="S2.p5.3.m3.1.1.cmml" xref="S2.p5.3.m3.1.1">𝑐</ci></annotation-xml><annotation encoding="application/x-tex" id="S2.p5.3.m3.1c">c</annotation></semantics></math>. The message <math id="S2.p5.4.m4.1" class="ltx_Math" alttext="m" display="inline"><semantics id="S2.p5.4.m4.1a"><mi id="S2.p5.4.m4.1.1" xref="S2.p5.4.m4.1.1.cmml">m</mi><annotation-xml encoding="MathML-Content" id="S2.p5.4.m4.1b"><ci id="S2.p5.4.m4.1.1.cmml" xref="S2.p5.4.m4.1.1">𝑚</ci></annotation-xml><annotation encoding="application/x-tex" id="S2.p5.4.m4.1c">m</annotation></semantics></math> can be recovered from <math id="S2.p5.5.m5.1" class="ltx_Math" alttext="c" display="inline"><semantics id="S2.p5.5.m5.1a"><mi id="S2.p5.5.m5.1.1" xref="S2.p5.5.m5.1.1.cmml">c</mi><annotation-xml encoding="MathML-Content" id="S2.p5.5.m5.1b"><ci id="S2.p5.5.m5.1.1.cmml" xref="S2.p5.5.m5.1.1">𝑐</ci></annotation-xml><annotation encoding="application/x-tex" id="S2.p5.5.m5.1c">c</annotation></semantics></math> using <math id="S2.p5.6.m6.1" class="ltx_Math" alttext="k" display="inline"><semantics id="S2.p5.6.m6.1a"><mi id="S2.p5.6.m6.1.1" xref="S2.p5.6.m6.1.1.cmml">k</mi><annotation-xml encoding="MathML-Content" id="S2.p5.6.m6.1b"><ci id="S2.p5.6.m6.1.1.cmml" xref="S2.p5.6.m6.1.1">𝑘</ci></annotation-xml><annotation encoding="application/x-tex" id="S2.p5.6.m6.1c">k</annotation></semantics></math>. (This is called “decrypting”.) Decrypting should be infeasible without <math id="S2.p5.7.m7.1" class="ltx_Math" alttext="k" display="inline"><semantics id="S2.p5.7.m7.1a"><mi id="S2.p5.7.m7.1.1" xref="S2.p5.7.m7.1.1.cmml">k</mi><annotation-xml encoding="MathML-Content" id="S2.p5.7.m7.1b"><ci id="S2.p5.7.m7.1.1.cmml" xref="S2.p5.7.m7.1.1">𝑘</ci></annotation-xml><annotation encoding="application/x-tex" id="S2.p5.7.m7.1c">k</annotation></semantics></math>.</p>
</div>
<div id="S2.p6" class="ltx_para">
<p id="S2.p6.2" class="ltx_p">A <em id="S2.p6.2.1" class="ltx_emph ltx_font_italic">public-key encryption function</em> uses two different keys: a <em id="S2.p6.2.2" class="ltx_emph ltx_font_italic">public key</em> for encrypting the message <math id="S2.p6.1.m1.1" class="ltx_Math" alttext="m" display="inline"><semantics id="S2.p6.1.m1.1a"><mi id="S2.p6.1.m1.1.1" xref="S2.p6.1.m1.1.1.cmml">m</mi><annotation-xml encoding="MathML-Content" id="S2.p6.1.m1.1b"><ci id="S2.p6.1.m1.1.1.cmml" xref="S2.p6.1.m1.1.1">𝑚</ci></annotation-xml><annotation encoding="application/x-tex" id="S2.p6.1.m1.1c">m</annotation></semantics></math> and a <em id="S2.p6.2.3" class="ltx_emph ltx_font_italic">private key</em> for decrypting the ciphertext <math id="S2.p6.2.m2.1" class="ltx_Math" alttext="c" display="inline"><semantics id="S2.p6.2.m2.1a"><mi id="S2.p6.2.m2.1.1" xref="S2.p6.2.m2.1.1.cmml">c</mi><annotation-xml encoding="MathML-Content" id="S2.p6.2.m2.1b"><ci id="S2.p6.2.m2.1.1.cmml" xref="S2.p6.2.m2.1.1">𝑐</ci></annotation-xml><annotation encoding="application/x-tex" id="S2.p6.2.m2.1c">c</annotation></semantics></math>. The public key is made public, but decryption should be infeasible without the private key.</p>
</div>
<div id="S2.p7" class="ltx_para">
<p id="S2.p7.1" class="ltx_p">Both secret-key and public-key encryption schemes generally include some randomness when encrypting, so that different encryptions of the same message are not the same.</p>
</div>
<div id="S2.p8" class="ltx_para">
<p id="S2.p8.1" class="ltx_p"><em id="S2.p8.1.1" class="ltx_emph ltx_font_italic">Secret sharing</em> <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib45" title="" class="ltx_ref">45</a>]</cite> allows a secret such as a key to be shared among several participants so that it can be recovered only if some threshold meet and exchange their shares. Fewer than a threshold of participants can derive no information about the secret.</p>
</div>
<section id="S2.SS1" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">2.1 </span>How cryptographic hashes of names can be reversed</h3>

<div id="S2.SS1.p1" class="ltx_para">
<p id="S2.SS1.p1.1" class="ltx_p">There is a persistent misunderstanding in the PPRL literature that cryptographic hash functions are impossible to reverse. This is incorrect.
Irreversibility can be true only if the input is <em id="S2.SS1.p1.1.1" class="ltx_emph ltx_font_italic">randomly and uniformly</em> chosen from a sufficiently large set that it is infeasible to try them all to see which one matches the given output.
Names are clearly not chosen in this way. The next sections explain some known ways of reversing hashes when the input set is predictable, as names are.</p>
</div>
<section id="S2.SS1.SSS1" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">2.1.1 </span>Dictionary attacks</h4>

<div id="S2.SS1.SSS1.p1" class="ltx_para">
<p id="S2.SS1.SSS1.p1.1" class="ltx_p">Name reversal can be applied to an entire database given a list of all (or many) probable names, derived for example from the Whitepages or the 2021 Census, or simply from the attacker’s memory of known names.</p>
</div>
<div id="S2.SS1.SSS1.p2" class="ltx_para">
<p id="S2.SS1.SSS1.p2.1" class="ltx_p">Simply trying all possible inputs, as described in Section <a href="#S1.SS3.SSS1" title="1.3.1 Linking by guessing all possible names ‣ 1.3 Why names that can be individually linked from plaintext can also be reversed ‣ 1 Introduction ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">1.3.1</span></a> is known as a <em id="S2.SS1.SSS1.p2.1.1" class="ltx_emph ltx_font_italic">dictionary attack</em>. Modern security would require at least <math id="S2.SS1.SSS1.p2.1.m1.1" class="ltx_Math" alttext="2^{128}" display="inline"><semantics id="S2.SS1.SSS1.p2.1.m1.1a"><msup id="S2.SS1.SSS1.p2.1.m1.1.1" xref="S2.SS1.SSS1.p2.1.m1.1.1.cmml"><mn id="S2.SS1.SSS1.p2.1.m1.1.1.2" xref="S2.SS1.SSS1.p2.1.m1.1.1.2.cmml">2</mn><mn id="S2.SS1.SSS1.p2.1.m1.1.1.3" xref="S2.SS1.SSS1.p2.1.m1.1.1.3.cmml">128</mn></msup><annotation-xml encoding="MathML-Content" id="S2.SS1.SSS1.p2.1.m1.1b"><apply id="S2.SS1.SSS1.p2.1.m1.1.1.cmml" xref="S2.SS1.SSS1.p2.1.m1.1.1"><csymbol cd="ambiguous" id="S2.SS1.SSS1.p2.1.m1.1.1.1.cmml" xref="S2.SS1.SSS1.p2.1.m1.1.1">superscript</csymbol><cn type="integer" id="S2.SS1.SSS1.p2.1.m1.1.1.2.cmml" xref="S2.SS1.SSS1.p2.1.m1.1.1.2">2</cn><cn type="integer" id="S2.SS1.SSS1.p2.1.m1.1.1.3.cmml" xref="S2.SS1.SSS1.p2.1.m1.1.1.3">128</cn></apply></annotation-xml><annotation encoding="application/x-tex" id="S2.SS1.SSS1.p2.1.m1.1c">2^{128}</annotation></semantics></math> possible input values to be considered secure against a brute force (dictionary) attack. There are fewer than 400,000 last names currently in use in Australia, which is small enough to guess all possible values. Calculating cryptographic hash values for all of them would take mere seconds. We ran a demonstration of this in our seminar at the ABS, based on simply running through a directory of all Australian names<span id="footnote2" class="ltx_note ltx_role_footnote"><sup class="ltx_note_mark">2</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">2</sup><span class="ltx_tag ltx_tag_note">2</span>We used the surname list from IP Australia and a list of baby names.</span></span></span> to see which one matched a SHA-256 hash of a volunteer’s name. It took a few seconds to recover. Cryptographic hashing alone provides a near-zero level of security in this context.</p>
</div>
</section>
<section id="S2.SS1.SSS2" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">2.1.2 </span>Why plain HMACs do not solve the problem</h4>

<div id="S2.SS1.SSS2.p1" class="ltx_para">
<p id="S2.SS1.SSS2.p1.1" class="ltx_p">More recent proposals have replaced the plain cryptographic hash with an HMAC (Hashing-based Message Authentication Code). A number of papers incorrectly refer to this as a hash, when it is not. It uses a hash but has different properties and security guarantees. The most significant difference is that it requires a key <math id="S2.SS1.SSS2.p1.1.m1.1" class="ltx_Math" alttext="k" display="inline"><semantics id="S2.SS1.SSS2.p1.1.m1.1a"><mi id="S2.SS1.SSS2.p1.1.m1.1.1" xref="S2.SS1.SSS2.p1.1.m1.1.1.cmml">k</mi><annotation-xml encoding="MathML-Content" id="S2.SS1.SSS2.p1.1.m1.1b"><ci id="S2.SS1.SSS2.p1.1.m1.1.1.cmml" xref="S2.SS1.SSS2.p1.1.m1.1.1">𝑘</ci></annotation-xml><annotation encoding="application/x-tex" id="S2.SS1.SSS2.p1.1.m1.1c">k</annotation></semantics></math>. The key must be generated in accordance with cryptographic procedures with good entropy.</p>
</div>
<div id="S2.SS1.SSS2.p2" class="ltx_para">
<p id="S2.SS1.SSS2.p2.1" class="ltx_p">The key is critical to the security of the output and must be kept absolutely secret. Were someone to gain access to the key, the HMACs tags (output values) would become as easy to reverse as plain cryptographic hash. A number of papers reject encryption as inappropriate because it permits decryption with knowledge of the key. Yet the same is true if using an HMAC over a small input set (such as names), for the reasons described above.</p>
</div>
<div id="S2.SS1.SSS2.p3" class="ltx_para">
<p id="S2.SS1.SSS2.p3.1" class="ltx_p">The misunderstanding of HMACs gives the mistaken impression that they comply with the requirement to be irreversible, when actually they do not.
In most cases, the input sets are small and the security of HMACs reduces to being equivalent to encryption. There is certainly no guarantee of irreversibility—just as with encryption the security depends on the key and access to the key.</p>
</div>
</section>
<section id="S2.SS1.SSS3" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">2.1.3 </span>Determinism and frequency attacks</h4>

<div id="S2.SS1.SSS3.p1" class="ltx_para">
<p id="S2.SS1.SSS3.p1.1" class="ltx_p">Another vulnerability of HMACs is that, for a given key, all HMACs of the same message are equal. (Note that this is not generally true of encryption, though it is true of keyless hashing too.) Such approaches allow efficient exact matching via comparison of outputs. However, whenever a deterministic approach is used, the frequency distribution of the input is replicated in the output. This presents a particular problem where the input distribution is not uniform, as is the case with names. For example, the name “Smith” is overwhelmingly the most popular last name in Australia. By looking at the output HMAC tags it would be trivially easy to identify which one represented “Smith” <em id="S2.SS1.SSS3.p1.1.1" class="ltx_emph ltx_font_italic">even without knowing the secret key</em>. In some cases, as in <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib37" title="" class="ltx_ref">37</a>]</cite>, where similarity information is provided, being able to reverse a single encoding can lead to reversing of many more <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib18" title="" class="ltx_ref">18</a>]</cite>.</p>
</div>
<div id="S2.SS1.SSS3.p2" class="ltx_para">
<p id="S2.SS1.SSS3.p2.1" class="ltx_p">Even where schemes apply a further level of abstraction, as is the case with Bloom filters, it has been shown that frequency analysis can still be performed and used to recover plaintexts <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib34" title="" class="ltx_ref">34</a>]</cite>.</p>
</div>
<div id="S2.SS1.SSS3.p3" class="ltx_para">
<p id="S2.SS1.SSS3.p3.1" class="ltx_p">So plain HMACs can be reversed if the attacker either</p>
<ul id="S2.I1" class="ltx_itemize">
<li id="S2.I1.i1" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">•</span> 
<div id="S2.I1.i1.p1" class="ltx_para">
<p id="S2.I1.i1.p1.1" class="ltx_p">knows the key and can guess the input value (for example by iterating over all possible input values), or</p>
</div>
</li>
<li id="S2.I1.i2" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">•</span> 
<div id="S2.I1.i2.p1" class="ltx_para">
<p id="S2.I1.i2.p1.1" class="ltx_p">doesn’t know the key but can identify an input by the matching frequency of its output.</p>
</div>
</li>
</ul>
</div>
<div class="ltx_pagination ltx_role_newpage"></div>
</section>
</section>
</section>
<section id="S3" class="ltx_section">
<h2 class="ltx_title ltx_title_section">
<span class="ltx_tag ltx_tag_section">3 </span>ABS requirements</h2>

<div id="S3.p1" class="ltx_para">
<p id="S3.p1.1" class="ltx_p">Much of the Privacy-preserving record linkage literature is concerned with “… how two or more organisations can determine if their databases contain records that refer to the same real-world entities without revealing any information besides the matched records to each other or to any other organisation.”<cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib15" title="" class="ltx_ref">15</a>]</cite> ABS’s setting is slightly different, because ABS is a single party aiming to link disparate datasets within the organisation, under the assumption that it arrives at the ABS in plaintext, but is then encoded to limit the
recovery of the underlying name from the encoded name. Thus the ABS requirements are different from the usual requirements in the literature.</p>
</div>
<div id="S3.p2" class="ltx_para">
<p id="S3.p2.1" class="ltx_p">The following is a summary of the key requirements as captured on 7th December 2016 during discussions between ABS and the University of Melbourne. Functional requirements capture what the protocol ought to allow properly-authenticated ABS employees to do; security requirements capture what the protocol ought to prevent an attacker from doing.</p>
</div>
<section id="S3.SS1" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">3.1 </span>Functional requirements</h3>

<div id="S3.SS1.p1" class="ltx_para">
<dl id="S3.I1" class="ltx_description">
<dt id="S3.I1.ix1" class="ltx_item"><span class="ltx_tag ltx_tag_item"><span id="S3.I1.ix1.1.1.1" class="ltx_text ltx_font_bold">Link First and Last Name</span></span></dt>
<dd class="ltx_item">
<div id="S3.I1.ix1.p1" class="ltx_para">
<p id="S3.I1.ix1.p1.1" class="ltx_p">The approach should provide a way of linking the first and last name fields. The first and last name should be treated separately. Address will be handled via geo-coding.</p>
</div>
</dd>
<dt id="S3.I1.ix2" class="ltx_item"><span class="ltx_tag ltx_tag_item"><span id="S3.I1.ix2.1.1.1" class="ltx_text ltx_font_bold">Fuzzy Matching</span></span></dt>
<dd class="ltx_item">
<div id="S3.I1.ix2.p1" class="ltx_para">
<p id="S3.I1.ix2.p1.1" class="ltx_p">Ideally the approach would provide for inexact matching to handle typical data capture errors such as transposed characters and differences in spelling. Note: this is a desirable but not necessary requirement, since names could be canonicalised before matching.</p>
</div>
</dd>
<dt id="S3.I1.ix3" class="ltx_item"><span class="ltx_tag ltx_tag_item"><span id="S3.I1.ix3.1.1.1" class="ltx_text ltx_font_bold">Exact Matching</span></span></dt>
<dd class="ltx_item">
<div id="S3.I1.ix3.p1" class="ltx_para">
<p id="S3.I1.ix3.p1.1" class="ltx_p">The matching should aim for an exact match. This is on a data level, as opposed to a record level i.e. Bob Smith matches to Bob Smith, but there may be multiple records with the name Bob Smith. Note: this again is a desirable but not necessary requirement, since a one-to-many matching of names could still allow one-to-one matching of records given other information.</p>
</div>
</dd>
<dt id="S3.I1.ix4" class="ltx_item"><span class="ltx_tag ltx_tag_item"><span id="S3.I1.ix4.1.1.1" class="ltx_text ltx_font_bold">Integrate into Data Integration Protocol</span></span></dt>
<dd class="ltx_item">
<div id="S3.I1.ix4.p1" class="ltx_para">
<p id="S3.I1.ix4.p1.1" class="ltx_p">Ideally the approach will fit with the Data Integration Protocol. Whilst the protocol is not absolutely rigid, and could be modified, any modification would require an equivalent business case. Cryptography could be used to enhance security of the data integration protocol by enforcing existing rules that restrict the data visible to different participants.</p>
</div>
</dd>
</dl>
</div>
</section>
<section id="S3.SS2" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">3.2 </span>Security requirements</h3>

<div id="S3.SS2.p1" class="ltx_para">
<p id="S3.SS2.p1.1" class="ltx_p">A key part of this project is translating into mathematical terms the requirements for security and privacy of the linking process.</p>
</div>
<div id="S3.SS2.p2" class="ltx_para">
<dl id="S3.I2" class="ltx_description">
<dt id="S3.I2.ix1" class="ltx_item"><span class="ltx_tag ltx_tag_item"><span id="S3.I2.ix1.1.1.1" class="ltx_text ltx_font_bold">Deletion of Names and Addresses</span></span></dt>
<dd class="ltx_item">
<div id="S3.I2.ix1.p1" class="ltx_para">
<p id="S3.I2.ix1.p1.1" class="ltx_p">The ABS has committed to the deletion of the names and addresses. The Senate submission includes the statement that “ABS confirms names and addresses will be destroyed when there is no longer any community benefit to their retention or four years after collection, whichever is soonest”</p>
</div>
</dd>
<dt id="S3.I2.ix2" class="ltx_item"><span class="ltx_tag ltx_tag_item"><span id="S3.I2.ix2.1.1.1" class="ltx_text ltx_font_bold">Cryptographic Hashing</span></span></dt>
<dd class="ltx_item">
<div id="S3.I2.ix2.p1" class="ltx_para">
<p id="S3.I2.ix2.p1.1" class="ltx_p">The ABS has made a public commitment to using a Cryptographic Hashing function. The statement reads “ABS will use a cryptographic hash function to anonymise name information prior to use in data linkage projects. This function converts a name into an unrecognizable value in a way that is not reversible…”.</p>
</div>
</dd>
</dl>
</div>
<div id="S3.SS2.p3" class="ltx_para">
<p id="S3.SS2.p3.1" class="ltx_p">Taken together and in an absolute sense, these requirements are impossible to deliver.
The requirement to delete names and addresses, if taken in an absolute sense, would include deleting derivatives of the names, which would prevent linking. It would be clearer to distinguish between plaintext and encoded names, and only assert the deletion of the plaintext names.
The assertion that a cryptographic hash cannot be reversed is mathematically incorrect
in this setting, as explained in Section <a href="#S2.SS1" title="2.1 How cryptographic hashes of names can be reversed ‣ 2 Background on Cryptography and possible attacks ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">2.1</span></a>.</p>
</div>
<div id="S3.SS2.p4" class="ltx_para">
<p id="S3.SS2.p4.1" class="ltx_p">For complex unit-record level data, including Census data, auxiliary data can be often be used to link individual records, even without name. This is the basis of ABS’s existing bronze linking.
This means that they can probably be re-identified without the encoded name anyway. Protection against re-identification depends on good processes within ABS.</p>
</div>
<div id="S3.SS2.p5" class="ltx_para">
<p id="S3.SS2.p5.1" class="ltx_p">The undertaking on the encoding of names should therefore be considered in the full context of auxiliary data and ABS processes. There are several reasonable interpretations:</p>
<ol id="S3.I3" class="ltx_enumerate">
<li id="S3.I3.i1" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">1.</span> 
<div id="S3.I3.i1.p1" class="ltx_para">
<p id="S3.I3.i1.p1.1" class="ltx_p">That the encoding cannot be reversed except with a secret key held by ABS. This is the property achieved by encryption (Option 1), if properly implemented;</p>
</div>
</li>
<li id="S3.I3.i2" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">2.</span> 
<div id="S3.I3.i2.p1" class="ltx_para">
<p id="S3.I3.i2.p1.1" class="ltx_p">That the encoding, taken alone without auxiliary data, cannot be reversed to a unique name. This is the property achieved by lossy encoding (Option 2), if properly implemented;</p>
</div>
</li>
<li id="S3.I3.i3" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">3.</span> 
<div id="S3.I3.i3.p1" class="ltx_para">
<p id="S3.I3.i3.p1.1" class="ltx_p">That the encoding doesn’t make re-identification easier, or increase the number of records that can be re-identified, except with a secret key held by ABS. This is the property achieved by HMAC-based linkage key derivation using subsets of attributes (Option 3), if properly implemented.</p>
</div>
</li>
</ol>
</div>
<div id="S3.SS2.p6" class="ltx_para">
<p id="S3.SS2.p6.1" class="ltx_p">linecolor=green,backgroundcolor=green!25,bordercolor=green]VJT:“Shared” sounds like the opposite of what it should mean.
Using encryption, for example, would mean that “not reversible” must be reinterpreted to mean “not reversible except given certain secret keys.” These keys would need to be stored securely or secret-shared among several entities within ABS—much like is already done in the ABS Data Integration Protocol. The security of such an approach is based on the assumption of trust and compliance with a process or protocol for key management. The distribution of trust could possibly be designed to align with existing protocols—this is the topic of the next sections of this report.</p>
</div>
<div id="S3.SS2.p7" class="ltx_para">
<p id="S3.SS2.p7.1" class="ltx_p">The following sections describe the tradeoffs among the various options for linking. For each option, we discuss how it addresses both the security requirements and the functionality and efficiency requirements. Some of the options could be combined. For example, if encoded names needed to be stored for longer periods, they could be generated using HMACs on subsets of attributes (Section <a href="#S6" title="6 Option 3: HMAC-based anonymised linkage identifiers using subsets of attributes ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">6</span></a>) but then encrypted with the public key of the Linker for storage (Option <a href="#S4" title="4 Option 1: Encrypting names using public-key encryption ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">4</span></a>).</p>
</div>
</section>
</section>
<section id="S4" class="ltx_section">
<h2 class="ltx_title ltx_title_section">
<span class="ltx_tag ltx_tag_section">4 </span>Option 1: Encrypting names using public-key encryption</h2>

<div id="S4.p1" class="ltx_para">
<p id="S4.p1.1" class="ltx_p">The simplest secure approach is to encrypt names with the public key of the Linker.<span id="footnote3" class="ltx_note ltx_role_footnote"><sup class="ltx_note_mark">3</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">3</sup><span class="ltx_tag ltx_tag_note">3</span>In practice, public key encryption can be implemented by generating a random key for a secret-key algorithm such as AES, encrypting the data with that key, and then encrypting the key with the recipient’s public key.</span></span></span> Other linkage items such as year of birth and location could also be encrypted, which would improve the security of the whole system. This would scarcely alter the ABS’s existing linkage process at all, except that the Linkage File produced by the Librarian would be encrypted. Indeed, the whole process could be considerably simplified: rather than a separate manager for names, there could be an initial step in which the names and any data used for linking were encrypted. The data could then be stored in encrypted form and simply passed to the Librarian and on to the Linker whenever linking was performed.</p>
</div>
<div id="S4.p2" class="ltx_para">
<p id="S4.p2.1" class="ltx_p">Variables that are both linking variables and analysis variables (such as year of birth) could either be sent separately to the Assembler (as they are now), or decrypted by the Linker and sent to the Assembler with the Linkage Output File.</p>
</div>
<div id="S4.p3" class="ltx_para">
<dl id="S4.I1" class="ltx_description">
<dt id="S4.I1.ix1" class="ltx_item"><span class="ltx_tag ltx_tag_item"><span id="S4.I1.ix1.1.1.1" class="ltx_text ltx_font_bold">Information required to make the anonymised name/linkage file: </span></span></dt>
<dd class="ltx_item">
<div id="S4.I1.ix1.p1" class="ltx_para">
<p id="S4.I1.ix1.p1.1" class="ltx_p">the public key of the Linker; the names and (possibly) other linking variables.</p>
</div>
</dd>
<dt id="S4.I1.ix2" class="ltx_item"><span class="ltx_tag ltx_tag_item"><span id="S4.I1.ix2.1.1.1" class="ltx_text ltx_font_bold">Information required for linking:</span></span></dt>
<dd class="ltx_item">
<div id="S4.I1.ix2.p1" class="ltx_para">
<p id="S4.I1.ix2.p1.1" class="ltx_p">the private key of the Linker.</p>
</div>
</dd>
<dt id="S4.I1.ix3" class="ltx_item"><span class="ltx_tag ltx_tag_item"><span id="S4.I1.ix3.1.1.1" class="ltx_text ltx_font_bold">Information required for reversing:</span></span></dt>
<dd class="ltx_item">
<div id="S4.I1.ix3.p1" class="ltx_para">
<p id="S4.I1.ix3.p1.1" class="ltx_p">the private key of the Linker.</p>
</div>
</dd>
<dt id="S4.I1.ix4" class="ltx_item"><span class="ltx_tag ltx_tag_item"><span id="S4.I1.ix4.1.1.1" class="ltx_text ltx_font_bold">Ways of inhibiting unauthorised reversing or linking:</span></span></dt>
<dd class="ltx_item">
<div id="S4.I1.ix4.p1" class="ltx_para">
<p id="S4.I1.ix4.p1.1" class="ltx_p">keep the Linker’s private key secret. For example, it could be secret-shared among several people at ABS or even some people outside, so that many had to participate to decrypt. Depending on how the SBTP access control mechanisms are implemented, it may be possible to simply re-use their key management infrastructure.</p>
</div>
</dd>
<dt id="S4.I1.ix5" class="ltx_item"><span class="ltx_tag ltx_tag_item"><span id="S4.I1.ix5.1.1.1" class="ltx_text ltx_font_bold">Fuzzy matching: </span></span></dt>
<dd class="ltx_item">
<div id="S4.I1.ix5.p1" class="ltx_para">
<p id="S4.I1.ix5.p1.1" class="ltx_p">Yes, by the Linker, after decrypting the data. Any fuzzy matching algorithm could be applied.</p>
</div>
</dd>
<dt id="S4.I1.ix6" class="ltx_item"><span class="ltx_tag ltx_tag_item"><span id="S4.I1.ix6.1.1.1" class="ltx_text ltx_font_bold">Linking accuracy: </span></span></dt>
<dd class="ltx_item">
<div id="S4.I1.ix6.p1" class="ltx_para">
<p id="S4.I1.ix6.p1.1" class="ltx_p">As good as linking on unencrypted values, because the Linker can see all unencrypted values.</p>
</div>
</dd>
<dt id="S4.I1.ix7" class="ltx_item"><span class="ltx_tag ltx_tag_item"><span id="S4.I1.ix7.1.1.1" class="ltx_text ltx_font_bold">Implementation difficulty: </span></span></dt>
<dd class="ltx_item">
<div id="S4.I1.ix7.p1" class="ltx_para">
<p id="S4.I1.ix7.p1.1" class="ltx_p">The protocol for encrypting, decrypting, and managing keys would need to be implemented with care by professionals, but would use standard techniques and might be able to re-use methods from the SIAM/SBTP technologies.</p>
</div>
</dd>
<dt id="S4.I1.ix8" class="ltx_item"><span class="ltx_tag ltx_tag_item"><span id="S4.I1.ix8.1.1.1" class="ltx_text ltx_font_bold">Computational Efficiency: </span></span></dt>
<dd class="ltx_item">
<div id="S4.I1.ix8.p1" class="ltx_para">
<p id="S4.I1.ix8.p1.1" class="ltx_p">This needs to be tested, but would probably be very efficient in practice because the cryptography is simple encryption/decryption, and the linking is performed on unencrypted values.</p>
</div>
</dd>
<dt id="S4.I1.ix9" class="ltx_item"><span class="ltx_tag ltx_tag_item"><span id="S4.I1.ix9.1.1.1" class="ltx_text ltx_font_bold">Other advantages: </span></span></dt>
<dd class="ltx_item">
<div id="S4.I1.ix9.p1" class="ltx_para">
<p id="S4.I1.ix9.p1.1" class="ltx_p">In future, other agencies sending their data to ABS could also encrypt their names and data with the Linker’s public key. This would mean that nobody within ABS would see the incoming names, except with access to the Linker’s private key. It would also protect the names and data from compromise during transmission between agencies. Although the private key must be kept secret, it would not have to be distributed very widely ever. In particular, it is not needed for the <em id="S4.I1.ix9.p1.1.1" class="ltx_emph ltx_font_italic">production</em> of the encrypted files—that is the great advantage of public key cryptography.</p>
</div>
</dd>
<dt id="S4.I1.ix10" class="ltx_item"><span class="ltx_tag ltx_tag_item"><span id="S4.I1.ix10.1.1.1" class="ltx_text ltx_font_bold">Other disadvantages: </span></span></dt>
<dd class="ltx_item">
<div id="S4.I1.ix10.p1" class="ltx_para">
<p id="S4.I1.ix10.p1.1" class="ltx_p">Strong requirements for keeping the private (decryption) key secret.</p>
</div>
</dd>
</dl>
</div>
</section>
<section id="S5" class="ltx_section">
<h2 class="ltx_title ltx_title_section">
<span class="ltx_tag ltx_tag_section">5 </span>Option 2: Lossy encoding for names</h2>

<div id="S5.p1" class="ltx_para">
<p id="S5.p1.1" class="ltx_p">Lossy encoding creates a many-to-one mapping between inputs (names) and outputs (encoded names).
The idea is to encode first and last names, separately, using a bucket that includes a whole set of possible names. A simple example is retaining initials rather than whole names. This is impossible to reverse without auxiliary data because many names have the same initial<span id="footnote4" class="ltx_note ltx_role_footnote"><sup class="ltx_note_mark">4</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">4</sup><span class="ltx_tag ltx_tag_note">4</span>Though if only one person has a particular pair of initials, more information than this needs to be lost.</span></span></span>. It nevertheless provides some useful information for linking, because a particular set of initials won’t match most names. All methods for lossy encoding have this same logical structure: information is truly lost, but some information is retained which can be used to eliminate some incorrect matches. Of course, the information that is retained also helps an attacker do unauthorised linking/re-identification if the dataset is leaked.</p>
</div>
<div id="S5.p2" class="ltx_para">
<p id="S5.p2.1" class="ltx_p">This option leverages the redundancy of identifiable information—most people are unique based on a subset of the attributes usually associated with Census data, so deleting some information from the name may not severely reduce the accuracy of linkage. The Linker would also need to consider age, gender and country of origin or last residence for accurate linking.
Unfortunately, this feature is also a challenge for privacy—attributes that can be used by the Linker for more accurate linking could also be used by an attacker for unauthorised re-identification. This approach therefore relies on proper processes within ABS for keeping the dataset secret.</p>
</div>
<div id="S5.p3" class="ltx_para">
<p id="S5.p3.1" class="ltx_p">Different lossy encodings might retain very different amounts of information. For example, the first three letters of a name provide much more information than the initial alone. The amount of information lost affects (legitimate) linking quality as well as the likely success of an attacker.</p>
</div>
<div id="S5.p4" class="ltx_para">
<p id="S5.p4.1" class="ltx_p">One approach to lossy encoding is to define a function that maps input names to output buckets, for example using the
ASCII character codes. Ideally, the function should have a near uniform output. One way to achieve this would be to use an HMAC and truncate it to an appropriate length for the number of buckets. For example, if you wanted 256 buckets you could truncate to the first 8 bits, and treat it as an integer.</p>
</div>
<div id="S5.p5" class="ltx_para">
<p id="S5.p5.1" class="ltx_p">The downside of the simple approach above is that it will to some degree replicate the frequency distribution of the input in the output, particularly for high frequency values. For example, the bucket with “Smith” will be detectable by looking for the most popular bucket (though other names may map to that bucket too). We simulated this approach using between 10, 50, 100 and 500 buckets. Smith was in the largest bucket every time.</p>
</div>
<div id="S5.p6" class="ltx_para">
<p id="S5.p6.1" class="ltx_p">One approach to mitigating this is to apply a more structured mapping that attempts to smooth the frequency distribution of the output. Such a mapping could combine less popular names together to create output buckets that are broadly of equal size. In such an approach the Name Manager produces, and the Librarian and Linker use, a table that lists the correspondence between name and bucket. Without that list, it should be hard to know what bucket contains what names.</p>
</div>
<div id="S5.p7" class="ltx_para">
<p id="S5.p7.1" class="ltx_p">One step of privacy protection is to keep the name-bucket correspondence secret; the other step is that many names have the same code, so extra information (such as age or location) is required to link an individual record.</p>
</div>
<div id="S5.p8" class="ltx_para">
<p id="S5.p8.1" class="ltx_p">However, this protection is quite easily reversed given some information about some people. Once one person has been re-identified based on other attributes such as their location and date of birth, the adversary can infer that everyone else with the same name is in the same bucket. It would only take a little auxiliary data, with a few successful re-identifications, to learn at least part of the name-bucket correspondence.</p>
</div>
<div id="S5.p9" class="ltx_para">
<dl id="S5.I1" class="ltx_description">
<dt id="S5.I1.ix1" class="ltx_item"><span class="ltx_tag ltx_tag_item"><span id="S5.I1.ix1.1.1.1" class="ltx_text ltx_font_bold">Information required to make the anonymised name/linkage file: </span></span></dt>
<dd class="ltx_item">
<div id="S5.I1.ix1.p1" class="ltx_para">
<p id="S5.I1.ix1.p1.1" class="ltx_p">the names.</p>
</div>
</dd>
<dt id="S5.I1.ix2" class="ltx_item"><span class="ltx_tag ltx_tag_item"><span id="S5.I1.ix2.1.1.1" class="ltx_text ltx_font_bold">Information required for linking:</span></span></dt>
<dd class="ltx_item">
<div id="S5.I1.ix2.p1" class="ltx_para">
<p id="S5.I1.ix2.p1.1" class="ltx_p">The table or function associating each name with its bucket, and also some other linkage variables such as age or location.</p>
</div>
</dd>
<dt id="S5.I1.ix3" class="ltx_item"><span class="ltx_tag ltx_tag_item"><span id="S5.I1.ix3.1.1.1" class="ltx_text ltx_font_bold">Information required for reversing:</span></span></dt>
<dd class="ltx_item">
<div id="S5.I1.ix3.p1" class="ltx_para">
<p id="S5.I1.ix3.p1.1" class="ltx_p">The name-bucket table, plus also some auxiliary information about the other linkage variables.</p>
</div>
</dd>
<dt id="S5.I1.ix4" class="ltx_item"><span class="ltx_tag ltx_tag_item"><span id="S5.I1.ix4.1.1.1" class="ltx_text ltx_font_bold">Ways of inhibiting unauthorised reversing or linking:</span></span></dt>
<dd class="ltx_item">
<div id="S5.I1.ix4.p1" class="ltx_para">
<p id="S5.I1.ix4.p1.1" class="ltx_p">Keeping the name-bucket table secret; encrypting other linkage variables. Unfortunately, unauthorised reversing or linking would be straightforward unless the other attributes were all encrypted.</p>
</div>
</dd>
<dt id="S5.I1.ix5" class="ltx_item"><span class="ltx_tag ltx_tag_item"><span id="S5.I1.ix5.1.1.1" class="ltx_text ltx_font_bold">Fuzzy matching: </span></span></dt>
<dd class="ltx_item">
<div id="S5.I1.ix5.p1" class="ltx_para">
<p id="S5.I1.ix5.p1.1" class="ltx_p">Possibly, depending on how the buckets were assigned. Fuzzy matching would come automatically if similar names could be assigned to the same bucket. However, it would be very difficult for names that were similar but assigned to different buckets.</p>
</div>
</dd>
<dt id="S5.I1.ix6" class="ltx_item"><span class="ltx_tag ltx_tag_item"><span id="S5.I1.ix6.1.1.1" class="ltx_text ltx_font_bold">Linking accuracy: </span></span></dt>
<dd class="ltx_item">
<div id="S5.I1.ix6.p1" class="ltx_para">
<p id="S5.I1.ix6.p1.1" class="ltx_p">Less than for full name matching. This could see an increase in false positives, particularly as a result of any overt frequency smoothing that has been applied. Accuracy would depend on how many other linkage variables were available.</p>
</div>
</dd>
<dt id="S5.I1.ix7" class="ltx_item"><span class="ltx_tag ltx_tag_item"><span id="S5.I1.ix7.1.1.1" class="ltx_text ltx_font_bold">Implementation difficulty: </span></span></dt>
<dd class="ltx_item">
<div id="S5.I1.ix7.p1" class="ltx_para">
<p id="S5.I1.ix7.p1.1" class="ltx_p">Depends on the method of generating the name-bucket table. This table would need to be stored in a secure way. The functional approach is simpler but remains susceptible to frequency attacks.</p>
</div>
</dd>
<dt id="S5.I1.ix8" class="ltx_item"><span class="ltx_tag ltx_tag_item"><span id="S5.I1.ix8.1.1.1" class="ltx_text ltx_font_bold">Computational Efficiency: </span></span></dt>
<dd class="ltx_item">
<div id="S5.I1.ix8.p1" class="ltx_para">
<p id="S5.I1.ix8.p1.1" class="ltx_p">Generating the table is probably quite efficient, depending on the method of generating the name-bucket table. However, the efficiency of the linking process could suffer because of the increased rate of false-positive matches.</p>
</div>
</dd>
<dt id="S5.I1.ix9" class="ltx_item"><span class="ltx_tag ltx_tag_item"><span id="S5.I1.ix9.1.1.1" class="ltx_text ltx_font_bold">Other advantages: </span></span></dt>
<dd class="ltx_item">
<div id="S5.I1.ix9.p1" class="ltx_para">
<p id="S5.I1.ix9.p1.1" class="ltx_p">Compliance with a literal interpretation of a name encoding that “cannot be reversed” to a unique name, if properly implemented.</p>
</div>
</dd>
<dt id="S5.I1.ix10" class="ltx_item"><span class="ltx_tag ltx_tag_item"><span id="S5.I1.ix10.1.1.1" class="ltx_text ltx_font_bold">Other disadvantages: </span></span></dt>
<dd class="ltx_item">
<div id="S5.I1.ix10.p1" class="ltx_para">
<p id="S5.I1.ix10.p1.1" class="ltx_p">Reduced accuracy of linking.</p>
</div>
</dd>
</dl>
</div>
<section id="S5.SS1" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">5.1 </span>An analysis of name frequencies and the implications of incorporating other variables</h3>

<div id="S5.SS1.p1" class="ltx_para">
<p id="S5.SS1.p1.1" class="ltx_p">As discussed above, most lossy encoding techniques remain susceptible to frequency attacks unless they are deliberately designed to produce buckets of equal size. In this section we look at how that could be achieved, and discuss some of the issues associated with it.</p>
</div>
<section id="S5.SS1.SSS1" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">5.1.1 </span>Input distribution equals output distribution</h4>

<div id="S5.SS1.SSS1.p1" class="ltx_para">
<p id="S5.SS1.SSS1.p1.1" class="ltx_p">If the mapping is deterministic, in that the same input is mapped to the same output each time, the input frequency distribution is largely replicated in the output. This is exactly what we want to avoid, since it leaks information and risks breaking down many-to-one relationship, at least probabilistically. For example, “Smith” is overwhelmingly the most popular last name, and whatever bin it is assigned to will be proportionally more popular than any others. As such, any row assigned to that bin has a high probability of being “Smith”. Attempting to create a uniform output distribution will likely lead to significant loss in accuracy. The frequency of “Smith” cannot be subdivided into multiple bins without increasing the false negative rate, so the only way to smooth the output distribution is to combine output bins to create the same large frequency. Looking at figure <a href="#S5.F1" title="Figure 1 ‣ 5.2 Summary ‣ 5 Option 2: Lossy encoding for names ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">1</span></a>, which shows the frequency distribution of last names in Australia it is clear that the dominance of “Smith” is an issue. In order to achieve a uniform output, or something close to uniform, it will require combining many low frequency names into a single bin. Even combining high values together, for example, “Jones” and “Williams” (the next two most popular names) will still result in a bin containing nearly 64 000 unique names. This will give high accuracy to popular names, but very poor accuracy to everything else. The skew in the input distribution is just too significant to meaningfully smooth it without a significant loss of accuracy.</p>
</div>
</section>
</section>
<section id="S5.SS2" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">5.2 </span>Summary</h3>

<div id="S5.SS2.p1" class="ltx_para">
<p id="S5.SS2.p1.1" class="ltx_p">The main advantage of lossy encoding is a literal adherence to the promise that the encoding of names “cannot be reversed.” Lossy encoding itself doesn’t significantly mitigate the risk of unauthorised linking—the same auxiliary information used for ABS linking could be used by an unauthorised attacker. It is therefore still very important to encrypt or otherwise protect the other variables.</p>
</div>
<figure id="S5.F1" class="ltx_figure"><img src="/html/1802.07975/assets/x1.png" id="S5.F1.g1" class="ltx_graphics ltx_centering ltx_img_landscape" width="461" height="262" alt="Refer to caption">
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure">Figure 1: </span>Frequency of last name</figcaption>
</figure>
</section>
</section>
<section id="S6" class="ltx_section">
<h2 class="ltx_title ltx_title_section">
<span class="ltx_tag ltx_tag_section">6 </span>Option 3: HMAC-based anonymised linkage identifiers using subsets of attributes</h2>

<div id="S6.p1" class="ltx_para">
<p id="S6.p1.1" class="ltx_p">In this section we describe a method for combining multiple attributes into a single anonymised linking identifier. This has many advantages for both computational efficiency and privacy. There is some degradation in linking quality compared to Option 1, but this may not be significant depending on how the linking identifiers are chosen. It could also be combined with a lossy encoding of names if required. The main advantage of this approach over plain lossy encoding is that the linking could be performed on the anonymised linking identifiers by a Linker that didn’t need to know the decryption key (though this would require some modifications to the current process).</p>
</div>
<section id="S6.SS1" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">6.1 </span>Smoothing the input distribution by including multiple attributes</h3>

<div id="S6.SS1.p1" class="ltx_para">
<p id="S6.SS1.p1.1" class="ltx_p">We want a distribution in which all inputs are unique. We can then assign those values to different outputs to maintain both privacy and accuracy. The only way to achieve this is to include many attributes in the input value. Combining first and last name will have some effect, although it will still display a skew. For example, there will be more “Steve Smith”s” than “Shanika Karunasekera”s. Also, birthdate correlates with first name because first names follow fashions that change over time.
The best idea is to combine many more fields into the input and then create multiple anonymised linking identifiers in an approach similar to that used by the UK Office of National Statistics (ONS). In <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib37" title="" class="ltx_ref">37</a>]</cite>
they create 11 anonymised linkage identifiers with various different parts of first, middle and last name, date of birth, postcode, and gender. They report a uniqueness value of at least 98% for all the linkage identifiers. The ONS do not perform a lossy encoding on those attributes, instead matching on them directly, but they could be lossy encoded.</p>
</div>
</section>
<section id="S6.SS2" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">6.2 </span>The cryptographic construction</h3>

<div id="S6.SS2.p1" class="ltx_para">
<p id="S6.SS2.p1.1" class="ltx_p">An HMAC is a function that takes a message and a secret key and returns a digest (often called a hash). We have explained elsewhere that, even without knowing the key, the HMAC of a list of names can be reversed because of frequency attacks.</p>
</div>
<div id="S6.SS2.p2" class="ltx_para">
<p id="S6.SS2.p2.1" class="ltx_p">Using unique inputs is a good way of mitigating frequency attacks on name-based HMAC. If you incorporate enough extra data, every record should be unique. Without the key, it could not be reversed (because an HMAC behaves like a random function in this case <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib6" title="" class="ltx_ref">6</a>]</cite>). With the key, it could be reversed only by knowing (or guessing) all the attributes in one hash/encryption.</p>
</div>
<div id="S6.SS2.p3" class="ltx_para">
<p id="S6.SS2.p3.1" class="ltx_p">The idea is similar to a technique in use by the UK ONS <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib37" title="" class="ltx_ref">37</a>]</cite>. It requires the secret key to be securely generated and carefully protected. The idea is, for each record, to produce several encodings using different combinations of variables (combined using the secret key) and store them all. For example, one might use first name, DoB and address; another might use surname, DoB and country of last residence.</p>
</div>
<div id="S6.SS2.p4" class="ltx_para">
<p id="S6.SS2.p4.1" class="ltx_p">For example, if <math id="S6.SS2.p4.1.m1.1" class="ltx_Math" alttext="k" display="inline"><semantics id="S6.SS2.p4.1.m1.1a"><mi id="S6.SS2.p4.1.m1.1.1" xref="S6.SS2.p4.1.m1.1.1.cmml">k</mi><annotation-xml encoding="MathML-Content" id="S6.SS2.p4.1.m1.1b"><ci id="S6.SS2.p4.1.m1.1.1.cmml" xref="S6.SS2.p4.1.m1.1.1">𝑘</ci></annotation-xml><annotation encoding="application/x-tex" id="S6.SS2.p4.1.m1.1c">k</annotation></semantics></math> is the secret key then the Linkage File for a particular Link ID could be computed as</p>
<table id="S6.Ex1" class="ltx_equation ltx_eqn_table">

<tbody><tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math id="S6.Ex1.m1.12" class="ltx_Math" alttext="\begin{array}[]{rl}\textit{Digest}_{1}&amp;=\textit{HMAC}_{k}(\textit{first-name},\textit{address},\textit{birth-year})\\
\textit{Digest}_{2}&amp;=\textit{HMAC}_{k}(\textit{first-name},\textit{last-name},\textit{address})\\
\textit{Digest}_{3}&amp;=\textit{HMAC}_{k}(\textit{country-of-last-residence},\textit{address},\textit{birth-year})\\
\textit{Digest}_{4}&amp;=\textit{HMAC}_{k}(\textit{first-name},\textit{last-name},\textit{birth-year})\\
\end{array}" display="block"><semantics id="S6.Ex1.m1.12a"><mtable columnspacing="5pt" displaystyle="true" rowspacing="0pt" id="S6.Ex1.m1.12.12" xref="S6.Ex1.m1.12.12.cmml"><mtr id="S6.Ex1.m1.12.12a" xref="S6.Ex1.m1.12.12.cmml"><mtd class="ltx_align_right" columnalign="right" id="S6.Ex1.m1.12.12b" xref="S6.Ex1.m1.12.12.cmml"><msub id="S6.Ex1.m1.3.3.3.4.1" xref="S6.Ex1.m1.3.3.3.4.1.cmml"><mtext class="ltx_mathvariant_italic" id="S6.Ex1.m1.3.3.3.4.1.2" xref="S6.Ex1.m1.3.3.3.4.1.2a.cmml">Digest</mtext><mn id="S6.Ex1.m1.3.3.3.4.1.3" xref="S6.Ex1.m1.3.3.3.4.1.3.cmml">1</mn></msub></mtd><mtd class="ltx_align_left" columnalign="left" id="S6.Ex1.m1.12.12c" xref="S6.Ex1.m1.12.12.cmml"><mrow id="S6.Ex1.m1.3.3.3.3.3" xref="S6.Ex1.m1.3.3.3.3.3.cmml"><mi id="S6.Ex1.m1.3.3.3.3.3.5" xref="S6.Ex1.m1.3.3.3.3.3.5.cmml"></mi><mo id="S6.Ex1.m1.3.3.3.3.3.4" xref="S6.Ex1.m1.3.3.3.3.3.4.cmml">=</mo><mrow id="S6.Ex1.m1.3.3.3.3.3.6" xref="S6.Ex1.m1.3.3.3.3.3.6.cmml"><msub id="S6.Ex1.m1.3.3.3.3.3.6.2" xref="S6.Ex1.m1.3.3.3.3.3.6.2.cmml"><mtext class="ltx_mathvariant_italic" id="S6.Ex1.m1.3.3.3.3.3.6.2.2" xref="S6.Ex1.m1.3.3.3.3.3.6.2.2a.cmml">HMAC</mtext><mi id="S6.Ex1.m1.3.3.3.3.3.6.2.3" xref="S6.Ex1.m1.3.3.3.3.3.6.2.3.cmml">k</mi></msub><mo lspace="0em" rspace="0em" id="S6.Ex1.m1.3.3.3.3.3.6.1" xref="S6.Ex1.m1.3.3.3.3.3.6.1.cmml">​</mo><mrow id="S6.Ex1.m1.3.3.3.3.3.6.3.2" xref="S6.Ex1.m1.3.3.3.3.3.6.3.1.cmml"><mo stretchy="false" id="S6.Ex1.m1.3.3.3.3.3.6.3.2.1" xref="S6.Ex1.m1.3.3.3.3.3.6.3.1.cmml">(</mo><mtext class="ltx_mathvariant_italic" id="S6.Ex1.m1.1.1.1.1.1.1" xref="S6.Ex1.m1.1.1.1.1.1.1a.cmml">first-name</mtext><mo id="S6.Ex1.m1.3.3.3.3.3.6.3.2.2" xref="S6.Ex1.m1.3.3.3.3.3.6.3.1.cmml">,</mo><mtext class="ltx_mathvariant_italic" id="S6.Ex1.m1.2.2.2.2.2.2" xref="S6.Ex1.m1.2.2.2.2.2.2a.cmml">address</mtext><mo id="S6.Ex1.m1.3.3.3.3.3.6.3.2.3" xref="S6.Ex1.m1.3.3.3.3.3.6.3.1.cmml">,</mo><mtext class="ltx_mathvariant_italic" id="S6.Ex1.m1.3.3.3.3.3.3" xref="S6.Ex1.m1.3.3.3.3.3.3a.cmml">birth-year</mtext><mo stretchy="false" id="S6.Ex1.m1.3.3.3.3.3.6.3.2.4" xref="S6.Ex1.m1.3.3.3.3.3.6.3.1.cmml">)</mo></mrow></mrow></mrow></mtd></mtr><mtr id="S6.Ex1.m1.12.12d" xref="S6.Ex1.m1.12.12.cmml"><mtd class="ltx_align_right" columnalign="right" id="S6.Ex1.m1.12.12e" xref="S6.Ex1.m1.12.12.cmml"><msub id="S6.Ex1.m1.6.6.6.4.1" xref="S6.Ex1.m1.6.6.6.4.1.cmml"><mtext class="ltx_mathvariant_italic" id="S6.Ex1.m1.6.6.6.4.1.2" xref="S6.Ex1.m1.6.6.6.4.1.2a.cmml">Digest</mtext><mn id="S6.Ex1.m1.6.6.6.4.1.3" xref="S6.Ex1.m1.6.6.6.4.1.3.cmml">2</mn></msub></mtd><mtd class="ltx_align_left" columnalign="left" id="S6.Ex1.m1.12.12f" xref="S6.Ex1.m1.12.12.cmml"><mrow id="S6.Ex1.m1.6.6.6.3.3" xref="S6.Ex1.m1.6.6.6.3.3.cmml"><mi id="S6.Ex1.m1.6.6.6.3.3.5" xref="S6.Ex1.m1.6.6.6.3.3.5.cmml"></mi><mo id="S6.Ex1.m1.6.6.6.3.3.4" xref="S6.Ex1.m1.6.6.6.3.3.4.cmml">=</mo><mrow id="S6.Ex1.m1.6.6.6.3.3.6" xref="S6.Ex1.m1.6.6.6.3.3.6.cmml"><msub id="S6.Ex1.m1.6.6.6.3.3.6.2" xref="S6.Ex1.m1.6.6.6.3.3.6.2.cmml"><mtext class="ltx_mathvariant_italic" id="S6.Ex1.m1.6.6.6.3.3.6.2.2" xref="S6.Ex1.m1.6.6.6.3.3.6.2.2a.cmml">HMAC</mtext><mi id="S6.Ex1.m1.6.6.6.3.3.6.2.3" xref="S6.Ex1.m1.6.6.6.3.3.6.2.3.cmml">k</mi></msub><mo lspace="0em" rspace="0em" id="S6.Ex1.m1.6.6.6.3.3.6.1" xref="S6.Ex1.m1.6.6.6.3.3.6.1.cmml">​</mo><mrow id="S6.Ex1.m1.6.6.6.3.3.6.3.2" xref="S6.Ex1.m1.6.6.6.3.3.6.3.1.cmml"><mo stretchy="false" id="S6.Ex1.m1.6.6.6.3.3.6.3.2.1" xref="S6.Ex1.m1.6.6.6.3.3.6.3.1.cmml">(</mo><mtext class="ltx_mathvariant_italic" id="S6.Ex1.m1.4.4.4.1.1.1" xref="S6.Ex1.m1.4.4.4.1.1.1a.cmml">first-name</mtext><mo id="S6.Ex1.m1.6.6.6.3.3.6.3.2.2" xref="S6.Ex1.m1.6.6.6.3.3.6.3.1.cmml">,</mo><mtext class="ltx_mathvariant_italic" id="S6.Ex1.m1.5.5.5.2.2.2" xref="S6.Ex1.m1.5.5.5.2.2.2a.cmml">last-name</mtext><mo id="S6.Ex1.m1.6.6.6.3.3.6.3.2.3" xref="S6.Ex1.m1.6.6.6.3.3.6.3.1.cmml">,</mo><mtext class="ltx_mathvariant_italic" id="S6.Ex1.m1.6.6.6.3.3.3" xref="S6.Ex1.m1.6.6.6.3.3.3a.cmml">address</mtext><mo stretchy="false" id="S6.Ex1.m1.6.6.6.3.3.6.3.2.4" xref="S6.Ex1.m1.6.6.6.3.3.6.3.1.cmml">)</mo></mrow></mrow></mrow></mtd></mtr><mtr id="S6.Ex1.m1.12.12g" xref="S6.Ex1.m1.12.12.cmml"><mtd class="ltx_align_right" columnalign="right" id="S6.Ex1.m1.12.12h" xref="S6.Ex1.m1.12.12.cmml"><msub id="S6.Ex1.m1.9.9.9.4.1" xref="S6.Ex1.m1.9.9.9.4.1.cmml"><mtext class="ltx_mathvariant_italic" id="S6.Ex1.m1.9.9.9.4.1.2" xref="S6.Ex1.m1.9.9.9.4.1.2a.cmml">Digest</mtext><mn id="S6.Ex1.m1.9.9.9.4.1.3" xref="S6.Ex1.m1.9.9.9.4.1.3.cmml">3</mn></msub></mtd><mtd class="ltx_align_left" columnalign="left" id="S6.Ex1.m1.12.12i" xref="S6.Ex1.m1.12.12.cmml"><mrow id="S6.Ex1.m1.9.9.9.3.3" xref="S6.Ex1.m1.9.9.9.3.3.cmml"><mi id="S6.Ex1.m1.9.9.9.3.3.5" xref="S6.Ex1.m1.9.9.9.3.3.5.cmml"></mi><mo id="S6.Ex1.m1.9.9.9.3.3.4" xref="S6.Ex1.m1.9.9.9.3.3.4.cmml">=</mo><mrow id="S6.Ex1.m1.9.9.9.3.3.6" xref="S6.Ex1.m1.9.9.9.3.3.6.cmml"><msub id="S6.Ex1.m1.9.9.9.3.3.6.2" xref="S6.Ex1.m1.9.9.9.3.3.6.2.cmml"><mtext class="ltx_mathvariant_italic" id="S6.Ex1.m1.9.9.9.3.3.6.2.2" xref="S6.Ex1.m1.9.9.9.3.3.6.2.2a.cmml">HMAC</mtext><mi id="S6.Ex1.m1.9.9.9.3.3.6.2.3" xref="S6.Ex1.m1.9.9.9.3.3.6.2.3.cmml">k</mi></msub><mo lspace="0em" rspace="0em" id="S6.Ex1.m1.9.9.9.3.3.6.1" xref="S6.Ex1.m1.9.9.9.3.3.6.1.cmml">​</mo><mrow id="S6.Ex1.m1.9.9.9.3.3.6.3.2" xref="S6.Ex1.m1.9.9.9.3.3.6.3.1.cmml"><mo stretchy="false" id="S6.Ex1.m1.9.9.9.3.3.6.3.2.1" xref="S6.Ex1.m1.9.9.9.3.3.6.3.1.cmml">(</mo><mtext class="ltx_mathvariant_italic" id="S6.Ex1.m1.7.7.7.1.1.1" xref="S6.Ex1.m1.7.7.7.1.1.1a.cmml">country-of-last-residence</mtext><mo id="S6.Ex1.m1.9.9.9.3.3.6.3.2.2" xref="S6.Ex1.m1.9.9.9.3.3.6.3.1.cmml">,</mo><mtext class="ltx_mathvariant_italic" id="S6.Ex1.m1.8.8.8.2.2.2" xref="S6.Ex1.m1.8.8.8.2.2.2a.cmml">address</mtext><mo id="S6.Ex1.m1.9.9.9.3.3.6.3.2.3" xref="S6.Ex1.m1.9.9.9.3.3.6.3.1.cmml">,</mo><mtext class="ltx_mathvariant_italic" id="S6.Ex1.m1.9.9.9.3.3.3" xref="S6.Ex1.m1.9.9.9.3.3.3a.cmml">birth-year</mtext><mo stretchy="false" id="S6.Ex1.m1.9.9.9.3.3.6.3.2.4" xref="S6.Ex1.m1.9.9.9.3.3.6.3.1.cmml">)</mo></mrow></mrow></mrow></mtd></mtr><mtr id="S6.Ex1.m1.12.12j" xref="S6.Ex1.m1.12.12.cmml"><mtd class="ltx_align_right" columnalign="right" id="S6.Ex1.m1.12.12k" xref="S6.Ex1.m1.12.12.cmml"><msub id="S6.Ex1.m1.12.12.12.4.1" xref="S6.Ex1.m1.12.12.12.4.1.cmml"><mtext class="ltx_mathvariant_italic" id="S6.Ex1.m1.12.12.12.4.1.2" xref="S6.Ex1.m1.12.12.12.4.1.2a.cmml">Digest</mtext><mn id="S6.Ex1.m1.12.12.12.4.1.3" xref="S6.Ex1.m1.12.12.12.4.1.3.cmml">4</mn></msub></mtd><mtd class="ltx_align_left" columnalign="left" id="S6.Ex1.m1.12.12l" xref="S6.Ex1.m1.12.12.cmml"><mrow id="S6.Ex1.m1.12.12.12.3.3" xref="S6.Ex1.m1.12.12.12.3.3.cmml"><mi id="S6.Ex1.m1.12.12.12.3.3.5" xref="S6.Ex1.m1.12.12.12.3.3.5.cmml"></mi><mo id="S6.Ex1.m1.12.12.12.3.3.4" xref="S6.Ex1.m1.12.12.12.3.3.4.cmml">=</mo><mrow id="S6.Ex1.m1.12.12.12.3.3.6" xref="S6.Ex1.m1.12.12.12.3.3.6.cmml"><msub id="S6.Ex1.m1.12.12.12.3.3.6.2" xref="S6.Ex1.m1.12.12.12.3.3.6.2.cmml"><mtext class="ltx_mathvariant_italic" id="S6.Ex1.m1.12.12.12.3.3.6.2.2" xref="S6.Ex1.m1.12.12.12.3.3.6.2.2a.cmml">HMAC</mtext><mi id="S6.Ex1.m1.12.12.12.3.3.6.2.3" xref="S6.Ex1.m1.12.12.12.3.3.6.2.3.cmml">k</mi></msub><mo lspace="0em" rspace="0em" id="S6.Ex1.m1.12.12.12.3.3.6.1" xref="S6.Ex1.m1.12.12.12.3.3.6.1.cmml">​</mo><mrow id="S6.Ex1.m1.12.12.12.3.3.6.3.2" xref="S6.Ex1.m1.12.12.12.3.3.6.3.1.cmml"><mo stretchy="false" id="S6.Ex1.m1.12.12.12.3.3.6.3.2.1" xref="S6.Ex1.m1.12.12.12.3.3.6.3.1.cmml">(</mo><mtext class="ltx_mathvariant_italic" id="S6.Ex1.m1.10.10.10.1.1.1" xref="S6.Ex1.m1.10.10.10.1.1.1a.cmml">first-name</mtext><mo id="S6.Ex1.m1.12.12.12.3.3.6.3.2.2" xref="S6.Ex1.m1.12.12.12.3.3.6.3.1.cmml">,</mo><mtext class="ltx_mathvariant_italic" id="S6.Ex1.m1.11.11.11.2.2.2" xref="S6.Ex1.m1.11.11.11.2.2.2a.cmml">last-name</mtext><mo id="S6.Ex1.m1.12.12.12.3.3.6.3.2.3" xref="S6.Ex1.m1.12.12.12.3.3.6.3.1.cmml">,</mo><mtext class="ltx_mathvariant_italic" id="S6.Ex1.m1.12.12.12.3.3.3" xref="S6.Ex1.m1.12.12.12.3.3.3a.cmml">birth-year</mtext><mo stretchy="false" id="S6.Ex1.m1.12.12.12.3.3.6.3.2.4" xref="S6.Ex1.m1.12.12.12.3.3.6.3.1.cmml">)</mo></mrow></mrow></mrow></mtd></mtr></mtable><annotation-xml encoding="MathML-Content" id="S6.Ex1.m1.12b"><matrix id="S6.Ex1.m1.12.12.cmml" xref="S6.Ex1.m1.12.12"><matrixrow id="S6.Ex1.m1.12.12a.cmml" xref="S6.Ex1.m1.12.12"><apply id="S6.Ex1.m1.3.3.3.4.1.cmml" xref="S6.Ex1.m1.3.3.3.4.1"><csymbol cd="ambiguous" id="S6.Ex1.m1.3.3.3.4.1.1.cmml" xref="S6.Ex1.m1.3.3.3.4.1">subscript</csymbol><ci id="S6.Ex1.m1.3.3.3.4.1.2a.cmml" xref="S6.Ex1.m1.3.3.3.4.1.2"><mtext class="ltx_mathvariant_italic" id="S6.Ex1.m1.3.3.3.4.1.2.cmml" xref="S6.Ex1.m1.3.3.3.4.1.2">Digest</mtext></ci><cn type="integer" id="S6.Ex1.m1.3.3.3.4.1.3.cmml" xref="S6.Ex1.m1.3.3.3.4.1.3">1</cn></apply><apply id="S6.Ex1.m1.3.3.3.3.3.cmml" xref="S6.Ex1.m1.3.3.3.3.3"><eq id="S6.Ex1.m1.3.3.3.3.3.4.cmml" xref="S6.Ex1.m1.3.3.3.3.3.4"></eq><csymbol cd="latexml" id="S6.Ex1.m1.3.3.3.3.3.5.cmml" xref="S6.Ex1.m1.3.3.3.3.3.5">absent</csymbol><apply id="S6.Ex1.m1.3.3.3.3.3.6.cmml" xref="S6.Ex1.m1.3.3.3.3.3.6"><times id="S6.Ex1.m1.3.3.3.3.3.6.1.cmml" xref="S6.Ex1.m1.3.3.3.3.3.6.1"></times><apply id="S6.Ex1.m1.3.3.3.3.3.6.2.cmml" xref="S6.Ex1.m1.3.3.3.3.3.6.2"><csymbol cd="ambiguous" id="S6.Ex1.m1.3.3.3.3.3.6.2.1.cmml" xref="S6.Ex1.m1.3.3.3.3.3.6.2">subscript</csymbol><ci id="S6.Ex1.m1.3.3.3.3.3.6.2.2a.cmml" xref="S6.Ex1.m1.3.3.3.3.3.6.2.2"><mtext class="ltx_mathvariant_italic" id="S6.Ex1.m1.3.3.3.3.3.6.2.2.cmml" xref="S6.Ex1.m1.3.3.3.3.3.6.2.2">HMAC</mtext></ci><ci id="S6.Ex1.m1.3.3.3.3.3.6.2.3.cmml" xref="S6.Ex1.m1.3.3.3.3.3.6.2.3">𝑘</ci></apply><vector id="S6.Ex1.m1.3.3.3.3.3.6.3.1.cmml" xref="S6.Ex1.m1.3.3.3.3.3.6.3.2"><ci id="S6.Ex1.m1.1.1.1.1.1.1a.cmml" xref="S6.Ex1.m1.1.1.1.1.1.1"><mtext class="ltx_mathvariant_italic" id="S6.Ex1.m1.1.1.1.1.1.1.cmml" xref="S6.Ex1.m1.1.1.1.1.1.1">first-name</mtext></ci><ci id="S6.Ex1.m1.2.2.2.2.2.2a.cmml" xref="S6.Ex1.m1.2.2.2.2.2.2"><mtext class="ltx_mathvariant_italic" id="S6.Ex1.m1.2.2.2.2.2.2.cmml" xref="S6.Ex1.m1.2.2.2.2.2.2">address</mtext></ci><ci id="S6.Ex1.m1.3.3.3.3.3.3a.cmml" xref="S6.Ex1.m1.3.3.3.3.3.3"><mtext class="ltx_mathvariant_italic" id="S6.Ex1.m1.3.3.3.3.3.3.cmml" xref="S6.Ex1.m1.3.3.3.3.3.3">birth-year</mtext></ci></vector></apply></apply></matrixrow><matrixrow id="S6.Ex1.m1.12.12b.cmml" xref="S6.Ex1.m1.12.12"><apply id="S6.Ex1.m1.6.6.6.4.1.cmml" xref="S6.Ex1.m1.6.6.6.4.1"><csymbol cd="ambiguous" id="S6.Ex1.m1.6.6.6.4.1.1.cmml" xref="S6.Ex1.m1.6.6.6.4.1">subscript</csymbol><ci id="S6.Ex1.m1.6.6.6.4.1.2a.cmml" xref="S6.Ex1.m1.6.6.6.4.1.2"><mtext class="ltx_mathvariant_italic" id="S6.Ex1.m1.6.6.6.4.1.2.cmml" xref="S6.Ex1.m1.6.6.6.4.1.2">Digest</mtext></ci><cn type="integer" id="S6.Ex1.m1.6.6.6.4.1.3.cmml" xref="S6.Ex1.m1.6.6.6.4.1.3">2</cn></apply><apply id="S6.Ex1.m1.6.6.6.3.3.cmml" xref="S6.Ex1.m1.6.6.6.3.3"><eq id="S6.Ex1.m1.6.6.6.3.3.4.cmml" xref="S6.Ex1.m1.6.6.6.3.3.4"></eq><csymbol cd="latexml" id="S6.Ex1.m1.6.6.6.3.3.5.cmml" xref="S6.Ex1.m1.6.6.6.3.3.5">absent</csymbol><apply id="S6.Ex1.m1.6.6.6.3.3.6.cmml" xref="S6.Ex1.m1.6.6.6.3.3.6"><times id="S6.Ex1.m1.6.6.6.3.3.6.1.cmml" xref="S6.Ex1.m1.6.6.6.3.3.6.1"></times><apply id="S6.Ex1.m1.6.6.6.3.3.6.2.cmml" xref="S6.Ex1.m1.6.6.6.3.3.6.2"><csymbol cd="ambiguous" id="S6.Ex1.m1.6.6.6.3.3.6.2.1.cmml" xref="S6.Ex1.m1.6.6.6.3.3.6.2">subscript</csymbol><ci id="S6.Ex1.m1.6.6.6.3.3.6.2.2a.cmml" xref="S6.Ex1.m1.6.6.6.3.3.6.2.2"><mtext class="ltx_mathvariant_italic" id="S6.Ex1.m1.6.6.6.3.3.6.2.2.cmml" xref="S6.Ex1.m1.6.6.6.3.3.6.2.2">HMAC</mtext></ci><ci id="S6.Ex1.m1.6.6.6.3.3.6.2.3.cmml" xref="S6.Ex1.m1.6.6.6.3.3.6.2.3">𝑘</ci></apply><vector id="S6.Ex1.m1.6.6.6.3.3.6.3.1.cmml" xref="S6.Ex1.m1.6.6.6.3.3.6.3.2"><ci id="S6.Ex1.m1.4.4.4.1.1.1a.cmml" xref="S6.Ex1.m1.4.4.4.1.1.1"><mtext class="ltx_mathvariant_italic" id="S6.Ex1.m1.4.4.4.1.1.1.cmml" xref="S6.Ex1.m1.4.4.4.1.1.1">first-name</mtext></ci><ci id="S6.Ex1.m1.5.5.5.2.2.2a.cmml" xref="S6.Ex1.m1.5.5.5.2.2.2"><mtext class="ltx_mathvariant_italic" id="S6.Ex1.m1.5.5.5.2.2.2.cmml" xref="S6.Ex1.m1.5.5.5.2.2.2">last-name</mtext></ci><ci id="S6.Ex1.m1.6.6.6.3.3.3a.cmml" xref="S6.Ex1.m1.6.6.6.3.3.3"><mtext class="ltx_mathvariant_italic" id="S6.Ex1.m1.6.6.6.3.3.3.cmml" xref="S6.Ex1.m1.6.6.6.3.3.3">address</mtext></ci></vector></apply></apply></matrixrow><matrixrow id="S6.Ex1.m1.12.12c.cmml" xref="S6.Ex1.m1.12.12"><apply id="S6.Ex1.m1.9.9.9.4.1.cmml" xref="S6.Ex1.m1.9.9.9.4.1"><csymbol cd="ambiguous" id="S6.Ex1.m1.9.9.9.4.1.1.cmml" xref="S6.Ex1.m1.9.9.9.4.1">subscript</csymbol><ci id="S6.Ex1.m1.9.9.9.4.1.2a.cmml" xref="S6.Ex1.m1.9.9.9.4.1.2"><mtext class="ltx_mathvariant_italic" id="S6.Ex1.m1.9.9.9.4.1.2.cmml" xref="S6.Ex1.m1.9.9.9.4.1.2">Digest</mtext></ci><cn type="integer" id="S6.Ex1.m1.9.9.9.4.1.3.cmml" xref="S6.Ex1.m1.9.9.9.4.1.3">3</cn></apply><apply id="S6.Ex1.m1.9.9.9.3.3.cmml" xref="S6.Ex1.m1.9.9.9.3.3"><eq id="S6.Ex1.m1.9.9.9.3.3.4.cmml" xref="S6.Ex1.m1.9.9.9.3.3.4"></eq><csymbol cd="latexml" id="S6.Ex1.m1.9.9.9.3.3.5.cmml" xref="S6.Ex1.m1.9.9.9.3.3.5">absent</csymbol><apply id="S6.Ex1.m1.9.9.9.3.3.6.cmml" xref="S6.Ex1.m1.9.9.9.3.3.6"><times id="S6.Ex1.m1.9.9.9.3.3.6.1.cmml" xref="S6.Ex1.m1.9.9.9.3.3.6.1"></times><apply id="S6.Ex1.m1.9.9.9.3.3.6.2.cmml" xref="S6.Ex1.m1.9.9.9.3.3.6.2"><csymbol cd="ambiguous" id="S6.Ex1.m1.9.9.9.3.3.6.2.1.cmml" xref="S6.Ex1.m1.9.9.9.3.3.6.2">subscript</csymbol><ci id="S6.Ex1.m1.9.9.9.3.3.6.2.2a.cmml" xref="S6.Ex1.m1.9.9.9.3.3.6.2.2"><mtext class="ltx_mathvariant_italic" id="S6.Ex1.m1.9.9.9.3.3.6.2.2.cmml" xref="S6.Ex1.m1.9.9.9.3.3.6.2.2">HMAC</mtext></ci><ci id="S6.Ex1.m1.9.9.9.3.3.6.2.3.cmml" xref="S6.Ex1.m1.9.9.9.3.3.6.2.3">𝑘</ci></apply><vector id="S6.Ex1.m1.9.9.9.3.3.6.3.1.cmml" xref="S6.Ex1.m1.9.9.9.3.3.6.3.2"><ci id="S6.Ex1.m1.7.7.7.1.1.1a.cmml" xref="S6.Ex1.m1.7.7.7.1.1.1"><mtext class="ltx_mathvariant_italic" id="S6.Ex1.m1.7.7.7.1.1.1.cmml" xref="S6.Ex1.m1.7.7.7.1.1.1">country-of-last-residence</mtext></ci><ci id="S6.Ex1.m1.8.8.8.2.2.2a.cmml" xref="S6.Ex1.m1.8.8.8.2.2.2"><mtext class="ltx_mathvariant_italic" id="S6.Ex1.m1.8.8.8.2.2.2.cmml" xref="S6.Ex1.m1.8.8.8.2.2.2">address</mtext></ci><ci id="S6.Ex1.m1.9.9.9.3.3.3a.cmml" xref="S6.Ex1.m1.9.9.9.3.3.3"><mtext class="ltx_mathvariant_italic" id="S6.Ex1.m1.9.9.9.3.3.3.cmml" xref="S6.Ex1.m1.9.9.9.3.3.3">birth-year</mtext></ci></vector></apply></apply></matrixrow><matrixrow id="S6.Ex1.m1.12.12d.cmml" xref="S6.Ex1.m1.12.12"><apply id="S6.Ex1.m1.12.12.12.4.1.cmml" xref="S6.Ex1.m1.12.12.12.4.1"><csymbol cd="ambiguous" id="S6.Ex1.m1.12.12.12.4.1.1.cmml" xref="S6.Ex1.m1.12.12.12.4.1">subscript</csymbol><ci id="S6.Ex1.m1.12.12.12.4.1.2a.cmml" xref="S6.Ex1.m1.12.12.12.4.1.2"><mtext class="ltx_mathvariant_italic" id="S6.Ex1.m1.12.12.12.4.1.2.cmml" xref="S6.Ex1.m1.12.12.12.4.1.2">Digest</mtext></ci><cn type="integer" id="S6.Ex1.m1.12.12.12.4.1.3.cmml" xref="S6.Ex1.m1.12.12.12.4.1.3">4</cn></apply><apply id="S6.Ex1.m1.12.12.12.3.3.cmml" xref="S6.Ex1.m1.12.12.12.3.3"><eq id="S6.Ex1.m1.12.12.12.3.3.4.cmml" xref="S6.Ex1.m1.12.12.12.3.3.4"></eq><csymbol cd="latexml" id="S6.Ex1.m1.12.12.12.3.3.5.cmml" xref="S6.Ex1.m1.12.12.12.3.3.5">absent</csymbol><apply id="S6.Ex1.m1.12.12.12.3.3.6.cmml" xref="S6.Ex1.m1.12.12.12.3.3.6"><times id="S6.Ex1.m1.12.12.12.3.3.6.1.cmml" xref="S6.Ex1.m1.12.12.12.3.3.6.1"></times><apply id="S6.Ex1.m1.12.12.12.3.3.6.2.cmml" xref="S6.Ex1.m1.12.12.12.3.3.6.2"><csymbol cd="ambiguous" id="S6.Ex1.m1.12.12.12.3.3.6.2.1.cmml" xref="S6.Ex1.m1.12.12.12.3.3.6.2">subscript</csymbol><ci id="S6.Ex1.m1.12.12.12.3.3.6.2.2a.cmml" xref="S6.Ex1.m1.12.12.12.3.3.6.2.2"><mtext class="ltx_mathvariant_italic" id="S6.Ex1.m1.12.12.12.3.3.6.2.2.cmml" xref="S6.Ex1.m1.12.12.12.3.3.6.2.2">HMAC</mtext></ci><ci id="S6.Ex1.m1.12.12.12.3.3.6.2.3.cmml" xref="S6.Ex1.m1.12.12.12.3.3.6.2.3">𝑘</ci></apply><vector id="S6.Ex1.m1.12.12.12.3.3.6.3.1.cmml" xref="S6.Ex1.m1.12.12.12.3.3.6.3.2"><ci id="S6.Ex1.m1.10.10.10.1.1.1a.cmml" xref="S6.Ex1.m1.10.10.10.1.1.1"><mtext class="ltx_mathvariant_italic" id="S6.Ex1.m1.10.10.10.1.1.1.cmml" xref="S6.Ex1.m1.10.10.10.1.1.1">first-name</mtext></ci><ci id="S6.Ex1.m1.11.11.11.2.2.2a.cmml" xref="S6.Ex1.m1.11.11.11.2.2.2"><mtext class="ltx_mathvariant_italic" id="S6.Ex1.m1.11.11.11.2.2.2.cmml" xref="S6.Ex1.m1.11.11.11.2.2.2">last-name</mtext></ci><ci id="S6.Ex1.m1.12.12.12.3.3.3a.cmml" xref="S6.Ex1.m1.12.12.12.3.3.3"><mtext class="ltx_mathvariant_italic" id="S6.Ex1.m1.12.12.12.3.3.3.cmml" xref="S6.Ex1.m1.12.12.12.3.3.3">birth-year</mtext></ci></vector></apply></apply></matrixrow></matrix></annotation-xml><annotation encoding="application/x-tex" id="S6.Ex1.m1.12c">\begin{array}[]{rl}\textit{Digest}_{1}&amp;=\textit{HMAC}_{k}(\textit{first-name},\textit{address},\textit{birth-year})\\
\textit{Digest}_{2}&amp;=\textit{HMAC}_{k}(\textit{first-name},\textit{last-name},\textit{address})\\
\textit{Digest}_{3}&amp;=\textit{HMAC}_{k}(\textit{country-of-last-residence},\textit{address},\textit{birth-year})\\
\textit{Digest}_{4}&amp;=\textit{HMAC}_{k}(\textit{first-name},\textit{last-name},\textit{birth-year})\\
\end{array}</annotation></semantics></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr></tbody>
</table>
<p id="S6.SS2.p4.2" class="ltx_p">or whatever other combinations of variables seemed useful.</p>
</div>
<div id="S6.SS2.p5" class="ltx_para">
<p id="S6.SS2.p5.1" class="ltx_p">When a new database is linked, the same computation is repeated on the incoming variables.
If the person has changed address, for example, the digests that use address will not match, but other digests should. If their surname has been mistyped, then the digests that don’t use surname or only use the first two letters might match.
We assume the Linker has access to the plaintext of the dataset to be linked. So information about how common each name is, or how likely it is that a certain name has been mistyped, <span id="S6.SS2.p5.1.1" class="ltx_text ltx_font_italic">etc.</span> could be derived from the non-Census data. Then it makes a linking decision based on how many collections of attributes seem to match and which ones it expects to have changed.</p>
</div>
<div id="S6.SS2.p6" class="ltx_para">
<p id="S6.SS2.p6.1" class="ltx_p">This technique could be combined with preprocessing of names for fuzzy matching, for example the n-gram approach of <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib43" title="" class="ltx_ref">43</a>]</cite>, or with known common transcription errors such as the reversal of names. The linker could try likely misspellings of names at linking time if the given one didn’t match. For example, given an input name “Smithe” the linking could be attempted using “Smithe” and, if it failed, re-attempted with “Smith” then “Smythe” <span id="S6.SS2.p6.1.1" class="ltx_text ltx_font_italic">etc.</span> The same technique could be applied to other variables that may not quite match. For example, when comparing 2021 ages with 2016 ages, you could subtract 4,5 and 6 years from the ages before recomputing the hash/encryption. Dealing with typographical and transcription errors in names is harder, because you need to guess what they were.
Name standardisation should help but may never produce results as good as having both names in the clear.</p>
</div>
<div id="S6.SS2.p7" class="ltx_para">
<p id="S6.SS2.p7.1" class="ltx_p">Ideally this would be handled by careful selection and construction of the encodings. The attributes should be selected to handle the typical distortions seen in the datasets. Where the above would potentially be useful is where there are compounded distortions, <span id="S6.SS2.p7.1.1" class="ltx_text ltx_font_italic">e.g.</span> someone has moved, changed their name and mistyped their firstname.</p>
</div>
<div id="S6.SS2.p8" class="ltx_para">
<p id="S6.SS2.p8.1" class="ltx_p">Obviously the anonymised linkage identifiers are not conditionally independent—if one attribute changes, then several linkage identifiers might change. This complicates the analysis for matching—it means that when a record matches some, but not all, linkage identifiers, a careful inference must be made about which attribute(s) might have changed. In Deterministic linking, multiple potential links will not be linked. In probabilistic linking, quality measures usually depend on the strength of each linking variable. This needs to be adapted to give a quality measure to each collection of variables. Also, mismatches among independent collections should be regarded as much more important than mismatches among related collections. For example, if every identifier involving address fails to match, but all the other ones do match, then the person has probably moved; if a similar number of mismatches occur, but do not all have a common variable, then at least two variables must have changed and it is less likely to be the same person.</p>
</div>
<div id="S6.SS2.p9" class="ltx_para">
<dl id="S6.I1" class="ltx_description">
<dt id="S6.I1.ix1" class="ltx_item"><span class="ltx_tag ltx_tag_item"><span id="S6.I1.ix1.1.1.1" class="ltx_text ltx_font_bold">Information required to make the encoded name (and other data) file: </span></span></dt>
<dd class="ltx_item">
<div id="S6.I1.ix1.p1" class="ltx_para">
<p id="S6.I1.ix1.p1.1" class="ltx_p">The HMAC secret key, the names and other linkage variables. (Note that this technique only works by combining names with at least some other variables.)</p>
</div>
</dd>
<dt id="S6.I1.ix2" class="ltx_item"><span class="ltx_tag ltx_tag_item"><span id="S6.I1.ix2.1.1.1" class="ltx_text ltx_font_bold">Information required for linking:</span></span></dt>
<dd class="ltx_item">
<div id="S6.I1.ix2.p1" class="ltx_para">
<p id="S6.I1.ix2.p1.1" class="ltx_p">The HMAC secret key plus some name and linkage variables from the incoming dataset.</p>
</div>
</dd>
<dt id="S6.I1.ix3" class="ltx_item"><span class="ltx_tag ltx_tag_item"><span id="S6.I1.ix3.1.1.1" class="ltx_text ltx_font_bold">Information required for reversing:</span></span></dt>
<dd class="ltx_item">
<div id="S6.I1.ix3.p1" class="ltx_para">
<p id="S6.I1.ix3.p1.1" class="ltx_p">Either frequency information on collections of variables (we would aim for this to be nearly uniform) or the HMAC secret key combined with a successful guess of at least one collection of variables.</p>
</div>
</dd>
<dt id="S6.I1.ix4" class="ltx_item"><span class="ltx_tag ltx_tag_item"><span id="S6.I1.ix4.1.1.1" class="ltx_text ltx_font_bold">Ways of inhibiting unauthorised reversing or linking:</span></span></dt>
<dd class="ltx_item">
<div id="S6.I1.ix4.p1" class="ltx_para">
<p id="S6.I1.ix4.p1.1" class="ltx_p">Keeping the key secret; ensuring that the encodings incorporate several variables.</p>
</div>
</dd>
<dt id="S6.I1.ix5" class="ltx_item"><span class="ltx_tag ltx_tag_item"><span id="S6.I1.ix5.1.1.1" class="ltx_text ltx_font_bold">Fuzzy matching: </span></span></dt>
<dd class="ltx_item">
<div id="S6.I1.ix5.p1" class="ltx_para">
<p id="S6.I1.ix5.p1.1" class="ltx_p">Yes, the linking identifiers already provide some fuzzy matching. The ONS report a very high rate of matching on the linking identifiers alone.
Furthermore, if a perfect match was not possible, the incoming names could be slightly perturbed and retried. This would not be quite as accurate as plaintext name matching, but could be quite good in practice.</p>
</div>
</dd>
<dt id="S6.I1.ix6" class="ltx_item"><span class="ltx_tag ltx_tag_item"><span id="S6.I1.ix6.1.1.1" class="ltx_text ltx_font_bold">Linking accuracy: </span></span></dt>
<dd class="ltx_item">
<div id="S6.I1.ix6.p1" class="ltx_para">
<p id="S6.I1.ix6.p1.1" class="ltx_p">It depends on which attributes are included in the HMAC digests. This would need some empirical investigation, the greater the degree of uniqueness the better the accuracy. A key which does not provide sufficient uniqueness not only risks privacy through frequency attacks, but also impacts on accuracy by causing false positives.</p>
</div>
</dd>
<dt id="S6.I1.ix7" class="ltx_item"><span class="ltx_tag ltx_tag_item"><span id="S6.I1.ix7.1.1.1" class="ltx_text ltx_font_bold">Implementation difficulty: </span></span></dt>
<dd class="ltx_item">
<div id="S6.I1.ix7.p1" class="ltx_para">
<p id="S6.I1.ix7.p1.1" class="ltx_p">Similar to encryption. It would need careful generation and management of the HMAC key and professional implementation of the cryptography. Possibly it could use existing libraries from the SIAM/SBTP project—this would need to be checked.</p>
</div>
</dd>
<dt id="S6.I1.ix8" class="ltx_item"><span class="ltx_tag ltx_tag_item"><span id="S6.I1.ix8.1.1.1" class="ltx_text ltx_font_bold">Computational Efficiency: </span></span></dt>
<dd class="ltx_item">
<div id="S6.I1.ix8.p1" class="ltx_para">
<p id="S6.I1.ix8.p1.1" class="ltx_p">Currently the most efficient approach we have (more efficient than plaintext similarity matching). This is largely due to it being deterministic matching, allowing extremely efficient matching on very large sets without requiring cross comparisons. It is efficient enough that it may not require any blocking, allowing whole population linking.
We will discuss further in a later section. We require further analysis to establish the accuracy of the approach on very large sets.</p>
</div>
</dd>
<dt id="S6.I1.ix9" class="ltx_item"><span class="ltx_tag ltx_tag_item"><span id="S6.I1.ix9.1.1.1" class="ltx_text ltx_font_bold">Other advantages: </span></span></dt>
<dd class="ltx_item">
<div id="S6.I1.ix9.p1" class="ltx_para">
<p id="S6.I1.ix9.p1.1" class="ltx_p">The main advantage of this over simply applying HMAC to each name separately is the mitigation of frequency attacks, if properly implemented. It also means that, even if the HMAC secret key was compromised, an attacker would need to guess all of the attributes for one of the digests in order to recover the name.</p>
</div>
</dd>
<dt id="S6.I1.ix10" class="ltx_item"><span class="ltx_tag ltx_tag_item"><span id="S6.I1.ix10.1.1.1" class="ltx_text ltx_font_bold">Other disadvantages: </span></span></dt>
<dd class="ltx_item">
<div id="S6.I1.ix10.p1" class="ltx_para">
<p id="S6.I1.ix10.p1.1" class="ltx_p">This structure would not be directly useful for computing the statistical data necessary for assessing the accuracy of probabilistic linking. Some of those values could be computed independently, but the ones involving names could not.</p>
</div>
</dd>
</dl>
</div>
</section>
<section id="S6.SS3" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">6.3 </span>Defending against frequency attacks</h3>

<div id="S6.SS3.p1" class="ltx_para">
<p id="S6.SS3.p1.1" class="ltx_p">Even for an attacker without the key, HMACs are subject to frequency attacks. The technique described in this section is secure only if a large enough collection of attributes is chosen to make the linkage identifiers entirely unique. Section <a href="#S2.SS1.SSS3" title="2.1.3 Determinism and frequency attacks ‣ 2.1 How cryptographic hashes of names can be reversed ‣ 2 Background on Cryptography and possible attacks ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">2.1.3</span></a> described frequency attacks as applying to very frequent names, but the same problem occurs in sets of almost-unique identifiers with one or two repeated values. Suppose for example that two people with the same first and last name live at the same address, which happens occasionally in cultures where children are named precisely after their parents. Then a digest incorporating first name, last name and address would be almost entirely unique except for those households. This would allow those individuals to be isolated among a small set of possible records.</p>
</div>
<div id="S6.SS3.p2" class="ltx_para">
<p id="S6.SS3.p2.1" class="ltx_p">At the time of building the digests, it is critically important to check for duplicates. If there are any, then records should be removed until all the digests are unique—this obviously lowers linking accuracy, but is critical for preventing frequency attacks. If there are too many duplicates to remove, then that collection of variables should not be used for a linking identifier.</p>
</div>
<div id="S6.SS3.p3" class="ltx_para">
<p id="S6.SS3.p3.1" class="ltx_p">This is the reason that a fairly large number of attributes need to be included in each digest. Empirical testing, on the spot, could determine which collections produced unique (or close enough to unique) outputs.</p>
</div>
</section>
<section id="S6.SS4" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">6.4 </span>Deterministic linking - performance advantages</h3>

<div id="S6.SS4.p1" class="ltx_para">
<p id="S6.SS4.p1.1" class="ltx_p">The linking identifiers could be stored in a database, with the corresponding original recordId as a field. Since most of the linking identifiers are unique they constitute an excellent record identifier, which can be effectively indexed. This is a critical performance advantage in practice: a database index allows the record to be found in a single lookup, rather than by searching through the entire list of millions of values until a match is found. When performing the linking, we only need to iterate over the incoming records and perform a single query for each of its record linking identifiers. Those queries are extremely quick because they are just looking up an index.</p>
</div>
<div id="S6.SS4.p2" class="ltx_para">
<p id="S6.SS4.p2.1" class="ltx_p">The database could be used directly as both the Anonymised Name File and the Linkage File in ABS’s current process. It also obviates the need for a separate Linkage Concordance file, though this could be included if desired.</p>
</div>
<div id="S6.SS4.p3" class="ltx_para">
<p id="S6.SS4.p3.1" class="ltx_p">One of the advantages of this approach is that it allows deterministic linking, whilst still handling some degree of distortion. Deterministic linking is considerably more efficient because it can be achieved by indexing the database by each encoding, thus avoiding a full cross comparison of the two datasets.</p>
</div>
<div id="S6.SS4.p4" class="ltx_para">
<p id="S6.SS4.p4.1" class="ltx_p">By way of an example, if we wanted to link the 2.9 million records in our sample dataset it would require a maximum of approximately 32 million queries. On a multi-core desktop machine we are able to perform those queries and the necessary linking in under 15 minutes. If we compare that to any scheme that involves cross comparison, we would have to perform <math id="S6.SS4.p4.1.m1.1" class="ltx_Math" alttext="(2.9\text{ million})^{2}/2=4205000000000" display="inline"><semantics id="S6.SS4.p4.1.m1.1a"><mrow id="S6.SS4.p4.1.m1.1.1" xref="S6.SS4.p4.1.m1.1.1.cmml"><mrow id="S6.SS4.p4.1.m1.1.1.1" xref="S6.SS4.p4.1.m1.1.1.1.cmml"><msup id="S6.SS4.p4.1.m1.1.1.1.1" xref="S6.SS4.p4.1.m1.1.1.1.1.cmml"><mrow id="S6.SS4.p4.1.m1.1.1.1.1.1.1" xref="S6.SS4.p4.1.m1.1.1.1.1.1.1.1.cmml"><mo stretchy="false" id="S6.SS4.p4.1.m1.1.1.1.1.1.1.2" xref="S6.SS4.p4.1.m1.1.1.1.1.1.1.1.cmml">(</mo><mrow id="S6.SS4.p4.1.m1.1.1.1.1.1.1.1" xref="S6.SS4.p4.1.m1.1.1.1.1.1.1.1.cmml"><mn id="S6.SS4.p4.1.m1.1.1.1.1.1.1.1.2" xref="S6.SS4.p4.1.m1.1.1.1.1.1.1.1.2.cmml">2.9</mn><mo lspace="0em" rspace="0em" id="S6.SS4.p4.1.m1.1.1.1.1.1.1.1.1" xref="S6.SS4.p4.1.m1.1.1.1.1.1.1.1.1.cmml">​</mo><mtext id="S6.SS4.p4.1.m1.1.1.1.1.1.1.1.3" xref="S6.SS4.p4.1.m1.1.1.1.1.1.1.1.3a.cmml"> million</mtext></mrow><mo stretchy="false" id="S6.SS4.p4.1.m1.1.1.1.1.1.1.3" xref="S6.SS4.p4.1.m1.1.1.1.1.1.1.1.cmml">)</mo></mrow><mn id="S6.SS4.p4.1.m1.1.1.1.1.3" xref="S6.SS4.p4.1.m1.1.1.1.1.3.cmml">2</mn></msup><mo id="S6.SS4.p4.1.m1.1.1.1.2" xref="S6.SS4.p4.1.m1.1.1.1.2.cmml">/</mo><mn id="S6.SS4.p4.1.m1.1.1.1.3" xref="S6.SS4.p4.1.m1.1.1.1.3.cmml">2</mn></mrow><mo id="S6.SS4.p4.1.m1.1.1.2" xref="S6.SS4.p4.1.m1.1.1.2.cmml">=</mo><mn id="S6.SS4.p4.1.m1.1.1.3" xref="S6.SS4.p4.1.m1.1.1.3.cmml">4205000000000</mn></mrow><annotation-xml encoding="MathML-Content" id="S6.SS4.p4.1.m1.1b"><apply id="S6.SS4.p4.1.m1.1.1.cmml" xref="S6.SS4.p4.1.m1.1.1"><eq id="S6.SS4.p4.1.m1.1.1.2.cmml" xref="S6.SS4.p4.1.m1.1.1.2"></eq><apply id="S6.SS4.p4.1.m1.1.1.1.cmml" xref="S6.SS4.p4.1.m1.1.1.1"><divide id="S6.SS4.p4.1.m1.1.1.1.2.cmml" xref="S6.SS4.p4.1.m1.1.1.1.2"></divide><apply id="S6.SS4.p4.1.m1.1.1.1.1.cmml" xref="S6.SS4.p4.1.m1.1.1.1.1"><csymbol cd="ambiguous" id="S6.SS4.p4.1.m1.1.1.1.1.2.cmml" xref="S6.SS4.p4.1.m1.1.1.1.1">superscript</csymbol><apply id="S6.SS4.p4.1.m1.1.1.1.1.1.1.1.cmml" xref="S6.SS4.p4.1.m1.1.1.1.1.1.1"><times id="S6.SS4.p4.1.m1.1.1.1.1.1.1.1.1.cmml" xref="S6.SS4.p4.1.m1.1.1.1.1.1.1.1.1"></times><cn type="float" id="S6.SS4.p4.1.m1.1.1.1.1.1.1.1.2.cmml" xref="S6.SS4.p4.1.m1.1.1.1.1.1.1.1.2">2.9</cn><ci id="S6.SS4.p4.1.m1.1.1.1.1.1.1.1.3a.cmml" xref="S6.SS4.p4.1.m1.1.1.1.1.1.1.1.3"><mtext id="S6.SS4.p4.1.m1.1.1.1.1.1.1.1.3.cmml" xref="S6.SS4.p4.1.m1.1.1.1.1.1.1.1.3"> million</mtext></ci></apply><cn type="integer" id="S6.SS4.p4.1.m1.1.1.1.1.3.cmml" xref="S6.SS4.p4.1.m1.1.1.1.1.3">2</cn></apply><cn type="integer" id="S6.SS4.p4.1.m1.1.1.1.3.cmml" xref="S6.SS4.p4.1.m1.1.1.1.3">2</cn></apply><cn type="integer" id="S6.SS4.p4.1.m1.1.1.3.cmml" xref="S6.SS4.p4.1.m1.1.1.3">4205000000000</cn></apply></annotation-xml><annotation encoding="application/x-tex" id="S6.SS4.p4.1.m1.1c">(2.9\text{ million})^{2}/2=4205000000000</annotation></semantics></math> record comparisons. Even if we could perform each comparison in a microsecond, on an 8 core machine, it would still take over 6 days. In such circumstances, blocking is essential to allow the linking to be feasibly performed.</p>
</div>
<div id="S6.SS4.p5" class="ltx_para">
<p id="S6.SS4.p5.1" class="ltx_p">However, blocking has its downsides, namely, that it will impact on accuracy. For example, if a geographically based blocking algorithm is used, and an individual changes address to somewhere outside of their block, they will definitely not be matched. This can be mitigated somewhat by performing multiple passes of blocking on different attributes, but it will still have an impact.</p>
</div>
<section id="S6.SS4.SSS1" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">6.4.1 </span>Whole population linking</h4>

<div id="S6.SS4.SSS1.p1" class="ltx_para">
<p id="S6.SS4.SSS1.p1.1" class="ltx_p">When looking at the figures above, it becomes apparent that the deterministic linking identifiers approach is efficient enough to perform whole population linking. This would both simplify the implementation and also avoid the negative impacts of blocking. However, it will be essential to ensure the linking identifiers remain unique across the entire population, and importantly, adequately handle the expected distortions.</p>
</div>
<div id="S6.SS4.SSS1.p2" class="ltx_para">
<p id="S6.SS4.SSS1.p2.1" class="ltx_p">Ideally we could get some data to evaluate the rates of uniqueness (which should be very high) for combinations of first name, last name, DoB, address, country of origin/last residence. Then also investigate which subsets of attributes are also (almost) all unique.</p>
</div>
<div id="S6.SS4.SSS1.p3" class="ltx_para">
<p id="S6.SS4.SSS1.p3.1" class="ltx_p">This creates the rather unintuitive situation of providing better privacy by adding more information about someone. An important caveat is that any dataset that is to be linked must provide the same granularity of data in order to create the necessary linking key. For example, if year of birth is included in the original dataset, but the incoming dataset doesn’t include that attribute, then none of the linking identifiers that incorporate year of birth can be used. Other linking identifiers that do not contain year of birth can. The decision of what attributes to use is vital and would need to be driven by the data that is available and the level of uniqueness it offers.
If it is necessary to perform the same pre-processing as the ONS approach, it would make more sense to utilise their approach for linking, instead of apply a further lossy encoding that may not improve privacy much, but could impact on accuracy.</p>
</div>
</section>
</section>
</section>
<section id="S7" class="ltx_section">
<h2 class="ltx_title ltx_title_section">
<span class="ltx_tag ltx_tag_section">7 </span>Option 4: Individual IDs</h2>

<div id="S7.p1" class="ltx_para">
<p id="S7.p1.1" class="ltx_p">Suppose that each person could be assigned a unique ID number. Then we could separate out two processes:</p>
</div>
<div id="S7.p2" class="ltx_para">
<ol id="S7.I1" class="ltx_enumerate">
<li id="S7.I1.i1" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">1.</span> 
<div id="S7.I1.i1.p1" class="ltx_para">
<p id="S7.I1.i1.p1.1" class="ltx_p">the process of linking a particular name, address and date of birth to the ID number, and</p>
</div>
</li>
<li id="S7.I1.i2" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">2.</span> 
<div id="S7.I1.i2.p1" class="ltx_para">
<p id="S7.I1.i2.p1.1" class="ltx_p">the process of linking the records associated with that ID number across different databases.</p>
</div>
</li>
</ol>
</div>
<div id="S7.p3" class="ltx_para">
<p id="S7.p3.1" class="ltx_p">So suppose that the ABS (and other agencies) had a large table like this:</p>
</div>
<div id="S7.p4" class="ltx_para">
<table id="S7.p4.1" class="ltx_tabular ltx_align_middle">
<tbody class="ltx_tbody">
<tr id="S7.p4.1.1.1" class="ltx_tr">
<td id="S7.p4.1.1.1.1" class="ltx_td ltx_align_left"><span id="S7.p4.1.1.1.1.1" class="ltx_text ltx_font_bold">Name</span></td>
<td id="S7.p4.1.1.1.2" class="ltx_td ltx_align_left"><span id="S7.p4.1.1.1.2.1" class="ltx_text ltx_font_bold">Address</span></td>
<td id="S7.p4.1.1.1.3" class="ltx_td ltx_align_left"><span id="S7.p4.1.1.1.3.1" class="ltx_text ltx_font_bold">DoB</span></td>
<td id="S7.p4.1.1.1.4" class="ltx_td ltx_align_left"><span id="S7.p4.1.1.1.4.1" class="ltx_text ltx_font_bold">ID num</span></td>
</tr>
<tr id="S7.p4.1.2.2" class="ltx_tr">
<td id="S7.p4.1.2.2.1" class="ltx_td ltx_align_left">John Citizen</td>
<td id="S7.p4.1.2.2.2" class="ltx_td ltx_align_left">1 Tree St Broadmeadows</td>
<td id="S7.p4.1.2.2.3" class="ltx_td ltx_align_left">10 Jan 1970</td>
<td id="S7.p4.1.2.2.4" class="ltx_td ltx_align_left">5795935</td>
</tr>
<tr id="S7.p4.1.3.3" class="ltx_tr">
<td id="S7.p4.1.3.3.1" class="ltx_td ltx_align_left">Jane Citizen</td>
<td id="S7.p4.1.3.3.2" class="ltx_td ltx_align_left">5 Apple Rd Surrey Hills</td>
<td id="S7.p4.1.3.3.3" class="ltx_td ltx_align_left">25 Dec 1912</td>
<td id="S7.p4.1.3.3.4" class="ltx_td ltx_align_left">12334225</td>
</tr>
<tr id="S7.p4.1.4.4" class="ltx_tr">
<td id="S7.p4.1.4.4.1" class="ltx_td ltx_align_left">…</td>
<td id="S7.p4.1.4.4.2" class="ltx_td ltx_align_left">…</td>
<td id="S7.p4.1.4.4.3" class="ltx_td ltx_align_left">…</td>
<td id="S7.p4.1.4.4.4" class="ltx_td ltx_align_left">…</td>
</tr>
</tbody>
</table>
</div>
<div id="S7.p5" class="ltx_para">
<p id="S7.p5.1" class="ltx_p">This table is not intended to be secret or sensitive: it is like the whitepages, with a link to a non-secret ID like a tax file number or the US social security number.</p>
</div>
<div id="S7.p6" class="ltx_para">
<p id="S7.p6.1" class="ltx_p">The suggestion in this section is that stored datasets remove the names, addresses and dates of birth entirely, and store instead the ID number, encrypted so that the private key is secret-shared among multiple people. When a new dataset is received, the ABS should first link the name, address, and date of birth to an ID number—this uses no cryptography, just whatever techniques for fuzzy matching ABS is familiar with. When each record has been assigned to an ID number, the names, address and dates of birth should be removed—the rest of the linking process should occur by looking for exact matches of the ID number. This can be performed on encrypted values.</p>
</div>
<div id="S7.p7" class="ltx_para">
<p id="S7.p7.1" class="ltx_p">The assignment and encryption of ID numbers could also be done by other agencies before they send data to the ABS.</p>
</div>
<section id="S7.SS1" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">7.1 </span>Methods for linking records based on exact ID matches</h3>

<div id="S7.SS1.p1" class="ltx_para">
<p id="S7.SS1.p1.1" class="ltx_p">Camenisch and Lehmann <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib13" title="" class="ltx_ref">13</a>]</cite> describe a protocol for linking individual ID numbers across government databases, in a very strong security model in which
three different parties cooperate to perform linking while leaking very little information about individual identities. This would be a good starting point for a design of a protocol for future use. Their setting is:</p>
</div>
<div id="S7.SS1.p2" class="ltx_para">
<ul id="S7.I2" class="ltx_itemize">
<li id="S7.I2.i1" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">•</span> 
<div id="S7.I2.i1.p1" class="ltx_para">
<p id="S7.I2.i1.p1.1" class="ltx_p">each of several data authorities may have a public key and some data,</p>
</div>
</li>
<li id="S7.I2.i2" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">•</span> 
<div id="S7.I2.i2.p1" class="ltx_para">
<p id="S7.I2.i2.p1.1" class="ltx_p">each person has an ID number,</p>
</div>
</li>
<li id="S7.I2.i3" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">•</span> 
<div id="S7.I2.i3.p1" class="ltx_para">
<p id="S7.I2.i3.p1.1" class="ltx_p">a linking authority knows some master information that allows it to translate IDs encrypted for one data authority into the same ID encrypted for a different data authority.</p>
</div>
</li>
</ul>
</div>
<div id="S7.SS1.p3" class="ltx_para">
<p id="S7.SS1.p3.1" class="ltx_p">Linking is performed by performing blinded decryption - a process in which a random shift is first applied to the cipher so that the decryption is the real value plus an unknown blinding factor. This is effective for exact matching, since if the two plaintexts are equal and you apply the same blinding factor to both, they will still be equal when decrypted. If they are not equal nobody learns what the original ID was.</p>
</div>
<div id="S7.SS1.p4" class="ltx_para">
<p id="S7.SS1.p4.1" class="ltx_p">This protocol has many good properties. In particular, it is “blind” in the sense that the linking authority does not learn which ID it is linking.</p>
</div>
<div id="S7.SS1.p5" class="ltx_para">
<dl id="S7.I3" class="ltx_description">
<dt id="S7.I3.ix1" class="ltx_item"><span class="ltx_tag ltx_tag_item"><span id="S7.I3.ix1.1.1.1" class="ltx_text ltx_font_bold">Information required to make the anonymised name/linkage file: </span></span></dt>
<dd class="ltx_item">
<div id="S7.I3.ix1.p1" class="ltx_para">
<p id="S7.I3.ix1.p1.1" class="ltx_p">The table linking IDs to the name, address, <span id="S7.I3.ix1.p1.1.1" class="ltx_text ltx_font_italic">etc.</span>, The public key of the Linker.</p>
</div>
</dd>
<dt id="S7.I3.ix2" class="ltx_item"><span class="ltx_tag ltx_tag_item"><span id="S7.I3.ix2.1.1.1" class="ltx_text ltx_font_bold">Information required for linking:</span></span></dt>
<dd class="ltx_item">
<div id="S7.I3.ix2.p1" class="ltx_para">
<p id="S7.I3.ix2.p1.1" class="ltx_p">The Linker’s private key, which can be secret-shared.</p>
</div>
</dd>
<dt id="S7.I3.ix3" class="ltx_item"><span class="ltx_tag ltx_tag_item"><span id="S7.I3.ix3.1.1.1" class="ltx_text ltx_font_bold">Information required for reversing:</span></span></dt>
<dd class="ltx_item">
<div id="S7.I3.ix3.p1" class="ltx_para">
<p id="S7.I3.ix3.p1.1" class="ltx_p">The Linker’s private key and the ID table, which is public.</p>
</div>
</dd>
<dt id="S7.I3.ix4" class="ltx_item"><span class="ltx_tag ltx_tag_item"><span id="S7.I3.ix4.1.1.1" class="ltx_text ltx_font_bold">Ways of inhibiting unauthorised reversing or linking:</span></span></dt>
<dd class="ltx_item">
<div id="S7.I3.ix4.p1" class="ltx_para">
<p id="S7.I3.ix4.p1.1" class="ltx_p">Keep the Linker’s private key secure</p>
</div>
</dd>
<dt id="S7.I3.ix5" class="ltx_item"><span class="ltx_tag ltx_tag_item"><span id="S7.I3.ix5.1.1.1" class="ltx_text ltx_font_bold">Fuzzy matching: </span></span></dt>
<dd class="ltx_item">
<div id="S7.I3.ix5.p1" class="ltx_para">
<p id="S7.I3.ix5.p1.1" class="ltx_p">Yes, at the stage where a name/address/DoB is matched to an ID.</p>
</div>
</dd>
<dt id="S7.I3.ix6" class="ltx_item"><span class="ltx_tag ltx_tag_item"><span id="S7.I3.ix6.1.1.1" class="ltx_text ltx_font_bold">Linking accuracy: </span></span></dt>
<dd class="ltx_item">
<div id="S7.I3.ix6.p1" class="ltx_para">
<p id="S7.I3.ix6.p1.1" class="ltx_p">Could be very high, becase fuzzy matching is performed on cleartext names. The fuzzy matching would, however, be in two steps, effectively canonicalising a name each time.</p>
</div>
</dd>
<dt id="S7.I3.ix7" class="ltx_item"><span class="ltx_tag ltx_tag_item"><span id="S7.I3.ix7.1.1.1" class="ltx_text ltx_font_bold">Implementation difficulty: </span></span></dt>
<dd class="ltx_item">
<div id="S7.I3.ix7.p1" class="ltx_para">
<p id="S7.I3.ix7.p1.1" class="ltx_p">Complex and requiring careful cryptography.</p>
</div>
</dd>
<dt id="S7.I3.ix8" class="ltx_item"><span class="ltx_tag ltx_tag_item"><span id="S7.I3.ix8.1.1.1" class="ltx_text ltx_font_bold">Computational Efficiency: </span></span></dt>
<dd class="ltx_item">
<div id="S7.I3.ix8.p1" class="ltx_para">
<p id="S7.I3.ix8.p1.1" class="ltx_p">Feasible but taking longer than plain encryption.</p>
</div>
</dd>
<dt id="S7.I3.ix9" class="ltx_item"><span class="ltx_tag ltx_tag_item"><span id="S7.I3.ix9.1.1.1" class="ltx_text ltx_font_bold">Other advantages: </span></span></dt>
<dd class="ltx_item"></dd>
<dt id="S7.I3.ix10" class="ltx_item"><span class="ltx_tag ltx_tag_item"><span id="S7.I3.ix10.1.1.1" class="ltx_text ltx_font_bold">Other disadvantages: </span></span></dt>
<dd class="ltx_item"></dd>
</dl>
</div>
</section>
</section>
<section id="S8" class="ltx_section">
<h2 class="ltx_title ltx_title_section">
<span class="ltx_tag ltx_tag_section">8 </span>Option 5: Homomorphic encryption</h2>

<div id="S8.p1" class="ltx_para">
<p id="S8.p1.1" class="ltx_p"><em id="S8.p1.1.1" class="ltx_emph ltx_font_italic">Homomorphic encryption</em> allows certain computations to be performed on encrypted data. For example, it has been used to add encrypted votes and then decrypt only the totals, not the individual ballots <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib2" title="" class="ltx_ref">2</a>]</cite>. Recent advances in cryptography include more efficient algorithms for wider classes of computation.</p>
</div>
<div id="S8.p2" class="ltx_para">
<p id="S8.p2.1" class="ltx_p">In principle it is now possible to compute any function (for Linking, comparison, <span id="S8.p2.1.1" class="ltx_text ltx_font_italic">etc.</span>) on encrypted data, decrypting only the final answer. In practice, however, the most general techniques require an impractical amount of computation. It is not practically possible to compute a rich linking process, tolerating fuzzy matching and other issues, in a reasonable time.</p>
</div>
<div id="S8.p3" class="ltx_para">
<p id="S8.p3.1" class="ltx_p">However, it would be possible to implement some simple comparisons on encrypted names, such as computing the Hamming distance (the total number of different characters). In this case names could remain encrypted throughout the linking process, while only distances were decrypted. The keys used to decrypt the distances <em id="S8.p3.1.1" class="ltx_emph ltx_font_italic">could</em> still be used to decrypt the names, but in a proper linking process they never would be.</p>
</div>
<div id="S8.p4" class="ltx_para">
<p id="S8.p4.1" class="ltx_p">This process would be very secure because the decryption key would never need to leave the Linker. It could even be shared among multiple people so that encrypted names truly could not be reversed unless a threshold of those shares were compromised.</p>
</div>
<div id="S8.p5" class="ltx_para">
<p id="S8.p5.1" class="ltx_p">However, even this restricted notion of homomorphic encryption would require vast computational resources. This, combined with the restricted set of linking policies, make it an unattractive option at present. However, it may be worth revisiting in the future if techniques improve. It could be combined with a secure multiparty computation (SMC) technique for computing only the links without revealing the inputs (See Literature Review Section <a href="#A1.SS6" title="A.6 Secure Multi-Party Computation ‣ Appendix A Literature Review ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">A.6</span></a>). Indeed, many MPC protocols use homomorphic encryption.</p>
</div>
<div id="S8.p6" class="ltx_para">
<dl id="S8.I1" class="ltx_description">
<dt id="S8.I1.ix1" class="ltx_item"><span class="ltx_tag ltx_tag_item"><span id="S8.I1.ix1.1.1.1" class="ltx_text ltx_font_bold">Information required to make the anonymised name/linkage file: </span></span></dt>
<dd class="ltx_item">
<div id="S8.I1.ix1.p1" class="ltx_para">
<p id="S8.I1.ix1.p1.1" class="ltx_p">The public key of the Linker.</p>
</div>
</dd>
<dt id="S8.I1.ix2" class="ltx_item"><span class="ltx_tag ltx_tag_item"><span id="S8.I1.ix2.1.1.1" class="ltx_text ltx_font_bold">Information required for linking:</span></span></dt>
<dd class="ltx_item">
<div id="S8.I1.ix2.p1" class="ltx_para">
<p id="S8.I1.ix2.p1.1" class="ltx_p">The private key of the Linker, but this could be stored in a distributed way and never explicitly recombined.</p>
</div>
</dd>
<dt id="S8.I1.ix3" class="ltx_item"><span class="ltx_tag ltx_tag_item"><span id="S8.I1.ix3.1.1.1" class="ltx_text ltx_font_bold">Information required for reversing:</span></span></dt>
<dd class="ltx_item">
<div id="S8.I1.ix3.p1" class="ltx_para">
<p id="S8.I1.ix3.p1.1" class="ltx_p">The private key of the Linker.</p>
</div>
</dd>
<dt id="S8.I1.ix4" class="ltx_item"><span class="ltx_tag ltx_tag_item"><span id="S8.I1.ix4.1.1.1" class="ltx_text ltx_font_bold">Ways of inhibiting unauthorised reversing or linking:</span></span></dt>
<dd class="ltx_item">
<div id="S8.I1.ix4.p1" class="ltx_para">
<p id="S8.I1.ix4.p1.1" class="ltx_p">Keeping the Linker’s private key secure; never explicitly computing it.</p>
</div>
</dd>
<dt id="S8.I1.ix5" class="ltx_item"><span class="ltx_tag ltx_tag_item"><span id="S8.I1.ix5.1.1.1" class="ltx_text ltx_font_bold">Fuzzy matching: </span></span></dt>
<dd class="ltx_item">
<div id="S8.I1.ix5.p1" class="ltx_para">
<p id="S8.I1.ix5.p1.1" class="ltx_p">Provides a modified hamming distance which will provide fuzzy matching equivalent to using such a string comparison metric. Could be improved further by careful string encoding.</p>
</div>
</dd>
<dt id="S8.I1.ix6" class="ltx_item"><span class="ltx_tag ltx_tag_item"><span id="S8.I1.ix6.1.1.1" class="ltx_text ltx_font_bold">Linking accuracy: </span></span></dt>
<dd class="ltx_item">
<div id="S8.I1.ix6.p1" class="ltx_para">
<p id="S8.I1.ix6.p1.1" class="ltx_p">Multiple comparison can be run, i.e. transposing first and last name if they don’t match. Accuracy likely to be high and close to plaintext matching.</p>
</div>
</dd>
<dt id="S8.I1.ix7" class="ltx_item"><span class="ltx_tag ltx_tag_item"><span id="S8.I1.ix7.1.1.1" class="ltx_text ltx_font_bold">Implementation difficulty: </span></span></dt>
<dd class="ltx_item">
<div id="S8.I1.ix7.p1" class="ltx_para">
<p id="S8.I1.ix7.p1.1" class="ltx_p">Very complex.</p>
</div>
</dd>
<dt id="S8.I1.ix8" class="ltx_item"><span class="ltx_tag ltx_tag_item"><span id="S8.I1.ix8.1.1.1" class="ltx_text ltx_font_bold">Computational Efficiency: </span></span></dt>
<dd class="ltx_item">
<div id="S8.I1.ix8.p1" class="ltx_para">
<p id="S8.I1.ix8.p1.1" class="ltx_p">Requires intensive computation.</p>
</div>
</dd>
<dt id="S8.I1.ix9" class="ltx_item"><span class="ltx_tag ltx_tag_item"><span id="S8.I1.ix9.1.1.1" class="ltx_text ltx_font_bold">Other advantages: </span></span></dt>
<dd class="ltx_item">
<div id="S8.I1.ix9.p1" class="ltx_para">
<p id="S8.I1.ix9.p1.1" class="ltx_p">This is a very secure option, because the decryption key would never need to leave the Linker. It could even be shared among multiple people so that encrypted names truly could not be reversed unless a threshold of those shares were compromised.</p>
</div>
</dd>
<dt id="S8.I1.ix10" class="ltx_item"><span class="ltx_tag ltx_tag_item"><span id="S8.I1.ix10.1.1.1" class="ltx_text ltx_font_bold">Other disadvantages: </span></span></dt>
<dd class="ltx_item">
<div id="S8.I1.ix10.p1" class="ltx_para">
<p id="S8.I1.ix10.p1.1" class="ltx_p">Would need careful analysis of what information could be obtained by the Linker from multiple runs of the protocol and measuring the similarity between different names.</p>
</div>
</dd>
</dl>
</div>
<div id="S8.p7" class="ltx_para">
<p id="S8.p7.1" class="ltx_p">Schemes based on homomorphic encryption or secure computation are the future of secure data processing. These sorts of schemes are an active area of cryptography research with many applications. These sorts of schemes would allow ABS to say truly that it was not able to reverse data if the key could be shared among other organisations. In the long run, these sorts of approaches should become the norm. For now, however, the difficulty of implementation probably means that this is better suited to a longer research project than a practical proposal for this year’s census data.</p>
</div>
</section>
<section id="S9" class="ltx_section">
<h2 class="ltx_title ltx_title_section">
<span class="ltx_tag ltx_tag_section">9 </span>Empirical linking results based on a Synthetic Data Generator</h2>

<div id="S9.p1" class="ltx_para">
<p id="S9.p1.1" class="ltx_p">In order to evaluate the various methods we constructed a synthetic dataset. Our aim was to create something that mirrored, as closely as possible, the frequency distribution of real world data. Validating this is difficult, since access to real world data is not an option. However, we have based our sampling on real world samples and aggregates.</p>
</div>
<section id="S9.SS1" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">9.1 </span>Datasets and frequency distributions</h3>

<div id="S9.SS1.p1" class="ltx_para">
<dl id="S9.I1" class="ltx_description">
<dt id="S9.I1.ix1" class="ltx_item"><span class="ltx_tag ltx_tag_item"><span id="S9.I1.ix1.1.1.1" class="ltx_text ltx_font_bold">MBS Demographics</span></span></dt>
<dd class="ltx_item">
<div id="S9.I1.ix1.p1" class="ltx_para">
<p id="S9.I1.ix1.p1.1" class="ltx_p">At the base of the generation is the demographic information from the MBS/PBS release. This contains approximately 29̇ million records with YOB and Gender.</p>
</div>
</dd>
<dt id="S9.I1.ix2" class="ltx_item"><span class="ltx_tag ltx_tag_item"><span id="S9.I1.ix2.1.1.1" class="ltx_text ltx_font_bold">Last Name</span></span></dt>
<dd class="ltx_item">
<div id="S9.I1.ix2.p1" class="ltx_para">
<p id="S9.I1.ix2.p1.1" class="ltx_p">We obtained a list of 384 370 last names the occur in Australia, and the corresponding frequencies. We draw from this at random with a probability distribution matching the frequencies to append a last name to each row of the MBS demographics.</p>
</div>
</dd>
<dt id="S9.I1.ix3" class="ltx_item"><span class="ltx_tag ltx_tag_item"><span id="S9.I1.ix3.1.1.1" class="ltx_text ltx_font_bold">First Name</span></span></dt>
<dd class="ltx_item">
<div id="S9.I1.ix3.p1" class="ltx_para">
<p id="S9.I1.ix3.p1.1" class="ltx_p">We use the NSW data release of frequencies of the top 100 first names for boys and girls from 1952 through to 2015, to select an appropriate Gender and YOB specific first name for each record in MBS demographics. Ideally, we would have more than 100 names, since this only provides 297 distinct boys names, and 377 distinct girls names. Where YOB is not in the NSW release we take the closest year.</p>
</div>
</dd>
<dt id="S9.I1.ix4" class="ltx_item"><span class="ltx_tag ltx_tag_item"><span id="S9.I1.ix4.1.1.1" class="ltx_text ltx_font_bold">Middle Name</span></span></dt>
<dd class="ltx_item">
<div id="S9.I1.ix4.p1" class="ltx_para">
<p id="S9.I1.ix4.p1.1" class="ltx_p">We re-use the NSW data, except we draw the middle name from YOB-20. This somewhat arbitrary, but done in an effort to get a different distribution of middle and first names for an particular year. linecolor=blue,backgroundcolor=blue!25,bordercolor=blue]CJC:I’m keen to expand the first and middle name parts of the generation, but FEBRL doesn’t have many more names either</p>
</div>
</dd>
<dt id="S9.I1.ix5" class="ltx_item"><span class="ltx_tag ltx_tag_item"><span id="S9.I1.ix5.1.1.1" class="ltx_text ltx_font_bold">Mesh Block</span></span></dt>
<dd class="ltx_item">
<div id="S9.I1.ix5.p1" class="ltx_para">
<p id="S9.I1.ix5.p1.1" class="ltx_p">We originally used postcode frequency data, but postcode is not fine grained enough to provide an equivalent uniqueness to the UK postcode and therefore achieve equivalence with the ONS results. We subsequently switched to use 2011 Census mesh block population distribution data. We select these at random according the population distribution, providing the mesh block, and a value synonymous with an SA3 area<span id="footnote5" class="ltx_note ltx_role_footnote"><sup class="ltx_note_mark">5</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">5</sup><span class="ltx_tag ltx_tag_note">5</span>We could convert from mesh block ID to actual SA3 codes, but it is not necessary for our analysis, because our distortions are performed only at meshblock level. When using the pseudo-SA3 value we need to just be representative of the number of codes, hence we derive it from the meshblock ID instead of going to the complexity of performing a full look-up</span></span></span> for use in the linking identifiers.</p>
</div>
</dd>
</dl>
</div>
</section>
<section id="S9.SS2" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">9.2 </span>Distortions</h3>

<div id="S9.SS2.p1" class="ltx_para">
<p id="S9.SS2.p1.1" class="ltx_p">We create a number duplicate datasets with distortions applied in order to evaluate the effective of fuzzy matching. The distortion framework is extensible, so we can further or different distortions. We currently apply the distortions to all records in the duplicate and then evaluate overall impact. We have a mechanism for apply these probabilistically as well. The distortions we currently apply are as follows:</p>
<dl id="S9.I2" class="ltx_description">
<dt id="S9.I2.ix1" class="ltx_item"><span class="ltx_tag ltx_tag_item"><span id="S9.I2.ix1.1.1.1" class="ltx_text ltx_font_bold">Change Gender</span></span></dt>
<dd class="ltx_item">
<div id="S9.I2.ix1.p1" class="ltx_para">
<p id="S9.I2.ix1.p1.1" class="ltx_p">We switch the Gender from M to F and F to M, primarily to simulate typos.</p>
</div>
</dd>
<dt id="S9.I2.ix2" class="ltx_item"><span class="ltx_tag ltx_tag_item"><span id="S9.I2.ix2.1.1.1" class="ltx_text ltx_font_bold">Change Middle Initial</span></span></dt>
<dd class="ltx_item">
<div id="S9.I2.ix2.p1" class="ltx_para">
<p id="S9.I2.ix2.p1.1" class="ltx_p">We select a different middle initial at random.</p>
</div>
</dd>
<dt id="S9.I2.ix3" class="ltx_item"><span class="ltx_tag ltx_tag_item"><span id="S9.I2.ix3.1.1.1" class="ltx_text ltx_font_bold">Change YOB</span></span></dt>
<dd class="ltx_item">
<div id="S9.I2.ix3.p1" class="ltx_para">
<p id="S9.I2.ix3.p1.1" class="ltx_p">Replace the YOB with a randomly selected YOB drawn from between 1916 and 2016.</p>
</div>
</dd>
<dt id="S9.I2.ix4" class="ltx_item"><span class="ltx_tag ltx_tag_item"><span id="S9.I2.ix4.1.1.1" class="ltx_text ltx_font_bold">First Last Transpose</span></span></dt>
<dd class="ltx_item">
<div id="S9.I2.ix4.p1" class="ltx_para">
<p id="S9.I2.ix4.p1.1" class="ltx_p">We transpose the first and last names</p>
</div>
</dd>
<dt id="S9.I2.ix5" class="ltx_item"><span class="ltx_tag ltx_tag_item"><span id="S9.I2.ix5.1.1.1" class="ltx_text ltx_font_bold">Mesh Block Change</span></span></dt>
<dd class="ltx_item">
<div id="S9.I2.ix5.p1" class="ltx_para">
<p id="S9.I2.ix5.p1.1" class="ltx_p">We randomly select a mesh block from the same distribution as used in the original generation.</p>
</div>
</dd>
<dt id="S9.I2.ix6" class="ltx_item"><span class="ltx_tag ltx_tag_item"><span id="S9.I2.ix6.1.1.1" class="ltx_text ltx_font_bold">Remove/Add Middle Initial</span></span></dt>
<dd class="ltx_item">
<div id="S9.I2.ix6.p1" class="ltx_para">
<p id="S9.I2.ix6.p1.1" class="ltx_p">Remove the middle initial, or randomly add one if there is not one</p>
</div>
</dd>
<dt id="S9.I2.ix7" class="ltx_item"><span class="ltx_tag ltx_tag_item"><span id="S9.I2.ix7.1.1.1" class="ltx_text ltx_font_bold">Transpose Inner Letters of Last Name</span></span></dt>
<dd class="ltx_item">
<div id="S9.I2.ix7.p1" class="ltx_para">
<p id="S9.I2.ix7.p1.1" class="ltx_p">We transpose 2 adjacent letters in the last name, picked at random.</p>
</div>
</dd>
<dt id="S9.I2.ix8" class="ltx_item"><span class="ltx_tag ltx_tag_item"><span id="S9.I2.ix8.1.1.1" class="ltx_text ltx_font_bold">Transpose Inner Letters of First Name</span></span></dt>
<dd class="ltx_item">
<div id="S9.I2.ix8.p1" class="ltx_para">
<p id="S9.I2.ix8.p1.1" class="ltx_p">We transpose 2 adjacent letters in the last name, picked at random.</p>
</div>
</dd>
</dl>
</div>
</section>
<section id="S9.SS3" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">9.3 </span>Analysis of HMAC-based anonymised Linking identifiers</h3>

<div id="S9.SS3.p1" class="ltx_para">
<p id="S9.SS3.p1.1" class="ltx_p">In order to evaluate the effectiveness of the HMAC Linking identifier approach we constructed a dataset of the relevant keys. We subsequently imported that data into a MongoDB database, with one collection per type of identifier, i.e. ForenameSurnameYoBSexSA4 was a collection. Within that collection each generated HMAC Linking identifier was a document, indexed by the HMAC Linking identifier value. Within the document was an array containing the rowID of any record that generated that identifier. The advantage of this approach is that it permits easy indexing of the HMAC Linking identifiers, providing extremely fast look-up times. In most cases the array of matching documents is an array of 1, since the objective is to generate primarily unique linking identifiers. When linking a record, the same set of HMAC Linking identifiers are generated from the dataset to be linked, each one is then submitted as a query to the database to find all the records that match that linking identifier. Such a query takes approximately 5ms to perform. Additionally, there is no cross-comparison, so the number of queries is linear with regards to the number of records being linked. This allows for full population linking to be undertaken on even large dataset.</p>
</div>
<section id="S9.SS3.SSS1" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">9.3.1 </span>Determining the best match</h4>

<div id="S9.SS3.SSS1.p1" class="ltx_para">
<p id="S9.SS3.SSS1.p1.1" class="ltx_p">The ONS <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib37" title="" class="ltx_ref">37</a>]</cite> approach to performing the linking was to use a hierarchy of identifiers, stopping as soon as a unique match was found. Additionally, they removed matches from both sides of the matching. This approach has a number of problems, it weights identifiers resulting in a false positive in one identifier negating all the identifiers below it in the hierarchy. As such, the ordering of the identifiers becomes very important, but difficult to judge. The removal of matches from both sides of the linking also risks compounding errors. In that if matching two equal populations, a false positive will result in either a subsequent false negative (no match found), or further false negative (lower quality match found), since the correct match has already been removed due the first false positive. Additionally, removing records is inefficient in terms of indexing, negating the performance advantages of this approach. As such, we evaluated two different approaches to finding a match.</p>
</div>
<section id="S9.SS3.SSS1.Px1" class="ltx_paragraph">
<h5 class="ltx_title ltx_title_paragraph">First unique match</h5>

<div id="S9.SS3.SSS1.Px1.p1" class="ltx_para">
<p id="S9.SS3.SSS1.Px1.p1.1" class="ltx_p">In this simulation we maintain the hierarchical nature of the identifiers and stop as soon as we get a unique match, i.e. the array of matching rowID’s is of size 1. However, in a departure from the ONS <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib37" title="" class="ltx_ref">37</a>]</cite> approach we do not subsequently remove the matching record. If no identifiers have a unique match we consider the record to not be matched even, for example, if one identifier matched multiple records. [Note that in a real run we would need to guarantee uniqueness.]</p>
</div>
</section>
<section id="S9.SS3.SSS1.Px2" class="ltx_paragraph">
<h5 class="ltx_title ltx_title_paragraph">Voting</h5>

<div id="S9.SS3.SSS1.Px2.p1" class="ltx_para">
<p id="S9.SS3.SSS1.Px2.p1.1" class="ltx_p">The second approach for matching we evaluated was to perform a vote across all identifiers to determine the most likely match. This was calculated by returning the arrays of rowID’s and then performing a frequency analysis of the contents. Whichever rowID received the most matches was considered to be a match. If two rowID’s had the same frequency one was selected at random. A failure to match would only be returned if there were no matches to any of the HMAC Linking identifiers. This reduces the importance of the order of HMAC Linking identifiers as well as mitigating any identifiers that may have a higher false positive rate, which could be a problem if they appear too high in the hierarchy.</p>
</div>
</section>
</section>
<section id="S9.SS3.SSS2" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">9.3.2 </span>Uniqueness</h4>

<div id="S9.SS3.SSS2.p1" class="ltx_para">
<p id="S9.SS3.SSS2.p1.1" class="ltx_p">At the heart of this approach is the concept that the HMAC Linking identifiers are unique. In order to evaluate that we analysed the identifiers we generated for a synthetic dataset and determined their uniqueness across the dataset. Table <a href="#S9.T1" title="Table 1 ‣ 9.3.2 Uniqueness ‣ 9.3 Analysis of HMAC-based anonymised Linking identifiers ‣ 9 Empirical linking results based on a Synthetic Data Generator ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">1</span></a> contains the uniqueness of the respective HMAC Linking identifiers. AS we can see most of the identifiers provide a very high level of uniqueness, across the 2.9 million records, the lowest being ForenameSurnameYoBSex at 94.524%. Uniqueness is essential to privacy protection—any degree of non-uniqueness presents a degree of privacy risk. For example, ForenameSurnameSexMeshblock is 99.998% unique, however, that leaves a tiny proportion that are not unique. That lack of uniqueness could be caused, in a real-world dataset, by people who are related, for example, a father and son who share the same first name. Such occurrences are rare, and access to auxiliary information could allow an attacker to look for just such rare occurrences. This is analogous to frequency attack, but on a very specific and small scale. One advantage of this approach is that it permits that risk to be quantified and mitigated. For example, it would be possible to remove entries that are not unique. Such an action would have some impact on recall, but may be preferable to the privacy risk. Such mitigation strategies become difficult when too large a percentage are not unique. For example, consider a linking identifier consisting of just Forename and Surname, which is only 59.778% unique in our test dataset. Depending on the identifier’s location within the hierarchy it could have an impact on precision. This set of attributes should not be used as a linking identifier.</p>
</div>
<figure id="S9.T1" class="ltx_table">
<table id="S9.T1.1" class="ltx_tabular ltx_centering ltx_guessed_headers ltx_align_middle">
<thead class="ltx_thead">
<tr id="S9.T1.1.1.1" class="ltx_tr">
<th id="S9.T1.1.1.1.1" class="ltx_td ltx_align_left ltx_th ltx_th_column ltx_border_l ltx_border_r ltx_border_t"><span id="S9.T1.1.1.1.1.1" class="ltx_text ltx_font_bold">Uniqueness of Linking Keys</span></th>
<th id="S9.T1.1.1.1.2" class="ltx_td ltx_align_center ltx_th ltx_th_column ltx_border_r ltx_border_t"><span id="S9.T1.1.1.1.2.1" class="ltx_text ltx_font_bold">% Unique</span></th>
</tr>
</thead>
<tbody class="ltx_tbody">
<tr id="S9.T1.1.2.1" class="ltx_tr">
<td id="S9.T1.1.2.1.1" class="ltx_td ltx_align_left ltx_border_l ltx_border_r ltx_border_t">ForenameSurnameYoBSexSA3</td>
<td id="S9.T1.1.2.1.2" class="ltx_td ltx_align_right ltx_border_r ltx_border_t">99.971</td>
</tr>
<tr id="S9.T1.1.3.2" class="ltx_tr">
<td id="S9.T1.1.3.2.1" class="ltx_td ltx_align_left ltx_border_l ltx_border_r ltx_border_t">ForenameInitialSurnameInitialYoBSexMeshblock</td>
<td id="S9.T1.1.3.2.2" class="ltx_td ltx_align_right ltx_border_r ltx_border_t">99.972</td>
</tr>
<tr id="S9.T1.1.4.3" class="ltx_tr">
<td id="S9.T1.1.4.3.1" class="ltx_td ltx_align_left ltx_border_l ltx_border_r ltx_border_t">ForenameSurnameYoBMeshblock</td>
<td id="S9.T1.1.4.3.2" class="ltx_td ltx_align_right ltx_border_r ltx_border_t">99.999</td>
</tr>
<tr id="S9.T1.1.5.4" class="ltx_tr">
<td id="S9.T1.1.5.4.1" class="ltx_td ltx_align_left ltx_border_l ltx_border_r ltx_border_t">SurnameForenameYoBSexMeshblockTrans</td>
<td id="S9.T1.1.5.4.2" class="ltx_td ltx_align_right ltx_border_r ltx_border_t">99.999</td>
</tr>
<tr id="S9.T1.1.6.5" class="ltx_tr">
<td id="S9.T1.1.6.5.1" class="ltx_td ltx_align_left ltx_border_l ltx_border_r ltx_border_t">ForenameSurnameYoBSexMeshblock</td>
<td id="S9.T1.1.6.5.2" class="ltx_td ltx_align_right ltx_border_r ltx_border_t">99.999</td>
</tr>
<tr id="S9.T1.1.7.6" class="ltx_tr">
<td id="S9.T1.1.7.6.1" class="ltx_td ltx_align_left ltx_border_l ltx_border_r ltx_border_t">ForenameSurnameYoBSex</td>
<td id="S9.T1.1.7.6.2" class="ltx_td ltx_align_right ltx_border_r ltx_border_t">94.524</td>
</tr>
<tr id="S9.T1.1.8.7" class="ltx_tr">
<td id="S9.T1.1.8.7.1" class="ltx_td ltx_align_left ltx_border_l ltx_border_r ltx_border_t">ForenameBiSurnameBiYoBSexMeshblock</td>
<td id="S9.T1.1.8.7.2" class="ltx_td ltx_align_right ltx_border_r ltx_border_t">99.844</td>
</tr>
<tr id="S9.T1.1.9.8" class="ltx_tr">
<td id="S9.T1.1.9.8.1" class="ltx_td ltx_align_left ltx_border_l ltx_border_r ltx_border_t">ForenameSurnameSexMeshblock</td>
<td id="S9.T1.1.9.8.2" class="ltx_td ltx_align_right ltx_border_r ltx_border_t">99.997</td>
</tr>
<tr id="S9.T1.1.10.9" class="ltx_tr">
<td id="S9.T1.1.10.9.1" class="ltx_td ltx_align_left ltx_border_l ltx_border_r ltx_border_t">SurnameInitialYoBSexMeshblock</td>
<td id="S9.T1.1.10.9.2" class="ltx_td ltx_align_right ltx_border_r ltx_border_t">99.708</td>
</tr>
<tr id="S9.T1.1.11.10" class="ltx_tr">
<td id="S9.T1.1.11.10.1" class="ltx_td ltx_align_left ltx_border_l ltx_border_r ltx_border_t">ForenameInitialYoBSexMeshblock</td>
<td id="S9.T1.1.11.10.2" class="ltx_td ltx_align_right ltx_border_r ltx_border_t">99.601</td>
</tr>
<tr id="S9.T1.1.12.11" class="ltx_tr">
<td id="S9.T1.1.12.11.1" class="ltx_td ltx_align_left ltx_border_b ltx_border_l ltx_border_r ltx_border_t">MiddleNameSurnameYoBSexMeshblock</td>
<td id="S9.T1.1.12.11.2" class="ltx_td ltx_align_right ltx_border_b ltx_border_r ltx_border_t">99.999</td>
</tr>
</tbody>
</table>
<figcaption class="ltx_caption"><span class="ltx_tag ltx_tag_table">Table 1: </span>Uniqueness of HMAC Linking Keys</figcaption>
</figure>
</section>
<section id="S9.SS3.SSS3" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">9.3.3 </span>Matching results</h4>

<div id="S9.SS3.SSS3.p1" class="ltx_para">
<p id="S9.SS3.SSS3.p1.1" class="ltx_p">Table <a href="#S9.T2" title="Table 2 ‣ 9.3.3 Matching results ‣ 9.3 Analysis of HMAC-based anonymised Linking identifiers ‣ 9 Empirical linking results based on a Synthetic Data Generator ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">2</span></a> shows the comparison of the matching results for Voting and Non-Voting methods. Precision and Recall are calculated based on comparing the return match with actual match. The linking dataset is a shuffled, and if appropriate, distorted copy of the original dataset. No records inserted or deleted, as such, we would expect recall to be 1. Recall would only drop below 1 when no matching to any record was found. The precision indicates the the HMAC Linking Key approach is an effective method for matching records when faced with the tested distortions. It should be noted that we have not evaluated results based on composite distortions, for example, transposing letters and changing mesh block. However, that would be fairly straightforward to test if required. The robustness of the approach to distortion can be determined by examining the HMAC Linking Keys that are constructed. Effectively, to be robust to a distortion there must remain at least one key that is not impacted by that distortion. For example, where a mesh block changes within an SA3 area we are reliant on the ForenameSurnameYoBSexSA3 and ForenameSurnameYoBSex linking keys to determine matches. Where a mesh block changes outside an SA3area we are reliant on only the ForenameSurnameYoBSex key. This is reflected in the precision results that show mesh block changes cause the greatest reduction in precision. Combining the uniqueness information with expected distortions it is possible to determine whether the linking keys generated will be robust to it, without having to perform an evaluation on the actual dataset. For example, if both Year Of Birth and Gender change we can be certain that no keys will be able to provide a match.</p>
</div>
<div id="S9.SS3.SSS3.p2" class="ltx_para">
<p id="S9.SS3.SSS3.p2.1" class="ltx_p">The set of keys used in our evaluation is not exhaustive, different keys could be created to handle specific distortions, or composite distortions. The only requirement is that they are largely unique. As such, the exact set of linking keys to be used should be derived from the looking at the actual dataset. It is important to perform this step, since once identifying data is deleted additional keys including that data cannot be created. As such, the approach should aim to handle all expected distortions at the point of creation.</p>
</div>
<figure id="S9.T2" class="ltx_table">
<table id="S9.T2.1" class="ltx_tabular ltx_centering ltx_guessed_headers ltx_align_middle">
<thead class="ltx_thead">
<tr id="S9.T2.1.1.1" class="ltx_tr">
<th id="S9.T2.1.1.1.1" class="ltx_td ltx_th ltx_th_column ltx_th_row ltx_border_l ltx_border_r ltx_border_t"></th>
<th id="S9.T2.1.1.1.2" class="ltx_td ltx_align_center ltx_th ltx_th_column ltx_border_r ltx_border_t" colspan="2"><span id="S9.T2.1.1.1.2.1" class="ltx_text ltx_font_bold">Non Voting</span></th>
<th id="S9.T2.1.1.1.3" class="ltx_td ltx_align_center ltx_th ltx_th_column ltx_border_r ltx_border_t" colspan="2"><span id="S9.T2.1.1.1.3.1" class="ltx_text ltx_font_bold">Voting</span></th>
</tr>
<tr id="S9.T2.1.2.2" class="ltx_tr">
<th id="S9.T2.1.2.2.1" class="ltx_td ltx_align_left ltx_th ltx_th_column ltx_th_row ltx_border_l ltx_border_r ltx_border_t"><span id="S9.T2.1.2.2.1.1" class="ltx_text ltx_font_bold">Distortion</span></th>
<th id="S9.T2.1.2.2.2" class="ltx_td ltx_align_center ltx_th ltx_th_column ltx_border_r ltx_border_t"><span id="S9.T2.1.2.2.2.1" class="ltx_text ltx_font_bold">Precision</span></th>
<th id="S9.T2.1.2.2.3" class="ltx_td ltx_align_center ltx_th ltx_th_column ltx_border_r ltx_border_t"><span id="S9.T2.1.2.2.3.1" class="ltx_text ltx_font_bold">Recall</span></th>
<th id="S9.T2.1.2.2.4" class="ltx_td ltx_align_center ltx_th ltx_th_column ltx_border_r ltx_border_t"><span id="S9.T2.1.2.2.4.1" class="ltx_text ltx_font_bold">Precision</span></th>
<th id="S9.T2.1.2.2.5" class="ltx_td ltx_align_center ltx_th ltx_th_column ltx_border_r ltx_border_t"><span id="S9.T2.1.2.2.5.1" class="ltx_text ltx_font_bold">Recall</span></th>
</tr>
</thead>
<tbody class="ltx_tbody">
<tr id="S9.T2.1.3.1" class="ltx_tr">
<th id="S9.T2.1.3.1.1" class="ltx_td ltx_align_left ltx_th ltx_th_row ltx_border_l ltx_border_r ltx_border_t">changeInitial</th>
<td id="S9.T2.1.3.1.2" class="ltx_td ltx_align_right ltx_border_r ltx_border_t">1.000</td>
<td id="S9.T2.1.3.1.3" class="ltx_td ltx_align_right ltx_border_r ltx_border_t">0.999</td>
<td id="S9.T2.1.3.1.4" class="ltx_td ltx_align_right ltx_border_r ltx_border_t">0.999</td>
<td id="S9.T2.1.3.1.5" class="ltx_td ltx_align_right ltx_border_r ltx_border_t">1.000</td>
</tr>
<tr id="S9.T2.1.4.2" class="ltx_tr">
<th id="S9.T2.1.4.2.1" class="ltx_td ltx_align_left ltx_th ltx_th_row ltx_border_l ltx_border_r ltx_border_t">firstLastTranspose</th>
<td id="S9.T2.1.4.2.2" class="ltx_td ltx_align_right ltx_border_r ltx_border_t">0.990</td>
<td id="S9.T2.1.4.2.3" class="ltx_td ltx_align_right ltx_border_r ltx_border_t">0.999</td>
<td id="S9.T2.1.4.2.4" class="ltx_td ltx_align_right ltx_border_r ltx_border_t">0.994</td>
<td id="S9.T2.1.4.2.5" class="ltx_td ltx_align_right ltx_border_r ltx_border_t">1.000</td>
</tr>
<tr id="S9.T2.1.5.3" class="ltx_tr">
<th id="S9.T2.1.5.3.1" class="ltx_td ltx_align_left ltx_th ltx_th_row ltx_border_l ltx_border_r ltx_border_t">exact</th>
<td id="S9.T2.1.5.3.2" class="ltx_td ltx_align_right ltx_border_r ltx_border_t">1.000</td>
<td id="S9.T2.1.5.3.3" class="ltx_td ltx_align_right ltx_border_r ltx_border_t">1.000</td>
<td id="S9.T2.1.5.3.4" class="ltx_td ltx_align_right ltx_border_r ltx_border_t">1.000</td>
<td id="S9.T2.1.5.3.5" class="ltx_td ltx_align_right ltx_border_r ltx_border_t">1.000</td>
</tr>
<tr id="S9.T2.1.6.4" class="ltx_tr">
<th id="S9.T2.1.6.4.1" class="ltx_td ltx_align_left ltx_th ltx_th_row ltx_border_l ltx_border_r ltx_border_t">lastName2LetterTranspose</th>
<td id="S9.T2.1.6.4.2" class="ltx_td ltx_align_right ltx_border_r ltx_border_t">0.999</td>
<td id="S9.T2.1.6.4.3" class="ltx_td ltx_align_right ltx_border_r ltx_border_t">0.999</td>
<td id="S9.T2.1.6.4.4" class="ltx_td ltx_align_right ltx_border_r ltx_border_t">0.999</td>
<td id="S9.T2.1.6.4.5" class="ltx_td ltx_align_right ltx_border_r ltx_border_t">1.000</td>
</tr>
<tr id="S9.T2.1.7.5" class="ltx_tr">
<th id="S9.T2.1.7.5.1" class="ltx_td ltx_align_left ltx_th ltx_th_row ltx_border_l ltx_border_r ltx_border_t">removeAddInitial</th>
<td id="S9.T2.1.7.5.2" class="ltx_td ltx_align_right ltx_border_r ltx_border_t">1.000</td>
<td id="S9.T2.1.7.5.3" class="ltx_td ltx_align_right ltx_border_r ltx_border_t">0.999</td>
<td id="S9.T2.1.7.5.4" class="ltx_td ltx_align_right ltx_border_r ltx_border_t">0.999</td>
<td id="S9.T2.1.7.5.5" class="ltx_td ltx_align_right ltx_border_r ltx_border_t">1.000</td>
</tr>
<tr id="S9.T2.1.8.6" class="ltx_tr">
<th id="S9.T2.1.8.6.1" class="ltx_td ltx_align_left ltx_th ltx_th_row ltx_border_l ltx_border_r ltx_border_t">firstName2LetterTranspose</th>
<td id="S9.T2.1.8.6.2" class="ltx_td ltx_align_right ltx_border_r ltx_border_t">1.000</td>
<td id="S9.T2.1.8.6.3" class="ltx_td ltx_align_right ltx_border_r ltx_border_t">0.999</td>
<td id="S9.T2.1.8.6.4" class="ltx_td ltx_align_right ltx_border_r ltx_border_t">0.999</td>
<td id="S9.T2.1.8.6.5" class="ltx_td ltx_align_right ltx_border_r ltx_border_t">1.000</td>
</tr>
<tr id="S9.T2.1.9.7" class="ltx_tr">
<th id="S9.T2.1.9.7.1" class="ltx_td ltx_align_left ltx_th ltx_th_row ltx_border_l ltx_border_r ltx_border_t">meshblockChange</th>
<td id="S9.T2.1.9.7.2" class="ltx_td ltx_align_right ltx_border_r ltx_border_t">0.982</td>
<td id="S9.T2.1.9.7.3" class="ltx_td ltx_align_right ltx_border_r ltx_border_t">0.904</td>
<td id="S9.T2.1.9.7.4" class="ltx_td ltx_align_right ltx_border_r ltx_border_t">0.937</td>
<td id="S9.T2.1.9.7.5" class="ltx_td ltx_align_right ltx_border_r ltx_border_t">1.000</td>
</tr>
<tr id="S9.T2.1.10.8" class="ltx_tr">
<th id="S9.T2.1.10.8.1" class="ltx_td ltx_align_left ltx_th ltx_th_row ltx_border_b ltx_border_l ltx_border_r ltx_border_t">changeGender</th>
<td id="S9.T2.1.10.8.2" class="ltx_td ltx_align_right ltx_border_b ltx_border_r ltx_border_t">0.987</td>
<td id="S9.T2.1.10.8.3" class="ltx_td ltx_align_right ltx_border_b ltx_border_r ltx_border_t">0.999</td>
<td id="S9.T2.1.10.8.4" class="ltx_td ltx_align_right ltx_border_b ltx_border_r ltx_border_t">0.967</td>
<td id="S9.T2.1.10.8.5" class="ltx_td ltx_align_right ltx_border_b ltx_border_r ltx_border_t">1.000</td>
</tr>
</tbody>
</table>
<figcaption class="ltx_caption"><span class="ltx_tag ltx_tag_table">Table 2: </span>HMAC Linking Keys Results</figcaption>
</figure>
</section>
</section>
<section id="S9.SS4" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">9.4 </span>Direct Bi-gram matching</h3>

<div id="S9.SS4.p1" class="ltx_para">
<p id="S9.SS4.p1.1" class="ltx_p">By way of a comparison we also analysed a simple bi-gram matching process. In this scheme each bi-gram was encoded into an HMAC, with the HMAC then being compared as bi-grams. This provided a degree of privacy protection, although it would remain susceptible to frequency attacks, particularly given the analysis in Section <a href="#A1.SS4.SSS5" title="A.4.5 Use of random values ‣ A.4 Security and accuracy of current literature on Bloom Filters ‣ Appendix A Literature Review ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">A.4.5</span></a> that demonstrated strong skews in the frequency distribution of bi-grams. A major challenge in performing the bi-gram matching was the inefficiency of performing a cross-comparison. It was infeasible to do this for the entire dataset, and as such we had to deploy a blocking procedure. Even with a reasonable level of blocking the processing time was substantial. In order to allow us to evaluate different matching techniques we took a sample of 3 blocks, each consisting of between 15,000 and 18,500 records. We then performed the cross comparison within those blocks.</p>
</div>
<div id="S9.SS4.p2" class="ltx_para">
<p id="S9.SS4.p2.1" class="ltx_p">We did not evaluate multi-round matching that would involve different blocking methods to allow handling of geographical changes. We only evaluated distortions that would impact on the result, as such, changes to middle initial, age, and gender were not evaluated. Likewise, given that we know that a wholesale geographical change would lead to a precision of 0, we did not evaluate that either.</p>
</div>
<div id="S9.SS4.p3" class="ltx_para">
<p id="S9.SS4.p3.1" class="ltx_p">In order to determine whether two sets of bi-grams matched we tried two approaches. The simple approach was to calculate a dice-coefficient between the bi-gram sets. This was simple and fast, and maintained the order of the bi-grams. However, it is not robust to insertion or deletions of bi-grams, that wasn’t an issue in our tests because we were not performing that distortion, but would be an issue in a real world setting. The second approach was to calculate the q-gram similarity of the two sets of bi-grams <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib47" title="" class="ltx_ref">47</a>]</cite>. This is calculated by first calculating the q-gram distance, which requires counting the occurrences of each bi-gram in the two strings and taking the sum of the absolute differences of those counts. We then sum the cardinality of the two bi-gram sets and set this as the maximum distance. We then take the calculated distance from the maximum and divide by the maximum to get a similarity score between 0 and 1.</p>
</div>
<div id="S9.SS4.p4" class="ltx_para">
<p id="S9.SS4.p4.1" class="ltx_p">The disadvantage of this approach is that it is more computationally expensive to calculate, which over a full set of blocks would impact on the time required to perform the linking.</p>
</div>
<div id="S9.SS4.p5" class="ltx_para">
<p id="S9.SS4.p5.1" class="ltx_p">Table <a href="#S9.T3" title="Table 3 ‣ 9.4 Direct Bi-gram matching ‣ 9 Empirical linking results based on a Synthetic Data Generator ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">3</span></a> shows the results for the first matching approach. We can see that it performs well in exact matching and the letter transposition distortions. It is not quite as good as the HMAC Linking Key approach, but it is not far off.</p>
</div>
<div id="S9.SS4.p6" class="ltx_para">
<p id="S9.SS4.p6.1" class="ltx_p">The transposition of the entire first and last name performs badly in terms of precision, as we would expect, since we evaluate first and last name as distinct values and then combine their similarities. This could be mitigated by performing an additional comparison with the query first and last name transposed, however, this will have the effect of doubling the computational effort required to perform the matching, which could well push a time consuming process into an infeasible process.</p>
</div>
<figure id="S9.T3" class="ltx_table">
<table id="S9.T3.1" class="ltx_tabular ltx_centering ltx_guessed_headers ltx_align_middle">
<thead class="ltx_thead">
<tr id="S9.T3.1.1.1" class="ltx_tr">
<th id="S9.T3.1.1.1.1" class="ltx_td ltx_align_left ltx_th ltx_th_column ltx_border_l ltx_border_r ltx_border_t"><span id="S9.T3.1.1.1.1.1" class="ltx_text ltx_font_bold">Bi-gram Linking Dice-Coefficient</span></th>
<th id="S9.T3.1.1.1.2" class="ltx_td ltx_th ltx_th_column ltx_border_r ltx_border_t"></th>
<th id="S9.T3.1.1.1.3" class="ltx_td ltx_th ltx_th_column ltx_border_r ltx_border_t"></th>
</tr>
<tr id="S9.T3.1.2.2" class="ltx_tr">
<th id="S9.T3.1.2.2.1" class="ltx_td ltx_align_left ltx_th ltx_th_column ltx_border_l ltx_border_r ltx_border_t"><span id="S9.T3.1.2.2.1.1" class="ltx_text ltx_font_bold">Distortion</span></th>
<th id="S9.T3.1.2.2.2" class="ltx_td ltx_align_center ltx_th ltx_th_column ltx_border_r ltx_border_t"><span id="S9.T3.1.2.2.2.1" class="ltx_text ltx_font_bold">Precision</span></th>
<th id="S9.T3.1.2.2.3" class="ltx_td ltx_align_center ltx_th ltx_th_column ltx_border_r ltx_border_t"><span id="S9.T3.1.2.2.3.1" class="ltx_text ltx_font_bold">Recall</span></th>
</tr>
</thead>
<tbody class="ltx_tbody">
<tr id="S9.T3.1.3.1" class="ltx_tr">
<td id="S9.T3.1.3.1.1" class="ltx_td ltx_align_left ltx_border_l ltx_border_r ltx_border_t">firstName2LetterTranspose</td>
<td id="S9.T3.1.3.1.2" class="ltx_td ltx_align_right ltx_border_r ltx_border_t">0.980</td>
<td id="S9.T3.1.3.1.3" class="ltx_td ltx_align_right ltx_border_r ltx_border_t">1</td>
</tr>
<tr id="S9.T3.1.4.2" class="ltx_tr">
<td id="S9.T3.1.4.2.1" class="ltx_td ltx_align_left ltx_border_l ltx_border_r ltx_border_t">exact</td>
<td id="S9.T3.1.4.2.2" class="ltx_td ltx_align_right ltx_border_r ltx_border_t">0.981</td>
<td id="S9.T3.1.4.2.3" class="ltx_td ltx_align_right ltx_border_r ltx_border_t">1</td>
</tr>
<tr id="S9.T3.1.5.3" class="ltx_tr">
<td id="S9.T3.1.5.3.1" class="ltx_td ltx_align_left ltx_border_l ltx_border_r ltx_border_t">firstLastTranspose</td>
<td id="S9.T3.1.5.3.2" class="ltx_td ltx_align_right ltx_border_r ltx_border_t">0.001</td>
<td id="S9.T3.1.5.3.3" class="ltx_td ltx_align_right ltx_border_r ltx_border_t">1</td>
</tr>
<tr id="S9.T3.1.6.4" class="ltx_tr">
<td id="S9.T3.1.6.4.1" class="ltx_td ltx_align_left ltx_border_b ltx_border_l ltx_border_r ltx_border_t">lastName2LetterTranspose</td>
<td id="S9.T3.1.6.4.2" class="ltx_td ltx_align_right ltx_border_b ltx_border_r ltx_border_t">0.969</td>
<td id="S9.T3.1.6.4.3" class="ltx_td ltx_align_right ltx_border_b ltx_border_r ltx_border_t">1</td>
</tr>
</tbody>
</table>
<figcaption class="ltx_caption"><span class="ltx_tag ltx_tag_table">Table 3: </span>Bi-Gram Linking Results</figcaption>
</figure>
<div id="S9.SS4.p7" class="ltx_para">
<p id="S9.SS4.p7.1" class="ltx_p">The results for the second approach are shown Table <a href="#S9.T4" title="Table 4 ‣ 9.4 Direct Bi-gram matching ‣ 9 Empirical linking results based on a Synthetic Data Generator ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">4</span></a>. They are marginally worse than for the simpler approach. This is somewhat to be expected, since this matching approach is more tolerant of changes, particularly insertion and deletion. As a result, the chance of false positive increases slightly.</p>
</div>
<figure id="S9.T4" class="ltx_table">
<table id="S9.T4.1" class="ltx_tabular ltx_centering ltx_guessed_headers ltx_align_middle">
<thead class="ltx_thead">
<tr id="S9.T4.1.1.1" class="ltx_tr">
<th id="S9.T4.1.1.1.1" class="ltx_td ltx_align_left ltx_th ltx_th_column ltx_border_l ltx_border_r ltx_border_t"><span id="S9.T4.1.1.1.1.1" class="ltx_text ltx_font_bold">Bi-gram Linking q-gram Scoring</span></th>
<th id="S9.T4.1.1.1.2" class="ltx_td ltx_th ltx_th_column ltx_border_r ltx_border_t"></th>
<th id="S9.T4.1.1.1.3" class="ltx_td ltx_th ltx_th_column ltx_border_r ltx_border_t"></th>
</tr>
<tr id="S9.T4.1.2.2" class="ltx_tr">
<th id="S9.T4.1.2.2.1" class="ltx_td ltx_align_left ltx_th ltx_th_column ltx_border_l ltx_border_r ltx_border_t"><span id="S9.T4.1.2.2.1.1" class="ltx_text ltx_font_bold">Distortion</span></th>
<th id="S9.T4.1.2.2.2" class="ltx_td ltx_align_center ltx_th ltx_th_column ltx_border_r ltx_border_t"><span id="S9.T4.1.2.2.2.1" class="ltx_text ltx_font_bold">Precision</span></th>
<th id="S9.T4.1.2.2.3" class="ltx_td ltx_align_center ltx_th ltx_th_column ltx_border_r ltx_border_t"><span id="S9.T4.1.2.2.3.1" class="ltx_text ltx_font_bold">Recall</span></th>
</tr>
</thead>
<tbody class="ltx_tbody">
<tr id="S9.T4.1.3.1" class="ltx_tr">
<td id="S9.T4.1.3.1.1" class="ltx_td ltx_align_left ltx_border_l ltx_border_r ltx_border_t">firstName2LetterTranspose</td>
<td id="S9.T4.1.3.1.2" class="ltx_td ltx_align_right ltx_border_r ltx_border_t">0.975</td>
<td id="S9.T4.1.3.1.3" class="ltx_td ltx_align_right ltx_border_r ltx_border_t">1</td>
</tr>
<tr id="S9.T4.1.4.2" class="ltx_tr">
<td id="S9.T4.1.4.2.1" class="ltx_td ltx_align_left ltx_border_l ltx_border_r ltx_border_t">exact</td>
<td id="S9.T4.1.4.2.2" class="ltx_td ltx_align_right ltx_border_r ltx_border_t">0.980</td>
<td id="S9.T4.1.4.2.3" class="ltx_td ltx_align_right ltx_border_r ltx_border_t">1</td>
</tr>
<tr id="S9.T4.1.5.3" class="ltx_tr">
<td id="S9.T4.1.5.3.1" class="ltx_td ltx_align_left ltx_border_l ltx_border_r ltx_border_t">firstLastTranspose</td>
<td id="S9.T4.1.5.3.2" class="ltx_td ltx_align_right ltx_border_r ltx_border_t">0.001</td>
<td id="S9.T4.1.5.3.3" class="ltx_td ltx_align_right ltx_border_r ltx_border_t">1</td>
</tr>
<tr id="S9.T4.1.6.4" class="ltx_tr">
<td id="S9.T4.1.6.4.1" class="ltx_td ltx_align_left ltx_border_b ltx_border_l ltx_border_r ltx_border_t">lastName2LetterTranspose</td>
<td id="S9.T4.1.6.4.2" class="ltx_td ltx_align_right ltx_border_b ltx_border_r ltx_border_t">0.957</td>
<td id="S9.T4.1.6.4.3" class="ltx_td ltx_align_right ltx_border_b ltx_border_r ltx_border_t">1</td>
</tr>
</tbody>
</table>
<figcaption class="ltx_caption"><span class="ltx_tag ltx_tag_table">Table 4: </span>Bi-Gram Linking Results (q-gram)</figcaption>
</figure>
<div id="S9.SS4.p8" class="ltx_para">
<p id="S9.SS4.p8.1" class="ltx_p">The bi-gram matching approach performs reasonably well, as would be expected. However, the computational cost, combined with it susceptibility to frequency attacks weaken the argument for its use.</p>
</div>
</section>
</section>
<section id="S10" class="ltx_section">
<h2 class="ltx_title ltx_title_section">
<span class="ltx_tag ltx_tag_section">10 </span>Conclusion</h2>

<div id="S10.p1" class="ltx_para">
<p id="S10.p1.1" class="ltx_p">All good cybersecurity solutions are a tradeoff among different objectives: security, usability, access, accuracy, computation time, cost, <span id="S10.p1.1.1" class="ltx_text ltx_font_italic">etc.</span> A clear attacker model is critical for understanding what the security guarantees are, so that the best solution can be chosen.
The aim of this report is to make clear the assumptions of the protocols, so that ABS’s careful processes for managing data security can be accurately matched to the assumptions on which the protocols’ security depends.</p>
</div>
<div id="S10.p2" class="ltx_para">
<p id="S10.p2.1" class="ltx_p">Detailed unit-record level data, including Census data, can often be re-identified even without the name, based on other information about the person or household, such as birthdates and location. The promise to encode names using a cryptographic hash function in a way that cannot be reversed is therefore, if taken absolutely, not achievable in the presence of auxiliary data—many records could be re-identified even if the names were completely removed.</p>
</div>
<div id="S10.p3" class="ltx_para">
<p id="S10.p3.1" class="ltx_p">We have presented several options that satisfy reasonable interpretations of the requirements, in the context of auxiliary data and ABS processes for securing Census data. Option 1 is simple encryption, which (if properly implemented) cannot be reversed except with the decryption key. Option 2, lossy encoding, sends many different names to the same encoded value. It can be reversed to a set of names, but not a unique one (if properly implemented), if the attacker has no auxiliary data about the person. Option 3 produces anonymised linking identifiers that do not make re-identification any easier for an attacker who doesn’t have the HMAC key (if properly implemented). It sacrifices some flexibility for very high computational efficiency. Options 4 and 5 provide suggestions for future directions using some more sophisticated cryptographic approaches based on homomorphic encryption and multiparty computation.</p>
</div>
<div id="S10.p4" class="ltx_para">
<p id="S10.p4.1" class="ltx_p">The most computationally efficient solution we could find is Option 3, to compute an HMAC on a collection of different subsets of attributes, then use exact matches at linking time (Section <a href="#S6" title="6 Option 3: HMAC-based anonymised linkage identifiers using subsets of attributes ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">6</span></a>). This provides some defence against a motivated attacker who does not know the secret key. The only information leaked is about the frequency of the different inputs — if the attributes are carefully chosen it is possible to ensure that every input is unique.
This solution could be adopted, and has approximately the same security, with a lossy encoding of names.</p>
</div>
<div id="S10.p5" class="ltx_para">
<p id="S10.p5.1" class="ltx_p">Our literature review explains why some other proposals in the literature, including plain cryptographic hashing and Bloom filters, do not defend against a motivated attacker.</p>
</div>
<div id="S10.p6" class="ltx_para">
<p id="S10.p6.1" class="ltx_p">We would like to thank the ABS for their time and engagement in discussing these questions. We valued the conversations and the motivation to work on a challenging and important practical problem.</p>
</div>
<div id="S10.p7" class="ltx_para">
<p id="S10.p7.1" class="ltx_p">A key aspect of earning public trust is to be open about the details of the algorithms used for keeping data secure. Whichever solution ABS decides to adopt, we hope that this paper contributes to an open, factual discussion of linking options and census data security.</p>
</div>
</section>
<section id="bib" class="ltx_bibliography">
<h2 class="ltx_title ltx_title_bibliography">References</h2>

<ul class="ltx_biblist">
<li id="bib.bib1" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[1]</span>
<span class="ltx_bibblock">
John Abowd.

</span>
<span class="ltx_bibblock">The Challenge of Privacy Protection for Statistical Agencies.

</span>
<span class="ltx_bibblock">Isaac Newton Institute: Data linkage and anonymisation: setting the
agenda, 2016.

</span>
</li>
<li id="bib.bib2" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[2]</span>
<span class="ltx_bibblock">
Ben Adida, Olivier De Marneffe, Olivier Pereira, Jean-Jacques Quisquater,
et al.

</span>
<span class="ltx_bibblock">Electing a university president using open-audit voting: Analysis of
real-world use of helios.

</span>
<span class="ltx_bibblock"><span id="bib.bib2.1.1" class="ltx_text ltx_font_italic">EVT/WOTE</span>, 9:10–10, 2009.

</span>
</li>
<li id="bib.bib3" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[3]</span>
<span class="ltx_bibblock">
Mikhail J Atallah, Florian Kerschbaum, and Wenliang Du.

</span>
<span class="ltx_bibblock">Secure and private sequence comparisons.

</span>
<span class="ltx_bibblock">In <span id="bib.bib3.1.1" class="ltx_text ltx_font_italic">Proceedings of the 2003 ACM workshop on Privacy in the
electronic society</span>, pages 39–44. ACM, 2003.

</span>
</li>
<li id="bib.bib4" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[4]</span>
<span class="ltx_bibblock">
Tobias Bachteler, Rainer Schnell, and Jörg Reiher.

</span>
<span class="ltx_bibblock">An empirical comparison of approaches to approximate string matching
in private record linkage.

</span>
<span class="ltx_bibblock">In <span id="bib.bib4.1.1" class="ltx_text ltx_font_italic">Proceedings of Statistics Canada Symposium</span>, volume 2010.
Citeseer, 2010.

</span>
</li>
<li id="bib.bib5" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[5]</span>
<span class="ltx_bibblock">
Boaz Barak, Kamalika Chaudhuri, Cynthia Dwork, Satyen Kale, Frank McSherry, and
Kunal Talwar.

</span>
<span class="ltx_bibblock">Privacy, accuracy, and consistency too: a holistic solution to
contingency table release.

</span>
<span class="ltx_bibblock">In <span id="bib.bib5.1.1" class="ltx_text ltx_font_italic">Proceedings of the Twenty-Sixth ACM SIGMOD-SIGACT-SIGART
Symposium on Principles of Database Systems</span>, pages 273–282. ACM, 2007.

</span>
</li>
<li id="bib.bib6" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[6]</span>
<span class="ltx_bibblock">
Mihir Bellare.

</span>
<span class="ltx_bibblock">New proofs for nmac and hmac: Security without collision-resistance.

</span>
<span class="ltx_bibblock">In <span id="bib.bib6.1.1" class="ltx_text ltx_font_italic">Annual International Cryptology Conference</span>, pages 602–619.
Springer, 2006.

</span>
</li>
<li id="bib.bib7" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[7]</span>
<span class="ltx_bibblock">
Steven M Bellovin and William R Cheswick.

</span>
<span class="ltx_bibblock">Privacy-Enhanced Searches Using Encrypted Bloom Filters.

</span>
<span class="ltx_bibblock"><span id="bib.bib7.1.1" class="ltx_text ltx_font_italic">IACR Cryptology ePrint Archive</span>, 2004:22, 2004.

</span>
</li>
<li id="bib.bib8" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[8]</span>
<span class="ltx_bibblock">
AM Benhamiche and J Faivre.

</span>
<span class="ltx_bibblock">Automatic record hash coding and linkage for epidemiological
follow-up data confidentiality.

</span>
<span class="ltx_bibblock"><span id="bib.bib8.1.1" class="ltx_text ltx_font_italic">Meth Inform Med</span>, 37:271–7, 1998.

</span>
</li>
<li id="bib.bib9" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[9]</span>
<span class="ltx_bibblock">
Burton H Bloom.

</span>
<span class="ltx_bibblock">Space/time trade-offs in hash coding with allowable errors.

</span>
<span class="ltx_bibblock"><span id="bib.bib9.1.1" class="ltx_text ltx_font_italic">Communications of the ACM</span>, 13(7):422–426, 1970.

</span>
</li>
<li id="bib.bib10" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[10]</span>
<span class="ltx_bibblock">
Avrim Blum, Katrina Ligett, and Aaron Roth.

</span>
<span class="ltx_bibblock">A learning theory approach to noninteractive database privacy.

</span>
<span class="ltx_bibblock"><span id="bib.bib10.1.1" class="ltx_text ltx_font_italic">Journal of the ACM (JACM)</span>, 60(2):12, 2013.

</span>
</li>
<li id="bib.bib11" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[11]</span>
<span class="ltx_bibblock">
Dan Boneh and Victor Shoup.

</span>
<span class="ltx_bibblock">A Graduate Course in Applied Cryptography, 2016.

</span>
<span class="ltx_bibblock"><a target="_blank" href="https://crypto.stanford.edu/~dabo/cryptobook/" title="" class="ltx_ref ltx_url ltx_font_typewriter">https://crypto.stanford.edu/~dabo/cryptobook/</a>.

</span>
</li>
<li id="bib.bib12" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[12]</span>
<span class="ltx_bibblock">
Andrei Broder and Michael Mitzenmacher.

</span>
<span class="ltx_bibblock">Network applications of bloom filters: A survey.

</span>
<span class="ltx_bibblock"><span id="bib.bib12.1.1" class="ltx_text ltx_font_italic">Internet mathematics</span>, 1(4):485–509, 2004.

</span>
</li>
<li id="bib.bib13" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[13]</span>
<span class="ltx_bibblock">
Jan Camenisch and Anja Lehmann.

</span>
<span class="ltx_bibblock">(un) linkable pseudonyms for governmental databases.

</span>
<span class="ltx_bibblock">In <span id="bib.bib13.1.1" class="ltx_text ltx_font_italic">Proceedings of the 22nd ACM SIGSAC Conference on Computer and
Communications Security</span>, pages 1467–1479. ACM, 2015.

</span>
</li>
<li id="bib.bib14" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[14]</span>
<span class="ltx_bibblock">
Kamalika Chaudhuri and Claire Monteleoni.

</span>
<span class="ltx_bibblock">Privacy-preserving logistic regression.

</span>
<span class="ltx_bibblock">In <span id="bib.bib14.1.1" class="ltx_text ltx_font_italic">Advances in Neural Information Processing Systems</span>, pages
289–296, 2009.

</span>
</li>
<li id="bib.bib15" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[15]</span>
<span class="ltx_bibblock">
Peter Christen.

</span>
<span class="ltx_bibblock"><span id="bib.bib15.1.1" class="ltx_text ltx_font_italic">Data matching: concepts and techniques for record linkage,
entity resolution, and duplicate detection</span>.

</span>
<span class="ltx_bibblock">Springer Science &amp; Business Media, 2012.

</span>
</li>
<li id="bib.bib16" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[16]</span>
<span class="ltx_bibblock">
Tim Churches and Peter Christen.

</span>
<span class="ltx_bibblock">Some methods for blindfolded record linkage.

</span>
<span class="ltx_bibblock"><span id="bib.bib16.1.1" class="ltx_text ltx_font_italic">BMC Medical Informatics and Decision Making</span>, 4(1):1, 2004.

</span>
</li>
<li id="bib.bib17" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[17]</span>
<span class="ltx_bibblock">
Chris Culnane, Benjamin IP Rubinstein, and Vanessa Teague.

</span>
<span class="ltx_bibblock">Health data in an open world.

</span>
<span class="ltx_bibblock"><span id="bib.bib17.1.1" class="ltx_text ltx_font_italic">arXiv preprint arXiv:1712.05627</span>, 2017.

</span>
</li>
<li id="bib.bib18" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[18]</span>
<span class="ltx_bibblock">
Chris Culnane, Benjamin IP Rubinstein, and Vanessa Teague.

</span>
<span class="ltx_bibblock">Vulnerabilities in the use of similarity tables in combination with
pseudonymisation to preserve data privacy in the uk office for national
statistics’ privacy-preserving record linkage.

</span>
<span class="ltx_bibblock"><span id="bib.bib18.1.1" class="ltx_text ltx_font_italic">arXiv preprint arXiv:1712.00871</span>, 2017.

</span>
</li>
<li id="bib.bib19" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[19]</span>
<span class="ltx_bibblock">
Peter C Dillinger and Panagiotis Manolios.

</span>
<span class="ltx_bibblock">Bloom filters in probabilistic verification.

</span>
<span class="ltx_bibblock">In <span id="bib.bib19.1.1" class="ltx_text ltx_font_italic">International Conference on Formal Methods in Computer-Aided
Design</span>, pages 367–381. Springer, 2004.

</span>
</li>
<li id="bib.bib20" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[20]</span>
<span class="ltx_bibblock">
Wenliang Du and Mikhail J Atallah.

</span>
<span class="ltx_bibblock">Protocols for secure remote database access with approximate
matching.

</span>
<span class="ltx_bibblock">In <span id="bib.bib20.1.1" class="ltx_text ltx_font_italic">E-Commerce Security and Privacy</span>, pages 87–111. Springer,
2001.

</span>
</li>
<li id="bib.bib21" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[21]</span>
<span class="ltx_bibblock">
Elizabeth Durham, Yuan Xue, Murat Kantarcioglu, and Bradley Malin.

</span>
<span class="ltx_bibblock">Quantifying the correctness, computational complexity, and security
of privacy-preserving string comparators for record linkage.

</span>
<span class="ltx_bibblock"><span id="bib.bib21.1.1" class="ltx_text ltx_font_italic">Information Fusion</span>, 13(4):245–259, 2012.

</span>
</li>
<li id="bib.bib22" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[22]</span>
<span class="ltx_bibblock">
L Dusserre, C Quantin, and H Bouzelat.

</span>
<span class="ltx_bibblock">A one way public key cryptosystem for the linkage of nominal files in
epidemiological studies.

</span>
<span class="ltx_bibblock"><span id="bib.bib22.1.1" class="ltx_text ltx_font_italic">Medinfo. MEDINFO</span>, 8:644–647, 1994.

</span>
</li>
<li id="bib.bib23" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[23]</span>
<span class="ltx_bibblock">
Cynthia Dwork, Frank McSherry, Kobbi Nissim, and Adam Smith.

</span>
<span class="ltx_bibblock">Calibrating noise to sensitivity in private data analysis.

</span>
<span class="ltx_bibblock">In <span id="bib.bib23.1.1" class="ltx_text ltx_font_italic">Theory of Cryptography Conference</span>, pages 265–284. Springer,
2006.

</span>
</li>
<li id="bib.bib24" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[24]</span>
<span class="ltx_bibblock">
Cynthia Dwork and Aaron Roth.

</span>
<span class="ltx_bibblock">The algorithmic foundations of differential privacy.

</span>
<span class="ltx_bibblock"><span id="bib.bib24.1.1" class="ltx_text ltx_font_italic">Foundations and Trends in Theoretical Computer Science</span>,
9(3–4):211–407, 2014.

</span>
</li>
<li id="bib.bib25" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[25]</span>
<span class="ltx_bibblock">
Ivan P Fellegi and Alan B Sunter.

</span>
<span class="ltx_bibblock">A theory for record linkage.

</span>
<span class="ltx_bibblock"><span id="bib.bib25.1.1" class="ltx_text ltx_font_italic">Journal of the American Statistical Association</span>,
64(328):1183–1210, 1969.

</span>
</li>
<li id="bib.bib26" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[26]</span>
<span class="ltx_bibblock">
Kristin Finklea, Michelle D Christensen, Eric A Fischer, Susan V Lawrence, and
Catherine A Theohary.

</span>
<span class="ltx_bibblock">Cyber intrusion into us office of personnel management: In brief.

</span>
<span class="ltx_bibblock">Crs report, Congressional Research Service, 2015.

</span>
<span class="ltx_bibblock"><a target="_blank" href="http://digitalcommons.ilr.cornell.edu/cgi/viewcontent.cgi?article=2447&amp;context=key_workplace" title="" class="ltx_ref ltx_url ltx_font_typewriter">http://digitalcommons.ilr.cornell.edu/cgi/viewcontent.cgi?article=2447&amp;context=key_workplace</a>.

</span>
</li>
<li id="bib.bib27" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[27]</span>
<span class="ltx_bibblock">
Maxence Guesdon, Eric Benzenine, Kamel Gadouche, and Catherine Quantin.

</span>
<span class="ltx_bibblock">Securizing data linkage in french public statistics.

</span>
<span class="ltx_bibblock"><span id="bib.bib27.1.1" class="ltx_text ltx_font_italic">BMC Medical Informatics and Decision Making</span>, 16(1):129, 2016.

</span>
</li>
<li id="bib.bib28" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[28]</span>
<span class="ltx_bibblock">
Rob Hall and Stephen E Fienberg.

</span>
<span class="ltx_bibblock">Privacy-preserving record linkage.

</span>
<span class="ltx_bibblock">In <span id="bib.bib28.1.1" class="ltx_text ltx_font_italic">International conference on privacy in statistical
databases</span>, pages 269–283. Springer, 2010.

</span>
</li>
<li id="bib.bib29" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[29]</span>
<span class="ltx_bibblock">
Ali Inan, Murat Kantarcioglu, Gabriel Ghinita, and Elisa Bertino.

</span>
<span class="ltx_bibblock">Private record matching using differential privacy.

</span>
<span class="ltx_bibblock">In <span id="bib.bib29.1.1" class="ltx_text ltx_font_italic">Proceedings of the 13th International Conference on Extending
Database Technology</span>, pages 123–134. ACM, 2010.

</span>
</li>
<li id="bib.bib30" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[30]</span>
<span class="ltx_bibblock">
Alexandros Karakasidis, Vassilios S Verykios, and Peter Christen.

</span>
<span class="ltx_bibblock">Fake injection strategies for private phonetic matching.

</span>
<span class="ltx_bibblock">In <span id="bib.bib30.1.1" class="ltx_text ltx_font_italic">Data Privacy Management and Autonomous Spontaneus Security</span>,
pages 9–24. Springer, 2012.

</span>
</li>
<li id="bib.bib31" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[31]</span>
<span class="ltx_bibblock">
Florian Kerschbaum.

</span>
<span class="ltx_bibblock">Public-key encrypted bloom filters with applications to supply chain
integrity.

</span>
<span class="ltx_bibblock">In <span id="bib.bib31.1.1" class="ltx_text ltx_font_italic">IFIP Annual Conference on Data and Applications Security and
Privacy</span>, pages 60–75. Springer, 2011.

</span>
</li>
<li id="bib.bib32" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[32]</span>
<span class="ltx_bibblock">
Adam Kirsch and Michael Mitzenmacher.

</span>
<span class="ltx_bibblock">Less hashing, same performance: Building a better bloom filter.

</span>
<span class="ltx_bibblock">In <span id="bib.bib32.1.1" class="ltx_text ltx_font_italic">European Symposium on Algorithms</span>, pages 456–467. Springer,
2006.

</span>
</li>
<li id="bib.bib33" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[33]</span>
<span class="ltx_bibblock">
Hugo Krawczyk, Ran Canetti, and Mihir Bellare.

</span>
<span class="ltx_bibblock">Hmac: Keyed-hashing for message authentication.

</span>
<span class="ltx_bibblock">RFC 2104, IETF, 1997.

</span>
<span class="ltx_bibblock"><a target="_blank" href="https://tools.ietf.org/html/rfc2104" title="" class="ltx_ref ltx_url ltx_font_typewriter">https://tools.ietf.org/html/rfc2104</a>.

</span>
</li>
<li id="bib.bib34" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[34]</span>
<span class="ltx_bibblock">
Mehmet Kuzu, Murat Kantarcioglu, Elizabeth Durham, and Bradley Malin.

</span>
<span class="ltx_bibblock">A constraint satisfaction cryptanalysis of bloom filters in private
record linkage.

</span>
<span class="ltx_bibblock">In <span id="bib.bib34.1.1" class="ltx_text ltx_font_italic">International Symposium on Privacy Enhancing Technologies
Symposium</span>, pages 226–245. Springer, 2011.

</span>
</li>
<li id="bib.bib35" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[35]</span>
<span class="ltx_bibblock">
Ronan A Lyons, Kerina H Jones, Gareth John, Caroline J Brooks, Jean-Philippe
Verplancke, David V Ford, Ginevra Brown, and Ken Leake.

</span>
<span class="ltx_bibblock">The SAIL databank: linking multiple health and social care
datasets.

</span>
<span class="ltx_bibblock"><span id="bib.bib35.1.1" class="ltx_text ltx_font_italic">BMC medical informatics and decision making</span>, 9(1):1, 2009.

</span>
</li>
<li id="bib.bib36" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[36]</span>
<span class="ltx_bibblock">
Joseph Menn and John Walcott.

</span>
<span class="ltx_bibblock">Probe of leaked u.s. NSA hacking tools examines operative’s
‘mistake’, Sep 2016.

</span>
<span class="ltx_bibblock"><a target="_blank" href="http://www.reuters.com/article/us-cyber-nsa-tools-idUSKCN11S2MF" title="" class="ltx_ref ltx_url ltx_font_typewriter">http://www.reuters.com/article/us-cyber-nsa-tools-idUSKCN11S2MF</a>.

</span>
</li>
<li id="bib.bib37" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[37]</span>
<span class="ltx_bibblock">
Office of National Statistics UK.

</span>
<span class="ltx_bibblock">Beyond 2011 Matching Anonymous Data M9, 2013.

</span>
</li>
<li id="bib.bib38" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[38]</span>
<span class="ltx_bibblock">
Chaoyi Pang and David Hansen.

</span>
<span class="ltx_bibblock">Improved record linkage for encrypted identifying data.

</span>
<span class="ltx_bibblock"><span id="bib.bib38.1.1" class="ltx_text ltx_font_italic">HIC 2006 and HINZ 2006: Proceedings</span>, page 164, 2006.

</span>
</li>
<li id="bib.bib39" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[39]</span>
<span class="ltx_bibblock">
Catherine Quantin, E Benzenine, FA Allaert, M Guesdon, JB Gouyon, and
B Riandey.

</span>
<span class="ltx_bibblock">Epidemiological and statistical secured matching in france.

</span>
<span class="ltx_bibblock"><span id="bib.bib39.1.1" class="ltx_text ltx_font_italic">Statistical Journal of the IAOS</span>, 30(3):255–261, 2014.

</span>
</li>
<li id="bib.bib40" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[40]</span>
<span class="ltx_bibblock">
M. V. Ramakrishna.

</span>
<span class="ltx_bibblock">Practical performance of bloom filters and parallel free-text
searching.

</span>
<span class="ltx_bibblock"><span id="bib.bib40.1.1" class="ltx_text ltx_font_italic">Commun. ACM</span>, 32(10):1237–1239, October 1989.

</span>
</li>
<li id="bib.bib41" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[41]</span>
<span class="ltx_bibblock">
Sean M Randall, Anna M Ferrante, James H Boyd, Jacqueline K Bauer, and James B
Semmens.

</span>
<span class="ltx_bibblock">Privacy-preserving record linkage on large real world datasets.

</span>
<span class="ltx_bibblock"><span id="bib.bib41.1.1" class="ltx_text ltx_font_italic">Journal of biomedical informatics</span>, 50:205–212, 2014.

</span>
</li>
<li id="bib.bib42" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[42]</span>
<span class="ltx_bibblock">
Monica Scannapieco, Ilya Figotin, Elisa Bertino, and Ahmed K Elmagarmid.

</span>
<span class="ltx_bibblock">Privacy preserving schema and data matching.

</span>
<span class="ltx_bibblock">In <span id="bib.bib42.1.1" class="ltx_text ltx_font_italic">Proceedings of the 2007 ACM SIGMOD international conference
on Management of data</span>, pages 653–664. ACM, 2007.

</span>
</li>
<li id="bib.bib43" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[43]</span>
<span class="ltx_bibblock">
Rainer Schnell, Tobias Bachteler, and Jörg Reiher.

</span>
<span class="ltx_bibblock">Privacy-preserving record linkage using bloom filters.

</span>
<span class="ltx_bibblock"><span id="bib.bib43.1.1" class="ltx_text ltx_font_italic">BMC medical informatics and decision making</span>, 9(1):41, 2009.

</span>
</li>
<li id="bib.bib44" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[44]</span>
<span class="ltx_bibblock">
Rainer Schnell, Tobias Bachteler, and Jörg Reiher.

</span>
<span class="ltx_bibblock">Private record linkage with bloom filters.

</span>
<span class="ltx_bibblock"><span id="bib.bib44.1.1" class="ltx_text ltx_font_italic">Social Statistics: The Interplay among Censuses, Surveys and
Administrative Data</span>, pages 304–9, 2010.

</span>
</li>
<li id="bib.bib45" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[45]</span>
<span class="ltx_bibblock">
Adi Shamir.

</span>
<span class="ltx_bibblock">How to share a secret.

</span>
<span class="ltx_bibblock"><span id="bib.bib45.1.1" class="ltx_text ltx_font_italic">Communications of the ACM</span>, 22(11):612–613, 1979.

</span>
</li>
<li id="bib.bib46" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[46]</span>
<span class="ltx_bibblock">
Stanley Trepetin.

</span>
<span class="ltx_bibblock">Privacy-preserving string comparisons in record linkage systems: a
review.

</span>
<span class="ltx_bibblock"><span id="bib.bib46.1.1" class="ltx_text ltx_font_italic">Information Security Journal: A Global Perspective</span>,
17(5-6):253–266, 2008.

</span>
</li>
<li id="bib.bib47" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[47]</span>
<span class="ltx_bibblock">
Esko Ukkonen.

</span>
<span class="ltx_bibblock">Approximate string-matching with q-grams and maximal matches.

</span>
<span class="ltx_bibblock"><span id="bib.bib47.1.1" class="ltx_text ltx_font_italic">Theoretical computer science</span>, 92(1):191–211, 1992.

</span>
</li>
<li id="bib.bib48" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[48]</span>
<span class="ltx_bibblock">
Dinusha Vatsalan, Peter Christen, and Vassilios S Verykios.

</span>
<span class="ltx_bibblock">An efficient two-party protocol for approximate matching in private
record linkage.

</span>
<span class="ltx_bibblock">In <span id="bib.bib48.1.1" class="ltx_text ltx_font_italic">Proceedings of the Ninth Australasian Data Mining
Conference-Volume 121</span>, pages 125–136. Australian Computer Society, Inc.,
2011.

</span>
</li>
<li id="bib.bib49" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[49]</span>
<span class="ltx_bibblock">
Dinusha Vatsalan, Peter Christen, and Vassilios S Verykios.

</span>
<span class="ltx_bibblock">A taxonomy of privacy-preserving record linkage techniques.

</span>
<span class="ltx_bibblock"><span id="bib.bib49.1.1" class="ltx_text ltx_font_italic">Information Systems</span>, 38(6):946–969, 2013.

</span>
</li>
<li id="bib.bib50" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[50]</span>
<span class="ltx_bibblock">
Susan C Weber, Henry Lowe, Amar Das, and Todd Ferris.

</span>
<span class="ltx_bibblock">A simple heuristic for blindfolded record linkage.

</span>
<span class="ltx_bibblock"><span id="bib.bib50.1.1" class="ltx_text ltx_font_italic">Journal of the American Medical Informatics Association</span>,
19(e1):e157–e161, 2012.

</span>
</li>
<li id="bib.bib51" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[51]</span>
<span class="ltx_bibblock">
William E Yancey.

</span>
<span class="ltx_bibblock">Evaluating string comparator performance for record linkage.

</span>
<span class="ltx_bibblock"><span id="bib.bib51.1.1" class="ltx_text ltx_font_italic">Statistical Research Division Research Report</span>, 2005.

</span>
<span class="ltx_bibblock"><a target="_blank" href="http://www.census.gov/srd/papers/pdf/rrs2005-05.pdf" title="" class="ltx_ref ltx_url ltx_font_typewriter">http://www.census.gov/srd/papers/pdf/rrs2005-05.pdf</a>.

</span>
</li>
</ul>
</section>
<section id="A1" class="ltx_appendix">
<h2 class="ltx_title ltx_title_appendix">
<span class="ltx_tag ltx_tag_appendix">Appendix A </span>Literature Review</h2>

<div id="A1.p1" class="ltx_para">
<p id="A1.p1.1" class="ltx_p">The field of record linkage has a long history, dating back nearly 50 years <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib25" title="" class="ltx_ref">25</a>]</cite>. Privacy Preserving Record Linkage (PPRL) dates back over a decade <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib22" title="" class="ltx_ref">22</a>]</cite>. A significant proportion of the literature has been published outside of Computer Science and Information Security venues, with a particular prevalence for publication within the medical domain.
This has resulted in proposals not being subjected to the normal level of rigour and analysis associated with information security.
A number of schemes do not achieve their claimed privacy properties.
Cryptographic primitives such as hashing have been used without a clear understanding of the security properties they provide and the attacker model they defend against. Persistent mistakes leading to security problems are repeated in many papers, even when the security issues have been identified.</p>
</div>
<div id="A1.p2" class="ltx_para">
<p id="A1.p2.1" class="ltx_p">Another significant problem is that protocols designed for one attacker model are reused in a different context. For example, a technique that obfuscates information well enough for well-meaning researchers in a controlled environment may not be sufficiently secure for publishing on the Internet, where malicious and dedicated attackers will attempt to reverse it.</p>
</div>
<div id="A1.p3" class="ltx_para">
<p id="A1.p3.1" class="ltx_p">Christen <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib15" title="" class="ltx_ref">15</a>]</cite> provides an overview of various techniques and methods for privacy preserving record linkage. The initial part of Christen’s book <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib15" title="" class="ltx_ref">15</a>]</cite> covers some of the typical trust assumptions associated with privacy preserving record linkage. Of note is the assumption that when matching data within a single organisation, as in our context, the employees responsible for performing the data matching “…do not have malicious intents to take identifying or other sensitive information, or the matched data, outside of their organisations for personal gain”. It is crucial, throughout this review of the literature, to distinguish the techniques that assume that the data will only be available to those without “malicious intents” from those that defend against deliberate attack. Whilst the work covers both hashing approaches and cryptographic approaches, the conclusion is that “simple one-way hash encoding allows efficient privacy preserving data matching across organisations”.
This is not correct against a motivated attacker. Christen details the attacks—dictionary and frequency—that result in hashing not being secure in that case.</p>
</div>
<div id="A1.p4" class="ltx_para">
<p id="A1.p4.1" class="ltx_p">Vatsalan et al. <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib49" title="" class="ltx_ref">49</a>]</cite> provide a taxonomy and overview of the field as a whole. Their taxonomy is both thorough and extensive. It reveals that all the schemes included in their taxonomy, which do not rely in some part on Secure Multi-party Computation (SMC), are susceptible to some form of privacy attack (dictionary, frequency, cryptanalysis). Such a view is not new, Trepetin’s review of Privacy Preserving String Comparisons in 2008 <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib46" title="" class="ltx_ref">46</a>]</cite> drew similar conclusions.</p>
</div>
<div id="A1.p5" class="ltx_para">
<p id="A1.p5.1" class="ltx_p">This section is divided into a number of sub-sections, Section <a href="#A1.SS2" title="A.2 Hashing and HMACs ‣ Appendix A Literature Review ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">A.2</span></a> discusses some of the schemes based on hashing and HMACs. Section <a href="#A1.SS4" title="A.4 Security and accuracy of current literature on Bloom Filters ‣ Appendix A Literature Review ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">A.4</span></a> looks at the usage of Bloom filters, whilst Section <a href="#A1.SS6" title="A.6 Secure Multi-Party Computation ‣ Appendix A Literature Review ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">A.6</span></a> explores Secure Multi-Party Computation approaches. Section <a href="#A1.SS8" title="A.8 UK Office of National Statistics ‣ Appendix A Literature Review ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">A.8</span></a> provides an in-depth analysis of the UK Office of National Statistics approach, which is closely aligned in aims, but unfortunately is insecure.</p>
</div>
<div id="A1.p6" class="ltx_para">
<p id="A1.p6.1" class="ltx_p">In terms of security the most promising approaches are based on Secure Multi-party Computation (SMC), which is rooted in the more formalised and rigorous field of cryptography. Such schemes offer stricter security guarantees and the potential to perform linking across multiple organisations. However, the current crop of SMC schemes are not efficient enough for deployment at large scale. Additionally, their dependence on having multiple independent parties is at odds with the setting the ABS operates in, in which it is the sole organisation performing the linking. A move to a more distributed, multi-party setting offers significant potential, and should be considered as part of a longer-term strategy. In the interim a more efficient approach will be required to meet the immediate privacy and linking requirements of the ABS.</p>
</div>
<section id="A1.SS1" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">A.1 </span>Data Matching: Concepts and Techniques For Record Linkage,Entity Resolution, and Duplicate Detection - Peter Christen <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib15" title="" class="ltx_ref">15</a>]</cite>
</h3>

<div id="A1.SS1.p1" class="ltx_para">
<p id="A1.SS1.p1.1" class="ltx_p">One of the seminal references in the field is the Data Matching book <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib15" title="" class="ltx_ref">15</a>]</cite> by Peter Christen. The book covers record linkage and the associated methodologies. The Chapter of particular interest for us is <em id="A1.SS1.p1.1.1" class="ltx_emph ltx_font_italic">Chapter 8 - Privacy Aspects of Data Matching</em>. Many of the approaches referenced by Christen in Chapter 8 are explored in more detail below. This section will act as an overview of the chapter as whole.</p>
</div>
<section id="A1.SS1.SSS1" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">A.1.1 </span>Framing Privacy Preserving Data Matching</h4>

<div id="A1.SS1.SSS1.p1" class="ltx_para">
<p id="A1.SS1.SSS1.p1.1" class="ltx_p">The chapter highlights that damage can occur where identification of only a few, or even just one, record occurs. For example, identifying a politician/celebrity in a medical dataset. Likewise, incorrect matches can cause damage if the output dataset is revealing a particular threat or characteristic, for example, identifying possible terrorists. Christen discusses the wider risks of re-identification that occur, even when identifiers have been removed. De-identification is a topic in its own right, and is beyond the scope of this document, but is of relevance to the data held by the ABS and the ability to re-identify after the deletion of the name and address. Christen provides an overview of scenarios where privacy and data mining interests have collided and emphasises the importance of addressing it.</p>
</div>
</section>
<section id="A1.SS1.SSS2" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">A.1.2 </span>Trust and Security Models</h4>

<div id="A1.SS1.SSS2.p1" class="ltx_para">
<p id="A1.SS1.SSS2.p1.1" class="ltx_p">In addition to the assumption of honesty in the single organisation setting, there are further assumptions for the multiple organisation setting. Christen provides two categories for the multi-party setting: the three party case, and the two party case. In the three party case a third party is required to perform the linking. In the two party case, two database owners work together, without any additional party, to perform the linking. The three party cases is not ideal due to the need to add an additional party, due to the risks associated with another linking party colluding with, or compromising, the third party. Whilst the two party setup is preferred, it often comes at the cost of higher computation complexity and runtimes.</p>
</div>
<div id="A1.SS1.SSS2.p2" class="ltx_para">
<p id="A1.SS1.SSS2.p2.1" class="ltx_p">Christen provides an overview of two most common security models used in the literature. The first is the semi-honest model, which is often referred to as the honest-but-curious model. In such a model the participants behave honestly with regard to the protocol, in that they send valid messages and respond accordingly, but they are free to record and infer as much information as they can. As such, they are free to mount frequency attacks and dictionary attacks as we discussed in Section <a href="#S2.SS1" title="2.1 How cryptographic hashes of names can be reversed ‣ 2 Background on Cryptography and possible attacks ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">2.1</span></a> and <a href="#S2.SS1.SSS3" title="2.1.3 Determinism and frequency attacks ‣ 2.1 How cryptographic hashes of names can be reversed ‣ 2 Background on Cryptography and possible attacks ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">2.1.3</span></a>. Participants are also free to augment their knowledge with any publicly available data, for example, the phone book.</p>
</div>
<div id="A1.SS1.SSS2.p3" class="ltx_para">
<p id="A1.SS1.SSS2.p3.1" class="ltx_p">The second security model is the malicious model, which does not place any restrictions on the participants. Furthermore, it allows participants to both deviate from the protocol and send malicious content in order to try and infer further information. It is a much stronger model than the honest-but-curious model, and is used in many secure multi-party computation protocols. Achieving privacy in the malicious model is much harder, due to the power of the adversary, and as such, it often requires the use of sophisticated cryptography.</p>
</div>
</section>
<section id="A1.SS1.SSS3" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">A.1.3 </span>Exact Matching</h4>

<div id="A1.SS1.SSS3.p1" class="ltx_para">
<p id="A1.SS1.SSS3.p1.1" class="ltx_p">Christen explains at length the usage of hashing for exact matching, as well as referencing a number of papers related to schemes developed by French researchers in the 90’s. Christen correctly notes the susceptibility of hashing approaches to dictionary attacks. He proceeds to state that due to this weakness “…simple hash-encoding approaches to privacy-preserving matching can only work for three-party protocols” <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib15" title="" class="ltx_ref">15</a>]</cite>. However, the subsequent paragraph explains that the dictionary attack weakness still exists with three parties, since the third party can mount the dictionary attack itself. The suggested counter to this is to use a keyed hash since this will prevent the dictionary attacks. This is then shown to also not work, since the third party can still mount a frequency attack. As such, there is no demonstration of any protocol that works under either of the defined security models, for either the two or three party setting. This is not explicitly stated, but the consequence is that schemes that utilise such approaches are in fact only sound under a fully-trusted third-party security model. In such a model, the third party is assumed to behave completely honestly and does not try to learn anything beyond what it has been given.
This is an extremely weak security model which is not appropriate for ABS because it requires complete protection of all the data.</p>
</div>
<div id="A1.SS1.SSS3.p2" class="ltx_para">
<p id="A1.SS1.SSS3.p2.1" class="ltx_p">Christen references a number of protocols, mostly secure multi-party protocols, for database record matching and extraction. None of which are relevant to our setting due to their only being able to achieve exact matches. There are also further limitations in that one party potentially learns the contents of a match, which is not consistent with our requirements.</p>
</div>
<div id="A1.SS1.SSS3.p3" class="ltx_para">
<p id="A1.SS1.SSS3.p3.1" class="ltx_p">The summary of the section on hashing states “…while simple one-way hash encoding allows efficient privacy preserving data matching across organisations, the main limitation of these approaches is that they can only find exact matches” <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib15" title="" class="ltx_ref">15</a>]</cite>. In fact, the main limitation is that it does not provide privacy under either security model defined earlier in the chapter. The fact it only permits exact matching is secondary if an intended privacy preserving record linkage method does not provide privacy.</p>
</div>
</section>
<section id="A1.SS1.SSS4" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">A.1.4 </span>Approximate Matching</h4>

<div id="A1.SS1.SSS4.p1" class="ltx_para">
<p id="A1.SS1.SSS4.p1.1" class="ltx_p">Christen provides short overviews of a number of techniques and challenges in approximate matching, including <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib3" title="" class="ltx_ref">3</a>]</cite>, <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib16" title="" class="ltx_ref">16</a>]</cite>, <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib43" title="" class="ltx_ref">43</a>]</cite>, and <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib34" title="" class="ltx_ref">34</a>]</cite>, all of which we cover in more detail below. He also references a number of survey papers, including <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib21" title="" class="ltx_ref">21</a>]</cite> and <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib46" title="" class="ltx_ref">46</a>]</cite>, both of which we discuss later in this section.</p>
</div>
<div id="A1.SS1.SSS4.p2" class="ltx_para">
<p id="A1.SS1.SSS4.p2.1" class="ltx_p">The conclusion taken from this part of the chapter, and the subject of the subsequent section, was that schemes did not take into consideration the computation cost of deploying them at scale. This is discussed further in “A taxonomy of privacy-preserving record linkage techniques” <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib49" title="" class="ltx_ref">49</a>]</cite>, of which Christen is a co-author. The chapter continues by discussing blocking and indexing techniques that can be used to improve the efficiency of running complex protocols on large datasets. Such approaches will be important to the efficiency of any approach taken by the ABS, but are beyond the scope of this paper.</p>
</div>
</section>
<section id="A1.SS1.SSS5" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">A.1.5 </span>Overall</h4>

<div id="A1.SS1.SSS5.p1" class="ltx_para">
<p id="A1.SS1.SSS5.p1.1" class="ltx_p">There is no single recommended approach, with trade-offs present in all. Sometimes those trade-offs are privacy related, sometimes complexity related. The chapter provides suggested areas of further reading, many of which we will refer to in the following sections. The overall conclusion should be that this is still an active area of research, and as such, no definitive solution has been found.</p>
</div>
</section>
</section>
<section id="A1.SS2" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">A.2 </span>Hashing and HMACs</h3>

<div id="A1.SS2.p1" class="ltx_para">
<p id="A1.SS2.p1.1" class="ltx_p">The usage of hashing in privacy preserving record linkage has a long history, and surprisingly, given its weaknesses, is still being used today. Quantin et al. <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib39" title="" class="ltx_ref">39</a>]</cite> utilise a salted hash algorithm, based on the approach by Benhamiche and Faivre <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib8" title="" class="ltx_ref">8</a>]</cite>, from 1998. The approach combines a cryptographic hash with a salt. A salt is an additional random input combined with the plaintext to prevent simple dictionary attacks. It is used most typically when hashing passwords. Benhamiche and Faivre <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib8" title="" class="ltx_ref">8</a>]</cite> use a deterministic salt generation algorithm of their own creation. As a result, the input will always hash to the same output. As a result the output remains susceptible to frequency attacks. Additionally, the usage of a deterministic salt generation algorithm is concerning, as it significantly reduces randomness, and when faced with frequency attacks, could allow recovery of all or parts of the salt codebook. Such an approach is not applicable to our setting because of the susceptibility to frequency attacks and questionable security properties of the underlying primitive.</p>
</div>
<div id="A1.SS2.p2" class="ltx_para">
<p id="A1.SS2.p2.1" class="ltx_p">Weber et al. <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib50" title="" class="ltx_ref">50</a>]</cite> proposed a similar construction to Quantin et al. <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib39" title="" class="ltx_ref">39</a>]</cite>, using a salted MD5 hash. Their contribution was in the construction of a linkage key, which involved an approach similar to the one taken by the ONS <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib37" title="" class="ltx_ref">37</a>]</cite>, except Weber et al. propose just a single linkage key. They postulate that the most errors in names occur after the first two characters. As such, taking the first two characters of the first and last names, and combining them with the date of birth, produces a highly unique linkage key. Whilst they do not provide an in-depth analysis of their assumption, it would appear to be consistent with what is shown by the ONS <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib37" title="" class="ltx_ref">37</a>]</cite>. Furthermore, if the approach does yield highly unique linking keys it will mitigate the chances of a frequency attack on the output tags. They also assume that the date of birth is highly reliable, which could well be true in medical settings, but may not be true on survey/census data. It would seem likely that different formats for dates could easily lead to month and day being transposed. Their approach does not handle fuzzy matching, and there is an inherent reversibility if one has knowledge of the key.</p>
</div>
<div id="A1.SS2.p3" class="ltx_para">
<p id="A1.SS2.p3.1" class="ltx_p">Churches and Christen <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib16" title="" class="ltx_ref">16</a>]</cite> first evaluate a previously proposed french scheme <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib22" title="" class="ltx_ref">22</a>]</cite>, highlighting some weaknesses before proposing a new approach. The paper discusses the weaknesses of Hashes, as well as the weakness that HMACs remains susceptible to frequency attacks. Despite this observation, their proposed scheme still utilises HMACs. The authors justify this on the basis of a trust model that involves trusting a third party to not perform an attack or to collude with another party. The full protocol involves five parties, with various different trust assumptions. There is also a suggestion that having multiple trusted third parties, selecting which one to use at the last minute, will improve security. This assertion is not justified by rigorous security analysis. The approach is not applicable to our setting because the security stems from the trust assumptions, not the protocol or methods themselves.</p>
</div>
<div id="A1.SS2.p4" class="ltx_para">
<p id="A1.SS2.p4.1" class="ltx_p">Other schemes mix hashing with crytpo via more complicated protocols. For example, Guesdon et al. <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib27" title="" class="ltx_ref">27</a>]</cite> apply multiple keyed hashes, as well as using asymmetric cryptography. The cryptography is only used for the transmission of the data, not in the underlying security of it. The scheme relies on a trusted third party that can decrypt the asymmetric ciphers. The scheme also utilises two rounds of keyed hashing, although it isn’t clear as to what additional security this really delivers. The scheme remains susceptible to frequency attacks, and combined with dependence on a trusted third party makes it unsuitable for our context.</p>
</div>
<div id="A1.SS2.p5" class="ltx_para">
<p id="A1.SS2.p5.1" class="ltx_p">Any scheme that relies on directly hashing or HMAC’ing the identifier will not be applicable due to susceptibility to frequency attack. Additionally, despite many papers misunderstanding the nature of hashes, they remain reversible when used over a small input set—the case in our context. HMACs do not solve that problem, they just place a dependence on knowledge of a secret key. As such, they become equivalent to symmetric encryption. If symmetric encryption is deemed inappropriate due to the recoverability, then HMACs are equally inappropriate.</p>
</div>
</section>
<section id="A1.SS3" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">A.3 </span>Similarity Tables</h3>

<div id="A1.SS3.p1" class="ltx_para">
<p id="A1.SS3.p1.1" class="ltx_p">The approach taken by Pang and Hansen <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib38" title="" class="ltx_ref">38</a>]</cite> claims to use encryption, although it appears it actually uses a keyed hash function. The misuses and substitution of cryptographic terminology is not uncommon in the field, but presents significant problems when performing a security analysis. The underlying approach is not of particular interest, as it suffers from the same weaknesses as the previously discussed approaches. However, it presents an approach for performing fuzzy matching on the values. The authors propose using a similarity table to calculate string similarity in advance of the linking.</p>
</div>
<div id="A1.SS3.p2" class="ltx_para">
<p id="A1.SS3.p2.1" class="ltx_p">A similarity table is formed by first constructing a list of distinct values. This could come from the data itself, as in the ONS case <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib37" title="" class="ltx_ref">37</a>]</cite>, or from an independent source, for example a voter registration database or phone book, as suggested by Pang and Hansen <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib38" title="" class="ltx_ref">38</a>]</cite>. Both parties must have the same list and prior to hashing they calculate the similarity of the plaintexts. If the similarities are below a threshold they are kept and stored in the similarity table, indexed by the hashed identifiers. When performing the linking, non exact matches can be be found by checking for records for the two hashes in the similarity table and retrieving the respective similarity scores.</p>
</div>
<div id="A1.SS3.p3" class="ltx_para">
<p id="A1.SS3.p3.1" class="ltx_p">The Pang and Hansen protocol <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib38" title="" class="ltx_ref">38</a>]</cite> is dependent on having two independent parties and a trusted third party to perform the actual linking, and as such is not applicable to our context. However, the concept of pre-calculating a similarity matrix has some merit, and is used in the ONS <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib37" title="" class="ltx_ref">37</a>]</cite> approach. Whilst the Pang and Hansen <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib38" title="" class="ltx_ref">38</a>]</cite> approach is not directly applicable, the concept of a similarity table is worth further consideration.</p>
</div>
<div id="A1.SS3.p4" class="ltx_para">
<p id="A1.SS3.p4.1" class="ltx_p">Vatsalan et al. <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib48" title="" class="ltx_ref">48</a>]</cite> propose a similar approach although they pre-process the database using phonetic similarity and a blocking process prior to calculating the similarity. Each block is only compared for similarity with the reference values associated with its block, thus reducing the size of the similarity table that needs to be calculated. The authors also use the reverse triangular inequality, instead of the triangular inequality used by Pang and Hansen <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib38" title="" class="ltx_ref">38</a>]</cite>. Whilst the approach offers some efficiency advantages, it does not fundamentally change the privacy properties, or the reliance on a trusted third party.</p>
</div>
</section>
<section id="A1.SS4" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">A.4 </span>Security and accuracy of current literature on Bloom Filters</h3>

<div id="A1.SS4.p1" class="ltx_para">
<p id="A1.SS4.p1.1" class="ltx_p">Bloom filters <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib9" title="" class="ltx_ref">9</a>]</cite> have been widely discussed in the privacy preserving record linkage literature. It is important to note that Bloom filters are a technique for performing set comparison, not preserving privacy. A number of papers have shown that Bloom filters remain susceptible to frequency attacks when used directly with plaintexts. However, that does not preclude their use for comparing sets of privacy-preserving elements. For example, it would be possible to create a Bloom filter from the linking identifiers in Section <a href="#S6" title="6 Option 3: HMAC-based anonymised linkage identifiers using subsets of attributes ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">6</span></a>. This would be advantageous if there was a constraint on storage space. However, this would have a significant impact on the efficiency of linking because the efficient indexes that could be created for the HMAC identifiers would no longer be possible. Like other probabilistic linking techniques, the comparison of Bloom filters requires a full cross comparison of the entire database, and for each comparison a full traversal of bits in the respective Bloom filters. This would make full population linking infeasible, and would be computationally expensive in comparison to deterministic linking, even with appropriate blocking.</p>
</div>
<div id="A1.SS4.p2" class="ltx_para">
<p id="A1.SS4.p2.1" class="ltx_p">In summary, Bloom filters are useful for set comparison, but are not a privacy preserving method in their own right.</p>
</div>
<section id="A1.SS4.SSS1" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">A.4.1 </span>Bloom Filter construction</h4>

<div id="A1.SS4.SSS1.p1" class="ltx_para">
<p id="A1.SS4.SSS1.p1.1" class="ltx_p">Constructing an efficient Bloom filter is non-trivial, requiring multiple independent hashes. The simple approach to generating indepedent hashes is to use Universal Hashing in the form of a Carter-Wegman hash. Such hashes are of the form:</p>
</div>
<div id="A1.SS4.SSS1.p2" class="ltx_para">
<table id="A1.Ex2" class="ltx_equation ltx_eqn_table">

<tbody><tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math id="A1.Ex2.m1.2" class="ltx_math_unparsed" alttext="h_{(a,b)}=((ax+b)\bmod p\bmod L" display="block"><semantics id="A1.Ex2.m1.2a"><mrow id="A1.Ex2.m1.2b"><msub id="A1.Ex2.m1.2.3"><mi id="A1.Ex2.m1.2.3.2">h</mi><mrow id="A1.Ex2.m1.2.2.2.4"><mo stretchy="false" id="A1.Ex2.m1.2.2.2.4.1">(</mo><mi id="A1.Ex2.m1.1.1.1.1">a</mi><mo id="A1.Ex2.m1.2.2.2.4.2">,</mo><mi id="A1.Ex2.m1.2.2.2.2">b</mi><mo stretchy="false" id="A1.Ex2.m1.2.2.2.4.3">)</mo></mrow></msub><mo id="A1.Ex2.m1.2.4">=</mo><mrow id="A1.Ex2.m1.2.5"><mo stretchy="false" id="A1.Ex2.m1.2.5.1">(</mo><mrow id="A1.Ex2.m1.2.5.2"><mo stretchy="false" id="A1.Ex2.m1.2.5.2.1">(</mo><mi id="A1.Ex2.m1.2.5.2.2">a</mi><mi id="A1.Ex2.m1.2.5.2.3">x</mi><mo id="A1.Ex2.m1.2.5.2.4">+</mo><mi id="A1.Ex2.m1.2.5.2.5">b</mi><mo stretchy="false" id="A1.Ex2.m1.2.5.2.6">)</mo></mrow><mo id="A1.Ex2.m1.2.5.3">mod</mo><mi id="A1.Ex2.m1.2.5.4">p</mi><mo id="A1.Ex2.m1.2.5.5">mod</mo><mi id="A1.Ex2.m1.2.5.6">L</mi></mrow></mrow><annotation encoding="application/x-tex" id="A1.Ex2.m1.2c">h_{(a,b)}=((ax+b)\bmod p\bmod L</annotation></semantics></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr></tbody>
</table>
<p id="A1.SS4.SSS1.p2.10" class="ltx_p">where <math id="A1.SS4.SSS1.p2.1.m1.1" class="ltx_Math" alttext="a" display="inline"><semantics id="A1.SS4.SSS1.p2.1.m1.1a"><mi id="A1.SS4.SSS1.p2.1.m1.1.1" xref="A1.SS4.SSS1.p2.1.m1.1.1.cmml">a</mi><annotation-xml encoding="MathML-Content" id="A1.SS4.SSS1.p2.1.m1.1b"><ci id="A1.SS4.SSS1.p2.1.m1.1.1.cmml" xref="A1.SS4.SSS1.p2.1.m1.1.1">𝑎</ci></annotation-xml><annotation encoding="application/x-tex" id="A1.SS4.SSS1.p2.1.m1.1c">a</annotation></semantics></math> and <math id="A1.SS4.SSS1.p2.2.m2.1" class="ltx_Math" alttext="b" display="inline"><semantics id="A1.SS4.SSS1.p2.2.m2.1a"><mi id="A1.SS4.SSS1.p2.2.m2.1.1" xref="A1.SS4.SSS1.p2.2.m2.1.1.cmml">b</mi><annotation-xml encoding="MathML-Content" id="A1.SS4.SSS1.p2.2.m2.1b"><ci id="A1.SS4.SSS1.p2.2.m2.1.1.cmml" xref="A1.SS4.SSS1.p2.2.m2.1.1">𝑏</ci></annotation-xml><annotation encoding="application/x-tex" id="A1.SS4.SSS1.p2.2.m2.1c">b</annotation></semantics></math> are random integers <math id="A1.SS4.SSS1.p2.3.m3.1" class="ltx_Math" alttext="\bmod\ p" display="inline"><semantics id="A1.SS4.SSS1.p2.3.m3.1a"><mrow id="A1.SS4.SSS1.p2.3.m3.1.1" xref="A1.SS4.SSS1.p2.3.m3.1.1.cmml"><mi id="A1.SS4.SSS1.p2.3.m3.1.1.2" xref="A1.SS4.SSS1.p2.3.m3.1.1.2.cmml"></mi><mo rspace="0.778em" id="A1.SS4.SSS1.p2.3.m3.1.1.1" xref="A1.SS4.SSS1.p2.3.m3.1.1.1.cmml">mod</mo><mi id="A1.SS4.SSS1.p2.3.m3.1.1.3" xref="A1.SS4.SSS1.p2.3.m3.1.1.3.cmml">p</mi></mrow><annotation-xml encoding="MathML-Content" id="A1.SS4.SSS1.p2.3.m3.1b"><apply id="A1.SS4.SSS1.p2.3.m3.1.1.cmml" xref="A1.SS4.SSS1.p2.3.m3.1.1"><csymbol cd="latexml" id="A1.SS4.SSS1.p2.3.m3.1.1.1.cmml" xref="A1.SS4.SSS1.p2.3.m3.1.1.1">modulo</csymbol><csymbol cd="latexml" id="A1.SS4.SSS1.p2.3.m3.1.1.2.cmml" xref="A1.SS4.SSS1.p2.3.m3.1.1.2">absent</csymbol><ci id="A1.SS4.SSS1.p2.3.m3.1.1.3.cmml" xref="A1.SS4.SSS1.p2.3.m3.1.1.3">𝑝</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="A1.SS4.SSS1.p2.3.m3.1c">\bmod\ p</annotation></semantics></math>, <math id="A1.SS4.SSS1.p2.4.m4.1" class="ltx_Math" alttext="a\neq 0" display="inline"><semantics id="A1.SS4.SSS1.p2.4.m4.1a"><mrow id="A1.SS4.SSS1.p2.4.m4.1.1" xref="A1.SS4.SSS1.p2.4.m4.1.1.cmml"><mi id="A1.SS4.SSS1.p2.4.m4.1.1.2" xref="A1.SS4.SSS1.p2.4.m4.1.1.2.cmml">a</mi><mo id="A1.SS4.SSS1.p2.4.m4.1.1.1" xref="A1.SS4.SSS1.p2.4.m4.1.1.1.cmml">≠</mo><mn id="A1.SS4.SSS1.p2.4.m4.1.1.3" xref="A1.SS4.SSS1.p2.4.m4.1.1.3.cmml">0</mn></mrow><annotation-xml encoding="MathML-Content" id="A1.SS4.SSS1.p2.4.m4.1b"><apply id="A1.SS4.SSS1.p2.4.m4.1.1.cmml" xref="A1.SS4.SSS1.p2.4.m4.1.1"><neq id="A1.SS4.SSS1.p2.4.m4.1.1.1.cmml" xref="A1.SS4.SSS1.p2.4.m4.1.1.1"></neq><ci id="A1.SS4.SSS1.p2.4.m4.1.1.2.cmml" xref="A1.SS4.SSS1.p2.4.m4.1.1.2">𝑎</ci><cn type="integer" id="A1.SS4.SSS1.p2.4.m4.1.1.3.cmml" xref="A1.SS4.SSS1.p2.4.m4.1.1.3">0</cn></apply></annotation-xml><annotation encoding="application/x-tex" id="A1.SS4.SSS1.p2.4.m4.1c">a\neq 0</annotation></semantics></math> and <math id="A1.SS4.SSS1.p2.5.m5.1" class="ltx_Math" alttext="L" display="inline"><semantics id="A1.SS4.SSS1.p2.5.m5.1a"><mi id="A1.SS4.SSS1.p2.5.m5.1.1" xref="A1.SS4.SSS1.p2.5.m5.1.1.cmml">L</mi><annotation-xml encoding="MathML-Content" id="A1.SS4.SSS1.p2.5.m5.1b"><ci id="A1.SS4.SSS1.p2.5.m5.1.1.cmml" xref="A1.SS4.SSS1.p2.5.m5.1.1">𝐿</ci></annotation-xml><annotation encoding="application/x-tex" id="A1.SS4.SSS1.p2.5.m5.1c">L</annotation></semantics></math> is the length of the Bloom filter, which must be a large prime<span id="footnote6" class="ltx_note ltx_role_footnote"><sup class="ltx_note_mark">6</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">6</sup><span class="ltx_tag ltx_tag_note">6</span>Setting <math id="footnote6.m1.1" class="ltx_Math" alttext="p=L" display="inline"><semantics id="footnote6.m1.1b"><mrow id="footnote6.m1.1.1" xref="footnote6.m1.1.1.cmml"><mi id="footnote6.m1.1.1.2" xref="footnote6.m1.1.1.2.cmml">p</mi><mo id="footnote6.m1.1.1.1" xref="footnote6.m1.1.1.1.cmml">=</mo><mi id="footnote6.m1.1.1.3" xref="footnote6.m1.1.1.3.cmml">L</mi></mrow><annotation-xml encoding="MathML-Content" id="footnote6.m1.1c"><apply id="footnote6.m1.1.1.cmml" xref="footnote6.m1.1.1"><eq id="footnote6.m1.1.1.1.cmml" xref="footnote6.m1.1.1.1"></eq><ci id="footnote6.m1.1.1.2.cmml" xref="footnote6.m1.1.1.2">𝑝</ci><ci id="footnote6.m1.1.1.3.cmml" xref="footnote6.m1.1.1.3">𝐿</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="footnote6.m1.1d">p=L</annotation></semantics></math>, both prime, also works without requiring <math id="footnote6.m2.1" class="ltx_Math" alttext="p" display="inline"><semantics id="footnote6.m2.1b"><mi id="footnote6.m2.1.1" xref="footnote6.m2.1.1.cmml">p</mi><annotation-xml encoding="MathML-Content" id="footnote6.m2.1c"><ci id="footnote6.m2.1.1.cmml" xref="footnote6.m2.1.1">𝑝</ci></annotation-xml><annotation encoding="application/x-tex" id="footnote6.m2.1d">p</annotation></semantics></math> to be large. The requirement for <math id="footnote6.m3.1" class="ltx_Math" alttext="p" display="inline"><semantics id="footnote6.m3.1b"><mi id="footnote6.m3.1.1" xref="footnote6.m3.1.1.cmml">p</mi><annotation-xml encoding="MathML-Content" id="footnote6.m3.1c"><ci id="footnote6.m3.1.1.cmml" xref="footnote6.m3.1.1">𝑝</ci></annotation-xml><annotation encoding="application/x-tex" id="footnote6.m3.1d">p</annotation></semantics></math> to be large produces a near-uniform distribution for any value of <math id="footnote6.m4.1" class="ltx_Math" alttext="L" display="inline"><semantics id="footnote6.m4.1b"><mi id="footnote6.m4.1.1" xref="footnote6.m4.1.1.cmml">L</mi><annotation-xml encoding="MathML-Content" id="footnote6.m4.1c"><ci id="footnote6.m4.1.1.cmml" xref="footnote6.m4.1.1">𝐿</ci></annotation-xml><annotation encoding="application/x-tex" id="footnote6.m4.1d">L</annotation></semantics></math> including composites.</span></span></span>. Independent hashes can be constructed by independently constructing <math id="A1.SS4.SSS1.p2.6.m6.1" class="ltx_Math" alttext="a_{i}" display="inline"><semantics id="A1.SS4.SSS1.p2.6.m6.1a"><msub id="A1.SS4.SSS1.p2.6.m6.1.1" xref="A1.SS4.SSS1.p2.6.m6.1.1.cmml"><mi id="A1.SS4.SSS1.p2.6.m6.1.1.2" xref="A1.SS4.SSS1.p2.6.m6.1.1.2.cmml">a</mi><mi id="A1.SS4.SSS1.p2.6.m6.1.1.3" xref="A1.SS4.SSS1.p2.6.m6.1.1.3.cmml">i</mi></msub><annotation-xml encoding="MathML-Content" id="A1.SS4.SSS1.p2.6.m6.1b"><apply id="A1.SS4.SSS1.p2.6.m6.1.1.cmml" xref="A1.SS4.SSS1.p2.6.m6.1.1"><csymbol cd="ambiguous" id="A1.SS4.SSS1.p2.6.m6.1.1.1.cmml" xref="A1.SS4.SSS1.p2.6.m6.1.1">subscript</csymbol><ci id="A1.SS4.SSS1.p2.6.m6.1.1.2.cmml" xref="A1.SS4.SSS1.p2.6.m6.1.1.2">𝑎</ci><ci id="A1.SS4.SSS1.p2.6.m6.1.1.3.cmml" xref="A1.SS4.SSS1.p2.6.m6.1.1.3">𝑖</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="A1.SS4.SSS1.p2.6.m6.1c">a_{i}</annotation></semantics></math>, <math id="A1.SS4.SSS1.p2.7.m7.1" class="ltx_Math" alttext="b_{i}" display="inline"><semantics id="A1.SS4.SSS1.p2.7.m7.1a"><msub id="A1.SS4.SSS1.p2.7.m7.1.1" xref="A1.SS4.SSS1.p2.7.m7.1.1.cmml"><mi id="A1.SS4.SSS1.p2.7.m7.1.1.2" xref="A1.SS4.SSS1.p2.7.m7.1.1.2.cmml">b</mi><mi id="A1.SS4.SSS1.p2.7.m7.1.1.3" xref="A1.SS4.SSS1.p2.7.m7.1.1.3.cmml">i</mi></msub><annotation-xml encoding="MathML-Content" id="A1.SS4.SSS1.p2.7.m7.1b"><apply id="A1.SS4.SSS1.p2.7.m7.1.1.cmml" xref="A1.SS4.SSS1.p2.7.m7.1.1"><csymbol cd="ambiguous" id="A1.SS4.SSS1.p2.7.m7.1.1.1.cmml" xref="A1.SS4.SSS1.p2.7.m7.1.1">subscript</csymbol><ci id="A1.SS4.SSS1.p2.7.m7.1.1.2.cmml" xref="A1.SS4.SSS1.p2.7.m7.1.1.2">𝑏</ci><ci id="A1.SS4.SSS1.p2.7.m7.1.1.3.cmml" xref="A1.SS4.SSS1.p2.7.m7.1.1.3">𝑖</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="A1.SS4.SSS1.p2.7.m7.1c">b_{i}</annotation></semantics></math>,
for <math id="A1.SS4.SSS1.p2.8.m8.1" class="ltx_Math" alttext="i=0" display="inline"><semantics id="A1.SS4.SSS1.p2.8.m8.1a"><mrow id="A1.SS4.SSS1.p2.8.m8.1.1" xref="A1.SS4.SSS1.p2.8.m8.1.1.cmml"><mi id="A1.SS4.SSS1.p2.8.m8.1.1.2" xref="A1.SS4.SSS1.p2.8.m8.1.1.2.cmml">i</mi><mo id="A1.SS4.SSS1.p2.8.m8.1.1.1" xref="A1.SS4.SSS1.p2.8.m8.1.1.1.cmml">=</mo><mn id="A1.SS4.SSS1.p2.8.m8.1.1.3" xref="A1.SS4.SSS1.p2.8.m8.1.1.3.cmml">0</mn></mrow><annotation-xml encoding="MathML-Content" id="A1.SS4.SSS1.p2.8.m8.1b"><apply id="A1.SS4.SSS1.p2.8.m8.1.1.cmml" xref="A1.SS4.SSS1.p2.8.m8.1.1"><eq id="A1.SS4.SSS1.p2.8.m8.1.1.1.cmml" xref="A1.SS4.SSS1.p2.8.m8.1.1.1"></eq><ci id="A1.SS4.SSS1.p2.8.m8.1.1.2.cmml" xref="A1.SS4.SSS1.p2.8.m8.1.1.2">𝑖</ci><cn type="integer" id="A1.SS4.SSS1.p2.8.m8.1.1.3.cmml" xref="A1.SS4.SSS1.p2.8.m8.1.1.3">0</cn></apply></annotation-xml><annotation encoding="application/x-tex" id="A1.SS4.SSS1.p2.8.m8.1c">i=0</annotation></semantics></math> to <math id="A1.SS4.SSS1.p2.9.m9.1" class="ltx_Math" alttext="k-1" display="inline"><semantics id="A1.SS4.SSS1.p2.9.m9.1a"><mrow id="A1.SS4.SSS1.p2.9.m9.1.1" xref="A1.SS4.SSS1.p2.9.m9.1.1.cmml"><mi id="A1.SS4.SSS1.p2.9.m9.1.1.2" xref="A1.SS4.SSS1.p2.9.m9.1.1.2.cmml">k</mi><mo id="A1.SS4.SSS1.p2.9.m9.1.1.1" xref="A1.SS4.SSS1.p2.9.m9.1.1.1.cmml">−</mo><mn id="A1.SS4.SSS1.p2.9.m9.1.1.3" xref="A1.SS4.SSS1.p2.9.m9.1.1.3.cmml">1</mn></mrow><annotation-xml encoding="MathML-Content" id="A1.SS4.SSS1.p2.9.m9.1b"><apply id="A1.SS4.SSS1.p2.9.m9.1.1.cmml" xref="A1.SS4.SSS1.p2.9.m9.1.1"><minus id="A1.SS4.SSS1.p2.9.m9.1.1.1.cmml" xref="A1.SS4.SSS1.p2.9.m9.1.1.1"></minus><ci id="A1.SS4.SSS1.p2.9.m9.1.1.2.cmml" xref="A1.SS4.SSS1.p2.9.m9.1.1.2">𝑘</ci><cn type="integer" id="A1.SS4.SSS1.p2.9.m9.1.1.3.cmml" xref="A1.SS4.SSS1.p2.9.m9.1.1.3">1</cn></apply></annotation-xml><annotation encoding="application/x-tex" id="A1.SS4.SSS1.p2.9.m9.1c">k-1</annotation></semantics></math>. This was shown by <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib40" title="" class="ltx_ref">40</a>]</cite> to provide a false positive result close to that of the theoretical optimum. However, it is considered a costly operation to construct and use such hashes, particularly if <math id="A1.SS4.SSS1.p2.10.m10.1" class="ltx_Math" alttext="k" display="inline"><semantics id="A1.SS4.SSS1.p2.10.m10.1a"><mi id="A1.SS4.SSS1.p2.10.m10.1.1" xref="A1.SS4.SSS1.p2.10.m10.1.1.cmml">k</mi><annotation-xml encoding="MathML-Content" id="A1.SS4.SSS1.p2.10.m10.1b"><ci id="A1.SS4.SSS1.p2.10.m10.1.1.cmml" xref="A1.SS4.SSS1.p2.10.m10.1.1">𝑘</ci></annotation-xml><annotation encoding="application/x-tex" id="A1.SS4.SSS1.p2.10.m10.1c">k</annotation></semantics></math> is large.</p>
</div>
<div id="A1.SS4.SSS1.p3" class="ltx_para">
<p id="A1.SS4.SSS1.p3.1" class="ltx_p">Kirsch <span id="A1.SS4.SSS1.p3.1.1" class="ltx_text ltx_font_italic">et al.</span> <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib32" title="" class="ltx_ref">32</a>]</cite> introduced a technique for efficiently constructing hashes from just two independent cryptographic hashes. They provide a proof that their proposal is asymptotically no worse than using <math id="A1.SS4.SSS1.p3.1.m1.1" class="ltx_Math" alttext="k" display="inline"><semantics id="A1.SS4.SSS1.p3.1.m1.1a"><mi id="A1.SS4.SSS1.p3.1.m1.1.1" xref="A1.SS4.SSS1.p3.1.m1.1.1.cmml">k</mi><annotation-xml encoding="MathML-Content" id="A1.SS4.SSS1.p3.1.m1.1b"><ci id="A1.SS4.SSS1.p3.1.m1.1.1.cmml" xref="A1.SS4.SSS1.p3.1.m1.1.1">𝑘</ci></annotation-xml><annotation encoding="application/x-tex" id="A1.SS4.SSS1.p3.1.m1.1c">k</annotation></semantics></math> independent hashes. Their construction is of the form</p>
</div>
<div id="A1.SS4.SSS1.p4" class="ltx_para">
<table id="A1.Ex3" class="ltx_equation ltx_eqn_table">

<tbody><tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math id="A1.Ex3.m1.4" class="ltx_Math" alttext="g_{i}(x)=h_{1}(x)+ih_{2}(x)+f(i)~{}mod~{}m" display="block"><semantics id="A1.Ex3.m1.4a"><mrow id="A1.Ex3.m1.4.5" xref="A1.Ex3.m1.4.5.cmml"><mrow id="A1.Ex3.m1.4.5.2" xref="A1.Ex3.m1.4.5.2.cmml"><msub id="A1.Ex3.m1.4.5.2.2" xref="A1.Ex3.m1.4.5.2.2.cmml"><mi id="A1.Ex3.m1.4.5.2.2.2" xref="A1.Ex3.m1.4.5.2.2.2.cmml">g</mi><mi id="A1.Ex3.m1.4.5.2.2.3" xref="A1.Ex3.m1.4.5.2.2.3.cmml">i</mi></msub><mo lspace="0em" rspace="0em" id="A1.Ex3.m1.4.5.2.1" xref="A1.Ex3.m1.4.5.2.1.cmml">​</mo><mrow id="A1.Ex3.m1.4.5.2.3.2" xref="A1.Ex3.m1.4.5.2.cmml"><mo stretchy="false" id="A1.Ex3.m1.4.5.2.3.2.1" xref="A1.Ex3.m1.4.5.2.cmml">(</mo><mi id="A1.Ex3.m1.1.1" xref="A1.Ex3.m1.1.1.cmml">x</mi><mo stretchy="false" id="A1.Ex3.m1.4.5.2.3.2.2" xref="A1.Ex3.m1.4.5.2.cmml">)</mo></mrow></mrow><mo id="A1.Ex3.m1.4.5.1" xref="A1.Ex3.m1.4.5.1.cmml">=</mo><mrow id="A1.Ex3.m1.4.5.3" xref="A1.Ex3.m1.4.5.3.cmml"><mrow id="A1.Ex3.m1.4.5.3.2" xref="A1.Ex3.m1.4.5.3.2.cmml"><msub id="A1.Ex3.m1.4.5.3.2.2" xref="A1.Ex3.m1.4.5.3.2.2.cmml"><mi id="A1.Ex3.m1.4.5.3.2.2.2" xref="A1.Ex3.m1.4.5.3.2.2.2.cmml">h</mi><mn id="A1.Ex3.m1.4.5.3.2.2.3" xref="A1.Ex3.m1.4.5.3.2.2.3.cmml">1</mn></msub><mo lspace="0em" rspace="0em" id="A1.Ex3.m1.4.5.3.2.1" xref="A1.Ex3.m1.4.5.3.2.1.cmml">​</mo><mrow id="A1.Ex3.m1.4.5.3.2.3.2" xref="A1.Ex3.m1.4.5.3.2.cmml"><mo stretchy="false" id="A1.Ex3.m1.4.5.3.2.3.2.1" xref="A1.Ex3.m1.4.5.3.2.cmml">(</mo><mi id="A1.Ex3.m1.2.2" xref="A1.Ex3.m1.2.2.cmml">x</mi><mo stretchy="false" id="A1.Ex3.m1.4.5.3.2.3.2.2" xref="A1.Ex3.m1.4.5.3.2.cmml">)</mo></mrow></mrow><mo id="A1.Ex3.m1.4.5.3.1" xref="A1.Ex3.m1.4.5.3.1.cmml">+</mo><mrow id="A1.Ex3.m1.4.5.3.3" xref="A1.Ex3.m1.4.5.3.3.cmml"><mi id="A1.Ex3.m1.4.5.3.3.2" xref="A1.Ex3.m1.4.5.3.3.2.cmml">i</mi><mo lspace="0em" rspace="0em" id="A1.Ex3.m1.4.5.3.3.1" xref="A1.Ex3.m1.4.5.3.3.1.cmml">​</mo><msub id="A1.Ex3.m1.4.5.3.3.3" xref="A1.Ex3.m1.4.5.3.3.3.cmml"><mi id="A1.Ex3.m1.4.5.3.3.3.2" xref="A1.Ex3.m1.4.5.3.3.3.2.cmml">h</mi><mn id="A1.Ex3.m1.4.5.3.3.3.3" xref="A1.Ex3.m1.4.5.3.3.3.3.cmml">2</mn></msub><mo lspace="0em" rspace="0em" id="A1.Ex3.m1.4.5.3.3.1a" xref="A1.Ex3.m1.4.5.3.3.1.cmml">​</mo><mrow id="A1.Ex3.m1.4.5.3.3.4.2" xref="A1.Ex3.m1.4.5.3.3.cmml"><mo stretchy="false" id="A1.Ex3.m1.4.5.3.3.4.2.1" xref="A1.Ex3.m1.4.5.3.3.cmml">(</mo><mi id="A1.Ex3.m1.3.3" xref="A1.Ex3.m1.3.3.cmml">x</mi><mo stretchy="false" id="A1.Ex3.m1.4.5.3.3.4.2.2" xref="A1.Ex3.m1.4.5.3.3.cmml">)</mo></mrow></mrow><mo id="A1.Ex3.m1.4.5.3.1a" xref="A1.Ex3.m1.4.5.3.1.cmml">+</mo><mrow id="A1.Ex3.m1.4.5.3.4" xref="A1.Ex3.m1.4.5.3.4.cmml"><mi id="A1.Ex3.m1.4.5.3.4.2" xref="A1.Ex3.m1.4.5.3.4.2.cmml">f</mi><mo lspace="0em" rspace="0em" id="A1.Ex3.m1.4.5.3.4.1" xref="A1.Ex3.m1.4.5.3.4.1.cmml">​</mo><mrow id="A1.Ex3.m1.4.5.3.4.3.2" xref="A1.Ex3.m1.4.5.3.4.cmml"><mo stretchy="false" id="A1.Ex3.m1.4.5.3.4.3.2.1" xref="A1.Ex3.m1.4.5.3.4.cmml">(</mo><mi id="A1.Ex3.m1.4.4" xref="A1.Ex3.m1.4.4.cmml">i</mi><mo stretchy="false" id="A1.Ex3.m1.4.5.3.4.3.2.2" xref="A1.Ex3.m1.4.5.3.4.cmml">)</mo></mrow><mo lspace="0.330em" rspace="0em" id="A1.Ex3.m1.4.5.3.4.1a" xref="A1.Ex3.m1.4.5.3.4.1.cmml">​</mo><mi id="A1.Ex3.m1.4.5.3.4.4" xref="A1.Ex3.m1.4.5.3.4.4.cmml">m</mi><mo lspace="0em" rspace="0em" id="A1.Ex3.m1.4.5.3.4.1b" xref="A1.Ex3.m1.4.5.3.4.1.cmml">​</mo><mi id="A1.Ex3.m1.4.5.3.4.5" xref="A1.Ex3.m1.4.5.3.4.5.cmml">o</mi><mo lspace="0em" rspace="0em" id="A1.Ex3.m1.4.5.3.4.1c" xref="A1.Ex3.m1.4.5.3.4.1.cmml">​</mo><mi id="A1.Ex3.m1.4.5.3.4.6" xref="A1.Ex3.m1.4.5.3.4.6.cmml">d</mi><mo lspace="0.330em" rspace="0em" id="A1.Ex3.m1.4.5.3.4.1d" xref="A1.Ex3.m1.4.5.3.4.1.cmml">​</mo><mi id="A1.Ex3.m1.4.5.3.4.7" xref="A1.Ex3.m1.4.5.3.4.7.cmml">m</mi></mrow></mrow></mrow><annotation-xml encoding="MathML-Content" id="A1.Ex3.m1.4b"><apply id="A1.Ex3.m1.4.5.cmml" xref="A1.Ex3.m1.4.5"><eq id="A1.Ex3.m1.4.5.1.cmml" xref="A1.Ex3.m1.4.5.1"></eq><apply id="A1.Ex3.m1.4.5.2.cmml" xref="A1.Ex3.m1.4.5.2"><times id="A1.Ex3.m1.4.5.2.1.cmml" xref="A1.Ex3.m1.4.5.2.1"></times><apply id="A1.Ex3.m1.4.5.2.2.cmml" xref="A1.Ex3.m1.4.5.2.2"><csymbol cd="ambiguous" id="A1.Ex3.m1.4.5.2.2.1.cmml" xref="A1.Ex3.m1.4.5.2.2">subscript</csymbol><ci id="A1.Ex3.m1.4.5.2.2.2.cmml" xref="A1.Ex3.m1.4.5.2.2.2">𝑔</ci><ci id="A1.Ex3.m1.4.5.2.2.3.cmml" xref="A1.Ex3.m1.4.5.2.2.3">𝑖</ci></apply><ci id="A1.Ex3.m1.1.1.cmml" xref="A1.Ex3.m1.1.1">𝑥</ci></apply><apply id="A1.Ex3.m1.4.5.3.cmml" xref="A1.Ex3.m1.4.5.3"><plus id="A1.Ex3.m1.4.5.3.1.cmml" xref="A1.Ex3.m1.4.5.3.1"></plus><apply id="A1.Ex3.m1.4.5.3.2.cmml" xref="A1.Ex3.m1.4.5.3.2"><times id="A1.Ex3.m1.4.5.3.2.1.cmml" xref="A1.Ex3.m1.4.5.3.2.1"></times><apply id="A1.Ex3.m1.4.5.3.2.2.cmml" xref="A1.Ex3.m1.4.5.3.2.2"><csymbol cd="ambiguous" id="A1.Ex3.m1.4.5.3.2.2.1.cmml" xref="A1.Ex3.m1.4.5.3.2.2">subscript</csymbol><ci id="A1.Ex3.m1.4.5.3.2.2.2.cmml" xref="A1.Ex3.m1.4.5.3.2.2.2">ℎ</ci><cn type="integer" id="A1.Ex3.m1.4.5.3.2.2.3.cmml" xref="A1.Ex3.m1.4.5.3.2.2.3">1</cn></apply><ci id="A1.Ex3.m1.2.2.cmml" xref="A1.Ex3.m1.2.2">𝑥</ci></apply><apply id="A1.Ex3.m1.4.5.3.3.cmml" xref="A1.Ex3.m1.4.5.3.3"><times id="A1.Ex3.m1.4.5.3.3.1.cmml" xref="A1.Ex3.m1.4.5.3.3.1"></times><ci id="A1.Ex3.m1.4.5.3.3.2.cmml" xref="A1.Ex3.m1.4.5.3.3.2">𝑖</ci><apply id="A1.Ex3.m1.4.5.3.3.3.cmml" xref="A1.Ex3.m1.4.5.3.3.3"><csymbol cd="ambiguous" id="A1.Ex3.m1.4.5.3.3.3.1.cmml" xref="A1.Ex3.m1.4.5.3.3.3">subscript</csymbol><ci id="A1.Ex3.m1.4.5.3.3.3.2.cmml" xref="A1.Ex3.m1.4.5.3.3.3.2">ℎ</ci><cn type="integer" id="A1.Ex3.m1.4.5.3.3.3.3.cmml" xref="A1.Ex3.m1.4.5.3.3.3.3">2</cn></apply><ci id="A1.Ex3.m1.3.3.cmml" xref="A1.Ex3.m1.3.3">𝑥</ci></apply><apply id="A1.Ex3.m1.4.5.3.4.cmml" xref="A1.Ex3.m1.4.5.3.4"><times id="A1.Ex3.m1.4.5.3.4.1.cmml" xref="A1.Ex3.m1.4.5.3.4.1"></times><ci id="A1.Ex3.m1.4.5.3.4.2.cmml" xref="A1.Ex3.m1.4.5.3.4.2">𝑓</ci><ci id="A1.Ex3.m1.4.4.cmml" xref="A1.Ex3.m1.4.4">𝑖</ci><ci id="A1.Ex3.m1.4.5.3.4.4.cmml" xref="A1.Ex3.m1.4.5.3.4.4">𝑚</ci><ci id="A1.Ex3.m1.4.5.3.4.5.cmml" xref="A1.Ex3.m1.4.5.3.4.5">𝑜</ci><ci id="A1.Ex3.m1.4.5.3.4.6.cmml" xref="A1.Ex3.m1.4.5.3.4.6">𝑑</ci><ci id="A1.Ex3.m1.4.5.3.4.7.cmml" xref="A1.Ex3.m1.4.5.3.4.7">𝑚</ci></apply></apply></apply></annotation-xml><annotation encoding="application/x-tex" id="A1.Ex3.m1.4c">g_{i}(x)=h_{1}(x)+ih_{2}(x)+f(i)~{}mod~{}m</annotation></semantics></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr></tbody>
</table>
</div>
<div id="A1.SS4.SSS1.p5" class="ltx_para">
<p id="A1.SS4.SSS1.p5.3" class="ltx_p">Where <math id="A1.SS4.SSS1.p5.1.m1.1" class="ltx_Math" alttext="h_{1}" display="inline"><semantics id="A1.SS4.SSS1.p5.1.m1.1a"><msub id="A1.SS4.SSS1.p5.1.m1.1.1" xref="A1.SS4.SSS1.p5.1.m1.1.1.cmml"><mi id="A1.SS4.SSS1.p5.1.m1.1.1.2" xref="A1.SS4.SSS1.p5.1.m1.1.1.2.cmml">h</mi><mn id="A1.SS4.SSS1.p5.1.m1.1.1.3" xref="A1.SS4.SSS1.p5.1.m1.1.1.3.cmml">1</mn></msub><annotation-xml encoding="MathML-Content" id="A1.SS4.SSS1.p5.1.m1.1b"><apply id="A1.SS4.SSS1.p5.1.m1.1.1.cmml" xref="A1.SS4.SSS1.p5.1.m1.1.1"><csymbol cd="ambiguous" id="A1.SS4.SSS1.p5.1.m1.1.1.1.cmml" xref="A1.SS4.SSS1.p5.1.m1.1.1">subscript</csymbol><ci id="A1.SS4.SSS1.p5.1.m1.1.1.2.cmml" xref="A1.SS4.SSS1.p5.1.m1.1.1.2">ℎ</ci><cn type="integer" id="A1.SS4.SSS1.p5.1.m1.1.1.3.cmml" xref="A1.SS4.SSS1.p5.1.m1.1.1.3">1</cn></apply></annotation-xml><annotation encoding="application/x-tex" id="A1.SS4.SSS1.p5.1.m1.1c">h_{1}</annotation></semantics></math> and <math id="A1.SS4.SSS1.p5.2.m2.1" class="ltx_Math" alttext="h_{2}" display="inline"><semantics id="A1.SS4.SSS1.p5.2.m2.1a"><msub id="A1.SS4.SSS1.p5.2.m2.1.1" xref="A1.SS4.SSS1.p5.2.m2.1.1.cmml"><mi id="A1.SS4.SSS1.p5.2.m2.1.1.2" xref="A1.SS4.SSS1.p5.2.m2.1.1.2.cmml">h</mi><mn id="A1.SS4.SSS1.p5.2.m2.1.1.3" xref="A1.SS4.SSS1.p5.2.m2.1.1.3.cmml">2</mn></msub><annotation-xml encoding="MathML-Content" id="A1.SS4.SSS1.p5.2.m2.1b"><apply id="A1.SS4.SSS1.p5.2.m2.1.1.cmml" xref="A1.SS4.SSS1.p5.2.m2.1.1"><csymbol cd="ambiguous" id="A1.SS4.SSS1.p5.2.m2.1.1.1.cmml" xref="A1.SS4.SSS1.p5.2.m2.1.1">subscript</csymbol><ci id="A1.SS4.SSS1.p5.2.m2.1.1.2.cmml" xref="A1.SS4.SSS1.p5.2.m2.1.1.2">ℎ</ci><cn type="integer" id="A1.SS4.SSS1.p5.2.m2.1.1.3.cmml" xref="A1.SS4.SSS1.p5.2.m2.1.1.3">2</cn></apply></annotation-xml><annotation encoding="application/x-tex" id="A1.SS4.SSS1.p5.2.m2.1c">h_{2}</annotation></semantics></math> are independent cryptographic hash functions, for example, SHA1 and MD5.<span id="footnote7" class="ltx_note ltx_role_footnote"><sup class="ltx_note_mark">7</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">7</sup><span class="ltx_tag ltx_tag_note">7</span>SHA1 and MD5 appear in the literature extensively, however, both are considered deprecated as cryptographic hash functions, particularly MD5. It is not immediately clear that using SHA512 and SHA256 would constitute two independent hashes.</span></span></span> If the arbitrary function <math id="A1.SS4.SSS1.p5.3.m3.1" class="ltx_Math" alttext="f(i)\equiv 0" display="inline"><semantics id="A1.SS4.SSS1.p5.3.m3.1a"><mrow id="A1.SS4.SSS1.p5.3.m3.1.2" xref="A1.SS4.SSS1.p5.3.m3.1.2.cmml"><mrow id="A1.SS4.SSS1.p5.3.m3.1.2.2" xref="A1.SS4.SSS1.p5.3.m3.1.2.2.cmml"><mi id="A1.SS4.SSS1.p5.3.m3.1.2.2.2" xref="A1.SS4.SSS1.p5.3.m3.1.2.2.2.cmml">f</mi><mo lspace="0em" rspace="0em" id="A1.SS4.SSS1.p5.3.m3.1.2.2.1" xref="A1.SS4.SSS1.p5.3.m3.1.2.2.1.cmml">​</mo><mrow id="A1.SS4.SSS1.p5.3.m3.1.2.2.3.2" xref="A1.SS4.SSS1.p5.3.m3.1.2.2.cmml"><mo stretchy="false" id="A1.SS4.SSS1.p5.3.m3.1.2.2.3.2.1" xref="A1.SS4.SSS1.p5.3.m3.1.2.2.cmml">(</mo><mi id="A1.SS4.SSS1.p5.3.m3.1.1" xref="A1.SS4.SSS1.p5.3.m3.1.1.cmml">i</mi><mo stretchy="false" id="A1.SS4.SSS1.p5.3.m3.1.2.2.3.2.2" xref="A1.SS4.SSS1.p5.3.m3.1.2.2.cmml">)</mo></mrow></mrow><mo id="A1.SS4.SSS1.p5.3.m3.1.2.1" xref="A1.SS4.SSS1.p5.3.m3.1.2.1.cmml">≡</mo><mn id="A1.SS4.SSS1.p5.3.m3.1.2.3" xref="A1.SS4.SSS1.p5.3.m3.1.2.3.cmml">0</mn></mrow><annotation-xml encoding="MathML-Content" id="A1.SS4.SSS1.p5.3.m3.1b"><apply id="A1.SS4.SSS1.p5.3.m3.1.2.cmml" xref="A1.SS4.SSS1.p5.3.m3.1.2"><equivalent id="A1.SS4.SSS1.p5.3.m3.1.2.1.cmml" xref="A1.SS4.SSS1.p5.3.m3.1.2.1"></equivalent><apply id="A1.SS4.SSS1.p5.3.m3.1.2.2.cmml" xref="A1.SS4.SSS1.p5.3.m3.1.2.2"><times id="A1.SS4.SSS1.p5.3.m3.1.2.2.1.cmml" xref="A1.SS4.SSS1.p5.3.m3.1.2.2.1"></times><ci id="A1.SS4.SSS1.p5.3.m3.1.2.2.2.cmml" xref="A1.SS4.SSS1.p5.3.m3.1.2.2.2">𝑓</ci><ci id="A1.SS4.SSS1.p5.3.m3.1.1.cmml" xref="A1.SS4.SSS1.p5.3.m3.1.1">𝑖</ci></apply><cn type="integer" id="A1.SS4.SSS1.p5.3.m3.1.2.3.cmml" xref="A1.SS4.SSS1.p5.3.m3.1.2.3">0</cn></apply></annotation-xml><annotation encoding="application/x-tex" id="A1.SS4.SSS1.p5.3.m3.1c">f(i)\equiv 0</annotation></semantics></math> the schemed is referred to as double hashing, otherwise it is referred to as extended double hashing. The analysis in <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib32" title="" class="ltx_ref">32</a>]</cite> is with regards to enhanced double hashing.</p>
</div>
<div id="A1.SS4.SSS1.p6" class="ltx_para">
<p id="A1.SS4.SSS1.p6.1" class="ltx_p">The guarantee of performance “asymptotically no worse” than the original construction may not mean much in practice. In this section we investigate empirically how much worse it is in practice. We find that many constructions have very high false-positive rates, especially when combined with approximate matching.</p>
</div>
<div id="A1.SS4.SSS1.p7" class="ltx_para">
<p id="A1.SS4.SSS1.p7.1" class="ltx_p">An important requirement, often overlooked, is that <math id="A1.SS4.SSS1.p7.1.m1.1" class="ltx_Math" alttext="m" display="inline"><semantics id="A1.SS4.SSS1.p7.1.m1.1a"><mi id="A1.SS4.SSS1.p7.1.m1.1.1" xref="A1.SS4.SSS1.p7.1.m1.1.1.cmml">m</mi><annotation-xml encoding="MathML-Content" id="A1.SS4.SSS1.p7.1.m1.1b"><ci id="A1.SS4.SSS1.p7.1.m1.1.1.cmml" xref="A1.SS4.SSS1.p7.1.m1.1.1">𝑚</ci></annotation-xml><annotation encoding="application/x-tex" id="A1.SS4.SSS1.p7.1.m1.1c">m</annotation></semantics></math> must be prime. This detailed further by Dillinger and Manolios <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib19" title="" class="ltx_ref">19</a>]</cite>, but is not included in the papers by either Schnell <span id="A1.SS4.SSS1.p7.1.1" class="ltx_text ltx_font_italic">et al.</span> <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib43" title="" class="ltx_ref">43</a>]</cite> or Randall <span id="A1.SS4.SSS1.p7.1.2" class="ltx_text ltx_font_italic">et al.</span> <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib41" title="" class="ltx_ref">41</a>]</cite>.</p>
</div>
</section>
<section id="A1.SS4.SSS2" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">A.4.2 </span>Bloom filter analysis</h4>

<div id="A1.SS4.SSS2.p1" class="ltx_para">
<p id="A1.SS4.SSS2.p1.1" class="ltx_p">Bloom filters were originally designed to efficiently determine whether an element was in a set or not. Their use has been expanded, particularly in the privacy preserving record linkage field, to be used as a measure of similarity. This is typically done by calculating the dice-coefficient between two Bloom filters <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib43" title="" class="ltx_ref">43</a>]</cite>,<cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib41" title="" class="ltx_ref">41</a>]</cite>. However, there is little theoretical analysis of this usage of Bloom filters. Broder and Mitzenmacher <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib12" title="" class="ltx_ref">12</a>]</cite> describe estimating the set intersection between two Bloom filters, however, it is considerably more complicated than a simple dice-coefficient.</p>
</div>
<div id="A1.SS4.SSS2.p2" class="ltx_para">
<p id="A1.SS4.SSS2.p2.1" class="ltx_p">We examine below the error rate for Bloom filters, both the original construction and the double hashing version, when combined with an n-gram approach for fuzzy matching of names. We find very high similarity rates even among data that should not be similar. These represent a combination of false matches caused by the n-gram treatment itself, the imperfect implementation of Bloom filters, and the difficulty of accurately computing similarity measures for Bloom filters. A typical example is given in Figure <a href="#A1.T5" title="Table 5 ‣ A.4.2 Bloom filter analysis ‣ A.4 Security and accuracy of current literature on Bloom Filters ‣ Appendix A Literature Review ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">5</span></a>, which shows similarity scores from using the dice-coefficient on n-grams stored in a Bloom filter using double-hashing.</p>
</div>
<figure id="A1.T5" class="ltx_table">
<table id="A1.T5.1" class="ltx_tabular ltx_centering ltx_guessed_headers ltx_align_middle">
<thead class="ltx_thead">
<tr id="A1.T5.1.1.1" class="ltx_tr">
<th id="A1.T5.1.1.1.1" class="ltx_td ltx_align_center ltx_th ltx_th_column ltx_border_l ltx_border_r ltx_border_t"><span id="A1.T5.1.1.1.1.1" class="ltx_text ltx_font_bold">Dice-coefficient</span></th>
<th id="A1.T5.1.1.1.2" class="ltx_td ltx_align_center ltx_th ltx_th_column ltx_border_r ltx_border_t"><span id="A1.T5.1.1.1.2.1" class="ltx_text ltx_font_bold">Name One</span></th>
<th id="A1.T5.1.1.1.3" class="ltx_td ltx_align_center ltx_th ltx_th_column ltx_border_r ltx_border_t"><span id="A1.T5.1.1.1.3.1" class="ltx_text ltx_font_bold">Name Two</span></th>
</tr>
</thead>
<tbody class="ltx_tbody">
<tr id="A1.T5.1.2.1" class="ltx_tr">
<td id="A1.T5.1.2.1.1" class="ltx_td ltx_align_left ltx_border_l ltx_border_r ltx_border_t">0.7347</td>
<td id="A1.T5.1.2.1.2" class="ltx_td ltx_align_left ltx_border_r ltx_border_t">blocklar</td>
<td id="A1.T5.1.2.1.3" class="ltx_td ltx_align_left ltx_border_r ltx_border_t">sahinagic</td>
</tr>
<tr id="A1.T5.1.3.2" class="ltx_tr">
<td id="A1.T5.1.3.2.1" class="ltx_td ltx_align_left ltx_border_l ltx_border_r ltx_border_t">0.7458</td>
<td id="A1.T5.1.3.2.2" class="ltx_td ltx_align_left ltx_border_r ltx_border_t">frankenfeld</td>
<td id="A1.T5.1.3.2.3" class="ltx_td ltx_align_left ltx_border_r ltx_border_t">dhumatkar</td>
</tr>
<tr id="A1.T5.1.4.3" class="ltx_tr">
<td id="A1.T5.1.4.3.1" class="ltx_td ltx_align_left ltx_border_l ltx_border_r ltx_border_t">0.7429</td>
<td id="A1.T5.1.4.3.2" class="ltx_td ltx_align_left ltx_border_r ltx_border_t">kolin</td>
<td id="A1.T5.1.4.3.3" class="ltx_td ltx_align_left ltx_border_r ltx_border_t">wendly</td>
</tr>
<tr id="A1.T5.1.5.4" class="ltx_tr">
<td id="A1.T5.1.5.4.1" class="ltx_td ltx_align_left ltx_border_l ltx_border_r ltx_border_t">0.7429</td>
<td id="A1.T5.1.5.4.2" class="ltx_td ltx_align_left ltx_border_r ltx_border_t">lehky</td>
<td id="A1.T5.1.5.4.3" class="ltx_td ltx_align_left ltx_border_r ltx_border_t">turcon</td>
</tr>
<tr id="A1.T5.1.6.5" class="ltx_tr">
<td id="A1.T5.1.6.5.1" class="ltx_td ltx_align_left ltx_border_l ltx_border_r ltx_border_t">0.7368</td>
<td id="A1.T5.1.6.5.2" class="ltx_td ltx_align_left ltx_border_r ltx_border_t">quinney</td>
<td id="A1.T5.1.6.5.3" class="ltx_td ltx_align_left ltx_border_r ltx_border_t">foica</td>
</tr>
<tr id="A1.T5.1.7.6" class="ltx_tr">
<td id="A1.T5.1.7.6.1" class="ltx_td ltx_align_left ltx_border_b ltx_border_l ltx_border_r ltx_border_t">0.7407</td>
<td id="A1.T5.1.7.6.2" class="ltx_td ltx_align_left ltx_border_b ltx_border_r ltx_border_t">runt</td>
<td id="A1.T5.1.7.6.3" class="ltx_td ltx_align_left ltx_border_b ltx_border_r ltx_border_t">meij</td>
</tr>
</tbody>
</table>
<figcaption class="ltx_caption"><span class="ltx_tag ltx_tag_table">Table 5: </span>Double Hashing Bloom Filter to Bi-gram Comparison: high similarity scores for dissimilar names</figcaption>
</figure>
<div id="A1.SS4.SSS2.p3" class="ltx_para">
<p id="A1.SS4.SSS2.p3.1" class="ltx_p">Bloom filters were designed to efficiently determine set membership. Using them for similarity measurement requires re-evaluation of the properties and construction. Our initial analysis indicates the optimisation strategies for similarity measurements are different to those for minimising false positive when testing set inclusion. As such the constructions generally do not work in the way they are intended.</p>
</div>
</section>
<section id="A1.SS4.SSS3" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">A.4.3 </span>Use of Bloom filters in linking</h4>

<div id="A1.SS4.SSS3.p1" class="ltx_para">
<p id="A1.SS4.SSS3.p1.1" class="ltx_p">Bloom filters provide an alternative approach to similarity tables for fuzzy matching. Schnell et al. <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib43" title="" class="ltx_ref">43</a>, <a href="#bib.bib44" title="" class="ltx_ref">44</a>]</cite> propose using hashes and Bloom filters to enable fuzzy matching. The concept itself is not new <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib32" title="" class="ltx_ref">32</a>]</cite>, but its use in privacy preserving record linkage was novel. A Bloom filter is an efficient randomised data structure for storing a set of items, and then determining whether subsequent items are present in the set or not. If a match is found it means an item is probably in the set, if it is not found it means it is definitely not in the set. As such, it permits false positives, but not false negatives. Bloom filters have applications in a number of areas of computing, and as such are well studied.</p>
</div>
<div id="A1.SS4.SSS3.p2" class="ltx_para">
<p id="A1.SS4.SSS3.p2.1" class="ltx_p">The approach of Schnell et al. is to use a standard Bloom filter populated using the bi-grams of the identifiers. When performing matching, two Bloom filters are compared by calculating the Dice Coefficient to give a similarity score that can then be used to determine if it should be treated as a match or not.</p>
</div>
<div id="A1.SS4.SSS3.p3" class="ltx_para">
<p id="A1.SS4.SSS3.p3.1" class="ltx_p">Instead of using hashes Schnell et al. suggest using HMACs to avoid simple dictionary attacks. This again results in a dependence on a key, and the addition of a Bloom filter does not significantly impact on the ability to recover plaintexts if the key is known. It was shown by Bachteler et al. <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib4" title="" class="ltx_ref">4</a>]</cite> that the approach by Schnell et al. <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib43" title="" class="ltx_ref">43</a>]</cite> was more accurate than the schemes proposed by Pang and Hansen <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib38" title="" class="ltx_ref">38</a>]</cite> and Scannapieco et al. <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib42" title="" class="ltx_ref">42</a>]</cite>. However, in the case of Pang and Hansen <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib38" title="" class="ltx_ref">38</a>]</cite>, the most significant impact on performance was the selection of a reference table: where it was not a superset of both parties’ sets, the accuracy deteriorated significantly. In the ONS <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib37" title="" class="ltx_ref">37</a>]</cite> approach they utilise the superset and report obtaining good results.</p>
</div>
<div id="A1.SS4.SSS3.p4" class="ltx_para">
<p id="A1.SS4.SSS3.p4.1" class="ltx_p">More recently it has been shown by Kuzu et al. <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib34" title="" class="ltx_ref">34</a>]</cite> that Bloom filters remain susceptible to frequency attacks. Kuzu et al. discuss approaches for making such attacks more difficult, but there is no rigorous proof of security, and as such, counter measures remain ad-hoc and potentially unreliable.</p>
</div>
<div id="A1.SS4.SSS3.p5" class="ltx_para">
<p id="A1.SS4.SSS3.p5.1" class="ltx_p">Bellovin et al. <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib7" title="" class="ltx_ref">7</a>]</cite> proposed using encrypted Bloom filters for privacy enhanced searching of a database. Their approach involved replacing the hash functions with encryption schemes. The cryptography they used is fairly esoteric, and there appears to be a reliance on hashing as well. They rely on a trusted third party to transform ciphers between different keys. The dependence on a trusted third party and inherent recoverability leads up to conclude that this is not applicable to our context.</p>
</div>
<div id="A1.SS4.SSS3.p6" class="ltx_para">
<p id="A1.SS4.SSS3.p6.1" class="ltx_p">Kerschbaum <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib31" title="" class="ltx_ref">31</a>]</cite> proposes using public key encrypted Bloom filters for supply chain integrity. The scheme is an interesting one, utilising the underlying homomorphic properties of the selected encryption scheme to protect the contents of the Bloom filter. The scheme utilises zero-knowledge proofs to enable non-interactive operations to be performed in a verifiable manner. The scheme relies on advanced cryptography, notably the Goldwasser-Micali (GM) encryption scheme. It is not immediately clear that the approach could be modified to enable fuzzy matching, due to the Bloom filter comparison being performed in the encrypted domain, which restricts the ability to calculate a similarity score like the Dice coefficient.</p>
</div>
</section>
<section id="A1.SS4.SSS4" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">A.4.4 </span>Uniformity of output</h4>

<div id="A1.SS4.SSS4.p1" class="ltx_para">
<p id="A1.SS4.SSS4.p1.1" class="ltx_p">This section examines the use of the dice-coefficient as a method of estimating
the similarity of two sets of elements in a Bloom filter.
One of the implicit aspects of using a dice-coefficient is that the bits being compared are of equal weight. As such, there is an implicit assumption that the Bloom filter is uniformly distributed. Were that not to be the case the bits with a higher frequency could distort the similarity scoring. If we look at the ideal implementation of a Bloom filter, using Universal Hashing, we can see it produces a largely uniform output—see Figure <a href="#A1.F2" title="Figure 2 ‣ A.4.4 Uniformity of output ‣ A.4 Security and accuracy of current literature on Bloom Filters ‣ Appendix A Literature Review ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">2</span></a>.</p>
</div>
<figure id="A1.F2" class="ltx_figure"><img src="/html/1802.07975/assets/x2.png" id="A1.F2.g1" class="ltx_graphics ltx_centering ltx_img_landscape" width="368" height="253" alt="Refer to caption">
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure">Figure 2: </span>Frequency Distribution of Universal Hash based Bloom Filter</figcaption>
</figure>
<div id="A1.SS4.SSS4.p2" class="ltx_para">
<p id="A1.SS4.SSS4.p2.1" class="ltx_p">Figure <a href="#A1.F2" title="Figure 2 ‣ A.4.4 Uniformity of output ‣ A.4 Security and accuracy of current literature on Bloom Filters ‣ Appendix A Literature Review ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">2</span></a> was generated by constructing 500,000 Bloom filters based on 3 independently generated Universal Hashing algorithms. Into each Bloom filter 5 randomly generated 2-byte values were submitted, to simulate bi-gram insertion. All 500,000 Bloom filters were then compared to calculate the frequency of each bit being set to 1. This uniform output is exactly what we would expect to see.</p>
</div>
<div id="A1.SS4.SSS4.p3" class="ltx_para">
<p id="A1.SS4.SSS4.p3.1" class="ltx_p">In contrast, Figure <a href="#A1.F3" title="Figure 3 ‣ A.4.4 Uniformity of output ‣ A.4 Security and accuracy of current literature on Bloom Filters ‣ Appendix A Literature Review ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">3</span></a> shows the frequency distribution of double hashing based Bloom filters. These filters were based on SHA1 and MD5 <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib41" title="" class="ltx_ref">41</a>]</cite><cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib43" title="" class="ltx_ref">43</a>]</cite>, using a size of 101 and <math id="A1.SS4.SSS4.p3.1.m1.1" class="ltx_Math" alttext="k=3" display="inline"><semantics id="A1.SS4.SSS4.p3.1.m1.1a"><mrow id="A1.SS4.SSS4.p3.1.m1.1.1" xref="A1.SS4.SSS4.p3.1.m1.1.1.cmml"><mi id="A1.SS4.SSS4.p3.1.m1.1.1.2" xref="A1.SS4.SSS4.p3.1.m1.1.1.2.cmml">k</mi><mo id="A1.SS4.SSS4.p3.1.m1.1.1.1" xref="A1.SS4.SSS4.p3.1.m1.1.1.1.cmml">=</mo><mn id="A1.SS4.SSS4.p3.1.m1.1.1.3" xref="A1.SS4.SSS4.p3.1.m1.1.1.3.cmml">3</mn></mrow><annotation-xml encoding="MathML-Content" id="A1.SS4.SSS4.p3.1.m1.1b"><apply id="A1.SS4.SSS4.p3.1.m1.1.1.cmml" xref="A1.SS4.SSS4.p3.1.m1.1.1"><eq id="A1.SS4.SSS4.p3.1.m1.1.1.1.cmml" xref="A1.SS4.SSS4.p3.1.m1.1.1.1"></eq><ci id="A1.SS4.SSS4.p3.1.m1.1.1.2.cmml" xref="A1.SS4.SSS4.p3.1.m1.1.1.2">𝑘</ci><cn type="integer" id="A1.SS4.SSS4.p3.1.m1.1.1.3.cmml" xref="A1.SS4.SSS4.p3.1.m1.1.1.3">3</cn></apply></annotation-xml><annotation encoding="application/x-tex" id="A1.SS4.SSS4.p3.1.m1.1c">k=3</annotation></semantics></math>. A size of 101 was selected to be the closet prime to the size used in <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib41" title="" class="ltx_ref">41</a>]</cite>. The same approach of generating 500,000 Bloom filters, each with 5 random 2 byte values submitted to them. It is clear from Figure <a href="#A1.F3" title="Figure 3 ‣ A.4.4 Uniformity of output ‣ A.4 Security and accuracy of current literature on Bloom Filters ‣ Appendix A Literature Review ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">3</span></a> that there is less uniformity in this construction. This is further evidenced by the data in Figure <a href="#A1.F2" title="Figure 2 ‣ A.4.4 Uniformity of output ‣ A.4 Security and accuracy of current literature on Bloom Filters ‣ Appendix A Literature Review ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">2</span></a> having a standard deviation of 233, whilst the data in Figure <a href="#A1.F3" title="Figure 3 ‣ A.4.4 Uniformity of output ‣ A.4 Security and accuracy of current literature on Bloom Filters ‣ Appendix A Literature Review ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">3</span></a> has a standard deviation of 1570. However, it is not immediately clear what impact this will have on the dice-coefficient. We evaluate that in the Section <a href="#A1.SS4.SSS6" title="A.4.6 Similarity score evaluation ‣ A.4 Security and accuracy of current literature on Bloom Filters ‣ Appendix A Literature Review ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">A.4.6</span></a>.</p>
</div>
<figure id="A1.F3" class="ltx_figure"><img src="/html/1802.07975/assets/x3.png" id="A1.F3.g1" class="ltx_graphics ltx_centering ltx_img_landscape" width="368" height="253" alt="Refer to caption">
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure">Figure 3: </span>Frequency Distribution of Double Hash based Bloom Filter</figcaption>
</figure>
</section>
<section id="A1.SS4.SSS5" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">A.4.5 </span>Use of random values</h4>

<div id="A1.SS4.SSS5.p1" class="ltx_para">
<p id="A1.SS4.SSS5.p1.1" class="ltx_p">The reason we evaluated uniformity using random values instead of data from our synthetic dataset is due to the non-uniform distribution of the bi-grams from last names. A skewed input set will result in a skewed output set, hence we wanted to eliminate that from our evaluation. In Section <a href="#A1.SS4.SSS6" title="A.4.6 Similarity score evaluation ‣ A.4 Security and accuracy of current literature on Bloom Filters ‣ Appendix A Literature Review ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">A.4.6</span></a> we evaluate against our synthetic dataset, since the evaluation of similarity in names is the specific application we are evaluating, and the skew in the input set will be present in any deployment, so should be considered something that the approach must be able to handle.</p>
</div>
<div id="A1.SS4.SSS5.p2" class="ltx_para">
<p id="A1.SS4.SSS5.p2.1" class="ltx_p">As an example of the skew of the input set, Figure <a href="#A1.F4" title="Figure 4 ‣ A.4.5 Use of random values ‣ A.4 Security and accuracy of current literature on Bloom Filters ‣ Appendix A Literature Review ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">4</span></a> shows the frequency distribution of the first bi-gram in the last name dataset we have, which consists of 384,370 real last names found in Australia. It is clear to see the prevalence of last names beginning with the letter “s”, and the extreme rarity of “q” and “x”.<span id="footnote8" class="ltx_note ltx_role_footnote"><sup class="ltx_note_mark">8</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">8</sup><span class="ltx_tag ltx_tag_note">8</span>Last names were were converted to lowercase to not adversely weight the first letter</span></span></span></p>
</div>
<figure id="A1.F4" class="ltx_figure"><img src="/html/1802.07975/assets/x4.png" id="A1.F4.g1" class="ltx_graphics ltx_centering ltx_img_landscape" width="368" height="205" alt="Refer to caption">
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure">Figure 4: </span>Frequency Distribution of First Bi-Gram in Last Names</figcaption>
</figure>
<div id="A1.SS4.SSS5.p3" class="ltx_para">
<p id="A1.SS4.SSS5.p3.1" class="ltx_p">A different trend is continues with the second bi-gram, although there is a much wider range of possible values. Figure <a href="#A1.F5" title="Figure 5 ‣ A.4.5 Use of random values ‣ A.4 Security and accuracy of current literature on Bloom Filters ‣ Appendix A Literature Review ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">5</span></a> shows the distribution for the second bi-grams, for bi-grams that had a frequency above 2,500. This threshold was selected to allow the graph to remain readable, and to show a representation of the shape of the frequency distribution. The distribution is ordered by size.</p>
</div>
<figure id="A1.F5" class="ltx_figure"><img src="/html/1802.07975/assets/x5.png" id="A1.F5.g1" class="ltx_graphics ltx_centering ltx_img_landscape" width="368" height="260" alt="Refer to caption">
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure">Figure 5: </span>Frequency Distribution of Second Bi-Gram in Last Names (over 2 500)</figcaption>
</figure>
<div id="A1.SS4.SSS5.p4" class="ltx_para">
<p id="A1.SS4.SSS5.p4.1" class="ltx_p">With such skewing in the input set we would expect to see some degree of skew in the output set as well.</p>
</div>
</section>
<section id="A1.SS4.SSS6" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">A.4.6 </span>Similarity score evaluation</h4>

<div id="A1.SS4.SSS6.p1" class="ltx_para">
<p id="A1.SS4.SSS6.p1.2" class="ltx_p">Whilst the application of Bloom filters in the general case is of interest, we are primarily of interest in how it performs in evaluating the similarity of names, and thus, we will focus on actual name data in this section. Our aim was to compare plaintext comparisons of bi-grams with comparisons bi-grams encoded into Bloom filters. In order to do this we took our dataset of 384,370 distinct real last names and constructed bi-grams for each one. For each name we constructed a Bloom filter based on double hashing with a length 100 and 101, both with <math id="A1.SS4.SSS6.p1.1.m1.1" class="ltx_Math" alttext="k" display="inline"><semantics id="A1.SS4.SSS6.p1.1.m1.1a"><mi id="A1.SS4.SSS6.p1.1.m1.1.1" xref="A1.SS4.SSS6.p1.1.m1.1.1.cmml">k</mi><annotation-xml encoding="MathML-Content" id="A1.SS4.SSS6.p1.1.m1.1b"><ci id="A1.SS4.SSS6.p1.1.m1.1.1.cmml" xref="A1.SS4.SSS6.p1.1.m1.1.1">𝑘</ci></annotation-xml><annotation encoding="application/x-tex" id="A1.SS4.SSS6.p1.1.m1.1c">k</annotation></semantics></math> of 3, using SHA1 and MD5 to replicate the setup in <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib41" title="" class="ltx_ref">41</a>]</cite>. We also constructed a Bloom filter based on Universal Hashing, with a size of 101 and <math id="A1.SS4.SSS6.p1.2.m2.1" class="ltx_Math" alttext="k" display="inline"><semantics id="A1.SS4.SSS6.p1.2.m2.1a"><mi id="A1.SS4.SSS6.p1.2.m2.1.1" xref="A1.SS4.SSS6.p1.2.m2.1.1.cmml">k</mi><annotation-xml encoding="MathML-Content" id="A1.SS4.SSS6.p1.2.m2.1b"><ci id="A1.SS4.SSS6.p1.2.m2.1.1.cmml" xref="A1.SS4.SSS6.p1.2.m2.1.1">𝑘</ci></annotation-xml><annotation encoding="application/x-tex" id="A1.SS4.SSS6.p1.2.m2.1c">k</annotation></semantics></math> of 3. We then performed a cross comparison of each entry, comparing the Bloom filters with each other, and the plaintext bi-grams. In the case of the plaintext bi-grams the comparison was performed using sets, in that the plaintext bi-grams were added to a set, and the comparison was performed between those sets. This was to ensure a fair comparison, since both comparison would be performed on distinct bi-grams without respect to ordering. In both cases we calculated the dice-coefficient between the Bloom filters, and bi-gram sets respectively. We then compared the similarity score produced by the dice-coefficient to evaluate how similar they were. If the Bloom filter provides an accurate measure of similarity it should produce similar similarity scores to the plaintext set comparison.</p>
</div>
</section>
<section id="A1.SS4.SSS7" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">A.4.7 </span>Loss of ordering</h4>

<div id="A1.SS4.SSS7.p1" class="ltx_para">
<p id="A1.SS4.SSS7.p1.1" class="ltx_p">One of the side-effects of Bloom filters is that they do not maintain order of n-grams, they construct a set of distinct n-grams without regard to the order. As mentioned above we replicated this in our plaintext n-gram comparison to provide a fair comparison. However, the loss of ordering does create a higher risk of false positives.</p>
</div>
<figure id="A1.T6" class="ltx_table">
<table id="A1.T6.1" class="ltx_tabular ltx_centering ltx_guessed_headers ltx_align_middle">
<thead class="ltx_thead">
<tr id="A1.T6.1.1.1" class="ltx_tr">
<th id="A1.T6.1.1.1.1" class="ltx_td ltx_align_center ltx_th ltx_th_column ltx_border_l ltx_border_r ltx_border_t"><span id="A1.T6.1.1.1.1.1" class="ltx_text ltx_font_bold">Names</span></th>
<th id="A1.T6.1.1.1.2" class="ltx_td ltx_th ltx_th_column ltx_border_r ltx_border_t"></th>
<th id="A1.T6.1.1.1.3" class="ltx_td ltx_th ltx_th_column ltx_border_r ltx_border_t"></th>
<th id="A1.T6.1.1.1.4" class="ltx_td ltx_align_left ltx_th ltx_th_column ltx_border_r ltx_border_t"><span id="A1.T6.1.1.1.4.1" class="ltx_text ltx_font_bold">Bi-grams</span></th>
</tr>
</thead>
<tbody class="ltx_tbody">
<tr id="A1.T6.1.2.1" class="ltx_tr">
<td id="A1.T6.1.2.1.1" class="ltx_td ltx_align_left ltx_border_l ltx_border_r ltx_border_t">petitt</td>
<td id="A1.T6.1.2.1.2" class="ltx_td ltx_align_left ltx_border_r ltx_border_t">pettit</td>
<td id="A1.T6.1.2.1.3" class="ltx_td ltx_align_left ltx_border_r ltx_border_t">pettitt</td>
<td id="A1.T6.1.2.1.4" class="ltx_td ltx_align_left ltx_border_r ltx_border_t">_p, pe, et, ti, it, tt, t_</td>
</tr>
<tr id="A1.T6.1.3.2" class="ltx_tr">
<td id="A1.T6.1.3.2.1" class="ltx_td ltx_align_left ltx_border_l ltx_border_r ltx_border_t">mamara</td>
<td id="A1.T6.1.3.2.2" class="ltx_td ltx_align_left ltx_border_r ltx_border_t">marama</td>
<td id="A1.T6.1.3.2.3" class="ltx_td ltx_align_left ltx_border_r ltx_border_t">maramara</td>
<td id="A1.T6.1.3.2.4" class="ltx_td ltx_align_left ltx_border_r ltx_border_t">_m, ma, am, ar, ra, a_</td>
</tr>
<tr id="A1.T6.1.4.3" class="ltx_tr">
<td id="A1.T6.1.4.3.1" class="ltx_td ltx_align_left ltx_border_l ltx_border_r ltx_border_t">lewellyn</td>
<td id="A1.T6.1.4.3.2" class="ltx_td ltx_align_left ltx_border_r ltx_border_t">llewellyn</td>
<td id="A1.T6.1.4.3.3" class="ltx_td ltx_align_left ltx_border_r ltx_border_t">llewelyn</td>
<td id="A1.T6.1.4.3.4" class="ltx_td ltx_align_left ltx_border_r ltx_border_t">_l, le, ew, we, el, ll, ly, yn, n_</td>
</tr>
<tr id="A1.T6.1.5.4" class="ltx_tr">
<td id="A1.T6.1.5.4.1" class="ltx_td ltx_align_left ltx_border_l ltx_border_r ltx_border_t">takata</td>
<td id="A1.T6.1.5.4.2" class="ltx_td ltx_align_left ltx_border_r ltx_border_t">takataka</td>
<td id="A1.T6.1.5.4.3" class="ltx_td ltx_align_left ltx_border_r ltx_border_t">tataka</td>
<td id="A1.T6.1.5.4.4" class="ltx_td ltx_align_left ltx_border_r ltx_border_t">_t, ta, ak, ka, at, a_</td>
</tr>
<tr id="A1.T6.1.6.5" class="ltx_tr">
<td id="A1.T6.1.6.5.1" class="ltx_td ltx_align_left ltx_border_l ltx_border_r ltx_border_t">linemann</td>
<td id="A1.T6.1.6.5.2" class="ltx_td ltx_align_left ltx_border_r ltx_border_t">linneman</td>
<td id="A1.T6.1.6.5.3" class="ltx_td ltx_align_left ltx_border_r ltx_border_t">linnemann</td>
<td id="A1.T6.1.6.5.4" class="ltx_td ltx_align_left ltx_border_r ltx_border_t">_l, li, in, ne, em, ma, an, nn, n_</td>
</tr>
<tr id="A1.T6.1.7.6" class="ltx_tr">
<td id="A1.T6.1.7.6.1" class="ltx_td ltx_align_left ltx_border_l ltx_border_r ltx_border_t">mulally</td>
<td id="A1.T6.1.7.6.2" class="ltx_td ltx_align_left ltx_border_r ltx_border_t">mullally</td>
<td id="A1.T6.1.7.6.3" class="ltx_td ltx_align_left ltx_border_r ltx_border_t">mullaly</td>
<td id="A1.T6.1.7.6.4" class="ltx_td ltx_align_left ltx_border_r ltx_border_t">_m, mu, ul, la, al, ll, ly, y_</td>
</tr>
<tr id="A1.T6.1.8.7" class="ltx_tr">
<td id="A1.T6.1.8.7.1" class="ltx_td ltx_align_left ltx_border_l ltx_border_r ltx_border_t">bebee</td>
<td id="A1.T6.1.8.7.2" class="ltx_td ltx_align_left ltx_border_r ltx_border_t">beebe</td>
<td id="A1.T6.1.8.7.3" class="ltx_td ltx_align_left ltx_border_r ltx_border_t">beebee</td>
<td id="A1.T6.1.8.7.4" class="ltx_td ltx_align_left ltx_border_r ltx_border_t">_b, be, eb, ee, e_</td>
</tr>
<tr id="A1.T6.1.9.8" class="ltx_tr">
<td id="A1.T6.1.9.8.1" class="ltx_td ltx_align_left ltx_border_l ltx_border_r ltx_border_t">kirisits</td>
<td id="A1.T6.1.9.8.2" class="ltx_td ltx_align_left ltx_border_r ltx_border_t">kiritsis</td>
<td id="A1.T6.1.9.8.3" class="ltx_td ltx_align_left ltx_border_r ltx_border_t">kitsiris</td>
<td id="A1.T6.1.9.8.4" class="ltx_td ltx_align_left ltx_border_r ltx_border_t">_k, ki, ir, ri, is, si, it, ts, s_</td>
</tr>
<tr id="A1.T6.1.10.9" class="ltx_tr">
<td id="A1.T6.1.10.9.1" class="ltx_td ltx_align_left ltx_border_l ltx_border_r ltx_border_t">minisi</td>
<td id="A1.T6.1.10.9.2" class="ltx_td ltx_align_left ltx_border_r ltx_border_t">minisini</td>
<td id="A1.T6.1.10.9.3" class="ltx_td ltx_align_left ltx_border_r ltx_border_t">misini</td>
<td id="A1.T6.1.10.9.4" class="ltx_td ltx_align_left ltx_border_r ltx_border_t">_m, mi, in, ni, is, si, i_</td>
</tr>
<tr id="A1.T6.1.11.10" class="ltx_tr">
<td id="A1.T6.1.11.10.1" class="ltx_td ltx_align_left ltx_border_l ltx_border_r ltx_border_t">kaparas</td>
<td id="A1.T6.1.11.10.2" class="ltx_td ltx_align_left ltx_border_r ltx_border_t">karapapas</td>
<td id="A1.T6.1.11.10.3" class="ltx_td ltx_align_left ltx_border_r ltx_border_t">karapas</td>
<td id="A1.T6.1.11.10.4" class="ltx_td ltx_align_left ltx_border_r ltx_border_t">_k, ka, ap, pa, ar, ra, as, s_</td>
</tr>
<tr id="A1.T6.1.12.11" class="ltx_tr">
<td id="A1.T6.1.12.11.1" class="ltx_td ltx_align_left ltx_border_l ltx_border_r ltx_border_t">hanemann</td>
<td id="A1.T6.1.12.11.2" class="ltx_td ltx_align_left ltx_border_r ltx_border_t">hanneman</td>
<td id="A1.T6.1.12.11.3" class="ltx_td ltx_align_left ltx_border_r ltx_border_t">hannemann</td>
<td id="A1.T6.1.12.11.4" class="ltx_td ltx_align_left ltx_border_r ltx_border_t">_h, ha, ne, em, ma, an, nn, n_</td>
</tr>
<tr id="A1.T6.1.13.12" class="ltx_tr">
<td id="A1.T6.1.13.12.1" class="ltx_td ltx_align_left ltx_border_l ltx_border_r ltx_border_t">amara</td>
<td id="A1.T6.1.13.12.2" class="ltx_td ltx_align_left ltx_border_r ltx_border_t">amarama</td>
<td id="A1.T6.1.13.12.3" class="ltx_td ltx_align_left ltx_border_r ltx_border_t">arama</td>
<td id="A1.T6.1.13.12.4" class="ltx_td ltx_align_left ltx_border_r ltx_border_t">_a, am, ma, ar, ra, a_</td>
</tr>
<tr id="A1.T6.1.14.13" class="ltx_tr">
<td id="A1.T6.1.14.13.1" class="ltx_td ltx_align_left ltx_border_l ltx_border_r ltx_border_t">pulella</td>
<td id="A1.T6.1.14.13.2" class="ltx_td ltx_align_left ltx_border_r ltx_border_t">pullela</td>
<td id="A1.T6.1.14.13.3" class="ltx_td ltx_align_left ltx_border_r ltx_border_t">pullella</td>
<td id="A1.T6.1.14.13.4" class="ltx_td ltx_align_left ltx_border_r ltx_border_t">_p, pu, ul, le, el, ll, la, a_</td>
</tr>
<tr id="A1.T6.1.15.14" class="ltx_tr">
<td id="A1.T6.1.15.14.1" class="ltx_td ltx_align_left ltx_border_l ltx_border_r ltx_border_t">debeen</td>
<td id="A1.T6.1.15.14.2" class="ltx_td ltx_align_left ltx_border_r ltx_border_t">deebeen</td>
<td id="A1.T6.1.15.14.3" class="ltx_td ltx_align_left ltx_border_r ltx_border_t">deeben</td>
<td id="A1.T6.1.15.14.4" class="ltx_td ltx_align_left ltx_border_r ltx_border_t">_d, de, eb, be, ee, en, n_</td>
</tr>
<tr id="A1.T6.1.16.15" class="ltx_tr">
<td id="A1.T6.1.16.15.1" class="ltx_td ltx_align_left ltx_border_b ltx_border_l ltx_border_r ltx_border_t">peirrera</td>
<td id="A1.T6.1.16.15.2" class="ltx_td ltx_align_left ltx_border_b ltx_border_r ltx_border_t">pereirra</td>
<td id="A1.T6.1.16.15.3" class="ltx_td ltx_align_left ltx_border_b ltx_border_r ltx_border_t">perreira</td>
<td id="A1.T6.1.16.15.4" class="ltx_td ltx_align_left ltx_border_b ltx_border_r ltx_border_t">_p, pe, ei, ir, rr, re, er, ra, a_</td>
</tr>
</tbody>
</table>
<figcaption class="ltx_caption"><span class="ltx_tag ltx_tag_table">Table 6: </span>Last names producing identical bi-grams</figcaption>
</figure>
<div id="A1.SS4.SSS7.p2" class="ltx_para">
<p id="A1.SS4.SSS7.p2.1" class="ltx_p">Any of the entries in the same row in Table <a href="#A1.T6" title="Table 6 ‣ A.4.7 Loss of ordering ‣ A.4 Security and accuracy of current literature on Bloom Filters ‣ Appendix A Literature Review ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">6</span></a> will appear to be exact matches even when they are not. This is largely unavoidable when using Bloom filters,<span id="footnote9" class="ltx_note ltx_role_footnote"><sup class="ltx_note_mark">9</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">9</sup><span class="ltx_tag ltx_tag_note">9</span>Whilst location could be included in the Bloom filter it would significantly impact on calculating similarity. If the Bloom filter was being used as originally designed, for exact matching, it would be prudent to include bi-gram location or to simply submit the name as a whole instead of n-grams. However, for similarity comparison n-grams without location are essential</span></span></span> however, when comparing plaintext n-grams it would be possible to retain ordering and use it in a more sophisticated similarity scoring technique, for example, looking at edit distance. However, such a comparison will significantly increase the computational costs of performing the cross-comparison and it is difficult to see how such an approach could be used in a privacy preserving manner, since recovery of plaintext n-grams is going to leak a significant amount of information.</p>
</div>
</section>
<section id="A1.SS4.SSS8" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">A.4.8 </span>Double hashing: Size of 100, <math id="A1.SS4.SSS8.1.m1.1" class="ltx_Math" alttext="k=3" display="inline"><semantics id="A1.SS4.SSS8.1.m1.1b"><mrow id="A1.SS4.SSS8.1.m1.1.1" xref="A1.SS4.SSS8.1.m1.1.1.cmml"><mi id="A1.SS4.SSS8.1.m1.1.1.2" xref="A1.SS4.SSS8.1.m1.1.1.2.cmml">k</mi><mo id="A1.SS4.SSS8.1.m1.1.1.1" xref="A1.SS4.SSS8.1.m1.1.1.1.cmml">=</mo><mn id="A1.SS4.SSS8.1.m1.1.1.3" xref="A1.SS4.SSS8.1.m1.1.1.3.cmml">3</mn></mrow><annotation-xml encoding="MathML-Content" id="A1.SS4.SSS8.1.m1.1c"><apply id="A1.SS4.SSS8.1.m1.1.1.cmml" xref="A1.SS4.SSS8.1.m1.1.1"><eq id="A1.SS4.SSS8.1.m1.1.1.1.cmml" xref="A1.SS4.SSS8.1.m1.1.1.1"></eq><ci id="A1.SS4.SSS8.1.m1.1.1.2.cmml" xref="A1.SS4.SSS8.1.m1.1.1.2">𝑘</ci><cn type="integer" id="A1.SS4.SSS8.1.m1.1.1.3.cmml" xref="A1.SS4.SSS8.1.m1.1.1.3">3</cn></apply></annotation-xml><annotation encoding="application/x-tex" id="A1.SS4.SSS8.1.m1.1d">k=3</annotation></semantics></math>
</h4>

<div id="A1.SS4.SSS8.p1" class="ltx_para">
<p id="A1.SS4.SSS8.p1.1" class="ltx_p">The results when comparing bi-grams of size 100, with <math id="A1.SS4.SSS8.p1.1.m1.1" class="ltx_Math" alttext="k=3" display="inline"><semantics id="A1.SS4.SSS8.p1.1.m1.1a"><mrow id="A1.SS4.SSS8.p1.1.m1.1.1" xref="A1.SS4.SSS8.p1.1.m1.1.1.cmml"><mi id="A1.SS4.SSS8.p1.1.m1.1.1.2" xref="A1.SS4.SSS8.p1.1.m1.1.1.2.cmml">k</mi><mo id="A1.SS4.SSS8.p1.1.m1.1.1.1" xref="A1.SS4.SSS8.p1.1.m1.1.1.1.cmml">=</mo><mn id="A1.SS4.SSS8.p1.1.m1.1.1.3" xref="A1.SS4.SSS8.p1.1.m1.1.1.3.cmml">3</mn></mrow><annotation-xml encoding="MathML-Content" id="A1.SS4.SSS8.p1.1.m1.1b"><apply id="A1.SS4.SSS8.p1.1.m1.1.1.cmml" xref="A1.SS4.SSS8.p1.1.m1.1.1"><eq id="A1.SS4.SSS8.p1.1.m1.1.1.1.cmml" xref="A1.SS4.SSS8.p1.1.m1.1.1.1"></eq><ci id="A1.SS4.SSS8.p1.1.m1.1.1.2.cmml" xref="A1.SS4.SSS8.p1.1.m1.1.1.2">𝑘</ci><cn type="integer" id="A1.SS4.SSS8.p1.1.m1.1.1.3.cmml" xref="A1.SS4.SSS8.p1.1.m1.1.1.3">3</cn></apply></annotation-xml><annotation encoding="application/x-tex" id="A1.SS4.SSS8.p1.1.m1.1c">k=3</annotation></semantics></math> are shown in Table <a href="#A1.T7" title="Table 7 ‣ A.4.8 Double hashing: Size of 100, 𝑘=3 ‣ A.4 Security and accuracy of current literature on Bloom Filters ‣ Appendix A Literature Review ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">7</span></a>. Table <a href="#A1.T7" title="Table 7 ‣ A.4.8 Double hashing: Size of 100, 𝑘=3 ‣ A.4 Security and accuracy of current literature on Bloom Filters ‣ Appendix A Literature Review ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">7</span></a> shows the total number of comparisons made, which is the full cross comparison of our dataset of last names. The table goes on to show the number of those comparisons where the similarity score for the bloom filter was equal to the similarity score calculated on the bi-grams directly. For those comparisons in which the bloom filter similarity score is greater than the direct bi-gram score we also calculate the mean and standard deviation of the difference.</p>
</div>
<div id="A1.SS4.SSS8.p2" class="ltx_para">
<p id="A1.SS4.SSS8.p2.1" class="ltx_p">Table <a href="#A1.T7" title="Table 7 ‣ A.4.8 Double hashing: Size of 100, 𝑘=3 ‣ A.4 Security and accuracy of current literature on Bloom Filters ‣ Appendix A Literature Review ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">7</span></a> shows that in the vast majority of cases the Bloom filter comparison over estimates the similarity, approximately 97% of the time. The mean difference, when it does over estimate the similarity, is approximately 0.2, the standard deviation of this difference is 0.0858<span id="footnote10" class="ltx_note ltx_role_footnote"><sup class="ltx_note_mark">10</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">10</sup><span class="ltx_tag ltx_tag_note">10</span>Due to the extremely large size of the dataset the standard deviation is calculated as a running standard deviation using the Welford method</span></span></span>.</p>
</div>
<figure id="A1.T7" class="ltx_table">
<table id="A1.T7.1" class="ltx_tabular ltx_centering ltx_guessed_headers ltx_align_middle">
<thead class="ltx_thead">
<tr id="A1.T7.1.1.1" class="ltx_tr">
<th id="A1.T7.1.1.1.1" class="ltx_td ltx_th ltx_th_column ltx_th_row ltx_border_l ltx_border_r ltx_border_t"></th>
<th id="A1.T7.1.1.1.2" class="ltx_td ltx_align_center ltx_th ltx_th_column ltx_border_r ltx_border_t"><span id="A1.T7.1.1.1.2.1" class="ltx_text ltx_font_bold">Totals</span></th>
<th id="A1.T7.1.1.1.3" class="ltx_td ltx_align_center ltx_th ltx_th_column ltx_border_r ltx_border_t"><span id="A1.T7.1.1.1.3.1" class="ltx_text ltx_font_bold">Percentage (%)</span></th>
</tr>
</thead>
<tbody class="ltx_tbody">
<tr id="A1.T7.1.2.1" class="ltx_tr">
<th id="A1.T7.1.2.1.1" class="ltx_td ltx_align_left ltx_th ltx_th_row ltx_border_l ltx_border_r ltx_border_t"><span id="A1.T7.1.2.1.1.1" class="ltx_text ltx_font_bold">Total Num. Comparisons</span></th>
<td id="A1.T7.1.2.1.2" class="ltx_td ltx_align_right ltx_border_r ltx_border_t">147383049024</td>
<td id="A1.T7.1.2.1.3" class="ltx_td ltx_align_right ltx_border_r ltx_border_t">100.00%</td>
</tr>
<tr id="A1.T7.1.3.2" class="ltx_tr">
<th id="A1.T7.1.3.2.1" class="ltx_td ltx_align_left ltx_th ltx_th_row ltx_border_l ltx_border_r ltx_border_t"><span id="A1.T7.1.3.2.1.1" class="ltx_text ltx_font_bold">Equal Comparisons</span></th>
<td id="A1.T7.1.3.2.2" class="ltx_td ltx_align_right ltx_border_r ltx_border_t">4478110664</td>
<td id="A1.T7.1.3.2.3" class="ltx_td ltx_align_right ltx_border_r ltx_border_t">0.030</td>
</tr>
<tr id="A1.T7.1.4.3" class="ltx_tr">
<th id="A1.T7.1.4.3.1" class="ltx_td ltx_align_left ltx_th ltx_th_row ltx_border_l ltx_border_r ltx_border_t"><span id="A1.T7.1.4.3.1.1" class="ltx_text ltx_font_bold">Bloom Filter Greater than n-gram Comp.</span></th>
<td id="A1.T7.1.4.3.2" class="ltx_td ltx_align_right ltx_border_r ltx_border_t">142904938360</td>
<td id="A1.T7.1.4.3.3" class="ltx_td ltx_align_right ltx_border_r ltx_border_t">0.970</td>
</tr>
<tr id="A1.T7.1.5.4" class="ltx_tr">
<th id="A1.T7.1.5.4.1" class="ltx_td ltx_align_left ltx_th ltx_th_row ltx_border_l ltx_border_r ltx_border_t"><span id="A1.T7.1.5.4.1.1" class="ltx_text ltx_font_bold">Mean Difference when Bloom Filter Greater</span></th>
<td id="A1.T7.1.5.4.2" class="ltx_td ltx_align_right ltx_border_r ltx_border_t">0.202</td>
<td id="A1.T7.1.5.4.3" class="ltx_td ltx_border_r ltx_border_t"></td>
</tr>
<tr id="A1.T7.1.6.5" class="ltx_tr">
<th id="A1.T7.1.6.5.1" class="ltx_td ltx_align_left ltx_th ltx_th_row ltx_border_b ltx_border_l ltx_border_r ltx_border_t"><span id="A1.T7.1.6.5.1.1" class="ltx_text ltx_font_bold">Standard Deviation of difference</span></th>
<td id="A1.T7.1.6.5.2" class="ltx_td ltx_align_right ltx_border_b ltx_border_r ltx_border_t">0.0858</td>
<td id="A1.T7.1.6.5.3" class="ltx_td ltx_border_b ltx_border_r ltx_border_t"></td>
</tr>
</tbody>
</table>
<figcaption class="ltx_caption"><span class="ltx_tag ltx_tag_table">Table 7: </span>Double Hashing Bloom Filter to Bi-gram Comparison</figcaption>
</figure>
<div id="A1.SS4.SSS8.p3" class="ltx_para">
<p id="A1.SS4.SSS8.p3.1" class="ltx_p">In addition to the overall picture of over estimation, there are also examples of extreme over estimation. Table <a href="#A1.T8" title="Table 8 ‣ A.4.8 Double hashing: Size of 100, 𝑘=3 ‣ A.4 Security and accuracy of current literature on Bloom Filters ‣ Appendix A Literature Review ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">8</span></a> (already shown in Section <a href="#A1.SS4.SSS2" title="A.4.2 Bloom filter analysis ‣ A.4 Security and accuracy of current literature on Bloom Filters ‣ Appendix A Literature Review ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">A.4.2</span></a>) shows some of the largest over estimates that were observed across the entire dataset. In this cases the two names do not share any bi-grams, yet they all receive a dice-coefficient on Bloom filter comparison of in excess of 0.73.</p>
</div>
<figure id="A1.T8" class="ltx_table">
<table id="A1.T8.1" class="ltx_tabular ltx_centering ltx_guessed_headers ltx_align_middle">
<thead class="ltx_thead">
<tr id="A1.T8.1.1.1" class="ltx_tr">
<th id="A1.T8.1.1.1.1" class="ltx_td ltx_align_center ltx_th ltx_th_column ltx_border_l ltx_border_r ltx_border_t"><span id="A1.T8.1.1.1.1.1" class="ltx_text ltx_font_bold">Dice-coefficient</span></th>
<th id="A1.T8.1.1.1.2" class="ltx_td ltx_align_center ltx_th ltx_th_column ltx_border_r ltx_border_t"><span id="A1.T8.1.1.1.2.1" class="ltx_text ltx_font_bold">Name One</span></th>
<th id="A1.T8.1.1.1.3" class="ltx_td ltx_align_center ltx_th ltx_th_column ltx_border_r ltx_border_t"><span id="A1.T8.1.1.1.3.1" class="ltx_text ltx_font_bold">Name Two</span></th>
</tr>
</thead>
<tbody class="ltx_tbody">
<tr id="A1.T8.1.2.1" class="ltx_tr">
<td id="A1.T8.1.2.1.1" class="ltx_td ltx_align_left ltx_border_l ltx_border_r ltx_border_t">0.7347</td>
<td id="A1.T8.1.2.1.2" class="ltx_td ltx_align_left ltx_border_r ltx_border_t">blocklar</td>
<td id="A1.T8.1.2.1.3" class="ltx_td ltx_align_left ltx_border_r ltx_border_t">sahinagic</td>
</tr>
<tr id="A1.T8.1.3.2" class="ltx_tr">
<td id="A1.T8.1.3.2.1" class="ltx_td ltx_align_left ltx_border_l ltx_border_r ltx_border_t">0.7458</td>
<td id="A1.T8.1.3.2.2" class="ltx_td ltx_align_left ltx_border_r ltx_border_t">frankenfeld</td>
<td id="A1.T8.1.3.2.3" class="ltx_td ltx_align_left ltx_border_r ltx_border_t">dhumatkar</td>
</tr>
<tr id="A1.T8.1.4.3" class="ltx_tr">
<td id="A1.T8.1.4.3.1" class="ltx_td ltx_align_left ltx_border_l ltx_border_r ltx_border_t">0.7429</td>
<td id="A1.T8.1.4.3.2" class="ltx_td ltx_align_left ltx_border_r ltx_border_t">kolin</td>
<td id="A1.T8.1.4.3.3" class="ltx_td ltx_align_left ltx_border_r ltx_border_t">wendly</td>
</tr>
<tr id="A1.T8.1.5.4" class="ltx_tr">
<td id="A1.T8.1.5.4.1" class="ltx_td ltx_align_left ltx_border_l ltx_border_r ltx_border_t">0.7429</td>
<td id="A1.T8.1.5.4.2" class="ltx_td ltx_align_left ltx_border_r ltx_border_t">lehky</td>
<td id="A1.T8.1.5.4.3" class="ltx_td ltx_align_left ltx_border_r ltx_border_t">turcon</td>
</tr>
<tr id="A1.T8.1.6.5" class="ltx_tr">
<td id="A1.T8.1.6.5.1" class="ltx_td ltx_align_left ltx_border_l ltx_border_r ltx_border_t">0.7368</td>
<td id="A1.T8.1.6.5.2" class="ltx_td ltx_align_left ltx_border_r ltx_border_t">quinney</td>
<td id="A1.T8.1.6.5.3" class="ltx_td ltx_align_left ltx_border_r ltx_border_t">foica</td>
</tr>
<tr id="A1.T8.1.7.6" class="ltx_tr">
<td id="A1.T8.1.7.6.1" class="ltx_td ltx_align_left ltx_border_b ltx_border_l ltx_border_r ltx_border_t">0.7407</td>
<td id="A1.T8.1.7.6.2" class="ltx_td ltx_align_left ltx_border_b ltx_border_r ltx_border_t">runt</td>
<td id="A1.T8.1.7.6.3" class="ltx_td ltx_align_left ltx_border_b ltx_border_r ltx_border_t">meij</td>
</tr>
</tbody>
</table>
<figcaption class="ltx_caption"><span class="ltx_tag ltx_tag_table">Table 8: </span>Double Hashing Bloom Filter to Bi-gram Comparison Largest Over Estimation</figcaption>
</figure>
<div id="A1.SS4.SSS8.p4" class="ltx_para">
<p id="A1.SS4.SSS8.p4.1" class="ltx_p">In addition to showing the over estimation in the Bloom filter comparison, this also provides a good practical example of the infeasibility of large cross comparison. In order to construct the comparisons shown we had to perform 147,383,049,024 comparisons. This less than the square of our dataset size due to the removal of duplicates. In order to process that number of comparisons, on an i7 Quad Core CPU, with all Bloom filters and n-grams pre-computed and held in memory, it took over 6 hours. This is a relatively small cross comparison, approximately 383,904 rows. although it does constitute two comparisons for each row. However, it is easy to see that even if that time was halved, the computational time for performing cross comparisons rapidly grows to the point of being infeasible.</p>
</div>
</section>
<section id="A1.SS4.SSS9" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">A.4.9 </span>Double hashing: Size of 101, <math id="A1.SS4.SSS9.1.m1.1" class="ltx_Math" alttext="k=3" display="inline"><semantics id="A1.SS4.SSS9.1.m1.1b"><mrow id="A1.SS4.SSS9.1.m1.1.1" xref="A1.SS4.SSS9.1.m1.1.1.cmml"><mi id="A1.SS4.SSS9.1.m1.1.1.2" xref="A1.SS4.SSS9.1.m1.1.1.2.cmml">k</mi><mo id="A1.SS4.SSS9.1.m1.1.1.1" xref="A1.SS4.SSS9.1.m1.1.1.1.cmml">=</mo><mn id="A1.SS4.SSS9.1.m1.1.1.3" xref="A1.SS4.SSS9.1.m1.1.1.3.cmml">3</mn></mrow><annotation-xml encoding="MathML-Content" id="A1.SS4.SSS9.1.m1.1c"><apply id="A1.SS4.SSS9.1.m1.1.1.cmml" xref="A1.SS4.SSS9.1.m1.1.1"><eq id="A1.SS4.SSS9.1.m1.1.1.1.cmml" xref="A1.SS4.SSS9.1.m1.1.1.1"></eq><ci id="A1.SS4.SSS9.1.m1.1.1.2.cmml" xref="A1.SS4.SSS9.1.m1.1.1.2">𝑘</ci><cn type="integer" id="A1.SS4.SSS9.1.m1.1.1.3.cmml" xref="A1.SS4.SSS9.1.m1.1.1.3">3</cn></apply></annotation-xml><annotation encoding="application/x-tex" id="A1.SS4.SSS9.1.m1.1d">k=3</annotation></semantics></math>
</h4>

<div id="A1.SS4.SSS9.p1" class="ltx_para">
<p id="A1.SS4.SSS9.p1.1" class="ltx_p">In order to establish that the primary cause of the problem was not just that the size was not prime, we repeated the experiment with the size set to 101. The results are shown in Table <a href="#A1.T9" title="Table 9 ‣ A.4.9 Double hashing: Size of 101, 𝑘=3 ‣ A.4 Security and accuracy of current literature on Bloom Filters ‣ Appendix A Literature Review ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">9</span></a>. The tables are almost identical, which indicates the underlying problem is not the primality of the size of the Bloom filter.</p>
</div>
<figure id="A1.T9" class="ltx_table">
<table id="A1.T9.1" class="ltx_tabular ltx_centering ltx_guessed_headers ltx_align_middle">
<thead class="ltx_thead">
<tr id="A1.T9.1.1.1" class="ltx_tr">
<th id="A1.T9.1.1.1.1" class="ltx_td ltx_th ltx_th_column ltx_th_row ltx_border_l ltx_border_r ltx_border_t"></th>
<th id="A1.T9.1.1.1.2" class="ltx_td ltx_align_center ltx_th ltx_th_column ltx_border_r ltx_border_t"><span id="A1.T9.1.1.1.2.1" class="ltx_text ltx_font_bold">Totals</span></th>
<th id="A1.T9.1.1.1.3" class="ltx_td ltx_align_center ltx_th ltx_th_column ltx_border_r ltx_border_t"><span id="A1.T9.1.1.1.3.1" class="ltx_text ltx_font_bold">Percentage (%)</span></th>
</tr>
</thead>
<tbody class="ltx_tbody">
<tr id="A1.T9.1.2.1" class="ltx_tr">
<th id="A1.T9.1.2.1.1" class="ltx_td ltx_align_left ltx_th ltx_th_row ltx_border_l ltx_border_r ltx_border_t"><span id="A1.T9.1.2.1.1.1" class="ltx_text ltx_font_bold">Total Num. Comparisons</span></th>
<td id="A1.T9.1.2.1.2" class="ltx_td ltx_align_right ltx_border_r ltx_border_t">147383049024</td>
<td id="A1.T9.1.2.1.3" class="ltx_td ltx_align_right ltx_border_r ltx_border_t">100.00%</td>
</tr>
<tr id="A1.T9.1.3.2" class="ltx_tr">
<th id="A1.T9.1.3.2.1" class="ltx_td ltx_align_left ltx_th ltx_th_row ltx_border_l ltx_border_r ltx_border_t"><span id="A1.T9.1.3.2.1.1" class="ltx_text ltx_font_bold">Equal Comparisons</span></th>
<td id="A1.T9.1.3.2.2" class="ltx_td ltx_align_right ltx_border_r ltx_border_t">4701012536</td>
<td id="A1.T9.1.3.2.3" class="ltx_td ltx_align_right ltx_border_r ltx_border_t">0.032</td>
</tr>
<tr id="A1.T9.1.4.3" class="ltx_tr">
<th id="A1.T9.1.4.3.1" class="ltx_td ltx_align_left ltx_th ltx_th_row ltx_border_l ltx_border_r ltx_border_t"><span id="A1.T9.1.4.3.1.1" class="ltx_text ltx_font_bold">Bloom Filter Greater than n-gram Comp.</span></th>
<td id="A1.T9.1.4.3.2" class="ltx_td ltx_align_right ltx_border_r ltx_border_t">142682036488</td>
<td id="A1.T9.1.4.3.3" class="ltx_td ltx_align_right ltx_border_r ltx_border_t">0.968</td>
</tr>
<tr id="A1.T9.1.5.4" class="ltx_tr">
<th id="A1.T9.1.5.4.1" class="ltx_td ltx_align_left ltx_th ltx_th_row ltx_border_l ltx_border_r ltx_border_t"><span id="A1.T9.1.5.4.1.1" class="ltx_text ltx_font_bold">Mean Difference when Bloom Filter Greater</span></th>
<td id="A1.T9.1.5.4.2" class="ltx_td ltx_align_right ltx_border_r ltx_border_t">0.202</td>
<td id="A1.T9.1.5.4.3" class="ltx_td ltx_border_r ltx_border_t"></td>
</tr>
<tr id="A1.T9.1.6.5" class="ltx_tr">
<th id="A1.T9.1.6.5.1" class="ltx_td ltx_align_left ltx_th ltx_th_row ltx_border_b ltx_border_l ltx_border_r ltx_border_t"><span id="A1.T9.1.6.5.1.1" class="ltx_text ltx_font_bold">Standard Deviation of difference</span></th>
<td id="A1.T9.1.6.5.2" class="ltx_td ltx_align_right ltx_border_b ltx_border_r ltx_border_t">0.0861</td>
<td id="A1.T9.1.6.5.3" class="ltx_td ltx_border_b ltx_border_r ltx_border_t"></td>
</tr>
</tbody>
</table>
<figcaption class="ltx_caption"><span class="ltx_tag ltx_tag_table">Table 9: </span>Double Hasing Bloom Filter to Bi-gram Comparison with Prime Size (101)</figcaption>
</figure>
<div id="A1.SS4.SSS9.p2" class="ltx_para">
<p id="A1.SS4.SSS9.p2.1" class="ltx_p">Again, we see similar results at the extremes with Bloom filters having high dice-coefficients between names that do not share any bi-grams, as shown in Table <a href="#A1.T10" title="Table 10 ‣ A.4.9 Double hashing: Size of 101, 𝑘=3 ‣ A.4 Security and accuracy of current literature on Bloom Filters ‣ Appendix A Literature Review ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">10</span></a>.</p>
</div>
<figure id="A1.T10" class="ltx_table">
<table id="A1.T10.1" class="ltx_tabular ltx_centering ltx_guessed_headers ltx_align_middle">
<thead class="ltx_thead">
<tr id="A1.T10.1.1.1" class="ltx_tr">
<th id="A1.T10.1.1.1.1" class="ltx_td ltx_align_center ltx_th ltx_th_column ltx_th_row ltx_border_l ltx_border_r ltx_border_t"><span id="A1.T10.1.1.1.1.1" class="ltx_text ltx_font_bold">Dice-coefficient</span></th>
<th id="A1.T10.1.1.1.2" class="ltx_td ltx_align_center ltx_th ltx_th_column ltx_border_r ltx_border_t"><span id="A1.T10.1.1.1.2.1" class="ltx_text ltx_font_bold">Name One</span></th>
<th id="A1.T10.1.1.1.3" class="ltx_td ltx_align_center ltx_th ltx_th_column ltx_border_r ltx_border_t"><span id="A1.T10.1.1.1.3.1" class="ltx_text ltx_font_bold">Name Two</span></th>
</tr>
</thead>
<tbody class="ltx_tbody">
<tr id="A1.T10.1.2.1" class="ltx_tr">
<th id="A1.T10.1.2.1.1" class="ltx_td ltx_align_right ltx_th ltx_th_row ltx_border_l ltx_border_r ltx_border_t">0.7385</th>
<td id="A1.T10.1.2.1.2" class="ltx_td ltx_align_left ltx_border_r ltx_border_t">baiden-amissah</td>
<td id="A1.T10.1.2.1.3" class="ltx_td ltx_align_left ltx_border_r ltx_border_t">tuzzolino</td>
</tr>
<tr id="A1.T10.1.3.2" class="ltx_tr">
<th id="A1.T10.1.3.2.1" class="ltx_td ltx_align_right ltx_th ltx_th_row ltx_border_l ltx_border_r ltx_border_t">0.7429</th>
<td id="A1.T10.1.3.2.2" class="ltx_td ltx_align_left ltx_border_r ltx_border_t">castrechini</td>
<td id="A1.T10.1.3.2.3" class="ltx_td ltx_align_left ltx_border_r ltx_border_t">prawirohardjo</td>
</tr>
<tr id="A1.T10.1.4.3" class="ltx_tr">
<th id="A1.T10.1.4.3.1" class="ltx_td ltx_align_right ltx_th ltx_th_row ltx_border_l ltx_border_r ltx_border_t">0.7500</th>
<td id="A1.T10.1.4.3.2" class="ltx_td ltx_align_left ltx_border_r ltx_border_t">eykhof</td>
<td id="A1.T10.1.4.3.3" class="ltx_td ltx_align_left ltx_border_r ltx_border_t">sliz</td>
</tr>
<tr id="A1.T10.1.5.4" class="ltx_tr">
<th id="A1.T10.1.5.4.1" class="ltx_td ltx_align_right ltx_th ltx_th_row ltx_border_l ltx_border_r ltx_border_t">0.7429</th>
<td id="A1.T10.1.5.4.2" class="ltx_td ltx_align_left ltx_border_r ltx_border_t">keays</td>
<td id="A1.T10.1.5.4.3" class="ltx_td ltx_align_left ltx_border_r ltx_border_t">goeby</td>
</tr>
<tr id="A1.T10.1.6.5" class="ltx_tr">
<th id="A1.T10.1.6.5.1" class="ltx_td ltx_align_right ltx_th ltx_th_row ltx_border_l ltx_border_r ltx_border_t">0.7586</th>
<td id="A1.T10.1.6.5.2" class="ltx_td ltx_align_left ltx_border_r ltx_border_t">lera</td>
<td id="A1.T10.1.6.5.3" class="ltx_td ltx_align_left ltx_border_r ltx_border_t">pagni</td>
</tr>
<tr id="A1.T10.1.7.6" class="ltx_tr">
<th id="A1.T10.1.7.6.1" class="ltx_td ltx_align_right ltx_th ltx_th_row ltx_border_b ltx_border_l ltx_border_r ltx_border_t">0.7391</th>
<td id="A1.T10.1.7.6.2" class="ltx_td ltx_align_left ltx_border_b ltx_border_r ltx_border_t">tempalar</td>
<td id="A1.T10.1.7.6.3" class="ltx_td ltx_align_left ltx_border_b ltx_border_r ltx_border_t">sedcole</td>
</tr>
</tbody>
</table>
<figcaption class="ltx_caption"><span class="ltx_tag ltx_tag_table">Table 10: </span>Double Hashing Bloom Filter to Bi-gram Comparison with Prime Size (101) Largest Over Estimation</figcaption>
</figure>
</section>
<section id="A1.SS4.SSS10" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">A.4.10 </span>Universal hashing: Size of 101, <math id="A1.SS4.SSS10.1.m1.1" class="ltx_Math" alttext="k=3" display="inline"><semantics id="A1.SS4.SSS10.1.m1.1b"><mrow id="A1.SS4.SSS10.1.m1.1.1" xref="A1.SS4.SSS10.1.m1.1.1.cmml"><mi id="A1.SS4.SSS10.1.m1.1.1.2" xref="A1.SS4.SSS10.1.m1.1.1.2.cmml">k</mi><mo id="A1.SS4.SSS10.1.m1.1.1.1" xref="A1.SS4.SSS10.1.m1.1.1.1.cmml">=</mo><mn id="A1.SS4.SSS10.1.m1.1.1.3" xref="A1.SS4.SSS10.1.m1.1.1.3.cmml">3</mn></mrow><annotation-xml encoding="MathML-Content" id="A1.SS4.SSS10.1.m1.1c"><apply id="A1.SS4.SSS10.1.m1.1.1.cmml" xref="A1.SS4.SSS10.1.m1.1.1"><eq id="A1.SS4.SSS10.1.m1.1.1.1.cmml" xref="A1.SS4.SSS10.1.m1.1.1.1"></eq><ci id="A1.SS4.SSS10.1.m1.1.1.2.cmml" xref="A1.SS4.SSS10.1.m1.1.1.2">𝑘</ci><cn type="integer" id="A1.SS4.SSS10.1.m1.1.1.3.cmml" xref="A1.SS4.SSS10.1.m1.1.1.3">3</cn></apply></annotation-xml><annotation encoding="application/x-tex" id="A1.SS4.SSS10.1.m1.1d">k=3</annotation></semantics></math>
</h4>

<div id="A1.SS4.SSS10.p1" class="ltx_para">
<p id="A1.SS4.SSS10.p1.1" class="ltx_p">If the over estimate observed above is due to the underlying hashing technique we would expect the Universal Hashing to not produce a similar over estimation. However, as we see in Table <a href="#A1.T11" title="Table 11 ‣ A.4.10 Universal hashing: Size of 101, 𝑘=3 ‣ A.4 Security and accuracy of current literature on Bloom Filters ‣ Appendix A Literature Review ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">11</span></a> the same problem exists.</p>
</div>
<figure id="A1.T11" class="ltx_table">
<table id="A1.T11.1" class="ltx_tabular ltx_centering ltx_guessed_headers ltx_align_middle">
<thead class="ltx_thead">
<tr id="A1.T11.1.1.1" class="ltx_tr">
<th id="A1.T11.1.1.1.1" class="ltx_td ltx_th ltx_th_column ltx_th_row ltx_border_l ltx_border_r ltx_border_t"></th>
<th id="A1.T11.1.1.1.2" class="ltx_td ltx_align_center ltx_th ltx_th_column ltx_border_r ltx_border_t"><span id="A1.T11.1.1.1.2.1" class="ltx_text ltx_font_bold">Totals</span></th>
<th id="A1.T11.1.1.1.3" class="ltx_td ltx_align_center ltx_th ltx_th_column ltx_border_r ltx_border_t"><span id="A1.T11.1.1.1.3.1" class="ltx_text ltx_font_bold">Percentage (%)</span></th>
</tr>
</thead>
<tbody class="ltx_tbody">
<tr id="A1.T11.1.2.1" class="ltx_tr">
<th id="A1.T11.1.2.1.1" class="ltx_td ltx_align_left ltx_th ltx_th_row ltx_border_l ltx_border_r ltx_border_t"><span id="A1.T11.1.2.1.1.1" class="ltx_text ltx_font_bold">Total Num. Comparisons</span></th>
<td id="A1.T11.1.2.1.2" class="ltx_td ltx_align_right ltx_border_r ltx_border_t">147383049024</td>
<td id="A1.T11.1.2.1.3" class="ltx_td ltx_align_right ltx_border_r ltx_border_t">100.00%</td>
</tr>
<tr id="A1.T11.1.3.2" class="ltx_tr">
<th id="A1.T11.1.3.2.1" class="ltx_td ltx_align_left ltx_th ltx_th_row ltx_border_l ltx_border_r ltx_border_t"><span id="A1.T11.1.3.2.1.1" class="ltx_text ltx_font_bold">Equal Comparisons</span></th>
<td id="A1.T11.1.3.2.2" class="ltx_td ltx_align_right ltx_border_r ltx_border_t">3983997357</td>
<td id="A1.T11.1.3.2.3" class="ltx_td ltx_align_right ltx_border_r ltx_border_t">0.027</td>
</tr>
<tr id="A1.T11.1.4.3" class="ltx_tr">
<th id="A1.T11.1.4.3.1" class="ltx_td ltx_align_left ltx_th ltx_th_row ltx_border_l ltx_border_r ltx_border_t"><span id="A1.T11.1.4.3.1.1" class="ltx_text ltx_font_bold">Bloom Filter Greater than n-gram Comp.</span></th>
<td id="A1.T11.1.4.3.2" class="ltx_td ltx_align_right ltx_border_r ltx_border_t">143399051667</td>
<td id="A1.T11.1.4.3.3" class="ltx_td ltx_align_right ltx_border_r ltx_border_t">0.973</td>
</tr>
<tr id="A1.T11.1.5.4" class="ltx_tr">
<th id="A1.T11.1.5.4.1" class="ltx_td ltx_align_left ltx_th ltx_th_row ltx_border_l ltx_border_r ltx_border_t"><span id="A1.T11.1.5.4.1.1" class="ltx_text ltx_font_bold">Mean Different when Bloom Filter Greater</span></th>
<td id="A1.T11.1.5.4.2" class="ltx_td ltx_align_right ltx_border_r ltx_border_t">0.214</td>
<td id="A1.T11.1.5.4.3" class="ltx_td ltx_border_r ltx_border_t"></td>
</tr>
<tr id="A1.T11.1.6.5" class="ltx_tr">
<th id="A1.T11.1.6.5.1" class="ltx_td ltx_align_left ltx_th ltx_th_row ltx_border_b ltx_border_l ltx_border_r ltx_border_t"><span id="A1.T11.1.6.5.1.1" class="ltx_text ltx_font_bold">Standard Deviation of difference</span></th>
<td id="A1.T11.1.6.5.2" class="ltx_td ltx_align_right ltx_border_b ltx_border_r ltx_border_t">0.0876</td>
<td id="A1.T11.1.6.5.3" class="ltx_td ltx_border_b ltx_border_r ltx_border_t"></td>
</tr>
</tbody>
</table>
<figcaption class="ltx_caption"><span class="ltx_tag ltx_tag_table">Table 11: </span>Universal Hashing Bloom Filter to Bi-gram Comparison with Prime Size (101)</figcaption>
</figure>
<div id="A1.SS4.SSS10.p2" class="ltx_para">
<p id="A1.SS4.SSS10.p2.1" class="ltx_p">Furthermore, as shown in Table <a href="#A1.T12" title="Table 12 ‣ A.4.10 Universal hashing: Size of 101, 𝑘=3 ‣ A.4 Security and accuracy of current literature on Bloom Filters ‣ Appendix A Literature Review ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">12</span></a>, we see similar examples of high similarity scores for names which do not share any bi-grams.</p>
</div>
<figure id="A1.T12" class="ltx_table">
<table id="A1.T12.1" class="ltx_tabular ltx_centering ltx_guessed_headers ltx_align_middle">
<thead class="ltx_thead">
<tr id="A1.T12.1.1.1" class="ltx_tr">
<th id="A1.T12.1.1.1.1" class="ltx_td ltx_align_center ltx_th ltx_th_column ltx_th_row ltx_border_l ltx_border_r ltx_border_t"><span id="A1.T12.1.1.1.1.1" class="ltx_text ltx_font_bold">Dice-coefficient</span></th>
<th id="A1.T12.1.1.1.2" class="ltx_td ltx_align_center ltx_th ltx_th_column ltx_border_r ltx_border_t"><span id="A1.T12.1.1.1.2.1" class="ltx_text ltx_font_bold">Name One</span></th>
<th id="A1.T12.1.1.1.3" class="ltx_td ltx_align_center ltx_th ltx_th_column ltx_border_r ltx_border_t"><span id="A1.T12.1.1.1.3.1" class="ltx_text ltx_font_bold">Name Two</span></th>
</tr>
</thead>
<tbody class="ltx_tbody">
<tr id="A1.T12.1.2.1" class="ltx_tr">
<th id="A1.T12.1.2.1.1" class="ltx_td ltx_align_right ltx_th ltx_th_row ltx_border_l ltx_border_r ltx_border_t">0.765</th>
<td id="A1.T12.1.2.1.2" class="ltx_td ltx_align_left ltx_border_r ltx_border_t">baban</td>
<td id="A1.T12.1.2.1.3" class="ltx_td ltx_align_left ltx_border_r ltx_border_t">murati</td>
</tr>
<tr id="A1.T12.1.3.2" class="ltx_tr">
<th id="A1.T12.1.3.2.1" class="ltx_td ltx_align_right ltx_th ltx_th_row ltx_border_l ltx_border_r ltx_border_t">0.769</th>
<td id="A1.T12.1.3.2.2" class="ltx_td ltx_align_left ltx_border_r ltx_border_t">diz</td>
<td id="A1.T12.1.3.2.3" class="ltx_td ltx_align_left ltx_border_r ltx_border_t">pats</td>
</tr>
<tr id="A1.T12.1.4.3" class="ltx_tr">
<th id="A1.T12.1.4.3.1" class="ltx_td ltx_align_right ltx_th ltx_th_row ltx_border_l ltx_border_r ltx_border_t">0.744</th>
<td id="A1.T12.1.4.3.2" class="ltx_td ltx_align_left ltx_border_r ltx_border_t">himarios</td>
<td id="A1.T12.1.4.3.3" class="ltx_td ltx_align_left ltx_border_r ltx_border_t">nikezic</td>
</tr>
<tr id="A1.T12.1.5.4" class="ltx_tr">
<th id="A1.T12.1.5.4.1" class="ltx_td ltx_align_right ltx_th ltx_th_row ltx_border_l ltx_border_r ltx_border_t">0.757</th>
<td id="A1.T12.1.5.4.2" class="ltx_td ltx_align_left ltx_border_r ltx_border_t">lebris</td>
<td id="A1.T12.1.5.4.3" class="ltx_td ltx_align_left ltx_border_r ltx_border_t">ravino</td>
</tr>
<tr id="A1.T12.1.6.5" class="ltx_tr">
<th id="A1.T12.1.6.5.1" class="ltx_td ltx_align_right ltx_th ltx_th_row ltx_border_l ltx_border_r ltx_border_t">0.750</th>
<td id="A1.T12.1.6.5.2" class="ltx_td ltx_align_left ltx_border_r ltx_border_t">singsuk</td>
<td id="A1.T12.1.6.5.3" class="ltx_td ltx_align_left ltx_border_r ltx_border_t">lebudel</td>
</tr>
<tr id="A1.T12.1.7.6" class="ltx_tr">
<th id="A1.T12.1.7.6.1" class="ltx_td ltx_align_right ltx_th ltx_th_row ltx_border_b ltx_border_l ltx_border_r ltx_border_t">0.750</th>
<td id="A1.T12.1.7.6.2" class="ltx_td ltx_align_left ltx_border_b ltx_border_r ltx_border_t">waku</td>
<td id="A1.T12.1.7.6.3" class="ltx_td ltx_align_left ltx_border_b ltx_border_r ltx_border_t">arrama</td>
</tr>
</tbody>
</table>
<figcaption class="ltx_caption"><span class="ltx_tag ltx_tag_table">Table 12: </span>Universal Hashing Bloom Filter to Bi-gram Comparison with Prime Size (101) Largest Over Estimation</figcaption>
</figure>
</section>
<section id="A1.SS4.SSS11" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">A.4.11 </span>Importance of filter size to <math id="A1.SS4.SSS11.1.m1.1" class="ltx_Math" alttext="k" display="inline"><semantics id="A1.SS4.SSS11.1.m1.1b"><mi id="A1.SS4.SSS11.1.m1.1.1" xref="A1.SS4.SSS11.1.m1.1.1.cmml">k</mi><annotation-xml encoding="MathML-Content" id="A1.SS4.SSS11.1.m1.1c"><ci id="A1.SS4.SSS11.1.m1.1.1.cmml" xref="A1.SS4.SSS11.1.m1.1.1">𝑘</ci></annotation-xml><annotation encoding="application/x-tex" id="A1.SS4.SSS11.1.m1.1d">k</annotation></semantics></math>
</h4>

<div id="A1.SS4.SSS11.p1" class="ltx_para">
<p id="A1.SS4.SSS11.p1.1" class="ltx_p">The results above indicate that the root cause of the over estimate is not the underlying hash construction. In order to further evaluate how changing the parameters impacted on the over estimate we constructed a random sample of 10,000 last names. Using this smaller sample allowed us to run more cross comparisons and therefore evaluate a larger range of values. We repeated the tests from above to confirm that the sample was an accurate reflection of the larger dataset.</p>
</div>
<div id="A1.SS4.SSS11.p2" class="ltx_para">
<p id="A1.SS4.SSS11.p2.1" class="ltx_p">The first parameter we examined was the size of the Bloom filter. We fixed <math id="A1.SS4.SSS11.p2.1.m1.1" class="ltx_Math" alttext="k=3" display="inline"><semantics id="A1.SS4.SSS11.p2.1.m1.1a"><mrow id="A1.SS4.SSS11.p2.1.m1.1.1" xref="A1.SS4.SSS11.p2.1.m1.1.1.cmml"><mi id="A1.SS4.SSS11.p2.1.m1.1.1.2" xref="A1.SS4.SSS11.p2.1.m1.1.1.2.cmml">k</mi><mo id="A1.SS4.SSS11.p2.1.m1.1.1.1" xref="A1.SS4.SSS11.p2.1.m1.1.1.1.cmml">=</mo><mn id="A1.SS4.SSS11.p2.1.m1.1.1.3" xref="A1.SS4.SSS11.p2.1.m1.1.1.3.cmml">3</mn></mrow><annotation-xml encoding="MathML-Content" id="A1.SS4.SSS11.p2.1.m1.1b"><apply id="A1.SS4.SSS11.p2.1.m1.1.1.cmml" xref="A1.SS4.SSS11.p2.1.m1.1.1"><eq id="A1.SS4.SSS11.p2.1.m1.1.1.1.cmml" xref="A1.SS4.SSS11.p2.1.m1.1.1.1"></eq><ci id="A1.SS4.SSS11.p2.1.m1.1.1.2.cmml" xref="A1.SS4.SSS11.p2.1.m1.1.1.2">𝑘</ci><cn type="integer" id="A1.SS4.SSS11.p2.1.m1.1.1.3.cmml" xref="A1.SS4.SSS11.p2.1.m1.1.1.3">3</cn></apply></annotation-xml><annotation encoding="application/x-tex" id="A1.SS4.SSS11.p2.1.m1.1c">k=3</annotation></semantics></math> and increased the size of the Bloom filter in increments of 100 between 100 and 1000. As we can see from the graph in Figure <a href="#A1.F6" title="Figure 6 ‣ A.4.11 Importance of filter size to 𝑘 ‣ A.4 Security and accuracy of current literature on Bloom Filters ‣ Appendix A Literature Review ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">6</span></a> as the size of the filter increases the over estimate reduces. Both the Double Hashing approach and the Universal Hashing approach show the same changes. However, it should be noted that whilst the size of the over estimation reduces as the Bloom filter size increases, the rate of reduction also reduces, indicating that there may be some base level of over estimation that cannot eliminated.</p>
</div>
<figure id="A1.F6" class="ltx_figure"><img src="/html/1802.07975/assets/x6.png" id="A1.F6.g1" class="ltx_graphics ltx_centering ltx_img_landscape" width="368" height="276" alt="Refer to caption">
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure">Figure 6: </span>Comparison of Similarity Differences as Filter Size Grows</figcaption>
</figure>
<div id="A1.SS4.SSS11.p3" class="ltx_para">
<p id="A1.SS4.SSS11.p3.1" class="ltx_p">In addition to the size of the over estimation reducing, the percentage of comparisons that were over estimated also reduces. Figure <a href="#A1.F7" title="Figure 7 ‣ A.4.11 Importance of filter size to 𝑘 ‣ A.4 Security and accuracy of current literature on Bloom Filters ‣ Appendix A Literature Review ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">7</span></a> and <a href="#A1.F8" title="Figure 8 ‣ A.4.11 Importance of filter size to 𝑘 ‣ A.4 Security and accuracy of current literature on Bloom Filters ‣ Appendix A Literature Review ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">8</span></a> shows the graphs comparing the percentage that were equal vs the percentage that were larger, for Universal Hashing and Double Hashing respectively. It should be noted that the n-gram similarity score was never larger.</p>
</div>
<figure id="A1.F7" class="ltx_figure"><img src="/html/1802.07975/assets/x7.png" id="A1.F7.g1" class="ltx_graphics ltx_centering ltx_img_landscape" width="368" height="230" alt="Refer to caption">
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure">Figure 7: </span>Comparison of Percentages of Larger or Equal Similarity Scores</figcaption>
</figure>
<figure id="A1.F8" class="ltx_figure"><img src="/html/1802.07975/assets/x8.png" id="A1.F8.g1" class="ltx_graphics ltx_centering ltx_img_landscape" width="368" height="230" alt="Refer to caption">
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure">Figure 8: </span>Comparison of Similarity Differences as Filter Size Grows</figcaption>
</figure>
<div id="A1.SS4.SSS11.p4" class="ltx_para">
<p id="A1.SS4.SSS11.p4.1" class="ltx_p">The reduction in the percentage of comparisons that was larger, in addition to the reduction in the size of the difference is doubly beneficial. However, the graphs indicate that it requires a filter of size 700 bits before the majority are not over estimated. This is a significantly larger Bloom filter, which will impact on performance and storage cost. We have used the value of 10 as the number of bi-grams we expect to put into a Bloom filter, which is broadly inline with our analysis of our last name dataset, which has an average of 9 bi-grams. An estimate of 10 is sufficient for our testing, however, at deployment it may need to be larger, which would have a further negative impact on the efficiency of Bloom filter.</p>
</div>
<div id="A1.SS4.SSS11.p5" class="ltx_para">
<p id="A1.SS4.SSS11.p5.2" class="ltx_p">It would be tempting to assume that it was purely the size of the Bloom filter that is important, but as we shall see, it is the ratio between the size and <math id="A1.SS4.SSS11.p5.1.m1.1" class="ltx_Math" alttext="k" display="inline"><semantics id="A1.SS4.SSS11.p5.1.m1.1a"><mi id="A1.SS4.SSS11.p5.1.m1.1.1" xref="A1.SS4.SSS11.p5.1.m1.1.1.cmml">k</mi><annotation-xml encoding="MathML-Content" id="A1.SS4.SSS11.p5.1.m1.1b"><ci id="A1.SS4.SSS11.p5.1.m1.1.1.cmml" xref="A1.SS4.SSS11.p5.1.m1.1.1">𝑘</ci></annotation-xml><annotation encoding="application/x-tex" id="A1.SS4.SSS11.p5.1.m1.1c">k</annotation></semantics></math> the number of hashes that is important. To confirm this we fixed the size at 1000 bits and then increased <math id="A1.SS4.SSS11.p5.2.m2.1" class="ltx_Math" alttext="k" display="inline"><semantics id="A1.SS4.SSS11.p5.2.m2.1a"><mi id="A1.SS4.SSS11.p5.2.m2.1.1" xref="A1.SS4.SSS11.p5.2.m2.1.1.cmml">k</mi><annotation-xml encoding="MathML-Content" id="A1.SS4.SSS11.p5.2.m2.1b"><ci id="A1.SS4.SSS11.p5.2.m2.1.1.cmml" xref="A1.SS4.SSS11.p5.2.m2.1.1">𝑘</ci></annotation-xml><annotation encoding="application/x-tex" id="A1.SS4.SSS11.p5.2.m2.1c">k</annotation></semantics></math> in increments of 3 from 3 to 30.</p>
</div>
<div id="A1.SS4.SSS11.p6" class="ltx_para">
<p id="A1.SS4.SSS11.p6.1" class="ltx_p">Figure <a href="#A1.F9" title="Figure 9 ‣ A.4.11 Importance of filter size to 𝑘 ‣ A.4 Security and accuracy of current literature on Bloom Filters ‣ Appendix A Literature Review ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">9</span></a> shows the graph of the results and as expected, it is the inverse of what we saw in Figure <a href="#A1.F6" title="Figure 6 ‣ A.4.11 Importance of filter size to 𝑘 ‣ A.4 Security and accuracy of current literature on Bloom Filters ‣ Appendix A Literature Review ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">6</span></a>. As <math id="A1.SS4.SSS11.p6.1.m1.1" class="ltx_Math" alttext="k" display="inline"><semantics id="A1.SS4.SSS11.p6.1.m1.1a"><mi id="A1.SS4.SSS11.p6.1.m1.1.1" xref="A1.SS4.SSS11.p6.1.m1.1.1.cmml">k</mi><annotation-xml encoding="MathML-Content" id="A1.SS4.SSS11.p6.1.m1.1b"><ci id="A1.SS4.SSS11.p6.1.m1.1.1.cmml" xref="A1.SS4.SSS11.p6.1.m1.1.1">𝑘</ci></annotation-xml><annotation encoding="application/x-tex" id="A1.SS4.SSS11.p6.1.m1.1c">k</annotation></semantics></math> increases and the ratio reduces the over estimation increases.</p>
</div>
<figure id="A1.F9" class="ltx_figure"><img src="/html/1802.07975/assets/x9.png" id="A1.F9.g1" class="ltx_graphics ltx_centering ltx_img_landscape" width="368" height="276" alt="Refer to caption">
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure">Figure 9: </span>Comparison of Similarity Differences as Number of Hashes Grows</figcaption>
</figure>
<div id="A1.SS4.SSS11.p7" class="ltx_para">
<p id="A1.SS4.SSS11.p7.3" class="ltx_p">This demonstrates that a size of 100 and <math id="A1.SS4.SSS11.p7.1.m1.1" class="ltx_Math" alttext="k=3" display="inline"><semantics id="A1.SS4.SSS11.p7.1.m1.1a"><mrow id="A1.SS4.SSS11.p7.1.m1.1.1" xref="A1.SS4.SSS11.p7.1.m1.1.1.cmml"><mi id="A1.SS4.SSS11.p7.1.m1.1.1.2" xref="A1.SS4.SSS11.p7.1.m1.1.1.2.cmml">k</mi><mo id="A1.SS4.SSS11.p7.1.m1.1.1.1" xref="A1.SS4.SSS11.p7.1.m1.1.1.1.cmml">=</mo><mn id="A1.SS4.SSS11.p7.1.m1.1.1.3" xref="A1.SS4.SSS11.p7.1.m1.1.1.3.cmml">3</mn></mrow><annotation-xml encoding="MathML-Content" id="A1.SS4.SSS11.p7.1.m1.1b"><apply id="A1.SS4.SSS11.p7.1.m1.1.1.cmml" xref="A1.SS4.SSS11.p7.1.m1.1.1"><eq id="A1.SS4.SSS11.p7.1.m1.1.1.1.cmml" xref="A1.SS4.SSS11.p7.1.m1.1.1.1"></eq><ci id="A1.SS4.SSS11.p7.1.m1.1.1.2.cmml" xref="A1.SS4.SSS11.p7.1.m1.1.1.2">𝑘</ci><cn type="integer" id="A1.SS4.SSS11.p7.1.m1.1.1.3.cmml" xref="A1.SS4.SSS11.p7.1.m1.1.1.3">3</cn></apply></annotation-xml><annotation encoding="application/x-tex" id="A1.SS4.SSS11.p7.1.m1.1c">k=3</annotation></semantics></math>, as suggested by Randall <span id="A1.SS4.SSS11.p7.3.1" class="ltx_text ltx_font_italic">et al.</span> <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib41" title="" class="ltx_ref">41</a>]</cite>, produces a high level of over-estimation. Furthermore, the recommendation to maintain the ratio between the size and <math id="A1.SS4.SSS11.p7.2.m2.1" class="ltx_Math" alttext="k" display="inline"><semantics id="A1.SS4.SSS11.p7.2.m2.1a"><mi id="A1.SS4.SSS11.p7.2.m2.1.1" xref="A1.SS4.SSS11.p7.2.m2.1.1.cmml">k</mi><annotation-xml encoding="MathML-Content" id="A1.SS4.SSS11.p7.2.m2.1b"><ci id="A1.SS4.SSS11.p7.2.m2.1.1.cmml" xref="A1.SS4.SSS11.p7.2.m2.1.1">𝑘</ci></annotation-xml><annotation encoding="application/x-tex" id="A1.SS4.SSS11.p7.2.m2.1c">k</annotation></semantics></math> as was used in <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib43" title="" class="ltx_ref">43</a>]</cite> has the effect of persisting the over estimation. Figure <a href="#A1.F9" title="Figure 9 ‣ A.4.11 Importance of filter size to 𝑘 ‣ A.4 Security and accuracy of current literature on Bloom Filters ‣ Appendix A Literature Review ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">9</span></a> shows that the parameters used by Schnell <span id="A1.SS4.SSS11.p7.3.2" class="ltx_text ltx_font_italic">et al.<cite class="ltx_cite ltx_citemacro_cite"><span id="A1.SS4.SSS11.p7.3.2.1.1" class="ltx_text ltx_font_upright">[</span><a href="#bib.bib43" title="" class="ltx_ref">43</a><span id="A1.SS4.SSS11.p7.3.2.2.2" class="ltx_text ltx_font_upright">]</span></cite></span> of a size of 1000 and <math id="A1.SS4.SSS11.p7.3.m3.1" class="ltx_Math" alttext="k=30" display="inline"><semantics id="A1.SS4.SSS11.p7.3.m3.1a"><mrow id="A1.SS4.SSS11.p7.3.m3.1.1" xref="A1.SS4.SSS11.p7.3.m3.1.1.cmml"><mi id="A1.SS4.SSS11.p7.3.m3.1.1.2" xref="A1.SS4.SSS11.p7.3.m3.1.1.2.cmml">k</mi><mo id="A1.SS4.SSS11.p7.3.m3.1.1.1" xref="A1.SS4.SSS11.p7.3.m3.1.1.1.cmml">=</mo><mn id="A1.SS4.SSS11.p7.3.m3.1.1.3" xref="A1.SS4.SSS11.p7.3.m3.1.1.3.cmml">30</mn></mrow><annotation-xml encoding="MathML-Content" id="A1.SS4.SSS11.p7.3.m3.1b"><apply id="A1.SS4.SSS11.p7.3.m3.1.1.cmml" xref="A1.SS4.SSS11.p7.3.m3.1.1"><eq id="A1.SS4.SSS11.p7.3.m3.1.1.1.cmml" xref="A1.SS4.SSS11.p7.3.m3.1.1.1"></eq><ci id="A1.SS4.SSS11.p7.3.m3.1.1.2.cmml" xref="A1.SS4.SSS11.p7.3.m3.1.1.2">𝑘</ci><cn type="integer" id="A1.SS4.SSS11.p7.3.m3.1.1.3.cmml" xref="A1.SS4.SSS11.p7.3.m3.1.1.3">30</cn></apply></annotation-xml><annotation encoding="application/x-tex" id="A1.SS4.SSS11.p7.3.m3.1c">k=30</annotation></semantics></math> suffers the same over estimation.</p>
</div>
<div id="A1.SS4.SSS11.p8" class="ltx_para">
<p id="A1.SS4.SSS11.p8.1" class="ltx_p">We see the same story with regards to the percentage of comparisons that were over estimated. Figure <a href="#A1.F10" title="Figure 10 ‣ A.4.11 Importance of filter size to 𝑘 ‣ A.4 Security and accuracy of current literature on Bloom Filters ‣ Appendix A Literature Review ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">10</span></a> and <a href="#A1.F11" title="Figure 11 ‣ A.4.11 Importance of filter size to 𝑘 ‣ A.4 Security and accuracy of current literature on Bloom Filters ‣ Appendix A Literature Review ‣ Options for encoding names for data linking at the Australian Bureau of Statistics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">11</span></a> shows the graphs comparing the percentage that were equal vs the percentage that were larger, for Universal Hashing and Double Hashing respectively.</p>
</div>
<figure id="A1.F10" class="ltx_figure"><img src="/html/1802.07975/assets/x10.png" id="A1.F10.g1" class="ltx_graphics ltx_centering ltx_img_landscape" width="368" height="230" alt="Refer to caption">
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure">Figure 10: </span>Comparison of Percentages of Larger or Equal Similarity Scores</figcaption>
</figure>
<figure id="A1.F11" class="ltx_figure"><img src="/html/1802.07975/assets/x11.png" id="A1.F11.g1" class="ltx_graphics ltx_centering ltx_img_landscape" width="368" height="230" alt="Refer to caption">
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure">Figure 11: </span>Comparison of Similarity Differences as Filter Size Grows</figcaption>
</figure>
<div id="A1.SS4.SSS11.p9" class="ltx_para">
<p id="A1.SS4.SSS11.p9.4" class="ltx_p">We can conclude that to minimise both the number and level of over estimate we need a large Bloom filter with a small <math id="A1.SS4.SSS11.p9.1.m1.1" class="ltx_Math" alttext="k" display="inline"><semantics id="A1.SS4.SSS11.p9.1.m1.1a"><mi id="A1.SS4.SSS11.p9.1.m1.1.1" xref="A1.SS4.SSS11.p9.1.m1.1.1.cmml">k</mi><annotation-xml encoding="MathML-Content" id="A1.SS4.SSS11.p9.1.m1.1b"><ci id="A1.SS4.SSS11.p9.1.m1.1.1.cmml" xref="A1.SS4.SSS11.p9.1.m1.1.1">𝑘</ci></annotation-xml><annotation encoding="application/x-tex" id="A1.SS4.SSS11.p9.1.m1.1c">k</annotation></semantics></math>. This is at odds with the literature which indicates that the ratio of size 100 to <math id="A1.SS4.SSS11.p9.2.m2.1" class="ltx_Math" alttext="k=3" display="inline"><semantics id="A1.SS4.SSS11.p9.2.m2.1a"><mrow id="A1.SS4.SSS11.p9.2.m2.1.1" xref="A1.SS4.SSS11.p9.2.m2.1.1.cmml"><mi id="A1.SS4.SSS11.p9.2.m2.1.1.2" xref="A1.SS4.SSS11.p9.2.m2.1.1.2.cmml">k</mi><mo id="A1.SS4.SSS11.p9.2.m2.1.1.1" xref="A1.SS4.SSS11.p9.2.m2.1.1.1.cmml">=</mo><mn id="A1.SS4.SSS11.p9.2.m2.1.1.3" xref="A1.SS4.SSS11.p9.2.m2.1.1.3.cmml">3</mn></mrow><annotation-xml encoding="MathML-Content" id="A1.SS4.SSS11.p9.2.m2.1b"><apply id="A1.SS4.SSS11.p9.2.m2.1.1.cmml" xref="A1.SS4.SSS11.p9.2.m2.1.1"><eq id="A1.SS4.SSS11.p9.2.m2.1.1.1.cmml" xref="A1.SS4.SSS11.p9.2.m2.1.1.1"></eq><ci id="A1.SS4.SSS11.p9.2.m2.1.1.2.cmml" xref="A1.SS4.SSS11.p9.2.m2.1.1.2">𝑘</ci><cn type="integer" id="A1.SS4.SSS11.p9.2.m2.1.1.3.cmml" xref="A1.SS4.SSS11.p9.2.m2.1.1.3">3</cn></apply></annotation-xml><annotation encoding="application/x-tex" id="A1.SS4.SSS11.p9.2.m2.1c">k=3</annotation></semantics></math> should be maintained to achieve results. In our analysis this offers particularly poor performance in terms of the number and scale of over estimation. As the size of the Bloom filter increases it becomes less efficient and more costly to store. As a result, given the limited domain of inputs we have and the relatively small size of the our strings, it is highly likely that straight comparison of bi-grams will give a better performance in terms of speed, storage and accuracy. Additionally, the optimal size of <math id="A1.SS4.SSS11.p9.3.m3.1" class="ltx_Math" alttext="k" display="inline"><semantics id="A1.SS4.SSS11.p9.3.m3.1a"><mi id="A1.SS4.SSS11.p9.3.m3.1.1" xref="A1.SS4.SSS11.p9.3.m3.1.1.cmml">k</mi><annotation-xml encoding="MathML-Content" id="A1.SS4.SSS11.p9.3.m3.1b"><ci id="A1.SS4.SSS11.p9.3.m3.1.1.cmml" xref="A1.SS4.SSS11.p9.3.m3.1.1">𝑘</ci></annotation-xml><annotation encoding="application/x-tex" id="A1.SS4.SSS11.p9.3.m3.1c">k</annotation></semantics></math>, in terms of false positives is calculated based on the ratio between the number of inputs and the size of the Bloom filter. As such, minimising <math id="A1.SS4.SSS11.p9.4.m4.1" class="ltx_Math" alttext="k" display="inline"><semantics id="A1.SS4.SSS11.p9.4.m4.1a"><mi id="A1.SS4.SSS11.p9.4.m4.1.1" xref="A1.SS4.SSS11.p9.4.m4.1.1.cmml">k</mi><annotation-xml encoding="MathML-Content" id="A1.SS4.SSS11.p9.4.m4.1b"><ci id="A1.SS4.SSS11.p9.4.m4.1.1.cmml" xref="A1.SS4.SSS11.p9.4.m4.1.1">𝑘</ci></annotation-xml><annotation encoding="application/x-tex" id="A1.SS4.SSS11.p9.4.m4.1c">k</annotation></semantics></math> with a large Bloom filter could increase the false positive rate. This may not be as important in this instance, since we are only ever performing a similarity score, not a set comparison. However, it highlights the problem of using a Bloom filter which is designed for evaluating set inclusion for measuring similarity. What is optimal for one may not be optimal for the other.</p>
</div>
</section>
</section>
<section id="A1.SS5" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">A.5 </span>Other Approaches</h3>

<div id="A1.SS5.p1" class="ltx_para">
<p id="A1.SS5.p1.1" class="ltx_p">Lyons et al. <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib35" title="" class="ltx_ref">35</a>]</cite> present their approach to matching records across multiple datasets in the context of the UK National Health Service. Their scheme, SAIL (Secure Anonymised Information Linkage) system has run in the Welsh NHS system. It has been used for exact matching between Anonymous Linking Fields (ALFs) which are derived from the patient identifier via the Blowfish cryptographic algorithm. The approach is not directly related to our context, in that it does not allow fuzzy matching, provides inherent recoverability, and would not protect against frequency attacks. However, it is of note because it is at least using appropriate cryptography for the job it is trying to do, as opposed to relying on hashing, and has been deployed at scale.</p>
</div>
<div id="A1.SS5.p2" class="ltx_para">
<p id="A1.SS5.p2.1" class="ltx_p">Scannapieco et al. <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib42" title="" class="ltx_ref">42</a>]</cite> present an approach based on a SparseMap. The concept is to map values into a vector space based on their similarity to a set of randomly selected words. The dimensions of the vector space is reduced, one assumes resulting in a loss of exact matching. The scheme relies on a trusted third party to compare the vector spaces from two parties. The security analysis around what the third party can learn during this process is lacking. It is possible that some information leaks during this process, to the extent that Vatsalan et al. <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib49" title="" class="ltx_ref">49</a>]</cite> consider it to be susceptible to frequency and collusion attacks.</p>
</div>
<div id="A1.SS5.p3" class="ltx_para">
<p id="A1.SS5.p3.1" class="ltx_p">Karakasidis et al. <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib30" title="" class="ltx_ref">30</a>]</cite> propose a scheme that involves injecting fake values into hash value sets to hide the frequency distribution. They do not even propose using a keyed hashing function, instead proposing the use of MD5. The use of MD5 is particularly weak, given that it was considered to be broken in the cryptographic sense long before the paper was published. Furthermore, it is the Soundex encoding that is being hashed, not the actual name. As a result the input set is even smaller than it would normally be. The reversing of the hash would be trivial. However, this would not lead to recovery of exact names, due to the Soundex encoding being lossy, it would only permit recover of the set of names that encode to that Soundex.</p>
</div>
<div id="A1.SS5.p4" class="ltx_para">
<p id="A1.SS5.p4.1" class="ltx_p">The main aim of the scheme appears to be to avoid frequency attacks, by injecting fake names to ensure all Soundex codes have the same frequency. This may defeat frequency attacks, but Soundex codes will be easily recoverable, making the protection against frequency attacks a moot point. The concept of injecting fake or duplicate values in order to smooth a frequency distribution is a sound one, though implemented in an insecure protocol in this instance. Such an approach could be considered in a proposed solution, in order to help protect against frequency attacks, and therefore warrants further consideration.</p>
</div>
</section>
<section id="A1.SS6" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">A.6 </span>Secure Multi-Party Computation</h3>

<div id="A1.SS6.p1" class="ltx_para">
<p id="A1.SS6.p1.1" class="ltx_p">Secure Multi-Party Computation is a large research field in its own right, which is beyond the scope of what we can review in this document. In general, SMC approaches offer stronger security guarantees, often based on the underlying mathematical guarantees of the cryptographic primitives. The key idea is to distribute the computation among two or more participants so that privacy and correctness can fail only if the attacker compromises more than a threshold of participants. For example, when there are two participants it is often possible to prove that one of them receives only the properly-linked information they need, while no information is leaked to the other. This sort of model would be very appropriate for ABS.</p>
</div>
<div id="A1.SS6.p2" class="ltx_para">
<p id="A1.SS6.p2.1" class="ltx_p">However, the computational cost of the schemes is often prohibitive if deployed at scale. There is also a significant increase in the capability required for implementation and support of a SMC protocol, due to the complex cryptography involved. Furthermore, evaluating that the implementation is a faithful replication of the design is non-trivial, and failure to comply with the design can have disastrous effects on the security of the protocol. Nonetheless, SMC is undoubtedly the future of privacy preserving record linkage. It will allow two or more parties to link, share and evaluate data in a manner that does not leak information or break privacy. As such, it is worth consideration if only in terms of longer term plans.</p>
</div>
<div id="A1.SS6.p3" class="ltx_para">
<p id="A1.SS6.p3.1" class="ltx_p">The usage of SMC in privacy preserving data processing is not new. As early as 2001 Du et al. <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib20" title="" class="ltx_ref">20</a>]</cite> proposed using SMC as way of securely retrieving data from the a database, in a manner in which the database holder does not learn the contents of the query and the querying party does not learn the contents of the database. Their approach used a number of techniques, including Oblivious Transfer. The scheme is quite old now, and more efficient approaches have been presented. However, it should give an indication of the length of time the problem has been studied for, and is still not solved at scale, to provide an indication that it could be several years before a suitable solution is available.</p>
</div>
<div id="A1.SS6.p4" class="ltx_para">
<p id="A1.SS6.p4.1" class="ltx_p">More recent proposals have attempted to resolve the scaling issue by blocking the dataset prior to performing the expensive SMC protocol. Inan et al. <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib29" title="" class="ltx_ref">29</a>]</cite> propose using Differential Privacy to permit a joint blocking process to take place, whilst limiting information leakage. Following the blocking a SMC protocol is run to calculate the matches. Whilst it undoubtedly improves the efficiency of the overall protocol, the implementation complexity would be significant.</p>
</div>
<div id="A1.SS6.p5" class="ltx_para">
<p id="A1.SS6.p5.1" class="ltx_p">An area which has driven a large amount of work in privacy preserving matching is in the area of DNA matching. As DNA databases grow the demand for efficient privacy preserving matching also grows. Atallah et al. <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib3" title="" class="ltx_ref">3</a>]</cite> propose using homomorphic cryptography to calculate an edit distance between DNA sequences. Such an approach is certainly worth further consideration, with the caveat of it having high complexity of implementation. It should also be noted that whenever encryption of the identifiers occurs directly there is always a decryption risk. The protocols proposed will also be based on multi-party settings, which will require re-analysing in a setting where there is a single entity, as in our context.</p>
</div>
<div id="A1.SS6.p6" class="ltx_para">
<p id="A1.SS6.p6.1" class="ltx_p">Hall and Fienberg <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib28" title="" class="ltx_ref">28</a>]</cite> present a review of Privacy Preserving Record Linkage literature. The focus of the paper is on secure multi-party computation and the remaining challenges. The paper initially looks at existing approaches that are based on hashes and HMACs and highlights that such schemes are insecure. The authors also highlight the different security models, and the limitations of requiring a trusted third party. A number of SMC approaches are discussed, with the overarching conclusion being that they remain computationally demanding, and possibly infeasible when deployed at scale. The authors draw the conclusion that most of the SMC-based protocols rely on either secure set intersection or inner products, and therefore these areas warrant further research to try to achieve the efficiency gains required to make the approaches feasible at scale. The paper discusses the security risks of revealing intermediate values, for example, in the form of similarity scores. It is this very problem that we discuss in relation to ONS <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib37" title="" class="ltx_ref">37</a>]</cite> approach in <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib18" title="" class="ltx_ref">18</a>]</cite>. The authors touch on the concept of thresholded cryptography and how it can play a part in ensuring that intermediate values, like similarity scores, are not revealed and how it can be used to enforce that a series of operations are performed on the cipher texts, to ensure the final decrypted output does not reveal any unintended information.</p>
</div>
<div id="A1.SS6.p7" class="ltx_para">
<p id="A1.SS6.p7.1" class="ltx_p">If a homomorphic approach were to be considered it would require further research into the most appropriate string comparison algorithm. The limitation of operations that can be performed homomorphically will reduce the applicable string comparisons, often to simple edit distance calculations. Yancey <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib51" title="" class="ltx_ref">51</a>]</cite> provides a comparison of different string comparators for matching in the context of the US Census, which would require further consideration when proposing a homomorphic solution.</p>
</div>
<div id="A1.SS6.p8" class="ltx_para">
<p id="A1.SS6.p8.1" class="ltx_p">Some schemes <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib48" title="" class="ltx_ref">48</a>]</cite> rely on secure set intersection protocols, without providing explicit details. Such protocols are potentially useful when comparing anything from Bloom filters to similarity tables. However, they are often dependent on having two genuinely distinct parties, who both have access to their underlying plaintext data. The efficiency of such protocols remains a problem, which makes them largely unsuitable for our context.</p>
</div>
</section>
<section id="A1.SS7" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">A.7 </span>Differential Privacy</h3>

<div id="A1.SS7.p1" class="ltx_para">
<p id="A1.SS7.p1.1" class="ltx_p">Differential privacy <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib23" title="" class="ltx_ref">23</a>]</cite> represents a formal framework for preserving privacy of datasets when releasing statistics. Releases could be scalars or vectors <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib23" title="" class="ltx_ref">23</a>]</cite>, marginal tables <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib5" title="" class="ltx_ref">5</a>]</cite>, models <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib14" title="" class="ltx_ref">14</a>]</cite>, or synthetic datasets <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib10" title="" class="ltx_ref">10</a>]</cite>. The privacy model of differential privacy is one of untrusted parties receiving the release, where it is assumed that the processing of the data into the release is performed by the data owner. As such it can complement models of untrusted/shared computation. The model of the receiving party is adversarial, which is why the framework has received significant attention recently over earlier frameworks such as <math id="A1.SS7.p1.1.m1.1" class="ltx_Math" alttext="k" display="inline"><semantics id="A1.SS7.p1.1.m1.1a"><mi id="A1.SS7.p1.1.m1.1.1" xref="A1.SS7.p1.1.m1.1.1.cmml">k</mi><annotation-xml encoding="MathML-Content" id="A1.SS7.p1.1.m1.1b"><ci id="A1.SS7.p1.1.m1.1.1.cmml" xref="A1.SS7.p1.1.m1.1.1">𝑘</ci></annotation-xml><annotation encoding="application/x-tex" id="A1.SS7.p1.1.m1.1c">k</annotation></semantics></math>-anonymity. For more on the framework refer to the book <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib24" title="" class="ltx_ref">24</a>]</cite>. For the task of PPRL on names (with plaintext deleted), for a single ABS party, releasing the unperturbed plaintext linked dataset, the framework is not immediately applicable.</p>
</div>
<div id="A1.SS7.p2" class="ltx_para">
<p id="A1.SS7.p2.1" class="ltx_p">In addition to Inan et al. <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib29" title="" class="ltx_ref">29</a>]</cite> using differential privacy, Abowd <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib1" title="" class="ltx_ref">1</a>]</cite> presented a seminar on Privacy Protection for Statistical Agencies that discussed differential privacy. The seminar did not cover privacy preserving record linkage, but did discuss Statistical Disclosure Limitation within the context of statistical agencies. In particular it discussed evaluating the Marginal Social Cost vs. Marginal Social benefit, and how different research fields assume a different trade-off point. The seminar highlights some important issues that are relevant to the more general setting. In particular that most SDL schemes were conceived when the public sphere was data starved, and as such, the statistical agency could largely determine what information crossed their firewall into the public sphere. In contrast, today, the opposite is true, big data now exists outside the statistical agencies, and to a large extent, not all data held by statistical agencies would even be considered big data. This changes the data release environment and requires different approaches, given both the quantity and lack of control over external data releases.</p>
</div>
<div id="A1.SS7.p3" class="ltx_para">
<p id="A1.SS7.p3.1" class="ltx_p">Abowd <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib1" title="" class="ltx_ref">1</a>]</cite> advocated the public release of documentation to achieve an open and auditable approach, as well highlighting the need for close collaboration between those formally modelling the approaches and the actual implementers. Such points are directly relevant to our context.</p>
</div>
</section>
<section id="A1.SS8" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">A.8 </span>UK Office of National Statistics</h3>

<div id="A1.SS8.p1" class="ltx_para">
<p id="A1.SS8.p1.1" class="ltx_p">The approach proposed by the UK Office of National Statistics in the set of reports “Beyond 2011” provides a detailed overview of their research and methods in the area of privacy preserving record linkage. It is applicable to the ABS given the broad similarity of the two organisations. However, there are significant differences in the objectives of the two organisations. First, the threat models are significantly different: the ONS is attempting to protect privacy in the presence of malicious external researchers (albeit extremely restricted researchers), whilst the ABS is attempting to protect privacy from internal actors. Second, the ONS is not constrained by a requirement to delete names and addresses, it is permitted to keep them and is potentially reliant on them when performing some of the linking processes (even in the case of the “hashed” linking). As such, the ONS approach would not be compliant with the ABS requirement for non-recoverable storage of names and addresses.</p>
</div>
<div id="A1.SS8.p2" class="ltx_para">
<p id="A1.SS8.p2.1" class="ltx_p">The ONS has successfully deployed an HMAC-based linkage identifier using subsets of attributes, like the one described in Option 3. This seems to work well. However, while studying for this report we identified weaknesses in other aspects of their methods, which have been reported to them and were published separately <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib18" title="" class="ltx_ref">18</a>]</cite>.</p>
</div>
<div class="ltx_pagination ltx_role_newpage"></div>
</section>
</section>
</article>
</div>
<div class="ar5iv-footer"><a href="/html/1802.07973" class="ar5iv-nav-button ar5iv-nav-button-prev">◄</a>
    <a class="ar5iv-home-button" href="/"><img height="40" alt="ar5iv homepage" src="/assets/ar5iv.png"></a>
    <a href="/feeling_lucky" class="ar5iv-text-button">Feeling<br>lucky?</a>
    <a href="/log/1802.07975" class="ar5iv-text-button ar5iv-severity-warning">Conversion<br>report</a>
    <a class="ar5iv-text-button" target="_blank" href="https://github.com/dginev/ar5iv/issues/new?template=improve-article--arxiv-id-.md&title=Improve+article+1802.07975">Report<br>an issue</a>
    <a href="https://arxiv.org/abs/1802.07975" class="ar5iv-text-button arxiv-ui-theme">View&nbsp;original<br>on&nbsp;arXiv</a><a href="/html/1802.07976" class="ar5iv-nav-button ar5iv-nav-button-next">►</a>
</div><footer class="ltx_page_footer">
<a class="ar5iv-toggle-color-scheme" href="javascript:toggleColorScheme()" title="Toggle ar5iv color scheme"><span class="color-scheme-icon"></span></a>
<a class="ar5iv-footer-button" href="https://arxiv.org/help/license" target="_blank">Copyright</a>
<a class="ar5iv-footer-button" href="https://arxiv.org/help/policies/privacy_policy" target="_blank">Privacy Policy</a>

<div class="ltx_page_logo">Generated  on Sat Mar  9 04:05:14 2024 by <a target="_blank" href="http://dlmf.nist.gov/LaTeXML/" class="ltx_LaTeXML_logo"><span style="letter-spacing:-0.2em; margin-right:0.1em;">L<span class="ltx_font_smallcaps" style="position:relative; bottom:2.2pt;">a</span>T<span class="ltx_font_smallcaps" style="font-size:120%;position:relative; bottom:-0.2ex;">e</span></span><span style="font-size:90%; position:relative; bottom:-0.2ex;">XML</span><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAAOCAYAAAD5YeaVAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9wKExQZLWTEaOUAAAAddEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIFRoZSBHSU1Q72QlbgAAAdpJREFUKM9tkL+L2nAARz9fPZNCKFapUn8kyI0e4iRHSR1Kb8ng0lJw6FYHFwv2LwhOpcWxTjeUunYqOmqd6hEoRDhtDWdA8ApRYsSUCDHNt5ul13vz4w0vWCgUnnEc975arX6ORqN3VqtVZbfbTQC4uEHANM3jSqXymFI6yWazP2KxWAXAL9zCUa1Wy2tXVxheKA9YNoR8Pt+aTqe4FVVVvz05O6MBhqUIBGk8Hn8HAOVy+T+XLJfLS4ZhTiRJgqIoVBRFIoric47jPnmeB1mW/9rr9ZpSSn3Lsmir1fJZlqWlUonKsvwWwD8ymc/nXwVBeLjf7xEKhdBut9Hr9WgmkyGEkJwsy5eHG5vN5g0AKIoCAEgkEkin0wQAfN9/cXPdheu6P33fBwB4ngcAcByHJpPJl+fn54mD3Gg0NrquXxeLRQAAwzAYj8cwTZPwPH9/sVg8PXweDAauqqr2cDjEer1GJBLBZDJBs9mE4zjwfZ85lAGg2+06hmGgXq+j3+/DsixYlgVN03a9Xu8jgCNCyIegIAgx13Vfd7vdu+FweG8YRkjXdWy329+dTgeSJD3ieZ7RNO0VAXAPwDEAO5VKndi2fWrb9jWl9Esul6PZbDY9Go1OZ7PZ9z/lyuD3OozU2wAAAABJRU5ErkJggg==" alt="Mascot Sammy"></a>
</div></footer>
</div>

    <script>
      var canMathML = typeof(MathMLElement) == "function";
      if (!canMathML) {
        var body = document.querySelector("body");
        body.firstElementChild.setAttribute('style', 'opacity: 0;');
        var loading = document.createElement("div");
        loading.setAttribute("id", "mathjax-loading-spinner");
        var message = document.createElement("div");
        message.setAttribute("id", "mathjax-loading-message");
        message.innerText = "Typesetting Equations...";
        body.prepend(loading);
        body.prepend(message);

        var el = document.createElement("script");
        el.src = "https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js";
        document.querySelector("head").appendChild(el);

        window.MathJax = {
          startup: {
            pageReady: () => {
              return MathJax.startup.defaultPageReady().then(() => {
                body.removeChild(loading);
                body.removeChild(message);
                body.firstElementChild.removeAttribute('style');
              }); } } };
      }
    </script>
    <script>
    // Auxiliary function, building the preview feature when
    // an inline citation is clicked
    function clicked_cite(e) {
      e.preventDefault();
      let cite = this.closest('.ltx_cite');
      let next = cite.nextSibling;
      if (next && next.nodeType == Node.ELEMENT_NODE && next.getAttribute('class') == "ar5iv-bibitem-preview") {
        next.remove();
        return; }
      // Before adding a preview modal,
      // cleanup older previews, in case they're still open
      document.querySelectorAll('span.ar5iv-bibitem-preview').forEach(function(node) {
        node.remove();
      })

      // Create the preview
      preview = document.createElement('span');
      preview.setAttribute('class','ar5iv-bibitem-preview');
      let target = document.getElementById(this.getAttribute('href').slice(1));
      target.childNodes.forEach(function (child) {
        preview.append(child.cloneNode(true));
      });
      let close_x = document.createElement('button');
      close_x.setAttribute("aria-label","Close modal for bibliography item preview");
      close_x.textContent = "×";
      close_x.setAttribute('class', 'ar5iv-button-close-preview');
      close_x.setAttribute('onclick','this.parentNode.remove()');
      preview.append(close_x);
      preview.querySelectorAll('.ltx_tag_bibitem').forEach(function(node) {
        node.remove();
      });
      cite.parentNode.insertBefore(preview, cite.nextSibling);
      return;
    }
    // Global Document initialization:
    // - assign the preview feature to all inline citation links
    document.querySelectorAll(".ltx_cite .ltx_ref").forEach(function (link) {
      link.addEventListener("click", clicked_cite);
    });
    </script>
    </body>
</html>
