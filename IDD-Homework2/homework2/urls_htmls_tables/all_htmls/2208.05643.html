<!DOCTYPE html><html lang="en">
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title>[2208.05643] An Overview on Over-the-Air Federated Edge Learning</title><meta property="og:description" content="Over-the-air federated edge learning (Air-FEEL) has emerged as a promising solution to support edge artificial intelligence (AI) in future beyond 5G (B5G) and 6G networks. In Air-FEEL, distributed edge devices use thei…">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="An Overview on Over-the-Air Federated Edge Learning">
<meta name="twitter:image:src" content="https://ar5iv.labs.arxiv.org/assets/ar5iv_card.png">
<meta name="twitter:image:alt" content="ar5iv logo">
<meta property="og:title" content="An Overview on Over-the-Air Federated Edge Learning">
<meta property="og:site_name" content="ar5iv">
<meta property="og:image" content="https://ar5iv.labs.arxiv.org/assets/ar5iv_card.png">
<meta property="og:type" content="article">
<meta property="og:url" content="https://ar5iv.labs.arxiv.org/html/2208.05643">

<!--Generated on Wed Mar 13 17:40:31 2024 by LaTeXML (version 0.8.8) http://dlmf.nist.gov/LaTeXML/.-->
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

<script>
  function detectColorScheme(){
    var theme="light";
    var current_theme = localStorage.getItem("ar5iv_theme");
    if(current_theme){
      if(current_theme == "dark"){
        theme = "dark";
      } }
    else if(!window.matchMedia) { return false; }
    else if(window.matchMedia("(prefers-color-scheme: dark)").matches) {
      theme = "dark"; }
    if (theme=="dark") {
      document.documentElement.setAttribute("data-theme", "dark");
    } else {
      document.documentElement.setAttribute("data-theme", "light"); } }

  detectColorScheme();

  function toggleColorScheme(){
    var current_theme = localStorage.getItem("ar5iv_theme");
    if (current_theme) {
      if (current_theme == "light") {
        localStorage.setItem("ar5iv_theme", "dark"); }
      else {
        localStorage.setItem("ar5iv_theme", "light"); } }
    else {
        localStorage.setItem("ar5iv_theme", "dark"); }
    detectColorScheme(); }
</script>
<link media="all" rel="stylesheet" href="/assets/ar5iv-fonts.0.8.0.min.css"><link media="all" rel="stylesheet" href="/assets/ar5iv.0.8.0.min.css"><link media="all" rel="stylesheet" href="/assets/ar5iv-site.0.2.2.css">
</head>
<body>
<div class="ltx_page_main">
<div class="ltx_page_content">
<article class="ltx_document ltx_authors_1line" lang="en">
<h1 class="ltx_title ltx_title_document">An Overview on Over-the-Air Federated Edge Learning</h1>
<div class="ltx_authors">
<span class="ltx_creator ltx_role_author">
<span class="ltx_personname">Xiaowen Cao, Zhonghao Lyu, Guangxu Zhu, Jie Xu, Lexi Xu, and Shuguang Cui
</span><span class="ltx_author_notes">X. Cao, Z. Lyu, and J. Xu are with the School of Science and Engineering (SSE) and the Future Network of Intelligence Institute (FNii), The Chinese University of Hong Kong (Shenzhen), Shenzhen 518172, China. (e-mail: caoxwen@outlook.com, zhonghaolyu@link.cuhk.edu.cn, xujie@cuhk.edu.cn).G. Zhu is with Shenzhen Research Institute of Big Data, Shenzhen 518172, China (e-mail: gxzhu@sribd.cn). G. Zhu and J. Xu are corresponding authors.  L. Xu is with Research Institute, China United Network Communications Corporation, Beijing, China (email: xulx29@chinaunicom.cn).S. Cui is with the SSE and FNii, The Chinese University of Hong Kong (Shenzhen), and Shenzhen Research Institute of Big Data, Shenzhen 518172, China. He is also affiliated with Peng Cheng Laboratory, Shenzhen, China, 518066 (e-mail: shuguangcui@cuhk.edu.cn).</span></span>
</div>

<div class="ltx_abstract">
<h6 class="ltx_title ltx_title_abstract">Abstract</h6>
<p id="id1.id1" class="ltx_p"><em id="id1.id1.1" class="ltx_emph ltx_font_italic">Over-the-air federated edge learning</em><span id="id1.id1.2" class="ltx_text"> (Air-FEEL) has emerged as a promising solution to support edge <em id="id1.id1.2.1" class="ltx_emph ltx_font_italic">artificial intelligence</em> (AI) in future <em id="id1.id1.2.2" class="ltx_emph ltx_font_italic">beyond 5G</em> (B5G) and 6G networks. In Air-FEEL, distributed edge devices use their local data to collaboratively train AI models while preserving data privacy, in which the over-the-air model/gradient aggregation is exploited for enhancing the learning efficiency. This article provides an overview on the state of the art of Air-FEEL. First, we present the basic principle of Air-FEEL, and introduce the technical challenges for Air-FEEL design due to the over-the-air aggregation errors, as well as the resource and data heterogeneities at edge devices. Next, we present the fundamental performance metrics for Air-FEEL, and review resource management solutions and design considerations for enhancing the Air-FEEL performance. Finally, several interesting research directions are pointed out to motivate future work.</span></p>
</div>
<section id="S1" class="ltx_section">
<h2 class="ltx_title ltx_title_section">
<span class="ltx_tag ltx_tag_section">I </span><span id="S1.1.1" class="ltx_text ltx_font_smallcaps">Introduction</span>
</h2>

<div id="S1.p1" class="ltx_para">
<p id="S1.p1.1" class="ltx_p">Recently, edge learning or edge intelligence has been recognized as a promising technique towards <span id="S1.p1.1.1" class="ltx_text ltx_font_italic">beyond 5G</span> (B5G) and 6G to enable emerging applications such as meta-verse, smart city, automated driving, and industrial automation, in which <span id="S1.p1.1.2" class="ltx_text ltx_font_italic">artificial intelligence</span> (AI) is relocated from the central cloud to the network edge to allow prompt data access and exploitation with significantly reduced latency. Among a variety of edge learning paradigms, <span id="S1.p1.1.3" class="ltx_text ltx_font_italic">federated edge learning</span> (FEEL) is particularly appealing, due to its advantages in efficient model training and data privacy preservation by exploiting the distributed computing and storage capabilities at network edge <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib1" title="" class="ltx_ref">1</a>]</cite>. Essentially, FEEL is implemented based on the distributed <span id="S1.p1.1.4" class="ltx_text ltx_font_italic">stochastic gradient descent</span> (SGD) over wireless networks, which aims to find optimized AI-model parameters by minimizing a properly designed loss function in an iterative manner. To be specific, at each global iteration or communication round, the edge server first broadcasts the global model to edge devices for synchronizing their local models; next, the edge devices update their respective local models by performing one or more local gradient descent iterations; finally, the edge devices upload their local gradients or models to the edge server for aggregation, thus yielding an updated global model to initiate the next-round training.
Based on the distributed SGD principle, FEEL can be implemented via two typical approaches, namely the <span id="S1.p1.1.5" class="ltx_text ltx_font_italic">federated stochastic gradient descent</span> (FedSGD) and <span id="S1.p1.1.6" class="ltx_text ltx_font_italic">federated averaging</span> (FedAvg), in which edge devices upload the local gradients and models after one and multiple local iterations, respectively, at each communication round <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib2" title="" class="ltx_ref">2</a>]</cite>. However, due to the frequent exchange of high-dimensional models or gradients (usually comprising millions to billions of parameters) between the edge server and edge devices, the communication cost becomes the paramount performance bottleneck for FEEL, especially when the number of participating edge devices becomes large.</p>
</div>
<figure id="S1.F1" class="ltx_figure"><img src="/html/2208.05643/assets/x1.png" id="S1.F1.g1" class="ltx_graphics ltx_centering ltx_img_landscape" width="500" height="332" alt="Refer to caption">
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure">Figure 1: </span>Example application scenarios of Air-FEEL. </figcaption>
</figure>
<div id="S1.p2" class="ltx_para">
<p id="S1.p2.1" class="ltx_p">To tackle this issue, <span id="S1.p2.1.1" class="ltx_text ltx_font_italic">over-the-air FEEL</span> (Air-FEEL) has been proposed recently as a promising solution, in which distributed edge devices are allowed to concurrently transmit their local gradient or model updates for “one-shot” aggregation at each communication round.
In such a way, the communication and computation are seamlessly integrated to enhance the communication efficiency in FEEL, thus supporting various low-latency and communication-efficient applications, such as Internet of vehicles and intelligent community, as shown in Fig. <a href="#S1.F1" title="Figure 1 ‣ I Introduction ‣ An Overview on Over-the-Air Federated Edge Learning" class="ltx_ref"><span class="ltx_text ltx_ref_tag">1</span></a>.
The magic behind the promising Air-FEEL applications is the so-called <span id="S1.p2.1.2" class="ltx_text ltx_font_italic">over-the-air computation</span> (AirComp) technique, which utilizes the superposition property of a <span id="S1.p2.1.3" class="ltx_text ltx_font_italic">multiple-access channel</span> (MAC) for distributed functional computation over the air <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib3" title="" class="ltx_ref">3</a>]</cite>.
As such, Air-FEEL can achieve remarkable communication latency reduction up to a factor equal to the device population, as compared to the conventional FEEL based on the classic communicate-then-compute approach for gradient/model aggregation.
Moreover, Air-FEEL is able to further enhance the data privacy by combating the potential eavesdropping attack during the gradient/model uploading process. This is due to the fact that with AirComp, potential eavesdroppers can only access to the aggregated updates with each local component hidden in the crowd <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib4" title="" class="ltx_ref">4</a>]</cite>.</p>
</div>
<div id="S1.p3" class="ltx_para">
<p id="S1.p3.1" class="ltx_p">Due to the aforementioned advantages, Air-FEEL is becoming a hot research topic in the field of edge intelligence, which has attracted growing research interests from both academia and industry. However, the successful implementation of Air-FEEL to materialize its promising gain faces various technical challenges resulting from the over-the-air aggregation errors as well as the resource and data heterogeneities at distributed edge devices. Various research efforts have been conducted in the literature to tackle these issues.</p>
</div>
<div id="S1.p4" class="ltx_para">
<p id="S1.p4.1" class="ltx_p">In view of the growing research interests, this article provides an overview on the state of the art of Air-FEEL. First, we introduce the basic principle of Air-FEEL, and discuss its fundamental performance metrics in terms of training loss and learning accuracy, learning latency, and energy consumption. Next, we review various solutions to enhance the Air-FEEL performance, covering power control, beamforming, user scheduling, and large-scale network optimization. Finally, we point out several interesting research directions to motivate future work on Air-FEEL.</p>
</div>
</section>
<section id="S2" class="ltx_section">
<h2 class="ltx_title ltx_title_section">
<span class="ltx_tag ltx_tag_section">II </span><span id="S2.1.1" class="ltx_text ltx_font_smallcaps">Basic Principle of Air-FEEL</span>
</h2>

<figure id="S2.F2" class="ltx_figure"><img src="/html/2208.05643/assets/x2.png" id="S2.F2.g1" class="ltx_graphics ltx_centering ltx_img_landscape" width="430" height="342" alt="Refer to caption">
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure">Figure 2: </span>Basic architecture of Air-FEEL. </figcaption>
</figure>
<div id="S2.p1" class="ltx_para">
<p id="S2.p1.1" class="ltx_p">This section introduces the basics of Air-FEEL. A typical Air-FEEL system is shown in Fig. <a href="#S2.F2" title="Figure 2 ‣ II Basic Principle of Air-FEEL ‣ An Overview on Over-the-Air Federated Edge Learning" class="ltx_ref"><span class="ltx_text ltx_ref_tag">2</span></a>, where one edge server coordinates multiple distributed edge devices to train an AI model based on the “one-shot” over-the-air model/gradient aggregation.
As mentioned earlier in the introduction, <span id="S2.p1.1.1" class="ltx_text ltx_font_italic">over-the-air FedSGD</span> (Air-FedSGD) and <span id="S2.p1.1.2" class="ltx_text ltx_font_italic">over-the-air FedAvg</span> (Air-FedAvg) are two typical approaches for Air-FEEL implementation.
In particular, at each global communication round, Air-FedSGD employs the over-the-air <span id="S2.p1.1.3" class="ltx_text ltx_font_italic">gradient</span> aggregation after <span id="S2.p1.1.4" class="ltx_text ltx_font_italic">one</span> local computation iteration, while Air-FedAvg performs the over-the-air <span id="S2.p1.1.5" class="ltx_text ltx_font_italic">model</span> aggregation after <span id="S2.p1.1.6" class="ltx_text ltx_font_italic">multiple</span> local computation iterations.
Generally, Air-FedSGD enjoys better robustness to the non-<span id="S2.p1.1.7" class="ltx_text ltx_font_italic">independent and identically distributed</span> (i.i.d.) data, while Air-FedAvg requires much less frequent model aggregation and thus lower communication cost.</p>
</div>
<div id="S2.p2" class="ltx_para">
<p id="S2.p2.29" class="ltx_p">The main difference of Air-FEEL from other FEEL paradigms is that, Air-FEEL exploits AirComp for one-shot over-the-air model/gradient aggregation <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib3" title="" class="ltx_ref">3</a>]</cite>, as explained in the following.
For example, consider the basic setup with one edge server and <math id="S2.p2.1.m1.1" class="ltx_Math" alttext="K" display="inline"><semantics id="S2.p2.1.m1.1a"><mi id="S2.p2.1.m1.1.1" xref="S2.p2.1.m1.1.1.cmml">K</mi><annotation-xml encoding="MathML-Content" id="S2.p2.1.m1.1b"><ci id="S2.p2.1.m1.1.1.cmml" xref="S2.p2.1.m1.1.1">𝐾</ci></annotation-xml><annotation encoding="application/x-tex" id="S2.p2.1.m1.1c">K</annotation></semantics></math> edge devices in an <span id="S2.p2.29.1" class="ltx_text ltx_font_italic">additive white Gaussian noise</span> (AWGN) channel. Consider a particular global communication round, in which each device <math id="S2.p2.2.m2.1" class="ltx_Math" alttext="k" display="inline"><semantics id="S2.p2.2.m2.1a"><mi id="S2.p2.2.m2.1.1" xref="S2.p2.2.m2.1.1.cmml">k</mi><annotation-xml encoding="MathML-Content" id="S2.p2.2.m2.1b"><ci id="S2.p2.2.m2.1.1.cmml" xref="S2.p2.2.m2.1.1">𝑘</ci></annotation-xml><annotation encoding="application/x-tex" id="S2.p2.2.m2.1c">k</annotation></semantics></math> needs to upload its local gradient/model parameter <math id="S2.p2.3.m3.1" class="ltx_Math" alttext="{\bf w}_{k}\in{\mathbb{C}}^{N\times 1}" display="inline"><semantics id="S2.p2.3.m3.1a"><mrow id="S2.p2.3.m3.1.1" xref="S2.p2.3.m3.1.1.cmml"><msub id="S2.p2.3.m3.1.1.2" xref="S2.p2.3.m3.1.1.2.cmml"><mi id="S2.p2.3.m3.1.1.2.2" xref="S2.p2.3.m3.1.1.2.2.cmml">𝐰</mi><mi id="S2.p2.3.m3.1.1.2.3" xref="S2.p2.3.m3.1.1.2.3.cmml">k</mi></msub><mo id="S2.p2.3.m3.1.1.1" xref="S2.p2.3.m3.1.1.1.cmml">∈</mo><msup id="S2.p2.3.m3.1.1.3" xref="S2.p2.3.m3.1.1.3.cmml"><mi id="S2.p2.3.m3.1.1.3.2" xref="S2.p2.3.m3.1.1.3.2.cmml">ℂ</mi><mrow id="S2.p2.3.m3.1.1.3.3" xref="S2.p2.3.m3.1.1.3.3.cmml"><mi id="S2.p2.3.m3.1.1.3.3.2" xref="S2.p2.3.m3.1.1.3.3.2.cmml">N</mi><mo lspace="0.222em" rspace="0.222em" id="S2.p2.3.m3.1.1.3.3.1" xref="S2.p2.3.m3.1.1.3.3.1.cmml">×</mo><mn id="S2.p2.3.m3.1.1.3.3.3" xref="S2.p2.3.m3.1.1.3.3.3.cmml">1</mn></mrow></msup></mrow><annotation-xml encoding="MathML-Content" id="S2.p2.3.m3.1b"><apply id="S2.p2.3.m3.1.1.cmml" xref="S2.p2.3.m3.1.1"><in id="S2.p2.3.m3.1.1.1.cmml" xref="S2.p2.3.m3.1.1.1"></in><apply id="S2.p2.3.m3.1.1.2.cmml" xref="S2.p2.3.m3.1.1.2"><csymbol cd="ambiguous" id="S2.p2.3.m3.1.1.2.1.cmml" xref="S2.p2.3.m3.1.1.2">subscript</csymbol><ci id="S2.p2.3.m3.1.1.2.2.cmml" xref="S2.p2.3.m3.1.1.2.2">𝐰</ci><ci id="S2.p2.3.m3.1.1.2.3.cmml" xref="S2.p2.3.m3.1.1.2.3">𝑘</ci></apply><apply id="S2.p2.3.m3.1.1.3.cmml" xref="S2.p2.3.m3.1.1.3"><csymbol cd="ambiguous" id="S2.p2.3.m3.1.1.3.1.cmml" xref="S2.p2.3.m3.1.1.3">superscript</csymbol><ci id="S2.p2.3.m3.1.1.3.2.cmml" xref="S2.p2.3.m3.1.1.3.2">ℂ</ci><apply id="S2.p2.3.m3.1.1.3.3.cmml" xref="S2.p2.3.m3.1.1.3.3"><times id="S2.p2.3.m3.1.1.3.3.1.cmml" xref="S2.p2.3.m3.1.1.3.3.1"></times><ci id="S2.p2.3.m3.1.1.3.3.2.cmml" xref="S2.p2.3.m3.1.1.3.3.2">𝑁</ci><cn type="integer" id="S2.p2.3.m3.1.1.3.3.3.cmml" xref="S2.p2.3.m3.1.1.3.3.3">1</cn></apply></apply></apply></annotation-xml><annotation encoding="application/x-tex" id="S2.p2.3.m3.1c">{\bf w}_{k}\in{\mathbb{C}}^{N\times 1}</annotation></semantics></math> with <math id="S2.p2.4.m4.1" class="ltx_Math" alttext="N" display="inline"><semantics id="S2.p2.4.m4.1a"><mi id="S2.p2.4.m4.1.1" xref="S2.p2.4.m4.1.1.cmml">N</mi><annotation-xml encoding="MathML-Content" id="S2.p2.4.m4.1b"><ci id="S2.p2.4.m4.1.1.cmml" xref="S2.p2.4.m4.1.1">𝑁</ci></annotation-xml><annotation encoding="application/x-tex" id="S2.p2.4.m4.1c">N</annotation></semantics></math> dimensions, and the desired global parameter at the edge server is <math id="S2.p2.5.m5.1" class="ltx_Math" alttext="\frac{1}{K}\sum_{k=1}^{K}{\bf w}_{k}" display="inline"><semantics id="S2.p2.5.m5.1a"><mrow id="S2.p2.5.m5.1.1" xref="S2.p2.5.m5.1.1.cmml"><mfrac id="S2.p2.5.m5.1.1.2" xref="S2.p2.5.m5.1.1.2.cmml"><mn id="S2.p2.5.m5.1.1.2.2" xref="S2.p2.5.m5.1.1.2.2.cmml">1</mn><mi id="S2.p2.5.m5.1.1.2.3" xref="S2.p2.5.m5.1.1.2.3.cmml">K</mi></mfrac><mo lspace="0em" rspace="0em" id="S2.p2.5.m5.1.1.1" xref="S2.p2.5.m5.1.1.1.cmml">​</mo><mrow id="S2.p2.5.m5.1.1.3" xref="S2.p2.5.m5.1.1.3.cmml"><msubsup id="S2.p2.5.m5.1.1.3.1" xref="S2.p2.5.m5.1.1.3.1.cmml"><mo id="S2.p2.5.m5.1.1.3.1.2.2" xref="S2.p2.5.m5.1.1.3.1.2.2.cmml">∑</mo><mrow id="S2.p2.5.m5.1.1.3.1.2.3" xref="S2.p2.5.m5.1.1.3.1.2.3.cmml"><mi id="S2.p2.5.m5.1.1.3.1.2.3.2" xref="S2.p2.5.m5.1.1.3.1.2.3.2.cmml">k</mi><mo id="S2.p2.5.m5.1.1.3.1.2.3.1" xref="S2.p2.5.m5.1.1.3.1.2.3.1.cmml">=</mo><mn id="S2.p2.5.m5.1.1.3.1.2.3.3" xref="S2.p2.5.m5.1.1.3.1.2.3.3.cmml">1</mn></mrow><mi id="S2.p2.5.m5.1.1.3.1.3" xref="S2.p2.5.m5.1.1.3.1.3.cmml">K</mi></msubsup><msub id="S2.p2.5.m5.1.1.3.2" xref="S2.p2.5.m5.1.1.3.2.cmml"><mi id="S2.p2.5.m5.1.1.3.2.2" xref="S2.p2.5.m5.1.1.3.2.2.cmml">𝐰</mi><mi id="S2.p2.5.m5.1.1.3.2.3" xref="S2.p2.5.m5.1.1.3.2.3.cmml">k</mi></msub></mrow></mrow><annotation-xml encoding="MathML-Content" id="S2.p2.5.m5.1b"><apply id="S2.p2.5.m5.1.1.cmml" xref="S2.p2.5.m5.1.1"><times id="S2.p2.5.m5.1.1.1.cmml" xref="S2.p2.5.m5.1.1.1"></times><apply id="S2.p2.5.m5.1.1.2.cmml" xref="S2.p2.5.m5.1.1.2"><divide id="S2.p2.5.m5.1.1.2.1.cmml" xref="S2.p2.5.m5.1.1.2"></divide><cn type="integer" id="S2.p2.5.m5.1.1.2.2.cmml" xref="S2.p2.5.m5.1.1.2.2">1</cn><ci id="S2.p2.5.m5.1.1.2.3.cmml" xref="S2.p2.5.m5.1.1.2.3">𝐾</ci></apply><apply id="S2.p2.5.m5.1.1.3.cmml" xref="S2.p2.5.m5.1.1.3"><apply id="S2.p2.5.m5.1.1.3.1.cmml" xref="S2.p2.5.m5.1.1.3.1"><csymbol cd="ambiguous" id="S2.p2.5.m5.1.1.3.1.1.cmml" xref="S2.p2.5.m5.1.1.3.1">superscript</csymbol><apply id="S2.p2.5.m5.1.1.3.1.2.cmml" xref="S2.p2.5.m5.1.1.3.1"><csymbol cd="ambiguous" id="S2.p2.5.m5.1.1.3.1.2.1.cmml" xref="S2.p2.5.m5.1.1.3.1">subscript</csymbol><sum id="S2.p2.5.m5.1.1.3.1.2.2.cmml" xref="S2.p2.5.m5.1.1.3.1.2.2"></sum><apply id="S2.p2.5.m5.1.1.3.1.2.3.cmml" xref="S2.p2.5.m5.1.1.3.1.2.3"><eq id="S2.p2.5.m5.1.1.3.1.2.3.1.cmml" xref="S2.p2.5.m5.1.1.3.1.2.3.1"></eq><ci id="S2.p2.5.m5.1.1.3.1.2.3.2.cmml" xref="S2.p2.5.m5.1.1.3.1.2.3.2">𝑘</ci><cn type="integer" id="S2.p2.5.m5.1.1.3.1.2.3.3.cmml" xref="S2.p2.5.m5.1.1.3.1.2.3.3">1</cn></apply></apply><ci id="S2.p2.5.m5.1.1.3.1.3.cmml" xref="S2.p2.5.m5.1.1.3.1.3">𝐾</ci></apply><apply id="S2.p2.5.m5.1.1.3.2.cmml" xref="S2.p2.5.m5.1.1.3.2"><csymbol cd="ambiguous" id="S2.p2.5.m5.1.1.3.2.1.cmml" xref="S2.p2.5.m5.1.1.3.2">subscript</csymbol><ci id="S2.p2.5.m5.1.1.3.2.2.cmml" xref="S2.p2.5.m5.1.1.3.2.2">𝐰</ci><ci id="S2.p2.5.m5.1.1.3.2.3.cmml" xref="S2.p2.5.m5.1.1.3.2.3">𝑘</ci></apply></apply></apply></annotation-xml><annotation encoding="application/x-tex" id="S2.p2.5.m5.1c">\frac{1}{K}\sum_{k=1}^{K}{\bf w}_{k}</annotation></semantics></math>.
In this case, after acquiring the information of its own channel coefficient <math id="S2.p2.6.m6.1" class="ltx_Math" alttext="h_{k}" display="inline"><semantics id="S2.p2.6.m6.1a"><msub id="S2.p2.6.m6.1.1" xref="S2.p2.6.m6.1.1.cmml"><mi id="S2.p2.6.m6.1.1.2" xref="S2.p2.6.m6.1.1.2.cmml">h</mi><mi id="S2.p2.6.m6.1.1.3" xref="S2.p2.6.m6.1.1.3.cmml">k</mi></msub><annotation-xml encoding="MathML-Content" id="S2.p2.6.m6.1b"><apply id="S2.p2.6.m6.1.1.cmml" xref="S2.p2.6.m6.1.1"><csymbol cd="ambiguous" id="S2.p2.6.m6.1.1.1.cmml" xref="S2.p2.6.m6.1.1">subscript</csymbol><ci id="S2.p2.6.m6.1.1.2.cmml" xref="S2.p2.6.m6.1.1.2">ℎ</ci><ci id="S2.p2.6.m6.1.1.3.cmml" xref="S2.p2.6.m6.1.1.3">𝑘</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="S2.p2.6.m6.1c">h_{k}</annotation></semantics></math>, each device <math id="S2.p2.7.m7.1" class="ltx_Math" alttext="k" display="inline"><semantics id="S2.p2.7.m7.1a"><mi id="S2.p2.7.m7.1.1" xref="S2.p2.7.m7.1.1.cmml">k</mi><annotation-xml encoding="MathML-Content" id="S2.p2.7.m7.1b"><ci id="S2.p2.7.m7.1.1.cmml" xref="S2.p2.7.m7.1.1">𝑘</ci></annotation-xml><annotation encoding="application/x-tex" id="S2.p2.7.m7.1c">k</annotation></semantics></math> multiplies <math id="S2.p2.8.m8.1" class="ltx_Math" alttext="{\bf w}_{k}" display="inline"><semantics id="S2.p2.8.m8.1a"><msub id="S2.p2.8.m8.1.1" xref="S2.p2.8.m8.1.1.cmml"><mi id="S2.p2.8.m8.1.1.2" xref="S2.p2.8.m8.1.1.2.cmml">𝐰</mi><mi id="S2.p2.8.m8.1.1.3" xref="S2.p2.8.m8.1.1.3.cmml">k</mi></msub><annotation-xml encoding="MathML-Content" id="S2.p2.8.m8.1b"><apply id="S2.p2.8.m8.1.1.cmml" xref="S2.p2.8.m8.1.1"><csymbol cd="ambiguous" id="S2.p2.8.m8.1.1.1.cmml" xref="S2.p2.8.m8.1.1">subscript</csymbol><ci id="S2.p2.8.m8.1.1.2.cmml" xref="S2.p2.8.m8.1.1.2">𝐰</ci><ci id="S2.p2.8.m8.1.1.3.cmml" xref="S2.p2.8.m8.1.1.3">𝑘</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="S2.p2.8.m8.1c">{\bf w}_{k}</annotation></semantics></math> by the pre-processing coefficient <math id="S2.p2.9.m9.1" class="ltx_Math" alttext="\alpha_{k}\frac{h_{k}^{c}}{|h_{k}|}" display="inline"><semantics id="S2.p2.9.m9.1a"><mrow id="S2.p2.9.m9.1.2" xref="S2.p2.9.m9.1.2.cmml"><msub id="S2.p2.9.m9.1.2.2" xref="S2.p2.9.m9.1.2.2.cmml"><mi id="S2.p2.9.m9.1.2.2.2" xref="S2.p2.9.m9.1.2.2.2.cmml">α</mi><mi id="S2.p2.9.m9.1.2.2.3" xref="S2.p2.9.m9.1.2.2.3.cmml">k</mi></msub><mo lspace="0em" rspace="0em" id="S2.p2.9.m9.1.2.1" xref="S2.p2.9.m9.1.2.1.cmml">​</mo><mfrac id="S2.p2.9.m9.1.1" xref="S2.p2.9.m9.1.1.cmml"><msubsup id="S2.p2.9.m9.1.1.3" xref="S2.p2.9.m9.1.1.3.cmml"><mi id="S2.p2.9.m9.1.1.3.2.2" xref="S2.p2.9.m9.1.1.3.2.2.cmml">h</mi><mi id="S2.p2.9.m9.1.1.3.2.3" xref="S2.p2.9.m9.1.1.3.2.3.cmml">k</mi><mi id="S2.p2.9.m9.1.1.3.3" xref="S2.p2.9.m9.1.1.3.3.cmml">c</mi></msubsup><mrow id="S2.p2.9.m9.1.1.1.1" xref="S2.p2.9.m9.1.1.1.2.cmml"><mo stretchy="false" id="S2.p2.9.m9.1.1.1.1.2" xref="S2.p2.9.m9.1.1.1.2.1.cmml">|</mo><msub id="S2.p2.9.m9.1.1.1.1.1" xref="S2.p2.9.m9.1.1.1.1.1.cmml"><mi id="S2.p2.9.m9.1.1.1.1.1.2" xref="S2.p2.9.m9.1.1.1.1.1.2.cmml">h</mi><mi id="S2.p2.9.m9.1.1.1.1.1.3" xref="S2.p2.9.m9.1.1.1.1.1.3.cmml">k</mi></msub><mo stretchy="false" id="S2.p2.9.m9.1.1.1.1.3" xref="S2.p2.9.m9.1.1.1.2.1.cmml">|</mo></mrow></mfrac></mrow><annotation-xml encoding="MathML-Content" id="S2.p2.9.m9.1b"><apply id="S2.p2.9.m9.1.2.cmml" xref="S2.p2.9.m9.1.2"><times id="S2.p2.9.m9.1.2.1.cmml" xref="S2.p2.9.m9.1.2.1"></times><apply id="S2.p2.9.m9.1.2.2.cmml" xref="S2.p2.9.m9.1.2.2"><csymbol cd="ambiguous" id="S2.p2.9.m9.1.2.2.1.cmml" xref="S2.p2.9.m9.1.2.2">subscript</csymbol><ci id="S2.p2.9.m9.1.2.2.2.cmml" xref="S2.p2.9.m9.1.2.2.2">𝛼</ci><ci id="S2.p2.9.m9.1.2.2.3.cmml" xref="S2.p2.9.m9.1.2.2.3">𝑘</ci></apply><apply id="S2.p2.9.m9.1.1.cmml" xref="S2.p2.9.m9.1.1"><divide id="S2.p2.9.m9.1.1.2.cmml" xref="S2.p2.9.m9.1.1"></divide><apply id="S2.p2.9.m9.1.1.3.cmml" xref="S2.p2.9.m9.1.1.3"><csymbol cd="ambiguous" id="S2.p2.9.m9.1.1.3.1.cmml" xref="S2.p2.9.m9.1.1.3">superscript</csymbol><apply id="S2.p2.9.m9.1.1.3.2.cmml" xref="S2.p2.9.m9.1.1.3"><csymbol cd="ambiguous" id="S2.p2.9.m9.1.1.3.2.1.cmml" xref="S2.p2.9.m9.1.1.3">subscript</csymbol><ci id="S2.p2.9.m9.1.1.3.2.2.cmml" xref="S2.p2.9.m9.1.1.3.2.2">ℎ</ci><ci id="S2.p2.9.m9.1.1.3.2.3.cmml" xref="S2.p2.9.m9.1.1.3.2.3">𝑘</ci></apply><ci id="S2.p2.9.m9.1.1.3.3.cmml" xref="S2.p2.9.m9.1.1.3.3">𝑐</ci></apply><apply id="S2.p2.9.m9.1.1.1.2.cmml" xref="S2.p2.9.m9.1.1.1.1"><abs id="S2.p2.9.m9.1.1.1.2.1.cmml" xref="S2.p2.9.m9.1.1.1.1.2"></abs><apply id="S2.p2.9.m9.1.1.1.1.1.cmml" xref="S2.p2.9.m9.1.1.1.1.1"><csymbol cd="ambiguous" id="S2.p2.9.m9.1.1.1.1.1.1.cmml" xref="S2.p2.9.m9.1.1.1.1.1">subscript</csymbol><ci id="S2.p2.9.m9.1.1.1.1.1.2.cmml" xref="S2.p2.9.m9.1.1.1.1.1.2">ℎ</ci><ci id="S2.p2.9.m9.1.1.1.1.1.3.cmml" xref="S2.p2.9.m9.1.1.1.1.1.3">𝑘</ci></apply></apply></apply></apply></annotation-xml><annotation encoding="application/x-tex" id="S2.p2.9.m9.1c">\alpha_{k}\frac{h_{k}^{c}}{|h_{k}|}</annotation></semantics></math> to amplify the signal and compensate the channel phase, and then transmits <math id="S2.p2.10.m10.1" class="ltx_Math" alttext="\alpha_{k}\frac{h_{k}^{c}}{|h_{k}|}{\bf w}_{k}" display="inline"><semantics id="S2.p2.10.m10.1a"><mrow id="S2.p2.10.m10.1.2" xref="S2.p2.10.m10.1.2.cmml"><msub id="S2.p2.10.m10.1.2.2" xref="S2.p2.10.m10.1.2.2.cmml"><mi id="S2.p2.10.m10.1.2.2.2" xref="S2.p2.10.m10.1.2.2.2.cmml">α</mi><mi id="S2.p2.10.m10.1.2.2.3" xref="S2.p2.10.m10.1.2.2.3.cmml">k</mi></msub><mo lspace="0em" rspace="0em" id="S2.p2.10.m10.1.2.1" xref="S2.p2.10.m10.1.2.1.cmml">​</mo><mfrac id="S2.p2.10.m10.1.1" xref="S2.p2.10.m10.1.1.cmml"><msubsup id="S2.p2.10.m10.1.1.3" xref="S2.p2.10.m10.1.1.3.cmml"><mi id="S2.p2.10.m10.1.1.3.2.2" xref="S2.p2.10.m10.1.1.3.2.2.cmml">h</mi><mi id="S2.p2.10.m10.1.1.3.2.3" xref="S2.p2.10.m10.1.1.3.2.3.cmml">k</mi><mi id="S2.p2.10.m10.1.1.3.3" xref="S2.p2.10.m10.1.1.3.3.cmml">c</mi></msubsup><mrow id="S2.p2.10.m10.1.1.1.1" xref="S2.p2.10.m10.1.1.1.2.cmml"><mo stretchy="false" id="S2.p2.10.m10.1.1.1.1.2" xref="S2.p2.10.m10.1.1.1.2.1.cmml">|</mo><msub id="S2.p2.10.m10.1.1.1.1.1" xref="S2.p2.10.m10.1.1.1.1.1.cmml"><mi id="S2.p2.10.m10.1.1.1.1.1.2" xref="S2.p2.10.m10.1.1.1.1.1.2.cmml">h</mi><mi id="S2.p2.10.m10.1.1.1.1.1.3" xref="S2.p2.10.m10.1.1.1.1.1.3.cmml">k</mi></msub><mo stretchy="false" id="S2.p2.10.m10.1.1.1.1.3" xref="S2.p2.10.m10.1.1.1.2.1.cmml">|</mo></mrow></mfrac><mo lspace="0em" rspace="0em" id="S2.p2.10.m10.1.2.1a" xref="S2.p2.10.m10.1.2.1.cmml">​</mo><msub id="S2.p2.10.m10.1.2.3" xref="S2.p2.10.m10.1.2.3.cmml"><mi id="S2.p2.10.m10.1.2.3.2" xref="S2.p2.10.m10.1.2.3.2.cmml">𝐰</mi><mi id="S2.p2.10.m10.1.2.3.3" xref="S2.p2.10.m10.1.2.3.3.cmml">k</mi></msub></mrow><annotation-xml encoding="MathML-Content" id="S2.p2.10.m10.1b"><apply id="S2.p2.10.m10.1.2.cmml" xref="S2.p2.10.m10.1.2"><times id="S2.p2.10.m10.1.2.1.cmml" xref="S2.p2.10.m10.1.2.1"></times><apply id="S2.p2.10.m10.1.2.2.cmml" xref="S2.p2.10.m10.1.2.2"><csymbol cd="ambiguous" id="S2.p2.10.m10.1.2.2.1.cmml" xref="S2.p2.10.m10.1.2.2">subscript</csymbol><ci id="S2.p2.10.m10.1.2.2.2.cmml" xref="S2.p2.10.m10.1.2.2.2">𝛼</ci><ci id="S2.p2.10.m10.1.2.2.3.cmml" xref="S2.p2.10.m10.1.2.2.3">𝑘</ci></apply><apply id="S2.p2.10.m10.1.1.cmml" xref="S2.p2.10.m10.1.1"><divide id="S2.p2.10.m10.1.1.2.cmml" xref="S2.p2.10.m10.1.1"></divide><apply id="S2.p2.10.m10.1.1.3.cmml" xref="S2.p2.10.m10.1.1.3"><csymbol cd="ambiguous" id="S2.p2.10.m10.1.1.3.1.cmml" xref="S2.p2.10.m10.1.1.3">superscript</csymbol><apply id="S2.p2.10.m10.1.1.3.2.cmml" xref="S2.p2.10.m10.1.1.3"><csymbol cd="ambiguous" id="S2.p2.10.m10.1.1.3.2.1.cmml" xref="S2.p2.10.m10.1.1.3">subscript</csymbol><ci id="S2.p2.10.m10.1.1.3.2.2.cmml" xref="S2.p2.10.m10.1.1.3.2.2">ℎ</ci><ci id="S2.p2.10.m10.1.1.3.2.3.cmml" xref="S2.p2.10.m10.1.1.3.2.3">𝑘</ci></apply><ci id="S2.p2.10.m10.1.1.3.3.cmml" xref="S2.p2.10.m10.1.1.3.3">𝑐</ci></apply><apply id="S2.p2.10.m10.1.1.1.2.cmml" xref="S2.p2.10.m10.1.1.1.1"><abs id="S2.p2.10.m10.1.1.1.2.1.cmml" xref="S2.p2.10.m10.1.1.1.1.2"></abs><apply id="S2.p2.10.m10.1.1.1.1.1.cmml" xref="S2.p2.10.m10.1.1.1.1.1"><csymbol cd="ambiguous" id="S2.p2.10.m10.1.1.1.1.1.1.cmml" xref="S2.p2.10.m10.1.1.1.1.1">subscript</csymbol><ci id="S2.p2.10.m10.1.1.1.1.1.2.cmml" xref="S2.p2.10.m10.1.1.1.1.1.2">ℎ</ci><ci id="S2.p2.10.m10.1.1.1.1.1.3.cmml" xref="S2.p2.10.m10.1.1.1.1.1.3">𝑘</ci></apply></apply></apply><apply id="S2.p2.10.m10.1.2.3.cmml" xref="S2.p2.10.m10.1.2.3"><csymbol cd="ambiguous" id="S2.p2.10.m10.1.2.3.1.cmml" xref="S2.p2.10.m10.1.2.3">subscript</csymbol><ci id="S2.p2.10.m10.1.2.3.2.cmml" xref="S2.p2.10.m10.1.2.3.2">𝐰</ci><ci id="S2.p2.10.m10.1.2.3.3.cmml" xref="S2.p2.10.m10.1.2.3.3">𝑘</ci></apply></apply></annotation-xml><annotation encoding="application/x-tex" id="S2.p2.10.m10.1c">\alpha_{k}\frac{h_{k}^{c}}{|h_{k}|}{\bf w}_{k}</annotation></semantics></math> over <math id="S2.p2.11.m11.1" class="ltx_Math" alttext="N" display="inline"><semantics id="S2.p2.11.m11.1a"><mi id="S2.p2.11.m11.1.1" xref="S2.p2.11.m11.1.1.cmml">N</mi><annotation-xml encoding="MathML-Content" id="S2.p2.11.m11.1b"><ci id="S2.p2.11.m11.1.1.cmml" xref="S2.p2.11.m11.1.1">𝑁</ci></annotation-xml><annotation encoding="application/x-tex" id="S2.p2.11.m11.1c">N</annotation></semantics></math> channel uses, where superscript <math id="S2.p2.12.m12.1" class="ltx_Math" alttext="c" display="inline"><semantics id="S2.p2.12.m12.1a"><mi id="S2.p2.12.m12.1.1" xref="S2.p2.12.m12.1.1.cmml">c</mi><annotation-xml encoding="MathML-Content" id="S2.p2.12.m12.1b"><ci id="S2.p2.12.m12.1.1.cmml" xref="S2.p2.12.m12.1.1">𝑐</ci></annotation-xml><annotation encoding="application/x-tex" id="S2.p2.12.m12.1c">c</annotation></semantics></math> denotes the conjugate, <math id="S2.p2.13.m13.1" class="ltx_math_unparsed" alttext="|\cdot|" display="inline"><semantics id="S2.p2.13.m13.1a"><mrow id="S2.p2.13.m13.1b"><mo fence="false" stretchy="false" id="S2.p2.13.m13.1.1">|</mo><mo lspace="0em" rspace="0em" id="S2.p2.13.m13.1.2">⋅</mo><mo fence="false" stretchy="false" id="S2.p2.13.m13.1.3">|</mo></mrow><annotation encoding="application/x-tex" id="S2.p2.13.m13.1c">|\cdot|</annotation></semantics></math> denotes the absolute value of a complex number, and <math id="S2.p2.14.m14.1" class="ltx_Math" alttext="\alpha_{k}" display="inline"><semantics id="S2.p2.14.m14.1a"><msub id="S2.p2.14.m14.1.1" xref="S2.p2.14.m14.1.1.cmml"><mi id="S2.p2.14.m14.1.1.2" xref="S2.p2.14.m14.1.1.2.cmml">α</mi><mi id="S2.p2.14.m14.1.1.3" xref="S2.p2.14.m14.1.1.3.cmml">k</mi></msub><annotation-xml encoding="MathML-Content" id="S2.p2.14.m14.1b"><apply id="S2.p2.14.m14.1.1.cmml" xref="S2.p2.14.m14.1.1"><csymbol cd="ambiguous" id="S2.p2.14.m14.1.1.1.cmml" xref="S2.p2.14.m14.1.1">subscript</csymbol><ci id="S2.p2.14.m14.1.1.2.cmml" xref="S2.p2.14.m14.1.1.2">𝛼</ci><ci id="S2.p2.14.m14.1.1.3.cmml" xref="S2.p2.14.m14.1.1.3">𝑘</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="S2.p2.14.m14.1c">\alpha_{k}</annotation></semantics></math> denotes the transmit amplitude depending on the transmit power. Accordingly, the received signal at the edge server becomes <math id="S2.p2.15.m15.1" class="ltx_Math" alttext="{\bf y}=\sum_{k=1}^{K}\alpha_{k}|h_{k}|{\bf w}_{k}+{\bf z}" display="inline"><semantics id="S2.p2.15.m15.1a"><mrow id="S2.p2.15.m15.1.1" xref="S2.p2.15.m15.1.1.cmml"><mi id="S2.p2.15.m15.1.1.3" xref="S2.p2.15.m15.1.1.3.cmml">𝐲</mi><mo rspace="0.111em" id="S2.p2.15.m15.1.1.2" xref="S2.p2.15.m15.1.1.2.cmml">=</mo><mrow id="S2.p2.15.m15.1.1.1" xref="S2.p2.15.m15.1.1.1.cmml"><mrow id="S2.p2.15.m15.1.1.1.1" xref="S2.p2.15.m15.1.1.1.1.cmml"><msubsup id="S2.p2.15.m15.1.1.1.1.2" xref="S2.p2.15.m15.1.1.1.1.2.cmml"><mo id="S2.p2.15.m15.1.1.1.1.2.2.2" xref="S2.p2.15.m15.1.1.1.1.2.2.2.cmml">∑</mo><mrow id="S2.p2.15.m15.1.1.1.1.2.2.3" xref="S2.p2.15.m15.1.1.1.1.2.2.3.cmml"><mi id="S2.p2.15.m15.1.1.1.1.2.2.3.2" xref="S2.p2.15.m15.1.1.1.1.2.2.3.2.cmml">k</mi><mo id="S2.p2.15.m15.1.1.1.1.2.2.3.1" xref="S2.p2.15.m15.1.1.1.1.2.2.3.1.cmml">=</mo><mn id="S2.p2.15.m15.1.1.1.1.2.2.3.3" xref="S2.p2.15.m15.1.1.1.1.2.2.3.3.cmml">1</mn></mrow><mi id="S2.p2.15.m15.1.1.1.1.2.3" xref="S2.p2.15.m15.1.1.1.1.2.3.cmml">K</mi></msubsup><mrow id="S2.p2.15.m15.1.1.1.1.1" xref="S2.p2.15.m15.1.1.1.1.1.cmml"><msub id="S2.p2.15.m15.1.1.1.1.1.3" xref="S2.p2.15.m15.1.1.1.1.1.3.cmml"><mi id="S2.p2.15.m15.1.1.1.1.1.3.2" xref="S2.p2.15.m15.1.1.1.1.1.3.2.cmml">α</mi><mi id="S2.p2.15.m15.1.1.1.1.1.3.3" xref="S2.p2.15.m15.1.1.1.1.1.3.3.cmml">k</mi></msub><mo lspace="0em" rspace="0em" id="S2.p2.15.m15.1.1.1.1.1.2" xref="S2.p2.15.m15.1.1.1.1.1.2.cmml">​</mo><mrow id="S2.p2.15.m15.1.1.1.1.1.1.1" xref="S2.p2.15.m15.1.1.1.1.1.1.2.cmml"><mo stretchy="false" id="S2.p2.15.m15.1.1.1.1.1.1.1.2" xref="S2.p2.15.m15.1.1.1.1.1.1.2.1.cmml">|</mo><msub id="S2.p2.15.m15.1.1.1.1.1.1.1.1" xref="S2.p2.15.m15.1.1.1.1.1.1.1.1.cmml"><mi id="S2.p2.15.m15.1.1.1.1.1.1.1.1.2" xref="S2.p2.15.m15.1.1.1.1.1.1.1.1.2.cmml">h</mi><mi id="S2.p2.15.m15.1.1.1.1.1.1.1.1.3" xref="S2.p2.15.m15.1.1.1.1.1.1.1.1.3.cmml">k</mi></msub><mo stretchy="false" id="S2.p2.15.m15.1.1.1.1.1.1.1.3" xref="S2.p2.15.m15.1.1.1.1.1.1.2.1.cmml">|</mo></mrow><mo lspace="0em" rspace="0em" id="S2.p2.15.m15.1.1.1.1.1.2a" xref="S2.p2.15.m15.1.1.1.1.1.2.cmml">​</mo><msub id="S2.p2.15.m15.1.1.1.1.1.4" xref="S2.p2.15.m15.1.1.1.1.1.4.cmml"><mi id="S2.p2.15.m15.1.1.1.1.1.4.2" xref="S2.p2.15.m15.1.1.1.1.1.4.2.cmml">𝐰</mi><mi id="S2.p2.15.m15.1.1.1.1.1.4.3" xref="S2.p2.15.m15.1.1.1.1.1.4.3.cmml">k</mi></msub></mrow></mrow><mo id="S2.p2.15.m15.1.1.1.2" xref="S2.p2.15.m15.1.1.1.2.cmml">+</mo><mi id="S2.p2.15.m15.1.1.1.3" xref="S2.p2.15.m15.1.1.1.3.cmml">𝐳</mi></mrow></mrow><annotation-xml encoding="MathML-Content" id="S2.p2.15.m15.1b"><apply id="S2.p2.15.m15.1.1.cmml" xref="S2.p2.15.m15.1.1"><eq id="S2.p2.15.m15.1.1.2.cmml" xref="S2.p2.15.m15.1.1.2"></eq><ci id="S2.p2.15.m15.1.1.3.cmml" xref="S2.p2.15.m15.1.1.3">𝐲</ci><apply id="S2.p2.15.m15.1.1.1.cmml" xref="S2.p2.15.m15.1.1.1"><plus id="S2.p2.15.m15.1.1.1.2.cmml" xref="S2.p2.15.m15.1.1.1.2"></plus><apply id="S2.p2.15.m15.1.1.1.1.cmml" xref="S2.p2.15.m15.1.1.1.1"><apply id="S2.p2.15.m15.1.1.1.1.2.cmml" xref="S2.p2.15.m15.1.1.1.1.2"><csymbol cd="ambiguous" id="S2.p2.15.m15.1.1.1.1.2.1.cmml" xref="S2.p2.15.m15.1.1.1.1.2">superscript</csymbol><apply id="S2.p2.15.m15.1.1.1.1.2.2.cmml" xref="S2.p2.15.m15.1.1.1.1.2"><csymbol cd="ambiguous" id="S2.p2.15.m15.1.1.1.1.2.2.1.cmml" xref="S2.p2.15.m15.1.1.1.1.2">subscript</csymbol><sum id="S2.p2.15.m15.1.1.1.1.2.2.2.cmml" xref="S2.p2.15.m15.1.1.1.1.2.2.2"></sum><apply id="S2.p2.15.m15.1.1.1.1.2.2.3.cmml" xref="S2.p2.15.m15.1.1.1.1.2.2.3"><eq id="S2.p2.15.m15.1.1.1.1.2.2.3.1.cmml" xref="S2.p2.15.m15.1.1.1.1.2.2.3.1"></eq><ci id="S2.p2.15.m15.1.1.1.1.2.2.3.2.cmml" xref="S2.p2.15.m15.1.1.1.1.2.2.3.2">𝑘</ci><cn type="integer" id="S2.p2.15.m15.1.1.1.1.2.2.3.3.cmml" xref="S2.p2.15.m15.1.1.1.1.2.2.3.3">1</cn></apply></apply><ci id="S2.p2.15.m15.1.1.1.1.2.3.cmml" xref="S2.p2.15.m15.1.1.1.1.2.3">𝐾</ci></apply><apply id="S2.p2.15.m15.1.1.1.1.1.cmml" xref="S2.p2.15.m15.1.1.1.1.1"><times id="S2.p2.15.m15.1.1.1.1.1.2.cmml" xref="S2.p2.15.m15.1.1.1.1.1.2"></times><apply id="S2.p2.15.m15.1.1.1.1.1.3.cmml" xref="S2.p2.15.m15.1.1.1.1.1.3"><csymbol cd="ambiguous" id="S2.p2.15.m15.1.1.1.1.1.3.1.cmml" xref="S2.p2.15.m15.1.1.1.1.1.3">subscript</csymbol><ci id="S2.p2.15.m15.1.1.1.1.1.3.2.cmml" xref="S2.p2.15.m15.1.1.1.1.1.3.2">𝛼</ci><ci id="S2.p2.15.m15.1.1.1.1.1.3.3.cmml" xref="S2.p2.15.m15.1.1.1.1.1.3.3">𝑘</ci></apply><apply id="S2.p2.15.m15.1.1.1.1.1.1.2.cmml" xref="S2.p2.15.m15.1.1.1.1.1.1.1"><abs id="S2.p2.15.m15.1.1.1.1.1.1.2.1.cmml" xref="S2.p2.15.m15.1.1.1.1.1.1.1.2"></abs><apply id="S2.p2.15.m15.1.1.1.1.1.1.1.1.cmml" xref="S2.p2.15.m15.1.1.1.1.1.1.1.1"><csymbol cd="ambiguous" id="S2.p2.15.m15.1.1.1.1.1.1.1.1.1.cmml" xref="S2.p2.15.m15.1.1.1.1.1.1.1.1">subscript</csymbol><ci id="S2.p2.15.m15.1.1.1.1.1.1.1.1.2.cmml" xref="S2.p2.15.m15.1.1.1.1.1.1.1.1.2">ℎ</ci><ci id="S2.p2.15.m15.1.1.1.1.1.1.1.1.3.cmml" xref="S2.p2.15.m15.1.1.1.1.1.1.1.1.3">𝑘</ci></apply></apply><apply id="S2.p2.15.m15.1.1.1.1.1.4.cmml" xref="S2.p2.15.m15.1.1.1.1.1.4"><csymbol cd="ambiguous" id="S2.p2.15.m15.1.1.1.1.1.4.1.cmml" xref="S2.p2.15.m15.1.1.1.1.1.4">subscript</csymbol><ci id="S2.p2.15.m15.1.1.1.1.1.4.2.cmml" xref="S2.p2.15.m15.1.1.1.1.1.4.2">𝐰</ci><ci id="S2.p2.15.m15.1.1.1.1.1.4.3.cmml" xref="S2.p2.15.m15.1.1.1.1.1.4.3">𝑘</ci></apply></apply></apply><ci id="S2.p2.15.m15.1.1.1.3.cmml" xref="S2.p2.15.m15.1.1.1.3">𝐳</ci></apply></apply></annotation-xml><annotation encoding="application/x-tex" id="S2.p2.15.m15.1c">{\bf y}=\sum_{k=1}^{K}\alpha_{k}|h_{k}|{\bf w}_{k}+{\bf z}</annotation></semantics></math> with a noise vector <math id="S2.p2.16.m16.1" class="ltx_Math" alttext="{\bf z}" display="inline"><semantics id="S2.p2.16.m16.1a"><mi id="S2.p2.16.m16.1.1" xref="S2.p2.16.m16.1.1.cmml">𝐳</mi><annotation-xml encoding="MathML-Content" id="S2.p2.16.m16.1b"><ci id="S2.p2.16.m16.1.1.cmml" xref="S2.p2.16.m16.1.1">𝐳</ci></annotation-xml><annotation encoding="application/x-tex" id="S2.p2.16.m16.1c">{\bf z}</annotation></semantics></math> over <math id="S2.p2.17.m17.1" class="ltx_Math" alttext="N" display="inline"><semantics id="S2.p2.17.m17.1a"><mi id="S2.p2.17.m17.1.1" xref="S2.p2.17.m17.1.1.cmml">N</mi><annotation-xml encoding="MathML-Content" id="S2.p2.17.m17.1b"><ci id="S2.p2.17.m17.1.1.cmml" xref="S2.p2.17.m17.1.1">𝑁</ci></annotation-xml><annotation encoding="application/x-tex" id="S2.p2.17.m17.1c">N</annotation></semantics></math> channel uses at edge server receiver. Then, after post-processing by multiplying denoising factor <math id="S2.p2.18.m18.1" class="ltx_Math" alttext="1/\eta" display="inline"><semantics id="S2.p2.18.m18.1a"><mrow id="S2.p2.18.m18.1.1" xref="S2.p2.18.m18.1.1.cmml"><mn id="S2.p2.18.m18.1.1.2" xref="S2.p2.18.m18.1.1.2.cmml">1</mn><mo id="S2.p2.18.m18.1.1.1" xref="S2.p2.18.m18.1.1.1.cmml">/</mo><mi id="S2.p2.18.m18.1.1.3" xref="S2.p2.18.m18.1.1.3.cmml">η</mi></mrow><annotation-xml encoding="MathML-Content" id="S2.p2.18.m18.1b"><apply id="S2.p2.18.m18.1.1.cmml" xref="S2.p2.18.m18.1.1"><divide id="S2.p2.18.m18.1.1.1.cmml" xref="S2.p2.18.m18.1.1.1"></divide><cn type="integer" id="S2.p2.18.m18.1.1.2.cmml" xref="S2.p2.18.m18.1.1.2">1</cn><ci id="S2.p2.18.m18.1.1.3.cmml" xref="S2.p2.18.m18.1.1.3">𝜂</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="S2.p2.18.m18.1c">1/\eta</annotation></semantics></math> and averaging operation<span id="footnote1" class="ltx_note ltx_role_footnote"><sup class="ltx_note_mark">1</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">1</sup><span class="ltx_tag ltx_tag_note">1</span>With proper pre- and post-processing, AirComp can go beyond averaging to compute a series of nomographic functions such as geometric mean, weighted sum, polynomial, and Euclidean norm <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib3" title="" class="ltx_ref">3</a>]</cite>.</span></span></span>, we have the AirComped parameters as <math id="S2.p2.19.m19.1" class="ltx_Math" alttext="{\bf r}=\frac{1}{\eta K}{\bf y}=\sum_{k=1}^{K}\frac{\alpha_{k}|h_{k}|{\bf w}_{k}}{\eta K}+\frac{{\bf z}}{\eta K}" display="inline"><semantics id="S2.p2.19.m19.1a"><mrow id="S2.p2.19.m19.1.2" xref="S2.p2.19.m19.1.2.cmml"><mi id="S2.p2.19.m19.1.2.2" xref="S2.p2.19.m19.1.2.2.cmml">𝐫</mi><mo id="S2.p2.19.m19.1.2.3" xref="S2.p2.19.m19.1.2.3.cmml">=</mo><mrow id="S2.p2.19.m19.1.2.4" xref="S2.p2.19.m19.1.2.4.cmml"><mfrac id="S2.p2.19.m19.1.2.4.2" xref="S2.p2.19.m19.1.2.4.2.cmml"><mn id="S2.p2.19.m19.1.2.4.2.2" xref="S2.p2.19.m19.1.2.4.2.2.cmml">1</mn><mrow id="S2.p2.19.m19.1.2.4.2.3" xref="S2.p2.19.m19.1.2.4.2.3.cmml"><mi id="S2.p2.19.m19.1.2.4.2.3.2" xref="S2.p2.19.m19.1.2.4.2.3.2.cmml">η</mi><mo lspace="0em" rspace="0em" id="S2.p2.19.m19.1.2.4.2.3.1" xref="S2.p2.19.m19.1.2.4.2.3.1.cmml">​</mo><mi id="S2.p2.19.m19.1.2.4.2.3.3" xref="S2.p2.19.m19.1.2.4.2.3.3.cmml">K</mi></mrow></mfrac><mo lspace="0em" rspace="0em" id="S2.p2.19.m19.1.2.4.1" xref="S2.p2.19.m19.1.2.4.1.cmml">​</mo><mi id="S2.p2.19.m19.1.2.4.3" xref="S2.p2.19.m19.1.2.4.3.cmml">𝐲</mi></mrow><mo rspace="0.111em" id="S2.p2.19.m19.1.2.5" xref="S2.p2.19.m19.1.2.5.cmml">=</mo><mrow id="S2.p2.19.m19.1.2.6" xref="S2.p2.19.m19.1.2.6.cmml"><mrow id="S2.p2.19.m19.1.2.6.2" xref="S2.p2.19.m19.1.2.6.2.cmml"><msubsup id="S2.p2.19.m19.1.2.6.2.1" xref="S2.p2.19.m19.1.2.6.2.1.cmml"><mo id="S2.p2.19.m19.1.2.6.2.1.2.2" xref="S2.p2.19.m19.1.2.6.2.1.2.2.cmml">∑</mo><mrow id="S2.p2.19.m19.1.2.6.2.1.2.3" xref="S2.p2.19.m19.1.2.6.2.1.2.3.cmml"><mi id="S2.p2.19.m19.1.2.6.2.1.2.3.2" xref="S2.p2.19.m19.1.2.6.2.1.2.3.2.cmml">k</mi><mo id="S2.p2.19.m19.1.2.6.2.1.2.3.1" xref="S2.p2.19.m19.1.2.6.2.1.2.3.1.cmml">=</mo><mn id="S2.p2.19.m19.1.2.6.2.1.2.3.3" xref="S2.p2.19.m19.1.2.6.2.1.2.3.3.cmml">1</mn></mrow><mi id="S2.p2.19.m19.1.2.6.2.1.3" xref="S2.p2.19.m19.1.2.6.2.1.3.cmml">K</mi></msubsup><mfrac id="S2.p2.19.m19.1.1" xref="S2.p2.19.m19.1.1.cmml"><mrow id="S2.p2.19.m19.1.1.1" xref="S2.p2.19.m19.1.1.1.cmml"><msub id="S2.p2.19.m19.1.1.1.3" xref="S2.p2.19.m19.1.1.1.3.cmml"><mi id="S2.p2.19.m19.1.1.1.3.2" xref="S2.p2.19.m19.1.1.1.3.2.cmml">α</mi><mi id="S2.p2.19.m19.1.1.1.3.3" xref="S2.p2.19.m19.1.1.1.3.3.cmml">k</mi></msub><mo lspace="0em" rspace="0em" id="S2.p2.19.m19.1.1.1.2" xref="S2.p2.19.m19.1.1.1.2.cmml">​</mo><mrow id="S2.p2.19.m19.1.1.1.1.1" xref="S2.p2.19.m19.1.1.1.1.2.cmml"><mo stretchy="false" id="S2.p2.19.m19.1.1.1.1.1.2" xref="S2.p2.19.m19.1.1.1.1.2.1.cmml">|</mo><msub id="S2.p2.19.m19.1.1.1.1.1.1" xref="S2.p2.19.m19.1.1.1.1.1.1.cmml"><mi id="S2.p2.19.m19.1.1.1.1.1.1.2" xref="S2.p2.19.m19.1.1.1.1.1.1.2.cmml">h</mi><mi id="S2.p2.19.m19.1.1.1.1.1.1.3" xref="S2.p2.19.m19.1.1.1.1.1.1.3.cmml">k</mi></msub><mo stretchy="false" id="S2.p2.19.m19.1.1.1.1.1.3" xref="S2.p2.19.m19.1.1.1.1.2.1.cmml">|</mo></mrow><mo lspace="0em" rspace="0em" id="S2.p2.19.m19.1.1.1.2a" xref="S2.p2.19.m19.1.1.1.2.cmml">​</mo><msub id="S2.p2.19.m19.1.1.1.4" xref="S2.p2.19.m19.1.1.1.4.cmml"><mi id="S2.p2.19.m19.1.1.1.4.2" xref="S2.p2.19.m19.1.1.1.4.2.cmml">𝐰</mi><mi id="S2.p2.19.m19.1.1.1.4.3" xref="S2.p2.19.m19.1.1.1.4.3.cmml">k</mi></msub></mrow><mrow id="S2.p2.19.m19.1.1.3" xref="S2.p2.19.m19.1.1.3.cmml"><mi id="S2.p2.19.m19.1.1.3.2" xref="S2.p2.19.m19.1.1.3.2.cmml">η</mi><mo lspace="0em" rspace="0em" id="S2.p2.19.m19.1.1.3.1" xref="S2.p2.19.m19.1.1.3.1.cmml">​</mo><mi id="S2.p2.19.m19.1.1.3.3" xref="S2.p2.19.m19.1.1.3.3.cmml">K</mi></mrow></mfrac></mrow><mo id="S2.p2.19.m19.1.2.6.1" xref="S2.p2.19.m19.1.2.6.1.cmml">+</mo><mfrac id="S2.p2.19.m19.1.2.6.3" xref="S2.p2.19.m19.1.2.6.3.cmml"><mi id="S2.p2.19.m19.1.2.6.3.2" xref="S2.p2.19.m19.1.2.6.3.2.cmml">𝐳</mi><mrow id="S2.p2.19.m19.1.2.6.3.3" xref="S2.p2.19.m19.1.2.6.3.3.cmml"><mi id="S2.p2.19.m19.1.2.6.3.3.2" xref="S2.p2.19.m19.1.2.6.3.3.2.cmml">η</mi><mo lspace="0em" rspace="0em" id="S2.p2.19.m19.1.2.6.3.3.1" xref="S2.p2.19.m19.1.2.6.3.3.1.cmml">​</mo><mi id="S2.p2.19.m19.1.2.6.3.3.3" xref="S2.p2.19.m19.1.2.6.3.3.3.cmml">K</mi></mrow></mfrac></mrow></mrow><annotation-xml encoding="MathML-Content" id="S2.p2.19.m19.1b"><apply id="S2.p2.19.m19.1.2.cmml" xref="S2.p2.19.m19.1.2"><and id="S2.p2.19.m19.1.2a.cmml" xref="S2.p2.19.m19.1.2"></and><apply id="S2.p2.19.m19.1.2b.cmml" xref="S2.p2.19.m19.1.2"><eq id="S2.p2.19.m19.1.2.3.cmml" xref="S2.p2.19.m19.1.2.3"></eq><ci id="S2.p2.19.m19.1.2.2.cmml" xref="S2.p2.19.m19.1.2.2">𝐫</ci><apply id="S2.p2.19.m19.1.2.4.cmml" xref="S2.p2.19.m19.1.2.4"><times id="S2.p2.19.m19.1.2.4.1.cmml" xref="S2.p2.19.m19.1.2.4.1"></times><apply id="S2.p2.19.m19.1.2.4.2.cmml" xref="S2.p2.19.m19.1.2.4.2"><divide id="S2.p2.19.m19.1.2.4.2.1.cmml" xref="S2.p2.19.m19.1.2.4.2"></divide><cn type="integer" id="S2.p2.19.m19.1.2.4.2.2.cmml" xref="S2.p2.19.m19.1.2.4.2.2">1</cn><apply id="S2.p2.19.m19.1.2.4.2.3.cmml" xref="S2.p2.19.m19.1.2.4.2.3"><times id="S2.p2.19.m19.1.2.4.2.3.1.cmml" xref="S2.p2.19.m19.1.2.4.2.3.1"></times><ci id="S2.p2.19.m19.1.2.4.2.3.2.cmml" xref="S2.p2.19.m19.1.2.4.2.3.2">𝜂</ci><ci id="S2.p2.19.m19.1.2.4.2.3.3.cmml" xref="S2.p2.19.m19.1.2.4.2.3.3">𝐾</ci></apply></apply><ci id="S2.p2.19.m19.1.2.4.3.cmml" xref="S2.p2.19.m19.1.2.4.3">𝐲</ci></apply></apply><apply id="S2.p2.19.m19.1.2c.cmml" xref="S2.p2.19.m19.1.2"><eq id="S2.p2.19.m19.1.2.5.cmml" xref="S2.p2.19.m19.1.2.5"></eq><share href="#S2.p2.19.m19.1.2.4.cmml" id="S2.p2.19.m19.1.2d.cmml" xref="S2.p2.19.m19.1.2"></share><apply id="S2.p2.19.m19.1.2.6.cmml" xref="S2.p2.19.m19.1.2.6"><plus id="S2.p2.19.m19.1.2.6.1.cmml" xref="S2.p2.19.m19.1.2.6.1"></plus><apply id="S2.p2.19.m19.1.2.6.2.cmml" xref="S2.p2.19.m19.1.2.6.2"><apply id="S2.p2.19.m19.1.2.6.2.1.cmml" xref="S2.p2.19.m19.1.2.6.2.1"><csymbol cd="ambiguous" id="S2.p2.19.m19.1.2.6.2.1.1.cmml" xref="S2.p2.19.m19.1.2.6.2.1">superscript</csymbol><apply id="S2.p2.19.m19.1.2.6.2.1.2.cmml" xref="S2.p2.19.m19.1.2.6.2.1"><csymbol cd="ambiguous" id="S2.p2.19.m19.1.2.6.2.1.2.1.cmml" xref="S2.p2.19.m19.1.2.6.2.1">subscript</csymbol><sum id="S2.p2.19.m19.1.2.6.2.1.2.2.cmml" xref="S2.p2.19.m19.1.2.6.2.1.2.2"></sum><apply id="S2.p2.19.m19.1.2.6.2.1.2.3.cmml" xref="S2.p2.19.m19.1.2.6.2.1.2.3"><eq id="S2.p2.19.m19.1.2.6.2.1.2.3.1.cmml" xref="S2.p2.19.m19.1.2.6.2.1.2.3.1"></eq><ci id="S2.p2.19.m19.1.2.6.2.1.2.3.2.cmml" xref="S2.p2.19.m19.1.2.6.2.1.2.3.2">𝑘</ci><cn type="integer" id="S2.p2.19.m19.1.2.6.2.1.2.3.3.cmml" xref="S2.p2.19.m19.1.2.6.2.1.2.3.3">1</cn></apply></apply><ci id="S2.p2.19.m19.1.2.6.2.1.3.cmml" xref="S2.p2.19.m19.1.2.6.2.1.3">𝐾</ci></apply><apply id="S2.p2.19.m19.1.1.cmml" xref="S2.p2.19.m19.1.1"><divide id="S2.p2.19.m19.1.1.2.cmml" xref="S2.p2.19.m19.1.1"></divide><apply id="S2.p2.19.m19.1.1.1.cmml" xref="S2.p2.19.m19.1.1.1"><times id="S2.p2.19.m19.1.1.1.2.cmml" xref="S2.p2.19.m19.1.1.1.2"></times><apply id="S2.p2.19.m19.1.1.1.3.cmml" xref="S2.p2.19.m19.1.1.1.3"><csymbol cd="ambiguous" id="S2.p2.19.m19.1.1.1.3.1.cmml" xref="S2.p2.19.m19.1.1.1.3">subscript</csymbol><ci id="S2.p2.19.m19.1.1.1.3.2.cmml" xref="S2.p2.19.m19.1.1.1.3.2">𝛼</ci><ci id="S2.p2.19.m19.1.1.1.3.3.cmml" xref="S2.p2.19.m19.1.1.1.3.3">𝑘</ci></apply><apply id="S2.p2.19.m19.1.1.1.1.2.cmml" xref="S2.p2.19.m19.1.1.1.1.1"><abs id="S2.p2.19.m19.1.1.1.1.2.1.cmml" xref="S2.p2.19.m19.1.1.1.1.1.2"></abs><apply id="S2.p2.19.m19.1.1.1.1.1.1.cmml" xref="S2.p2.19.m19.1.1.1.1.1.1"><csymbol cd="ambiguous" id="S2.p2.19.m19.1.1.1.1.1.1.1.cmml" xref="S2.p2.19.m19.1.1.1.1.1.1">subscript</csymbol><ci id="S2.p2.19.m19.1.1.1.1.1.1.2.cmml" xref="S2.p2.19.m19.1.1.1.1.1.1.2">ℎ</ci><ci id="S2.p2.19.m19.1.1.1.1.1.1.3.cmml" xref="S2.p2.19.m19.1.1.1.1.1.1.3">𝑘</ci></apply></apply><apply id="S2.p2.19.m19.1.1.1.4.cmml" xref="S2.p2.19.m19.1.1.1.4"><csymbol cd="ambiguous" id="S2.p2.19.m19.1.1.1.4.1.cmml" xref="S2.p2.19.m19.1.1.1.4">subscript</csymbol><ci id="S2.p2.19.m19.1.1.1.4.2.cmml" xref="S2.p2.19.m19.1.1.1.4.2">𝐰</ci><ci id="S2.p2.19.m19.1.1.1.4.3.cmml" xref="S2.p2.19.m19.1.1.1.4.3">𝑘</ci></apply></apply><apply id="S2.p2.19.m19.1.1.3.cmml" xref="S2.p2.19.m19.1.1.3"><times id="S2.p2.19.m19.1.1.3.1.cmml" xref="S2.p2.19.m19.1.1.3.1"></times><ci id="S2.p2.19.m19.1.1.3.2.cmml" xref="S2.p2.19.m19.1.1.3.2">𝜂</ci><ci id="S2.p2.19.m19.1.1.3.3.cmml" xref="S2.p2.19.m19.1.1.3.3">𝐾</ci></apply></apply></apply><apply id="S2.p2.19.m19.1.2.6.3.cmml" xref="S2.p2.19.m19.1.2.6.3"><divide id="S2.p2.19.m19.1.2.6.3.1.cmml" xref="S2.p2.19.m19.1.2.6.3"></divide><ci id="S2.p2.19.m19.1.2.6.3.2.cmml" xref="S2.p2.19.m19.1.2.6.3.2">𝐳</ci><apply id="S2.p2.19.m19.1.2.6.3.3.cmml" xref="S2.p2.19.m19.1.2.6.3.3"><times id="S2.p2.19.m19.1.2.6.3.3.1.cmml" xref="S2.p2.19.m19.1.2.6.3.3.1"></times><ci id="S2.p2.19.m19.1.2.6.3.3.2.cmml" xref="S2.p2.19.m19.1.2.6.3.3.2">𝜂</ci><ci id="S2.p2.19.m19.1.2.6.3.3.3.cmml" xref="S2.p2.19.m19.1.2.6.3.3.3">𝐾</ci></apply></apply></apply></apply></apply></annotation-xml><annotation encoding="application/x-tex" id="S2.p2.19.m19.1c">{\bf r}=\frac{1}{\eta K}{\bf y}=\sum_{k=1}^{K}\frac{\alpha_{k}|h_{k}|{\bf w}_{k}}{\eta K}+\frac{{\bf z}}{\eta K}</annotation></semantics></math>.
Especially, the <span id="S2.p2.29.2" class="ltx_text ltx_font_italic">aggregation error</span> caused by AirComp with respect to the desired average parameter <math id="S2.p2.20.m20.1" class="ltx_Math" alttext="\frac{1}{K}\sum_{k=1}^{K}{\bf w}_{k}" display="inline"><semantics id="S2.p2.20.m20.1a"><mrow id="S2.p2.20.m20.1.1" xref="S2.p2.20.m20.1.1.cmml"><mfrac id="S2.p2.20.m20.1.1.2" xref="S2.p2.20.m20.1.1.2.cmml"><mn id="S2.p2.20.m20.1.1.2.2" xref="S2.p2.20.m20.1.1.2.2.cmml">1</mn><mi id="S2.p2.20.m20.1.1.2.3" xref="S2.p2.20.m20.1.1.2.3.cmml">K</mi></mfrac><mo lspace="0em" rspace="0em" id="S2.p2.20.m20.1.1.1" xref="S2.p2.20.m20.1.1.1.cmml">​</mo><mrow id="S2.p2.20.m20.1.1.3" xref="S2.p2.20.m20.1.1.3.cmml"><msubsup id="S2.p2.20.m20.1.1.3.1" xref="S2.p2.20.m20.1.1.3.1.cmml"><mo id="S2.p2.20.m20.1.1.3.1.2.2" xref="S2.p2.20.m20.1.1.3.1.2.2.cmml">∑</mo><mrow id="S2.p2.20.m20.1.1.3.1.2.3" xref="S2.p2.20.m20.1.1.3.1.2.3.cmml"><mi id="S2.p2.20.m20.1.1.3.1.2.3.2" xref="S2.p2.20.m20.1.1.3.1.2.3.2.cmml">k</mi><mo id="S2.p2.20.m20.1.1.3.1.2.3.1" xref="S2.p2.20.m20.1.1.3.1.2.3.1.cmml">=</mo><mn id="S2.p2.20.m20.1.1.3.1.2.3.3" xref="S2.p2.20.m20.1.1.3.1.2.3.3.cmml">1</mn></mrow><mi id="S2.p2.20.m20.1.1.3.1.3" xref="S2.p2.20.m20.1.1.3.1.3.cmml">K</mi></msubsup><msub id="S2.p2.20.m20.1.1.3.2" xref="S2.p2.20.m20.1.1.3.2.cmml"><mi id="S2.p2.20.m20.1.1.3.2.2" xref="S2.p2.20.m20.1.1.3.2.2.cmml">𝐰</mi><mi id="S2.p2.20.m20.1.1.3.2.3" xref="S2.p2.20.m20.1.1.3.2.3.cmml">k</mi></msub></mrow></mrow><annotation-xml encoding="MathML-Content" id="S2.p2.20.m20.1b"><apply id="S2.p2.20.m20.1.1.cmml" xref="S2.p2.20.m20.1.1"><times id="S2.p2.20.m20.1.1.1.cmml" xref="S2.p2.20.m20.1.1.1"></times><apply id="S2.p2.20.m20.1.1.2.cmml" xref="S2.p2.20.m20.1.1.2"><divide id="S2.p2.20.m20.1.1.2.1.cmml" xref="S2.p2.20.m20.1.1.2"></divide><cn type="integer" id="S2.p2.20.m20.1.1.2.2.cmml" xref="S2.p2.20.m20.1.1.2.2">1</cn><ci id="S2.p2.20.m20.1.1.2.3.cmml" xref="S2.p2.20.m20.1.1.2.3">𝐾</ci></apply><apply id="S2.p2.20.m20.1.1.3.cmml" xref="S2.p2.20.m20.1.1.3"><apply id="S2.p2.20.m20.1.1.3.1.cmml" xref="S2.p2.20.m20.1.1.3.1"><csymbol cd="ambiguous" id="S2.p2.20.m20.1.1.3.1.1.cmml" xref="S2.p2.20.m20.1.1.3.1">superscript</csymbol><apply id="S2.p2.20.m20.1.1.3.1.2.cmml" xref="S2.p2.20.m20.1.1.3.1"><csymbol cd="ambiguous" id="S2.p2.20.m20.1.1.3.1.2.1.cmml" xref="S2.p2.20.m20.1.1.3.1">subscript</csymbol><sum id="S2.p2.20.m20.1.1.3.1.2.2.cmml" xref="S2.p2.20.m20.1.1.3.1.2.2"></sum><apply id="S2.p2.20.m20.1.1.3.1.2.3.cmml" xref="S2.p2.20.m20.1.1.3.1.2.3"><eq id="S2.p2.20.m20.1.1.3.1.2.3.1.cmml" xref="S2.p2.20.m20.1.1.3.1.2.3.1"></eq><ci id="S2.p2.20.m20.1.1.3.1.2.3.2.cmml" xref="S2.p2.20.m20.1.1.3.1.2.3.2">𝑘</ci><cn type="integer" id="S2.p2.20.m20.1.1.3.1.2.3.3.cmml" xref="S2.p2.20.m20.1.1.3.1.2.3.3">1</cn></apply></apply><ci id="S2.p2.20.m20.1.1.3.1.3.cmml" xref="S2.p2.20.m20.1.1.3.1.3">𝐾</ci></apply><apply id="S2.p2.20.m20.1.1.3.2.cmml" xref="S2.p2.20.m20.1.1.3.2"><csymbol cd="ambiguous" id="S2.p2.20.m20.1.1.3.2.1.cmml" xref="S2.p2.20.m20.1.1.3.2">subscript</csymbol><ci id="S2.p2.20.m20.1.1.3.2.2.cmml" xref="S2.p2.20.m20.1.1.3.2.2">𝐰</ci><ci id="S2.p2.20.m20.1.1.3.2.3.cmml" xref="S2.p2.20.m20.1.1.3.2.3">𝑘</ci></apply></apply></apply></annotation-xml><annotation encoding="application/x-tex" id="S2.p2.20.m20.1c">\frac{1}{K}\sum_{k=1}^{K}{\bf w}_{k}</annotation></semantics></math> is <math id="S2.p2.21.m21.1" class="ltx_Math" alttext="{\bm{\varepsilon}}={\bf r}-\frac{1}{K}\sum_{k=1}^{K}{\bf w}_{k}" display="inline"><semantics id="S2.p2.21.m21.1a"><mrow id="S2.p2.21.m21.1.1" xref="S2.p2.21.m21.1.1.cmml"><mi id="S2.p2.21.m21.1.1.2" xref="S2.p2.21.m21.1.1.2.cmml">𝜺</mi><mo id="S2.p2.21.m21.1.1.1" xref="S2.p2.21.m21.1.1.1.cmml">=</mo><mrow id="S2.p2.21.m21.1.1.3" xref="S2.p2.21.m21.1.1.3.cmml"><mi id="S2.p2.21.m21.1.1.3.2" xref="S2.p2.21.m21.1.1.3.2.cmml">𝐫</mi><mo id="S2.p2.21.m21.1.1.3.1" xref="S2.p2.21.m21.1.1.3.1.cmml">−</mo><mrow id="S2.p2.21.m21.1.1.3.3" xref="S2.p2.21.m21.1.1.3.3.cmml"><mfrac id="S2.p2.21.m21.1.1.3.3.2" xref="S2.p2.21.m21.1.1.3.3.2.cmml"><mn id="S2.p2.21.m21.1.1.3.3.2.2" xref="S2.p2.21.m21.1.1.3.3.2.2.cmml">1</mn><mi id="S2.p2.21.m21.1.1.3.3.2.3" xref="S2.p2.21.m21.1.1.3.3.2.3.cmml">K</mi></mfrac><mo lspace="0em" rspace="0em" id="S2.p2.21.m21.1.1.3.3.1" xref="S2.p2.21.m21.1.1.3.3.1.cmml">​</mo><mrow id="S2.p2.21.m21.1.1.3.3.3" xref="S2.p2.21.m21.1.1.3.3.3.cmml"><msubsup id="S2.p2.21.m21.1.1.3.3.3.1" xref="S2.p2.21.m21.1.1.3.3.3.1.cmml"><mo id="S2.p2.21.m21.1.1.3.3.3.1.2.2" xref="S2.p2.21.m21.1.1.3.3.3.1.2.2.cmml">∑</mo><mrow id="S2.p2.21.m21.1.1.3.3.3.1.2.3" xref="S2.p2.21.m21.1.1.3.3.3.1.2.3.cmml"><mi id="S2.p2.21.m21.1.1.3.3.3.1.2.3.2" xref="S2.p2.21.m21.1.1.3.3.3.1.2.3.2.cmml">k</mi><mo id="S2.p2.21.m21.1.1.3.3.3.1.2.3.1" xref="S2.p2.21.m21.1.1.3.3.3.1.2.3.1.cmml">=</mo><mn id="S2.p2.21.m21.1.1.3.3.3.1.2.3.3" xref="S2.p2.21.m21.1.1.3.3.3.1.2.3.3.cmml">1</mn></mrow><mi id="S2.p2.21.m21.1.1.3.3.3.1.3" xref="S2.p2.21.m21.1.1.3.3.3.1.3.cmml">K</mi></msubsup><msub id="S2.p2.21.m21.1.1.3.3.3.2" xref="S2.p2.21.m21.1.1.3.3.3.2.cmml"><mi id="S2.p2.21.m21.1.1.3.3.3.2.2" xref="S2.p2.21.m21.1.1.3.3.3.2.2.cmml">𝐰</mi><mi id="S2.p2.21.m21.1.1.3.3.3.2.3" xref="S2.p2.21.m21.1.1.3.3.3.2.3.cmml">k</mi></msub></mrow></mrow></mrow></mrow><annotation-xml encoding="MathML-Content" id="S2.p2.21.m21.1b"><apply id="S2.p2.21.m21.1.1.cmml" xref="S2.p2.21.m21.1.1"><eq id="S2.p2.21.m21.1.1.1.cmml" xref="S2.p2.21.m21.1.1.1"></eq><ci id="S2.p2.21.m21.1.1.2.cmml" xref="S2.p2.21.m21.1.1.2">𝜺</ci><apply id="S2.p2.21.m21.1.1.3.cmml" xref="S2.p2.21.m21.1.1.3"><minus id="S2.p2.21.m21.1.1.3.1.cmml" xref="S2.p2.21.m21.1.1.3.1"></minus><ci id="S2.p2.21.m21.1.1.3.2.cmml" xref="S2.p2.21.m21.1.1.3.2">𝐫</ci><apply id="S2.p2.21.m21.1.1.3.3.cmml" xref="S2.p2.21.m21.1.1.3.3"><times id="S2.p2.21.m21.1.1.3.3.1.cmml" xref="S2.p2.21.m21.1.1.3.3.1"></times><apply id="S2.p2.21.m21.1.1.3.3.2.cmml" xref="S2.p2.21.m21.1.1.3.3.2"><divide id="S2.p2.21.m21.1.1.3.3.2.1.cmml" xref="S2.p2.21.m21.1.1.3.3.2"></divide><cn type="integer" id="S2.p2.21.m21.1.1.3.3.2.2.cmml" xref="S2.p2.21.m21.1.1.3.3.2.2">1</cn><ci id="S2.p2.21.m21.1.1.3.3.2.3.cmml" xref="S2.p2.21.m21.1.1.3.3.2.3">𝐾</ci></apply><apply id="S2.p2.21.m21.1.1.3.3.3.cmml" xref="S2.p2.21.m21.1.1.3.3.3"><apply id="S2.p2.21.m21.1.1.3.3.3.1.cmml" xref="S2.p2.21.m21.1.1.3.3.3.1"><csymbol cd="ambiguous" id="S2.p2.21.m21.1.1.3.3.3.1.1.cmml" xref="S2.p2.21.m21.1.1.3.3.3.1">superscript</csymbol><apply id="S2.p2.21.m21.1.1.3.3.3.1.2.cmml" xref="S2.p2.21.m21.1.1.3.3.3.1"><csymbol cd="ambiguous" id="S2.p2.21.m21.1.1.3.3.3.1.2.1.cmml" xref="S2.p2.21.m21.1.1.3.3.3.1">subscript</csymbol><sum id="S2.p2.21.m21.1.1.3.3.3.1.2.2.cmml" xref="S2.p2.21.m21.1.1.3.3.3.1.2.2"></sum><apply id="S2.p2.21.m21.1.1.3.3.3.1.2.3.cmml" xref="S2.p2.21.m21.1.1.3.3.3.1.2.3"><eq id="S2.p2.21.m21.1.1.3.3.3.1.2.3.1.cmml" xref="S2.p2.21.m21.1.1.3.3.3.1.2.3.1"></eq><ci id="S2.p2.21.m21.1.1.3.3.3.1.2.3.2.cmml" xref="S2.p2.21.m21.1.1.3.3.3.1.2.3.2">𝑘</ci><cn type="integer" id="S2.p2.21.m21.1.1.3.3.3.1.2.3.3.cmml" xref="S2.p2.21.m21.1.1.3.3.3.1.2.3.3">1</cn></apply></apply><ci id="S2.p2.21.m21.1.1.3.3.3.1.3.cmml" xref="S2.p2.21.m21.1.1.3.3.3.1.3">𝐾</ci></apply><apply id="S2.p2.21.m21.1.1.3.3.3.2.cmml" xref="S2.p2.21.m21.1.1.3.3.3.2"><csymbol cd="ambiguous" id="S2.p2.21.m21.1.1.3.3.3.2.1.cmml" xref="S2.p2.21.m21.1.1.3.3.3.2">subscript</csymbol><ci id="S2.p2.21.m21.1.1.3.3.3.2.2.cmml" xref="S2.p2.21.m21.1.1.3.3.3.2.2">𝐰</ci><ci id="S2.p2.21.m21.1.1.3.3.3.2.3.cmml" xref="S2.p2.21.m21.1.1.3.3.3.2.3">𝑘</ci></apply></apply></apply></apply></apply></annotation-xml><annotation encoding="application/x-tex" id="S2.p2.21.m21.1c">{\bm{\varepsilon}}={\bf r}-\frac{1}{K}\sum_{k=1}^{K}{\bf w}_{k}</annotation></semantics></math>.
For instance, when <math id="S2.p2.22.m22.1" class="ltx_Math" alttext="h_{k}=h" display="inline"><semantics id="S2.p2.22.m22.1a"><mrow id="S2.p2.22.m22.1.1" xref="S2.p2.22.m22.1.1.cmml"><msub id="S2.p2.22.m22.1.1.2" xref="S2.p2.22.m22.1.1.2.cmml"><mi id="S2.p2.22.m22.1.1.2.2" xref="S2.p2.22.m22.1.1.2.2.cmml">h</mi><mi id="S2.p2.22.m22.1.1.2.3" xref="S2.p2.22.m22.1.1.2.3.cmml">k</mi></msub><mo id="S2.p2.22.m22.1.1.1" xref="S2.p2.22.m22.1.1.1.cmml">=</mo><mi id="S2.p2.22.m22.1.1.3" xref="S2.p2.22.m22.1.1.3.cmml">h</mi></mrow><annotation-xml encoding="MathML-Content" id="S2.p2.22.m22.1b"><apply id="S2.p2.22.m22.1.1.cmml" xref="S2.p2.22.m22.1.1"><eq id="S2.p2.22.m22.1.1.1.cmml" xref="S2.p2.22.m22.1.1.1"></eq><apply id="S2.p2.22.m22.1.1.2.cmml" xref="S2.p2.22.m22.1.1.2"><csymbol cd="ambiguous" id="S2.p2.22.m22.1.1.2.1.cmml" xref="S2.p2.22.m22.1.1.2">subscript</csymbol><ci id="S2.p2.22.m22.1.1.2.2.cmml" xref="S2.p2.22.m22.1.1.2.2">ℎ</ci><ci id="S2.p2.22.m22.1.1.2.3.cmml" xref="S2.p2.22.m22.1.1.2.3">𝑘</ci></apply><ci id="S2.p2.22.m22.1.1.3.cmml" xref="S2.p2.22.m22.1.1.3">ℎ</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="S2.p2.22.m22.1c">h_{k}=h</annotation></semantics></math> and <math id="S2.p2.23.m23.1" class="ltx_Math" alttext="\alpha_{k}=\sqrt{P}" display="inline"><semantics id="S2.p2.23.m23.1a"><mrow id="S2.p2.23.m23.1.1" xref="S2.p2.23.m23.1.1.cmml"><msub id="S2.p2.23.m23.1.1.2" xref="S2.p2.23.m23.1.1.2.cmml"><mi id="S2.p2.23.m23.1.1.2.2" xref="S2.p2.23.m23.1.1.2.2.cmml">α</mi><mi id="S2.p2.23.m23.1.1.2.3" xref="S2.p2.23.m23.1.1.2.3.cmml">k</mi></msub><mo id="S2.p2.23.m23.1.1.1" xref="S2.p2.23.m23.1.1.1.cmml">=</mo><msqrt id="S2.p2.23.m23.1.1.3" xref="S2.p2.23.m23.1.1.3.cmml"><mi id="S2.p2.23.m23.1.1.3.2" xref="S2.p2.23.m23.1.1.3.2.cmml">P</mi></msqrt></mrow><annotation-xml encoding="MathML-Content" id="S2.p2.23.m23.1b"><apply id="S2.p2.23.m23.1.1.cmml" xref="S2.p2.23.m23.1.1"><eq id="S2.p2.23.m23.1.1.1.cmml" xref="S2.p2.23.m23.1.1.1"></eq><apply id="S2.p2.23.m23.1.1.2.cmml" xref="S2.p2.23.m23.1.1.2"><csymbol cd="ambiguous" id="S2.p2.23.m23.1.1.2.1.cmml" xref="S2.p2.23.m23.1.1.2">subscript</csymbol><ci id="S2.p2.23.m23.1.1.2.2.cmml" xref="S2.p2.23.m23.1.1.2.2">𝛼</ci><ci id="S2.p2.23.m23.1.1.2.3.cmml" xref="S2.p2.23.m23.1.1.2.3">𝑘</ci></apply><apply id="S2.p2.23.m23.1.1.3.cmml" xref="S2.p2.23.m23.1.1.3"><root id="S2.p2.23.m23.1.1.3a.cmml" xref="S2.p2.23.m23.1.1.3"></root><ci id="S2.p2.23.m23.1.1.3.2.cmml" xref="S2.p2.23.m23.1.1.3.2">𝑃</ci></apply></apply></annotation-xml><annotation encoding="application/x-tex" id="S2.p2.23.m23.1c">\alpha_{k}=\sqrt{P}</annotation></semantics></math>, we can set <math id="S2.p2.24.m24.1" class="ltx_Math" alttext="\eta=h\sqrt{P}" display="inline"><semantics id="S2.p2.24.m24.1a"><mrow id="S2.p2.24.m24.1.1" xref="S2.p2.24.m24.1.1.cmml"><mi id="S2.p2.24.m24.1.1.2" xref="S2.p2.24.m24.1.1.2.cmml">η</mi><mo id="S2.p2.24.m24.1.1.1" xref="S2.p2.24.m24.1.1.1.cmml">=</mo><mrow id="S2.p2.24.m24.1.1.3" xref="S2.p2.24.m24.1.1.3.cmml"><mi id="S2.p2.24.m24.1.1.3.2" xref="S2.p2.24.m24.1.1.3.2.cmml">h</mi><mo lspace="0em" rspace="0em" id="S2.p2.24.m24.1.1.3.1" xref="S2.p2.24.m24.1.1.3.1.cmml">​</mo><msqrt id="S2.p2.24.m24.1.1.3.3" xref="S2.p2.24.m24.1.1.3.3.cmml"><mi id="S2.p2.24.m24.1.1.3.3.2" xref="S2.p2.24.m24.1.1.3.3.2.cmml">P</mi></msqrt></mrow></mrow><annotation-xml encoding="MathML-Content" id="S2.p2.24.m24.1b"><apply id="S2.p2.24.m24.1.1.cmml" xref="S2.p2.24.m24.1.1"><eq id="S2.p2.24.m24.1.1.1.cmml" xref="S2.p2.24.m24.1.1.1"></eq><ci id="S2.p2.24.m24.1.1.2.cmml" xref="S2.p2.24.m24.1.1.2">𝜂</ci><apply id="S2.p2.24.m24.1.1.3.cmml" xref="S2.p2.24.m24.1.1.3"><times id="S2.p2.24.m24.1.1.3.1.cmml" xref="S2.p2.24.m24.1.1.3.1"></times><ci id="S2.p2.24.m24.1.1.3.2.cmml" xref="S2.p2.24.m24.1.1.3.2">ℎ</ci><apply id="S2.p2.24.m24.1.1.3.3.cmml" xref="S2.p2.24.m24.1.1.3.3"><root id="S2.p2.24.m24.1.1.3.3a.cmml" xref="S2.p2.24.m24.1.1.3.3"></root><ci id="S2.p2.24.m24.1.1.3.3.2.cmml" xref="S2.p2.24.m24.1.1.3.3.2">𝑃</ci></apply></apply></apply></annotation-xml><annotation encoding="application/x-tex" id="S2.p2.24.m24.1c">\eta=h\sqrt{P}</annotation></semantics></math> to get <math id="S2.p2.25.m25.1" class="ltx_Math" alttext="{\bf r}=\frac{1}{K}\sum_{k=1}^{K}{\bf w}_{k}+\frac{{\bf z}}{Kh\sqrt{P}}" display="inline"><semantics id="S2.p2.25.m25.1a"><mrow id="S2.p2.25.m25.1.1" xref="S2.p2.25.m25.1.1.cmml"><mi id="S2.p2.25.m25.1.1.2" xref="S2.p2.25.m25.1.1.2.cmml">𝐫</mi><mo id="S2.p2.25.m25.1.1.1" xref="S2.p2.25.m25.1.1.1.cmml">=</mo><mrow id="S2.p2.25.m25.1.1.3" xref="S2.p2.25.m25.1.1.3.cmml"><mrow id="S2.p2.25.m25.1.1.3.2" xref="S2.p2.25.m25.1.1.3.2.cmml"><mfrac id="S2.p2.25.m25.1.1.3.2.2" xref="S2.p2.25.m25.1.1.3.2.2.cmml"><mn id="S2.p2.25.m25.1.1.3.2.2.2" xref="S2.p2.25.m25.1.1.3.2.2.2.cmml">1</mn><mi id="S2.p2.25.m25.1.1.3.2.2.3" xref="S2.p2.25.m25.1.1.3.2.2.3.cmml">K</mi></mfrac><mo lspace="0em" rspace="0em" id="S2.p2.25.m25.1.1.3.2.1" xref="S2.p2.25.m25.1.1.3.2.1.cmml">​</mo><mrow id="S2.p2.25.m25.1.1.3.2.3" xref="S2.p2.25.m25.1.1.3.2.3.cmml"><msubsup id="S2.p2.25.m25.1.1.3.2.3.1" xref="S2.p2.25.m25.1.1.3.2.3.1.cmml"><mo id="S2.p2.25.m25.1.1.3.2.3.1.2.2" xref="S2.p2.25.m25.1.1.3.2.3.1.2.2.cmml">∑</mo><mrow id="S2.p2.25.m25.1.1.3.2.3.1.2.3" xref="S2.p2.25.m25.1.1.3.2.3.1.2.3.cmml"><mi id="S2.p2.25.m25.1.1.3.2.3.1.2.3.2" xref="S2.p2.25.m25.1.1.3.2.3.1.2.3.2.cmml">k</mi><mo id="S2.p2.25.m25.1.1.3.2.3.1.2.3.1" xref="S2.p2.25.m25.1.1.3.2.3.1.2.3.1.cmml">=</mo><mn id="S2.p2.25.m25.1.1.3.2.3.1.2.3.3" xref="S2.p2.25.m25.1.1.3.2.3.1.2.3.3.cmml">1</mn></mrow><mi id="S2.p2.25.m25.1.1.3.2.3.1.3" xref="S2.p2.25.m25.1.1.3.2.3.1.3.cmml">K</mi></msubsup><msub id="S2.p2.25.m25.1.1.3.2.3.2" xref="S2.p2.25.m25.1.1.3.2.3.2.cmml"><mi id="S2.p2.25.m25.1.1.3.2.3.2.2" xref="S2.p2.25.m25.1.1.3.2.3.2.2.cmml">𝐰</mi><mi id="S2.p2.25.m25.1.1.3.2.3.2.3" xref="S2.p2.25.m25.1.1.3.2.3.2.3.cmml">k</mi></msub></mrow></mrow><mo id="S2.p2.25.m25.1.1.3.1" xref="S2.p2.25.m25.1.1.3.1.cmml">+</mo><mfrac id="S2.p2.25.m25.1.1.3.3" xref="S2.p2.25.m25.1.1.3.3.cmml"><mi id="S2.p2.25.m25.1.1.3.3.2" xref="S2.p2.25.m25.1.1.3.3.2.cmml">𝐳</mi><mrow id="S2.p2.25.m25.1.1.3.3.3" xref="S2.p2.25.m25.1.1.3.3.3.cmml"><mi id="S2.p2.25.m25.1.1.3.3.3.2" xref="S2.p2.25.m25.1.1.3.3.3.2.cmml">K</mi><mo lspace="0em" rspace="0em" id="S2.p2.25.m25.1.1.3.3.3.1" xref="S2.p2.25.m25.1.1.3.3.3.1.cmml">​</mo><mi id="S2.p2.25.m25.1.1.3.3.3.3" xref="S2.p2.25.m25.1.1.3.3.3.3.cmml">h</mi><mo lspace="0em" rspace="0em" id="S2.p2.25.m25.1.1.3.3.3.1a" xref="S2.p2.25.m25.1.1.3.3.3.1.cmml">​</mo><msqrt id="S2.p2.25.m25.1.1.3.3.3.4" xref="S2.p2.25.m25.1.1.3.3.3.4.cmml"><mi id="S2.p2.25.m25.1.1.3.3.3.4.2" xref="S2.p2.25.m25.1.1.3.3.3.4.2.cmml">P</mi></msqrt></mrow></mfrac></mrow></mrow><annotation-xml encoding="MathML-Content" id="S2.p2.25.m25.1b"><apply id="S2.p2.25.m25.1.1.cmml" xref="S2.p2.25.m25.1.1"><eq id="S2.p2.25.m25.1.1.1.cmml" xref="S2.p2.25.m25.1.1.1"></eq><ci id="S2.p2.25.m25.1.1.2.cmml" xref="S2.p2.25.m25.1.1.2">𝐫</ci><apply id="S2.p2.25.m25.1.1.3.cmml" xref="S2.p2.25.m25.1.1.3"><plus id="S2.p2.25.m25.1.1.3.1.cmml" xref="S2.p2.25.m25.1.1.3.1"></plus><apply id="S2.p2.25.m25.1.1.3.2.cmml" xref="S2.p2.25.m25.1.1.3.2"><times id="S2.p2.25.m25.1.1.3.2.1.cmml" xref="S2.p2.25.m25.1.1.3.2.1"></times><apply id="S2.p2.25.m25.1.1.3.2.2.cmml" xref="S2.p2.25.m25.1.1.3.2.2"><divide id="S2.p2.25.m25.1.1.3.2.2.1.cmml" xref="S2.p2.25.m25.1.1.3.2.2"></divide><cn type="integer" id="S2.p2.25.m25.1.1.3.2.2.2.cmml" xref="S2.p2.25.m25.1.1.3.2.2.2">1</cn><ci id="S2.p2.25.m25.1.1.3.2.2.3.cmml" xref="S2.p2.25.m25.1.1.3.2.2.3">𝐾</ci></apply><apply id="S2.p2.25.m25.1.1.3.2.3.cmml" xref="S2.p2.25.m25.1.1.3.2.3"><apply id="S2.p2.25.m25.1.1.3.2.3.1.cmml" xref="S2.p2.25.m25.1.1.3.2.3.1"><csymbol cd="ambiguous" id="S2.p2.25.m25.1.1.3.2.3.1.1.cmml" xref="S2.p2.25.m25.1.1.3.2.3.1">superscript</csymbol><apply id="S2.p2.25.m25.1.1.3.2.3.1.2.cmml" xref="S2.p2.25.m25.1.1.3.2.3.1"><csymbol cd="ambiguous" id="S2.p2.25.m25.1.1.3.2.3.1.2.1.cmml" xref="S2.p2.25.m25.1.1.3.2.3.1">subscript</csymbol><sum id="S2.p2.25.m25.1.1.3.2.3.1.2.2.cmml" xref="S2.p2.25.m25.1.1.3.2.3.1.2.2"></sum><apply id="S2.p2.25.m25.1.1.3.2.3.1.2.3.cmml" xref="S2.p2.25.m25.1.1.3.2.3.1.2.3"><eq id="S2.p2.25.m25.1.1.3.2.3.1.2.3.1.cmml" xref="S2.p2.25.m25.1.1.3.2.3.1.2.3.1"></eq><ci id="S2.p2.25.m25.1.1.3.2.3.1.2.3.2.cmml" xref="S2.p2.25.m25.1.1.3.2.3.1.2.3.2">𝑘</ci><cn type="integer" id="S2.p2.25.m25.1.1.3.2.3.1.2.3.3.cmml" xref="S2.p2.25.m25.1.1.3.2.3.1.2.3.3">1</cn></apply></apply><ci id="S2.p2.25.m25.1.1.3.2.3.1.3.cmml" xref="S2.p2.25.m25.1.1.3.2.3.1.3">𝐾</ci></apply><apply id="S2.p2.25.m25.1.1.3.2.3.2.cmml" xref="S2.p2.25.m25.1.1.3.2.3.2"><csymbol cd="ambiguous" id="S2.p2.25.m25.1.1.3.2.3.2.1.cmml" xref="S2.p2.25.m25.1.1.3.2.3.2">subscript</csymbol><ci id="S2.p2.25.m25.1.1.3.2.3.2.2.cmml" xref="S2.p2.25.m25.1.1.3.2.3.2.2">𝐰</ci><ci id="S2.p2.25.m25.1.1.3.2.3.2.3.cmml" xref="S2.p2.25.m25.1.1.3.2.3.2.3">𝑘</ci></apply></apply></apply><apply id="S2.p2.25.m25.1.1.3.3.cmml" xref="S2.p2.25.m25.1.1.3.3"><divide id="S2.p2.25.m25.1.1.3.3.1.cmml" xref="S2.p2.25.m25.1.1.3.3"></divide><ci id="S2.p2.25.m25.1.1.3.3.2.cmml" xref="S2.p2.25.m25.1.1.3.3.2">𝐳</ci><apply id="S2.p2.25.m25.1.1.3.3.3.cmml" xref="S2.p2.25.m25.1.1.3.3.3"><times id="S2.p2.25.m25.1.1.3.3.3.1.cmml" xref="S2.p2.25.m25.1.1.3.3.3.1"></times><ci id="S2.p2.25.m25.1.1.3.3.3.2.cmml" xref="S2.p2.25.m25.1.1.3.3.3.2">𝐾</ci><ci id="S2.p2.25.m25.1.1.3.3.3.3.cmml" xref="S2.p2.25.m25.1.1.3.3.3.3">ℎ</ci><apply id="S2.p2.25.m25.1.1.3.3.3.4.cmml" xref="S2.p2.25.m25.1.1.3.3.3.4"><root id="S2.p2.25.m25.1.1.3.3.3.4a.cmml" xref="S2.p2.25.m25.1.1.3.3.3.4"></root><ci id="S2.p2.25.m25.1.1.3.3.3.4.2.cmml" xref="S2.p2.25.m25.1.1.3.3.3.4.2">𝑃</ci></apply></apply></apply></apply></apply></annotation-xml><annotation encoding="application/x-tex" id="S2.p2.25.m25.1c">{\bf r}=\frac{1}{K}\sum_{k=1}^{K}{\bf w}_{k}+\frac{{\bf z}}{Kh\sqrt{P}}</annotation></semantics></math> with a noise-induced error <math id="S2.p2.26.m26.1" class="ltx_Math" alttext="{\bm{\varepsilon}}=\frac{{\bf z}}{Kh\sqrt{P}}" display="inline"><semantics id="S2.p2.26.m26.1a"><mrow id="S2.p2.26.m26.1.1" xref="S2.p2.26.m26.1.1.cmml"><mi id="S2.p2.26.m26.1.1.2" xref="S2.p2.26.m26.1.1.2.cmml">𝜺</mi><mo id="S2.p2.26.m26.1.1.1" xref="S2.p2.26.m26.1.1.1.cmml">=</mo><mfrac id="S2.p2.26.m26.1.1.3" xref="S2.p2.26.m26.1.1.3.cmml"><mi id="S2.p2.26.m26.1.1.3.2" xref="S2.p2.26.m26.1.1.3.2.cmml">𝐳</mi><mrow id="S2.p2.26.m26.1.1.3.3" xref="S2.p2.26.m26.1.1.3.3.cmml"><mi id="S2.p2.26.m26.1.1.3.3.2" xref="S2.p2.26.m26.1.1.3.3.2.cmml">K</mi><mo lspace="0em" rspace="0em" id="S2.p2.26.m26.1.1.3.3.1" xref="S2.p2.26.m26.1.1.3.3.1.cmml">​</mo><mi id="S2.p2.26.m26.1.1.3.3.3" xref="S2.p2.26.m26.1.1.3.3.3.cmml">h</mi><mo lspace="0em" rspace="0em" id="S2.p2.26.m26.1.1.3.3.1a" xref="S2.p2.26.m26.1.1.3.3.1.cmml">​</mo><msqrt id="S2.p2.26.m26.1.1.3.3.4" xref="S2.p2.26.m26.1.1.3.3.4.cmml"><mi id="S2.p2.26.m26.1.1.3.3.4.2" xref="S2.p2.26.m26.1.1.3.3.4.2.cmml">P</mi></msqrt></mrow></mfrac></mrow><annotation-xml encoding="MathML-Content" id="S2.p2.26.m26.1b"><apply id="S2.p2.26.m26.1.1.cmml" xref="S2.p2.26.m26.1.1"><eq id="S2.p2.26.m26.1.1.1.cmml" xref="S2.p2.26.m26.1.1.1"></eq><ci id="S2.p2.26.m26.1.1.2.cmml" xref="S2.p2.26.m26.1.1.2">𝜺</ci><apply id="S2.p2.26.m26.1.1.3.cmml" xref="S2.p2.26.m26.1.1.3"><divide id="S2.p2.26.m26.1.1.3.1.cmml" xref="S2.p2.26.m26.1.1.3"></divide><ci id="S2.p2.26.m26.1.1.3.2.cmml" xref="S2.p2.26.m26.1.1.3.2">𝐳</ci><apply id="S2.p2.26.m26.1.1.3.3.cmml" xref="S2.p2.26.m26.1.1.3.3"><times id="S2.p2.26.m26.1.1.3.3.1.cmml" xref="S2.p2.26.m26.1.1.3.3.1"></times><ci id="S2.p2.26.m26.1.1.3.3.2.cmml" xref="S2.p2.26.m26.1.1.3.3.2">𝐾</ci><ci id="S2.p2.26.m26.1.1.3.3.3.cmml" xref="S2.p2.26.m26.1.1.3.3.3">ℎ</ci><apply id="S2.p2.26.m26.1.1.3.3.4.cmml" xref="S2.p2.26.m26.1.1.3.3.4"><root id="S2.p2.26.m26.1.1.3.3.4a.cmml" xref="S2.p2.26.m26.1.1.3.3.4"></root><ci id="S2.p2.26.m26.1.1.3.3.4.2.cmml" xref="S2.p2.26.m26.1.1.3.3.4.2">𝑃</ci></apply></apply></apply></apply></annotation-xml><annotation encoding="application/x-tex" id="S2.p2.26.m26.1c">{\bm{\varepsilon}}=\frac{{\bf z}}{Kh\sqrt{P}}</annotation></semantics></math>.
It is clear that by properly designing <math id="S2.p2.27.m27.1" class="ltx_Math" alttext="\{\alpha_{k}\}" display="inline"><semantics id="S2.p2.27.m27.1a"><mrow id="S2.p2.27.m27.1.1.1" xref="S2.p2.27.m27.1.1.2.cmml"><mo stretchy="false" id="S2.p2.27.m27.1.1.1.2" xref="S2.p2.27.m27.1.1.2.cmml">{</mo><msub id="S2.p2.27.m27.1.1.1.1" xref="S2.p2.27.m27.1.1.1.1.cmml"><mi id="S2.p2.27.m27.1.1.1.1.2" xref="S2.p2.27.m27.1.1.1.1.2.cmml">α</mi><mi id="S2.p2.27.m27.1.1.1.1.3" xref="S2.p2.27.m27.1.1.1.1.3.cmml">k</mi></msub><mo stretchy="false" id="S2.p2.27.m27.1.1.1.3" xref="S2.p2.27.m27.1.1.2.cmml">}</mo></mrow><annotation-xml encoding="MathML-Content" id="S2.p2.27.m27.1b"><set id="S2.p2.27.m27.1.1.2.cmml" xref="S2.p2.27.m27.1.1.1"><apply id="S2.p2.27.m27.1.1.1.1.cmml" xref="S2.p2.27.m27.1.1.1.1"><csymbol cd="ambiguous" id="S2.p2.27.m27.1.1.1.1.1.cmml" xref="S2.p2.27.m27.1.1.1.1">subscript</csymbol><ci id="S2.p2.27.m27.1.1.1.1.2.cmml" xref="S2.p2.27.m27.1.1.1.1.2">𝛼</ci><ci id="S2.p2.27.m27.1.1.1.1.3.cmml" xref="S2.p2.27.m27.1.1.1.1.3">𝑘</ci></apply></set></annotation-xml><annotation encoding="application/x-tex" id="S2.p2.27.m27.1c">\{\alpha_{k}\}</annotation></semantics></math>, we are able to obtain the desired average value of gradient or model parameters for FEEL, but subject to certain distortion caused by <span id="S2.p2.29.3" class="ltx_text ltx_font_italic">amplitude misalignment</span> (i.e., when <math id="S2.p2.28.m28.1" class="ltx_Math" alttext="\alpha_{k}|h_{k}|" display="inline"><semantics id="S2.p2.28.m28.1a"><mrow id="S2.p2.28.m28.1.1" xref="S2.p2.28.m28.1.1.cmml"><msub id="S2.p2.28.m28.1.1.3" xref="S2.p2.28.m28.1.1.3.cmml"><mi id="S2.p2.28.m28.1.1.3.2" xref="S2.p2.28.m28.1.1.3.2.cmml">α</mi><mi id="S2.p2.28.m28.1.1.3.3" xref="S2.p2.28.m28.1.1.3.3.cmml">k</mi></msub><mo lspace="0em" rspace="0em" id="S2.p2.28.m28.1.1.2" xref="S2.p2.28.m28.1.1.2.cmml">​</mo><mrow id="S2.p2.28.m28.1.1.1.1" xref="S2.p2.28.m28.1.1.1.2.cmml"><mo stretchy="false" id="S2.p2.28.m28.1.1.1.1.2" xref="S2.p2.28.m28.1.1.1.2.1.cmml">|</mo><msub id="S2.p2.28.m28.1.1.1.1.1" xref="S2.p2.28.m28.1.1.1.1.1.cmml"><mi id="S2.p2.28.m28.1.1.1.1.1.2" xref="S2.p2.28.m28.1.1.1.1.1.2.cmml">h</mi><mi id="S2.p2.28.m28.1.1.1.1.1.3" xref="S2.p2.28.m28.1.1.1.1.1.3.cmml">k</mi></msub><mo stretchy="false" id="S2.p2.28.m28.1.1.1.1.3" xref="S2.p2.28.m28.1.1.1.2.1.cmml">|</mo></mrow></mrow><annotation-xml encoding="MathML-Content" id="S2.p2.28.m28.1b"><apply id="S2.p2.28.m28.1.1.cmml" xref="S2.p2.28.m28.1.1"><times id="S2.p2.28.m28.1.1.2.cmml" xref="S2.p2.28.m28.1.1.2"></times><apply id="S2.p2.28.m28.1.1.3.cmml" xref="S2.p2.28.m28.1.1.3"><csymbol cd="ambiguous" id="S2.p2.28.m28.1.1.3.1.cmml" xref="S2.p2.28.m28.1.1.3">subscript</csymbol><ci id="S2.p2.28.m28.1.1.3.2.cmml" xref="S2.p2.28.m28.1.1.3.2">𝛼</ci><ci id="S2.p2.28.m28.1.1.3.3.cmml" xref="S2.p2.28.m28.1.1.3.3">𝑘</ci></apply><apply id="S2.p2.28.m28.1.1.1.2.cmml" xref="S2.p2.28.m28.1.1.1.1"><abs id="S2.p2.28.m28.1.1.1.2.1.cmml" xref="S2.p2.28.m28.1.1.1.1.2"></abs><apply id="S2.p2.28.m28.1.1.1.1.1.cmml" xref="S2.p2.28.m28.1.1.1.1.1"><csymbol cd="ambiguous" id="S2.p2.28.m28.1.1.1.1.1.1.cmml" xref="S2.p2.28.m28.1.1.1.1.1">subscript</csymbol><ci id="S2.p2.28.m28.1.1.1.1.1.2.cmml" xref="S2.p2.28.m28.1.1.1.1.1.2">ℎ</ci><ci id="S2.p2.28.m28.1.1.1.1.1.3.cmml" xref="S2.p2.28.m28.1.1.1.1.1.3">𝑘</ci></apply></apply></apply></annotation-xml><annotation encoding="application/x-tex" id="S2.p2.28.m28.1c">\alpha_{k}|h_{k}|</annotation></semantics></math>’s are different over edge devices) and noise <math id="S2.p2.29.m29.1" class="ltx_Math" alttext="{\bf z}" display="inline"><semantics id="S2.p2.29.m29.1a"><mi id="S2.p2.29.m29.1.1" xref="S2.p2.29.m29.1.1.cmml">𝐳</mi><annotation-xml encoding="MathML-Content" id="S2.p2.29.m29.1b"><ci id="S2.p2.29.m29.1.1.cmml" xref="S2.p2.29.m29.1.1">𝐳</ci></annotation-xml><annotation encoding="application/x-tex" id="S2.p2.29.m29.1c">{\bf z}</annotation></semantics></math>.</p>
</div>
<div id="S2.p3" class="ltx_para">
<p id="S2.p3.1" class="ltx_p">Notice that AirComp and Air-FEEL designs can also be implemented over fading wideband channels, in which the above process can be implemented over each subchannel independently.
For instance, Fig. <a href="#S2.F3" title="Figure 3 ‣ II Basic Principle of Air-FEEL ‣ An Overview on Over-the-Air Federated Edge Learning" class="ltx_ref"><span class="ltx_text ltx_ref_tag">3</span></a> shows the digital realization of AirComp over an <span id="S2.p3.1.1" class="ltx_text ltx_font_italic">orthogonal frequency multiplex access</span> (OFDM) system, which is different from conventional OFDM communications in the following two aspects. First, we need to add an additional pre-processing at each edge device to compensate the channel fading and phase shift, and proper post-processing at the edge server receiver. Next, analog input is implemented for AirComp in Fig. <a href="#S2.F3" title="Figure 3 ‣ II Basic Principle of Air-FEEL ‣ An Overview on Over-the-Air Federated Edge Learning" class="ltx_ref"><span class="ltx_text ltx_ref_tag">3</span></a>, which is in sharp contrast to the conventional OFDM communications using digital bits as inputs.
For more details on AirComp, please refer to the overview paper <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib3" title="" class="ltx_ref">3</a>]</cite>.</p>
</div>
<figure id="S2.F3" class="ltx_figure"><img src="/html/2208.05643/assets/x3.png" id="S2.F3.g1" class="ltx_graphics ltx_centering ltx_img_landscape" width="522" height="212" alt="Refer to caption">
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure">Figure 3: </span>Illustration of wideband digital AirComp implementation over OFDM. </figcaption>
</figure>
<section id="S2.SS1" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection"><span id="S2.SS1.4.1.1" class="ltx_text">II-A</span> </span><span id="S2.SS1.5.2" class="ltx_text ltx_font_italic">Benefits of Air-FEEL</span>
</h3>

<div id="S2.SS1.p1" class="ltx_para">
<p id="S2.SS1.p1.4" class="ltx_p">The benefits of Air-FEEL are two-fold. First, Air-FEEL is advantageous in enhancing the communication efficiency and reducing the training latency. In particular, in Air-FEEL, the over-the-air aggregation of each AI-model parameter from <math id="S2.SS1.p1.1.m1.1" class="ltx_Math" alttext="K" display="inline"><semantics id="S2.SS1.p1.1.m1.1a"><mi id="S2.SS1.p1.1.m1.1.1" xref="S2.SS1.p1.1.m1.1.1.cmml">K</mi><annotation-xml encoding="MathML-Content" id="S2.SS1.p1.1.m1.1b"><ci id="S2.SS1.p1.1.m1.1.1.cmml" xref="S2.SS1.p1.1.m1.1.1">𝐾</ci></annotation-xml><annotation encoding="application/x-tex" id="S2.SS1.p1.1.m1.1c">K</annotation></semantics></math> edge devices only requires one single channel use, thus making the required total number of resource blocks and the training latency independent from <math id="S2.SS1.p1.2.m2.1" class="ltx_Math" alttext="K" display="inline"><semantics id="S2.SS1.p1.2.m2.1a"><mi id="S2.SS1.p1.2.m2.1.1" xref="S2.SS1.p1.2.m2.1.1.cmml">K</mi><annotation-xml encoding="MathML-Content" id="S2.SS1.p1.2.m2.1b"><ci id="S2.SS1.p1.2.m2.1.1.cmml" xref="S2.SS1.p1.2.m2.1.1">𝐾</ci></annotation-xml><annotation encoding="application/x-tex" id="S2.SS1.p1.2.m2.1c">K</annotation></semantics></math>. This is in sharp contrast to the conventional design with sequential “communication-then-computation”, in which the edge server needs to decode individual AI-model parameters from <math id="S2.SS1.p1.3.m3.1" class="ltx_Math" alttext="K" display="inline"><semantics id="S2.SS1.p1.3.m3.1a"><mi id="S2.SS1.p1.3.m3.1.1" xref="S2.SS1.p1.3.m3.1.1.cmml">K</mi><annotation-xml encoding="MathML-Content" id="S2.SS1.p1.3.m3.1b"><ci id="S2.SS1.p1.3.m3.1.1.cmml" xref="S2.SS1.p1.3.m3.1.1">𝐾</ci></annotation-xml><annotation encoding="application/x-tex" id="S2.SS1.p1.3.m3.1c">K</annotation></semantics></math> devices by mitigating the inter-user interference, such that the required total number of resource blocks and the training latency generally grow with respect to <math id="S2.SS1.p1.4.m4.1" class="ltx_Math" alttext="K" display="inline"><semantics id="S2.SS1.p1.4.m4.1a"><mi id="S2.SS1.p1.4.m4.1.1" xref="S2.SS1.p1.4.m4.1.1.cmml">K</mi><annotation-xml encoding="MathML-Content" id="S2.SS1.p1.4.m4.1b"><ci id="S2.SS1.p1.4.m4.1.1.cmml" xref="S2.SS1.p1.4.m4.1.1">𝐾</ci></annotation-xml><annotation encoding="application/x-tex" id="S2.SS1.p1.4.m4.1c">K</annotation></semantics></math> linearly.</p>
</div>
<div id="S2.SS1.p2" class="ltx_para">
<p id="S2.SS1.p2.1" class="ltx_p">Next, Air-FEEL is beneficial in better preserving data privacy. In conventional FEEL, raw data exposure to the third party is avoided by exchanging model/gradient updates; however, private data information can still be inferred from the individual updates via membership inference or update leakage attacks <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib4" title="" class="ltx_ref">4</a>]</cite>, thus causing certain level of privacy leakage. By contrast, in Air-FEEL, only the aggregate updates, instead of individual ones, can be accessed by potential eavesdroppers, thus providing double privacy protection at edge devices.</p>
</div>
</section>
<section id="S2.SS2" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection"><span id="S2.SS2.4.1.1" class="ltx_text">II-B</span> </span><span id="S2.SS2.5.2" class="ltx_text ltx_font_italic">Challenges</span>
</h3>

<div id="S2.SS2.p1" class="ltx_para">
<p id="S2.SS2.p1.1" class="ltx_p">The successful implementation of Air-FEEL faces the following technical challenges.</p>
</div>
<section id="S2.SS2.SSS1" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection"><span id="S2.SS2.SSS1.4.1.1" class="ltx_text">II-B</span>1 </span>Over-the-air Aggregation Errors</h4>

<div id="S2.SS2.SSS1.p1" class="ltx_para">
<p id="S2.SS2.SSS1.p1.1" class="ltx_p">In Air-FEEL, analog magnitude modulation is implemented for one-shot distributed functional computation. This, however, is vulnerable to signal distortion caused by channel fading, noise, and channel estimation errors, and thus may degrade the training performance. How to quantify the effect of such over-the-air aggregation errors on Air-FEEL performance and accordingly optimize the system design is an uncharted problem that has not been investigated in conventional FEEL and wireless communication systems.</p>
</div>
</section>
<section id="S2.SS2.SSS2" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection"><span id="S2.SS2.SSS2.4.1.1" class="ltx_text">II-B</span>2 </span>Resource Limitation and Heterogeneity</h4>

<div id="S2.SS2.SSS2.p1" class="ltx_para">
<p id="S2.SS2.SSS2.p1.1" class="ltx_p">While the distributed learning tasks are generally resource-consuming, the participating edge devices only have limited computation and communication resources, and their available resources may vary significantly. Such resource limitation and heterogeneity are becoming a challenging issue faced in Air-FEEL. On one hand, the over-the-air gradient/model aggregation needs to be implemented synchronously by all edge devices after their local iteration, but their local iteration latencies may differ significantly due to their distinct computation capabilities. In this case, the total computation latency of Air-FEEL is restrained by the device with the smallest computation power. On the other hand, the over-the-air aggregation errors highly depend on the channel conditions and the transmit power at distributed edge devices. In this case, devices with poor channel and/or limited transmit power become the performance bottleneck of AirComp, and increasing their transmit powers can accelerate the Air-FEEL training but at a cost of high energy consumption cost.</p>
</div>
</section>
<section id="S2.SS2.SSS3" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection"><span id="S2.SS2.SSS3.4.1.1" class="ltx_text">II-B</span>3 </span>Data Heterogeneity</h4>

<div id="S2.SS2.SSS3.p1" class="ltx_para">
<p id="S2.SS2.SSS3.p1.1" class="ltx_p">Data heterogeneity is another key factor affecting the performance of Air-FEEL. Specifically, in practical wireless networks, training data are distributed at different edge devices in a non-i.i.d. manner, and the number of available data samples may be highly unbalanced among different edge devices. The non-i.i.d. and unbalanced data distribution poses a grand challenge in designing good Air-FEEL systems with convergence and generalization guarantee.</p>
</div>
</section>
</section>
</section>
<section id="S3" class="ltx_section">
<h2 class="ltx_title ltx_title_section">
<span class="ltx_tag ltx_tag_section">III </span><span id="S3.1.1" class="ltx_text ltx_font_smallcaps">Fundamental Performance Limits </span>
</h2>

<div id="S3.p1" class="ltx_para">
<p id="S3.p1.1" class="ltx_p">To facilitate the Air-FEEL design, it is important to understand its fundamental performance limits. This section first presents the widely adopted performance metrics in Air-FEEL, and then discusses their fundamental tradeoffs under practical over-the-air aggregation errors.</p>
</div>
<section id="S3.SS1" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection"><span id="S3.SS1.4.1.1" class="ltx_text">III-A</span> </span><span id="S3.SS1.5.2" class="ltx_text ltx_font_italic">Performance Metrics</span>
</h3>

<div id="S3.SS1.p1" class="ltx_para">
<p id="S3.SS1.p1.1" class="ltx_p">Air-FEEL aims to train AI models. The widely adopted performance metrics include training loss and learning accuracy, learning latency, and energy consumption, which are detailed in the following.</p>
</div>
<div id="S3.SS1.p2" class="ltx_para">
<ul id="S3.I1" class="ltx_itemize">
<li id="S3.I1.i1" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">•</span> 
<div id="S3.I1.i1.p1" class="ltx_para">
<p id="S3.I1.i1.p1.1" class="ltx_p"><span id="S3.I1.i1.p1.1.1" class="ltx_text ltx_font_bold">Training loss and learning accuracy</span>: Training loss means the loss (or objective) function value of the trained AI model, and learning accuracy describes how the trained model performs over test samples. In general, with a given AI model, lower training loss corresponds to higher learning accuracy. To analyze the convergence behavior of Air-FEEL, loss optimality gap (the gap between the current loss and the global minimum) is widely adopted in practice <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib4" title="" class="ltx_ref">4</a>, <a href="#bib.bib5" title="" class="ltx_ref">5</a>, <a href="#bib.bib6" title="" class="ltx_ref">6</a>]</cite>.</p>
</div>
</li>
<li id="S3.I1.i2" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">•</span> 
<div id="S3.I1.i2.p1" class="ltx_para">
<p id="S3.I1.i2.p1.1" class="ltx_p"><span id="S3.I1.i2.p1.1.1" class="ltx_text ltx_font_bold">Learning latency</span>: Learning latency is defined as the wall clock time for the learning process to converge within a given accuracy. In Air-FEEL, the learning latency generally corresponds to the number of global communication rounds times per-round latency <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib5" title="" class="ltx_ref">5</a>]</cite>. Here, the per-round latency includes the computation latency (of the slowest device) for local gradient/model-update iterations, and the communication latency for over-the-air updates aggregation from the edge devices to the edge server.</p>
</div>
</li>
<li id="S3.I1.i3" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">•</span> 
<div id="S3.I1.i3.p1" class="ltx_para">
<p id="S3.I1.i3.p1.1" class="ltx_p"><span id="S3.I1.i3.p1.1.1" class="ltx_text ltx_font_bold">Energy consumption</span>: Energy consumption corresponds to the communication and computation energy required by both the edge devices and edge server for training the AI model. The computation energy is mainly consumed by the edge devices for locally updating AI models, and the communication energy is consumed by the edge devices and edge server to exchange their models/gradients.</p>
</div>
</li>
</ul>
</div>
<div id="S3.SS1.p3" class="ltx_para">
<p id="S3.SS1.p3.1" class="ltx_p">Intuitively, the above three Air-FEEL performance objectives are competing, e.g., to achieve higher accuracy normally requires longer learning latency and more energy consumption. Such performance tradeoffs, however, are quite complicated and depend on various system design parameters, such as the numbers of global and local iterations, the transmit power at edge devices for AirComp, and their computation power for local computation. In the literature, there have been well-established analytic models on the learning latency and energy consumption for Air-FEEL <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib3" title="" class="ltx_ref">3</a>]</cite>. It remains a fundamental problem to analytically understand the relationship between the training loss and learning accuracy versus system parameters under different AI models, especially subject to the unique over-the-air aggregation errors.</p>
</div>
</section>
<section id="S3.SS2" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection"><span id="S3.SS2.4.1.1" class="ltx_text">III-B</span> </span><span id="S3.SS2.5.2" class="ltx_text ltx_font_italic">Convergence of Air-FEEL with Aggregation Errors </span>
</h3>

<div id="S3.SS2.p1" class="ltx_para">
<p id="S3.SS2.p1.1" class="ltx_p">To resolve the above issue, it is essential to analyze the convergence behavior of Air-FEEL, which characterizes how the (expected) gradient norm or loss optimality gap changes over global communication rounds. However, it is difficult to find the exact expression for gradient norm or loss optimality gap under general AI models. To tackle this problem, their upper bounds are alternatively used to represent the convergence behavior in the FEEL literature <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib4" title="" class="ltx_ref">4</a>]</cite>, by making specific assumptions on the AI model (e.g., on the smoothness of the loss functions and Lipschitz-continuous gradients). However, due to the newly involved over-the-air aggregation errors, the convergence analysis for Air-FEEL is still challenging.</p>
</div>
<div id="S3.SS2.p2" class="ltx_para">
<p id="S3.SS2.p2.1" class="ltx_p">Recently, the work <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib6" title="" class="ltx_ref">6</a>]</cite> established a convergence analysis for Air-FedSGD with gradient aggregation after one local iteration. This framework reveals the impact of the bias and MSE of aggregation errors on the excepted optimality gap. In particular, under the smoothness assumption and Polyak-Łojasiewicz inequality, the loss optimality gap is shown to satisfy the simplified inequality as shown in the upper frame in Fig. <a href="#S3.F4" title="Figure 4 ‣ III-B Convergence of Air-FEEL with Aggregation Errors ‣ III Fundamental Performance Limits ‣ An Overview on Over-the-Air Federated Edge Learning" class="ltx_ref"><span class="ltx_text ltx_ref_tag">4</span></a>.</p>
</div>
<figure id="S3.F4" class="ltx_figure"><img src="/html/2208.05643/assets/x4.png" id="S3.F4.g1" class="ltx_graphics ltx_centering ltx_img_landscape" width="461" height="292" alt="Refer to caption">
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure">Figure 4: </span>Illustration of the convergence behavior by taking into account over-the-air aggregation errors <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib6" title="" class="ltx_ref">6</a>]</cite>, where <math id="S3.F4.6.m1.1" class="ltx_Math" alttext="T" display="inline"><semantics id="S3.F4.6.m1.1b"><mi id="S3.F4.6.m1.1.1" xref="S3.F4.6.m1.1.1.cmml">T</mi><annotation-xml encoding="MathML-Content" id="S3.F4.6.m1.1c"><ci id="S3.F4.6.m1.1.1.cmml" xref="S3.F4.6.m1.1.1">𝑇</ci></annotation-xml><annotation encoding="application/x-tex" id="S3.F4.6.m1.1d">T</annotation></semantics></math> denotes the needed global communication rounds for convergence with <math id="S3.F4.7.m2.1" class="ltx_Math" alttext="1\leq t\leq T" display="inline"><semantics id="S3.F4.7.m2.1b"><mrow id="S3.F4.7.m2.1.1" xref="S3.F4.7.m2.1.1.cmml"><mn id="S3.F4.7.m2.1.1.2" xref="S3.F4.7.m2.1.1.2.cmml">1</mn><mo id="S3.F4.7.m2.1.1.3" xref="S3.F4.7.m2.1.1.3.cmml">≤</mo><mi id="S3.F4.7.m2.1.1.4" xref="S3.F4.7.m2.1.1.4.cmml">t</mi><mo id="S3.F4.7.m2.1.1.5" xref="S3.F4.7.m2.1.1.5.cmml">≤</mo><mi id="S3.F4.7.m2.1.1.6" xref="S3.F4.7.m2.1.1.6.cmml">T</mi></mrow><annotation-xml encoding="MathML-Content" id="S3.F4.7.m2.1c"><apply id="S3.F4.7.m2.1.1.cmml" xref="S3.F4.7.m2.1.1"><and id="S3.F4.7.m2.1.1a.cmml" xref="S3.F4.7.m2.1.1"></and><apply id="S3.F4.7.m2.1.1b.cmml" xref="S3.F4.7.m2.1.1"><leq id="S3.F4.7.m2.1.1.3.cmml" xref="S3.F4.7.m2.1.1.3"></leq><cn type="integer" id="S3.F4.7.m2.1.1.2.cmml" xref="S3.F4.7.m2.1.1.2">1</cn><ci id="S3.F4.7.m2.1.1.4.cmml" xref="S3.F4.7.m2.1.1.4">𝑡</ci></apply><apply id="S3.F4.7.m2.1.1c.cmml" xref="S3.F4.7.m2.1.1"><leq id="S3.F4.7.m2.1.1.5.cmml" xref="S3.F4.7.m2.1.1.5"></leq><share href="#S3.F4.7.m2.1.1.4.cmml" id="S3.F4.7.m2.1.1d.cmml" xref="S3.F4.7.m2.1.1"></share><ci id="S3.F4.7.m2.1.1.6.cmml" xref="S3.F4.7.m2.1.1.6">𝑇</ci></apply></apply></annotation-xml><annotation encoding="application/x-tex" id="S3.F4.7.m2.1d">1\leq t\leq T</annotation></semantics></math>, and <math id="S3.F4.8.m3.2" class="ltx_Math" alttext="\mathbb{E}\left[{\bm{\varepsilon}}(t)\right]" display="inline"><semantics id="S3.F4.8.m3.2b"><mrow id="S3.F4.8.m3.2.2" xref="S3.F4.8.m3.2.2.cmml"><mi id="S3.F4.8.m3.2.2.3" xref="S3.F4.8.m3.2.2.3.cmml">𝔼</mi><mo lspace="0em" rspace="0em" id="S3.F4.8.m3.2.2.2" xref="S3.F4.8.m3.2.2.2.cmml">​</mo><mrow id="S3.F4.8.m3.2.2.1.1" xref="S3.F4.8.m3.2.2.1.2.cmml"><mo id="S3.F4.8.m3.2.2.1.1.2" xref="S3.F4.8.m3.2.2.1.2.1.cmml">[</mo><mrow id="S3.F4.8.m3.2.2.1.1.1" xref="S3.F4.8.m3.2.2.1.1.1.cmml"><mi id="S3.F4.8.m3.2.2.1.1.1.2" xref="S3.F4.8.m3.2.2.1.1.1.2.cmml">𝜺</mi><mo lspace="0em" rspace="0em" id="S3.F4.8.m3.2.2.1.1.1.1" xref="S3.F4.8.m3.2.2.1.1.1.1.cmml">​</mo><mrow id="S3.F4.8.m3.2.2.1.1.1.3.2" xref="S3.F4.8.m3.2.2.1.1.1.cmml"><mo stretchy="false" id="S3.F4.8.m3.2.2.1.1.1.3.2.1" xref="S3.F4.8.m3.2.2.1.1.1.cmml">(</mo><mi id="S3.F4.8.m3.1.1" xref="S3.F4.8.m3.1.1.cmml">t</mi><mo stretchy="false" id="S3.F4.8.m3.2.2.1.1.1.3.2.2" xref="S3.F4.8.m3.2.2.1.1.1.cmml">)</mo></mrow></mrow><mo id="S3.F4.8.m3.2.2.1.1.3" xref="S3.F4.8.m3.2.2.1.2.1.cmml">]</mo></mrow></mrow><annotation-xml encoding="MathML-Content" id="S3.F4.8.m3.2c"><apply id="S3.F4.8.m3.2.2.cmml" xref="S3.F4.8.m3.2.2"><times id="S3.F4.8.m3.2.2.2.cmml" xref="S3.F4.8.m3.2.2.2"></times><ci id="S3.F4.8.m3.2.2.3.cmml" xref="S3.F4.8.m3.2.2.3">𝔼</ci><apply id="S3.F4.8.m3.2.2.1.2.cmml" xref="S3.F4.8.m3.2.2.1.1"><csymbol cd="latexml" id="S3.F4.8.m3.2.2.1.2.1.cmml" xref="S3.F4.8.m3.2.2.1.1.2">delimited-[]</csymbol><apply id="S3.F4.8.m3.2.2.1.1.1.cmml" xref="S3.F4.8.m3.2.2.1.1.1"><times id="S3.F4.8.m3.2.2.1.1.1.1.cmml" xref="S3.F4.8.m3.2.2.1.1.1.1"></times><ci id="S3.F4.8.m3.2.2.1.1.1.2.cmml" xref="S3.F4.8.m3.2.2.1.1.1.2">𝜺</ci><ci id="S3.F4.8.m3.1.1.cmml" xref="S3.F4.8.m3.1.1">𝑡</ci></apply></apply></apply></annotation-xml><annotation encoding="application/x-tex" id="S3.F4.8.m3.2d">\mathbb{E}\left[{\bm{\varepsilon}}(t)\right]</annotation></semantics></math> and <math id="S3.F4.9.m4.2" class="ltx_Math" alttext="\mathbb{E}\left[\|{\bm{\varepsilon}}(t)\|^{2}\right]" display="inline"><semantics id="S3.F4.9.m4.2b"><mrow id="S3.F4.9.m4.2.2" xref="S3.F4.9.m4.2.2.cmml"><mi id="S3.F4.9.m4.2.2.3" xref="S3.F4.9.m4.2.2.3.cmml">𝔼</mi><mo lspace="0em" rspace="0em" id="S3.F4.9.m4.2.2.2" xref="S3.F4.9.m4.2.2.2.cmml">​</mo><mrow id="S3.F4.9.m4.2.2.1.1" xref="S3.F4.9.m4.2.2.1.2.cmml"><mo id="S3.F4.9.m4.2.2.1.1.2" xref="S3.F4.9.m4.2.2.1.2.1.cmml">[</mo><msup id="S3.F4.9.m4.2.2.1.1.1" xref="S3.F4.9.m4.2.2.1.1.1.cmml"><mrow id="S3.F4.9.m4.2.2.1.1.1.1.1" xref="S3.F4.9.m4.2.2.1.1.1.1.2.cmml"><mo stretchy="false" id="S3.F4.9.m4.2.2.1.1.1.1.1.2" xref="S3.F4.9.m4.2.2.1.1.1.1.2.1.cmml">‖</mo><mrow id="S3.F4.9.m4.2.2.1.1.1.1.1.1" xref="S3.F4.9.m4.2.2.1.1.1.1.1.1.cmml"><mi id="S3.F4.9.m4.2.2.1.1.1.1.1.1.2" xref="S3.F4.9.m4.2.2.1.1.1.1.1.1.2.cmml">𝜺</mi><mo lspace="0em" rspace="0em" id="S3.F4.9.m4.2.2.1.1.1.1.1.1.1" xref="S3.F4.9.m4.2.2.1.1.1.1.1.1.1.cmml">​</mo><mrow id="S3.F4.9.m4.2.2.1.1.1.1.1.1.3.2" xref="S3.F4.9.m4.2.2.1.1.1.1.1.1.cmml"><mo stretchy="false" id="S3.F4.9.m4.2.2.1.1.1.1.1.1.3.2.1" xref="S3.F4.9.m4.2.2.1.1.1.1.1.1.cmml">(</mo><mi id="S3.F4.9.m4.1.1" xref="S3.F4.9.m4.1.1.cmml">t</mi><mo stretchy="false" id="S3.F4.9.m4.2.2.1.1.1.1.1.1.3.2.2" xref="S3.F4.9.m4.2.2.1.1.1.1.1.1.cmml">)</mo></mrow></mrow><mo stretchy="false" id="S3.F4.9.m4.2.2.1.1.1.1.1.3" xref="S3.F4.9.m4.2.2.1.1.1.1.2.1.cmml">‖</mo></mrow><mn id="S3.F4.9.m4.2.2.1.1.1.3" xref="S3.F4.9.m4.2.2.1.1.1.3.cmml">2</mn></msup><mo id="S3.F4.9.m4.2.2.1.1.3" xref="S3.F4.9.m4.2.2.1.2.1.cmml">]</mo></mrow></mrow><annotation-xml encoding="MathML-Content" id="S3.F4.9.m4.2c"><apply id="S3.F4.9.m4.2.2.cmml" xref="S3.F4.9.m4.2.2"><times id="S3.F4.9.m4.2.2.2.cmml" xref="S3.F4.9.m4.2.2.2"></times><ci id="S3.F4.9.m4.2.2.3.cmml" xref="S3.F4.9.m4.2.2.3">𝔼</ci><apply id="S3.F4.9.m4.2.2.1.2.cmml" xref="S3.F4.9.m4.2.2.1.1"><csymbol cd="latexml" id="S3.F4.9.m4.2.2.1.2.1.cmml" xref="S3.F4.9.m4.2.2.1.1.2">delimited-[]</csymbol><apply id="S3.F4.9.m4.2.2.1.1.1.cmml" xref="S3.F4.9.m4.2.2.1.1.1"><csymbol cd="ambiguous" id="S3.F4.9.m4.2.2.1.1.1.2.cmml" xref="S3.F4.9.m4.2.2.1.1.1">superscript</csymbol><apply id="S3.F4.9.m4.2.2.1.1.1.1.2.cmml" xref="S3.F4.9.m4.2.2.1.1.1.1.1"><csymbol cd="latexml" id="S3.F4.9.m4.2.2.1.1.1.1.2.1.cmml" xref="S3.F4.9.m4.2.2.1.1.1.1.1.2">norm</csymbol><apply id="S3.F4.9.m4.2.2.1.1.1.1.1.1.cmml" xref="S3.F4.9.m4.2.2.1.1.1.1.1.1"><times id="S3.F4.9.m4.2.2.1.1.1.1.1.1.1.cmml" xref="S3.F4.9.m4.2.2.1.1.1.1.1.1.1"></times><ci id="S3.F4.9.m4.2.2.1.1.1.1.1.1.2.cmml" xref="S3.F4.9.m4.2.2.1.1.1.1.1.1.2">𝜺</ci><ci id="S3.F4.9.m4.1.1.cmml" xref="S3.F4.9.m4.1.1">𝑡</ci></apply></apply><cn type="integer" id="S3.F4.9.m4.2.2.1.1.1.3.cmml" xref="S3.F4.9.m4.2.2.1.1.1.3">2</cn></apply></apply></apply></annotation-xml><annotation encoding="application/x-tex" id="S3.F4.9.m4.2d">\mathbb{E}\left[\|{\bm{\varepsilon}}(t)\|^{2}\right]</annotation></semantics></math> denote the bias and MSE of the aggregation error at each global communication round <math id="S3.F4.10.m5.1" class="ltx_Math" alttext="t" display="inline"><semantics id="S3.F4.10.m5.1b"><mi id="S3.F4.10.m5.1.1" xref="S3.F4.10.m5.1.1.cmml">t</mi><annotation-xml encoding="MathML-Content" id="S3.F4.10.m5.1c"><ci id="S3.F4.10.m5.1.1.cmml" xref="S3.F4.10.m5.1.1">𝑡</ci></annotation-xml><annotation encoding="application/x-tex" id="S3.F4.10.m5.1d">t</annotation></semantics></math>, respectively. </figcaption>
</figure>
<div id="S3.SS2.p3" class="ltx_para">
<p id="S3.SS2.p3.1" class="ltx_p">The lower frame in Fig. <a href="#S3.F4" title="Figure 4 ‣ III-B Convergence of Air-FEEL with Aggregation Errors ‣ III Fundamental Performance Limits ‣ An Overview on Over-the-Air Federated Edge Learning" class="ltx_ref"><span class="ltx_text ltx_ref_tag">4</span></a> illustrates the convergence behavior of Air-FEEL in terms of the derived loss optimality gap under the specified assumptions <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib6" title="" class="ltx_ref">6</a>]</cite>.
First, the Air-FEEL algorithm converges towards the optimality within a certain error floor, which becomes zero if the over-the-air aggregation is unbiased but strictly positive otherwise.
Nevertheless, enforcing unbiased aggregation for vanishing error floor may elevate the gap to the error floor, and thus may slow down the convergence. Next, with the increasing discounting factor, the aggregation errors at the latter global rounds contribute more to the optimality gap and thus are more damaging to the learning process.
</p>
</div>
<div id="S3.SS2.p4" class="ltx_para">
<p id="S3.SS2.p4.1" class="ltx_p">The above analytical result in <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib6" title="" class="ltx_ref">6</a>]</cite> sheds light on how the imperfect aggregate updates affect the convergence of Air-FedSGD. This result was then extended to Air-FedAvg with model aggregation after multiple local iterations <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib5" title="" class="ltx_ref">5</a>]</cite>. It is shown that, as the number of local iterations increases, the needed number of global communication rounds may decrease, but at the cost of a large divergence among the local updates at edge devices. This thus shows the significance of judiciously designing the number of local iterations in Air-FedAvg for improving the learning performance. These analytical results build the foundation for optimizing the Air-FEEL performance, as will be elaborated in the sequel.</p>
</div>
</section>
</section>
<section id="S4" class="ltx_section">
<h2 class="ltx_title ltx_title_section">
<span class="ltx_tag ltx_tag_section">IV </span><span id="S4.1.1" class="ltx_text ltx_font_smallcaps">Resource Management for Air-FEEL</span>
</h2>

<div id="S4.p1" class="ltx_para">
<p id="S4.p1.1" class="ltx_p">Based on the performance analysis in Section <a href="#S3" title="III Fundamental Performance Limits ‣ An Overview on Over-the-Air Federated Edge Learning" class="ltx_ref"><span class="ltx_text ltx_ref_tag">III</span></a>, this section reviews the state-of-the-art techniques for improving the Air-FEEL performance, which jointly optimizes the communication parameters for AirComp and the learning parameters.</p>
</div>
<section id="S4.SS1" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection"><span id="S4.SS1.4.1.1" class="ltx_text">IV-A</span> </span><span id="S4.SS1.5.2" class="ltx_text ltx_font_italic">Power Control Optimization</span>
</h3>

<div id="S4.SS1.p1" class="ltx_para">
<p id="S4.SS1.p1.1" class="ltx_p">In Air-FEEL, the edge devices can adaptively control their transmit power to reduce the aggregation error for model/gradient aggregation, and accordingly enhance the learning accuracy or convergence rate. In general, there are two different transmit power control design principles. The first design principle optimizes AirComp independently at each global round for, e.g., minimizing the communication error or MSE. For instance, the most straightforward way is for the edge devices to adopt the channel inversion power control for achieving the perfect signal magnitude alignment. This, however, is highly suboptimal in MSE minimization. This is because in this case, the aligned signal magnitude is compromised by the device with the worst channel conditions, which may significantly weaken the aggregate signal strength and equivalently amplify the noise power, especially when some devices are in deep fading. To deal with this issue, the optimal power control to minimize the AirComp MSE was developed in <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib3" title="" class="ltx_ref">3</a>, <a href="#bib.bib7" title="" class="ltx_ref">7</a>]</cite>, which exhibits a threshold-based structure depending on the channel conditions at different edge devices. For a certain device, if the channel power gain is greater than a certain threshold, then a channel-inversion-like power control is employed at that device for signal magnitude alignment; otherwise, the full power transmission is performed at that device to mitigate the noise.</p>
</div>
<figure id="S4.F5" class="ltx_figure"><img src="/html/2208.05643/assets/x5.png" id="S4.F5.g1" class="ltx_graphics ltx_centering ltx_img_landscape" width="307" height="227" alt="Refer to caption">
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure">Figure 5: </span>Learning performance of Air-FEEL on MNIST dataset over the number of communication rounds under different power control schemes <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib6" title="" class="ltx_ref">6</a>]</cite>.</figcaption>
</figure>
<div id="S4.SS1.p2" class="ltx_para">
<p id="S4.SS1.p2.1" class="ltx_p">Instead of minimizing the aggregation MSE in each round independently, the second design principle jointly optimizes the power allocation over different global rounds to maximize the convergence rate in terms of the loss optimality gap (e.g., in the upper frame in Fig. <a href="#S3.F4" title="Figure 4 ‣ III-B Convergence of Air-FEEL with Aggregation Errors ‣ III Fundamental Performance Limits ‣ An Overview on Over-the-Air Federated Edge Learning" class="ltx_ref"><span class="ltx_text ltx_ref_tag">4</span></a>). For instance, the work <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib6" title="" class="ltx_ref">6</a>]</cite> investigated the power allocation problem in Air-FedSGD, in which two joint power control designs with biased and unbiased aggregations are developed, respectively.
As shown in Fig. <a href="#S4.F5" title="Figure 5 ‣ IV-A Power Control Optimization ‣ IV Resource Management for Air-FEEL ‣ An Overview on Over-the-Air Federated Edge Learning" class="ltx_ref"><span class="ltx_text ltx_ref_tag">5</span></a>, both joint power control designs achieve faster convergence and lower loss value compared with the fixed power transmission and independent power control for MSE minimization. This thus shows the benefit of power control optimization in accelerating the learning convergence. As compared with independent power control for MSE minimization, the joint power control designs capture the fact that the loss optimality gap is more sensitive to the aggregation errors at latter rounds.
Fig. <a href="#S4.F5" title="Figure 5 ‣ IV-A Power Control Optimization ‣ IV Resource Management for Air-FEEL ‣ An Overview on Over-the-Air Federated Edge Learning" class="ltx_ref"><span class="ltx_text ltx_ref_tag">5</span></a> also compares the loss value and learning accuracy of the two joint power control designs. It is shown that the design under the unbiased aggregation achieves lower optimality gap than that under the biased aggregation when the number of communication rounds is sufficiently large. This coincides with the discussion in Section <a href="#S3.SS2" title="III-B Convergence of Air-FEEL with Aggregation Errors ‣ III Fundamental Performance Limits ‣ An Overview on Over-the-Air Federated Edge Learning" class="ltx_ref"><span class="ltx_text ltx_ref_tag"><span class="ltx_text">III-B</span></span></a> that the Air-FedSGD algorithm converges to the optimal point with unbiased gradient aggregation.
The convergence-aware joint power control design was then extended to the Air-FedAvg system in <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib5" title="" class="ltx_ref">5</a>]</cite>.</p>
</div>
</section>
<section id="S4.SS2" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection"><span id="S4.SS2.4.1.1" class="ltx_text">IV-B</span> </span><span id="S4.SS2.5.2" class="ltx_text ltx_font_italic">Beamforming Design</span>
</h3>

<div id="S4.SS2.p1" class="ltx_para">
<p id="S4.SS2.p1.1" class="ltx_p">Multi-antenna beamforming is an efficient solution to further improve the Air-FEEL performance by enhancing both aggregation efficiency and aggregation accuracy, via exploiting the spatial multiplexing and spatial diversity gains, respectively. On one hand, by deploying multiple antennas at both the edge devices and the edge server, multiple AI-model parameters or gradient elements can be simultaneously aggregated over one single time-frequency block. On the other hand, via proper transmit and/or receive beamforming, multiple signal copies from different antennas can be properly combined to further reduce the aggregated errors. For instance, existing works in <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib3" title="" class="ltx_ref">3</a>, <a href="#bib.bib8" title="" class="ltx_ref">8</a>]</cite> developed the joint design of transmit beamforming at the edge devices and aggregation beamforming at edge server for substantially enhancing the aggregation performance, which can be directly used for enhancing Air-FEEL performance.</p>
</div>
<div id="S4.SS2.p2" class="ltx_para">
<p id="S4.SS2.p2.1" class="ltx_p">More recently, <span id="S4.SS2.p2.1.1" class="ltx_text ltx_font_italic">reconfigurable intelligent surface</span> (RIS) has emerged as a candidate technique to enhance the spectrum and energy efficiencies of 6G networks <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib9" title="" class="ltx_ref">9</a>]</cite>. RIS is composed of a large number of low-cost and passive reflecting elements, whose amplitudes and phases can be adjusted to properly control the propagation environment to facilitate wireless transmissions. In particular, RIS can assist the edge devices with poor channel conditions to enhance their signal strengths towards the edge server, thus enhancing the aggregated signal magnitude level for minimizing the aggregation error. For RIS-empowered Air-FEEL, it is critical to jointly control the phase shifts of reflecting elements at RIS, the transmit beamforming at edge devices, and the receive beamforming at edge server for enhancing the learning performance <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib9" title="" class="ltx_ref">9</a>]</cite>.</p>
</div>
</section>
<section id="S4.SS3" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection"><span id="S4.SS3.4.1.1" class="ltx_text">IV-C</span> </span><span id="S4.SS3.5.2" class="ltx_text ltx_font_italic">User Selection/Scheduling</span>
</h3>

<div id="S4.SS3.p1" class="ltx_para">
<p id="S4.SS3.p1.1" class="ltx_p">Use selection and scheduling is another efficient technique to enhance the Air-FEEL performance by resolving the resource heterogeneity issue via dropping the edge devices with bad channels and/or limited communication and computation resources.
A new tradeoff arises in scheduling edge devices for optimizing Air-FEEL performance. In particular, allowing more devices to participate in Air-FEEL can aggregate more training data for accelerating the convergence, which, however, may lead to larger aggregation errors as more devices with poorer channels are involved. Such tradeoffs were first studied in <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib10" title="" class="ltx_ref">10</a>]</cite> to regulate the device population in the scenario when the edge devices are i.i.d. distributed in a certain area, in which the devices with weak channel conditions were excluded. Next, the joint design of device scheduling and receive beamforming was presented in <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib8" title="" class="ltx_ref">8</a>]</cite>, in which the devices with weak signal strengths after receive beamforming were dropped from the training process. Moreover, the work <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib11" title="" class="ltx_ref">11</a>]</cite> investigated the device scheduling by further considering their diverse energy constraints and computation capabilities, in which an energy-aware dynamic device scheduling algorithm was proposed based on Lyapunov optimization.</p>
</div>
</section>
<section id="S4.SS4" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection"><span id="S4.SS4.4.1.1" class="ltx_text">IV-D</span> </span><span id="S4.SS4.5.2" class="ltx_text ltx_font_italic">Model/Gradient Compression Based on Sparsification</span>
</h3>

<div id="S4.SS4.p1" class="ltx_para">
<p id="S4.SS4.p1.1" class="ltx_p">Compression is useful in reducing the data dimensions to be exchanged, and thus is important to accelerate the communication process in Air-FEEL. However, different from FEEL that can apply conventional digital compression techniques, Air-FEEL needs to implement new compression methods based on analog modulated model/gradient parameters. For example, the authors in <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib12" title="" class="ltx_ref">12</a>]</cite> exploited the sparsity of the gradient/model updates to compress the local gradient estimates to the dimension of available channel uses.
In this design, edge devices first sparsify the gradient estimates by setting elements with small absolute values to zero, and then projected the processed gradient estimates into a low-dimensional vector by applying a synchronized pseudo-random measurement matrix. This thus avoids the additional transmission of index information of zero elements in gradient vector. Furthermore, the work <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib13" title="" class="ltx_ref">13</a>]</cite> considered gradient sparsification together with an error-feedback mechanism, in which the common dimensions can be selected uniformly via synchronized pseudo-random number generators and the sparsification errors are added back to the next-round gradient update to alleviate the possible gradient error. Under this setup, the adaptive power control was implemented to combat the aggregation errors over time-varying channels.</p>
</div>
</section>
</section>
<section id="S5" class="ltx_section">
<h2 class="ltx_title ltx_title_section">
<span class="ltx_tag ltx_tag_section">V </span><span id="S5.1.1" class="ltx_text ltx_font_smallcaps">Future Research Directions</span>
</h2>

<div id="S5.p1" class="ltx_para">
<p id="S5.p1.1" class="ltx_p">Besides the above resource management designs, there also remain various new design issues that are important for the success of Air-FEEL in 6G, but not well investigated yet. In this section, we discuss some of these issues to motivate future work.</p>
</div>
<section id="S5.SS1" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection"><span id="S5.SS1.4.1.1" class="ltx_text">V-A</span> </span><span id="S5.SS1.5.2" class="ltx_text ltx_font_italic">Secure Design Against Jamming and Spoofing</span>
</h3>

<div id="S5.SS1.p1" class="ltx_para">
<p id="S5.SS1.p1.1" class="ltx_p">The analog over-the-air aggregation in Air-FEEL makes it vulnerable to jamming or spoofing attacks due to the lack of coding and encryption. For instance, some corrupted devices due to malfunction or malicious adversary (a.k.a. Byzantine devices) may send fault or manipulated messages to the edge server to attack Air-FEEL for preventing the convergence or leading to a counterfeit model. In this case, how to detect or even correct the manipulated abnormal model/gradient updates by malicious devices (i.e., poisoning attacks) on global model training is important. This task, however, is particularly challenging, due to the simultaneous model/gradient transmission over the air.</p>
</div>
<div id="S5.SS1.p2" class="ltx_para">
<p id="S5.SS1.p2.1" class="ltx_p">To tackle the above issue, the authors in <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib14" title="" class="ltx_ref">14</a>]</cite> proposed to use the Weiszfeld algorithm to obtain the smoothed geometric median of model/gradient for resisting the Byzantine attack. In this design, the edge devices are divided into several groups, based on which the devices within each group can employ AirComp for computing the geometric median of their local models/gradients, but those in different groups need to transmit over orthogonal time-frequency blocks. Based on such an over-the-air geometric median aggregation scheme, it is shown that when the number of Byzantine attacks is lower than half of the number of groups or individual transmissions, the aggregation values are ensured to achieve a well approximation to the mean of updates of honest devices. In essence, the design in <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib14" title="" class="ltx_ref">14</a>]</cite> combats against the Byzantine attacks at the cost of more communication costs. How to further improve such design and study new approaches to combat other attacks still requires more efforts from our community.</p>
</div>
</section>
<section id="S5.SS2" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection"><span id="S5.SS2.4.1.1" class="ltx_text">V-B</span> </span><span id="S5.SS2.5.2" class="ltx_text ltx_font_italic">Air-FEEL over Large-Scale Networks</span>
</h3>

<div id="S5.SS2.p1" class="ltx_para">
<p id="S5.SS2.p1.1" class="ltx_p">The success of FEEL needs massive training data. It is thus desirable to involve more edge devices over large-scale networks for Air-FEEL. Towards this end, hierarchical Air-FEEL and <span id="S5.SS2.p1.1.1" class="ltx_text ltx_font_italic">device-to-device</span> (D2D) Air-FEEL can be two viable architectures, as depicted in the two lower sub-figures in Fig. <a href="#S5.F6" title="Figure 6 ‣ V-B Air-FEEL over Large-Scale Networks ‣ V Future Research Directions ‣ An Overview on Over-the-Air Federated Edge Learning" class="ltx_ref"><span class="ltx_text ltx_ref_tag">6</span></a>. In particular, the hierarchical Air-FEEL architecture may correspond to a multi-cell network with multiple edge servers and one (or more) cloud server at the core network. At the lower level, the edge server may aggregate local models/gradients from edge devices over the air; at the upper level, the cloud server performs global aggregation of regional updates from edge servers via wired or wireless backhauls. How to associate edge devices with edge servers, and how to determine the numbers of local computation iterations at the lower and upper levels are new problemsto tackle. These problems, however, are difficult, especially when the distributed data samples follow varied distribution at edge devices.</p>
</div>
<div id="S5.SS2.p2" class="ltx_para">
<p id="S5.SS2.p2.1" class="ltx_p">On the other hand, in the D2D Air-FEEL without a centralized controller, all participating edge devices are divided into multiple clusters, such that each device is associated with a cluster head via D2D communications <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib15" title="" class="ltx_ref">15</a>]</cite>. In this system, edge devices within the same cluster first simultaneously send the updates to the associated cluster head, and then the head broadcasts the aggregated (cluster) signal to all devices to achieve consensus. In this case, how to cluster the edge devices and how to determine cluster heads are important problems.</p>
</div>
<figure id="S5.F6" class="ltx_figure"><img src="/html/2208.05643/assets/x6.png" id="S5.F6.g1" class="ltx_graphics ltx_centering ltx_img_landscape" width="500" height="315" alt="Refer to caption">
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure">Figure 6: </span>Future Air-FEEL framework with potential solutions. </figcaption>
</figure>
</section>
<section id="S5.SS3" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection"><span id="S5.SS3.4.1.1" class="ltx_text">V-C</span> </span><span id="S5.SS3.5.2" class="ltx_text ltx_font_italic">Air-FEEL with New Energy Technologies</span>
</h3>

<div id="S5.SS3.p1" class="ltx_para">
<p id="S5.SS3.p1.1" class="ltx_p">AI model training is generally energy consuming, and the resultant energy cost and carbon emission are becoming serious problems. While conventionally resource management solutions are implemented at the energy demand side, exploiting new energy technologies such as energy harvesting (from, e.g., solar, wind, and ambient radio signals) and smart grids at the energy supply side is becoming a viable new solution to resolve the above problem, as shown in the upper-left subfigure in Fig. <a href="#S5.F6" title="Figure 6 ‣ V-B Air-FEEL over Large-Scale Networks ‣ V Future Research Directions ‣ An Overview on Over-the-Air Federated Edge Learning" class="ltx_ref"><span class="ltx_text ltx_ref_tag">6</span></a>. However, the energy harvesting processes are random and intermittent in nature and the smart grids enable various new features such as dynamic energy pricing and two-way energy trading and sharing. Sophisticated joint energy and Air-FEEL design is desirable for future research.</p>
</div>
<div id="S5.SS3.p2" class="ltx_para">
<p id="S5.SS3.p2.1" class="ltx_p">In addition, <span id="S5.SS3.p2.1.1" class="ltx_text ltx_font_italic">wireless power transfer</span> (WPT) is another powering technique over wireless networks, which can be utilized for the edge server to wirelessly charge edge devices to enable their sustainable and even battery-free operation.
For such wireless powered Air-FEEL systems, how to jointly optimize the WPT transmission and the Air-FEEL operation is a new technical issue.</p>
</div>
</section>
<section id="S5.SS4" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection"><span id="S5.SS4.4.1.1" class="ltx_text">V-D</span> </span><span id="S5.SS4.5.2" class="ltx_text ltx_font_italic">Air-FEEL with Integrated Sensing and Communications (ISAC) </span>
</h3>

<div id="S5.SS4.p1" class="ltx_para">
<p id="S5.SS4.p1.1" class="ltx_p">ISAC has been recognized as an enabling 6G technology at the physical layer to enable wireless sensing over cellular networks for supporting new intelligent applications. ISAC integrates both functions of data collection and transmission, and its combination with Air-FEEL can be exploited to provide an ultra-low-latency “sensing-communication computation” solution for edge intelligence. For example, as shown in the upper-right subfigure in Fig. <a href="#S5.F6" title="Figure 6 ‣ V-B Air-FEEL over Large-Scale Networks ‣ V Future Research Directions ‣ An Overview on Over-the-Air Federated Edge Learning" class="ltx_ref"><span class="ltx_text ltx_ref_tag">6</span></a>, distributed edge devices can simultaneously transmit probing signals to detect the target and data symbols to the edge server for update aggregation via AirComp. However, the implementation of integrated Air-FEEL and ISAC also faces many challenges. First, since such networks need to support wireless sensing and update aggregation at the same time, the already scarce spectrum resources may become even more strained. Next, different types of edge devices generate different data modalities, and thus how to apply multi-modal sensing data to improve the performance of Air-FEEL deserves more in-depth investigation.</p>
</div>
</section>
</section>
<section id="S6" class="ltx_section">
<h2 class="ltx_title ltx_title_section">
<span class="ltx_tag ltx_tag_section">VI </span><span id="S6.1.1" class="ltx_text ltx_font_smallcaps">Conclusion</span>
</h2>

<div id="S6.p1" class="ltx_para">
<p id="S6.p1.1" class="ltx_p">This article presented an overview on Air-FEEL that exploits the advanced over-the-air data aggregation or AirComp to enhance the communication efficiency for FEEL towards edge intelligence. We discussed the basic principles, design challenges, advanced techniques, and various new research issues of Air-FEEL. It is our hope that this article can provide new insights on this interesting research topic, and motivate more interdisciplinary research from the communities of wireless communications, machine learning, and computing.</p>
</div>
</section>
<section id="bib" class="ltx_bibliography">
<h2 class="ltx_title ltx_title_bibliography">References</h2>

<ul class="ltx_biblist">
<li id="bib.bib1" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[1]</span>
<span class="ltx_bibblock">
M. Chen, D. Gündüz, K. Huang, W. Saad, M. Bennis, A. V. Feljan, and
H. V. Poor, “Distributed learning in wireless networks: Recent progress and
future challenges,” <em id="bib.bib1.1.1" class="ltx_emph ltx_font_italic">IEEE J. Sel. Areas Commun.</em>, vol. 39, no. 12, pp.
3579–3605, Dec. 2021.

</span>
</li>
<li id="bib.bib2" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[2]</span>
<span class="ltx_bibblock">
B. McMahan, E. Moore, D. Ramage, S. Hampson, and B. Arcas,
“Communication-efficient learning of deep networks from decentralized
data,” in <em id="bib.bib2.1.1" class="ltx_emph ltx_font_italic">Proc. International Conference on Artificial Intelligence
and Statistics</em>, vol. 54, Fort Lauderdale, FL, USA, 20–22 Apr. 2017, pp.
1273–1282.

</span>
</li>
<li id="bib.bib3" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[3]</span>
<span class="ltx_bibblock">
G. Zhu, J. Xu, K. Huang, and S. Cui, “Over-the-air computing for wireless data
aggregation in massive IoT,” <em id="bib.bib3.1.1" class="ltx_emph ltx_font_italic">IEEE Wireless Commun.</em>, vol. 28, no. 4,
pp. 57–65, Aug. 2021.

</span>
</li>
<li id="bib.bib4" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[4]</span>
<span class="ltx_bibblock">
D. Liu and O. Simeone, “Privacy for free: Wireless federated learning via
uncoded transmission with adaptive power control,” <em id="bib.bib4.1.1" class="ltx_emph ltx_font_italic">IEEE J. Sel. Areas
Commun.</em>, vol. 39, no. 1, pp. 170–185, Jan. 2021.

</span>
</li>
<li id="bib.bib5" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[5]</span>
<span class="ltx_bibblock">
X. Cao, G. Zhu, J. Xu, and S. Cui, “Transmission power control for
over-the-air federated averaging at network edge,” <em id="bib.bib5.1.1" class="ltx_emph ltx_font_italic">IEEE J. Sel. Areas
Commun.</em>, vol. 40, no. 5, pp. 1571–1586, May 2022.

</span>
</li>
<li id="bib.bib6" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[6]</span>
<span class="ltx_bibblock">
X. Cao, G. Zhu, J. Xu, Z. Wang, and S. Cui, “Optimized power control design
for over-the-air federated edge learning,” <em id="bib.bib6.1.1" class="ltx_emph ltx_font_italic">IEEE J. Sel. Areas
Commun.</em>, vol. 40, no. 1, pp. 342–358, Jan. 2022.

</span>
</li>
<li id="bib.bib7" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[7]</span>
<span class="ltx_bibblock">
N. Zhang and M. Tao, “Gradient statistics aware power control for over-the-air
federated learning,” <em id="bib.bib7.1.1" class="ltx_emph ltx_font_italic">IEEE Trans. Wireless Commun.</em>, vol. 20, no. 8,
pp. 5115–5128, Aug. 2021.

</span>
</li>
<li id="bib.bib8" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[8]</span>
<span class="ltx_bibblock">
K. Yang, T. Jiang, Y. Shi, and Z. Ding, “Federated learning via
over-the-air computation,” <em id="bib.bib8.1.1" class="ltx_emph ltx_font_italic">IEEE Trans. Wireless Commun.</em>, vol. 19,
no. 3, pp. 2022–2035, Mar. 2020.

</span>
</li>
<li id="bib.bib9" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[9]</span>
<span class="ltx_bibblock">
W. Ni, Y. Liu, Y. C. Eldar, Z. Yang, and H. Tian, “STAR-RIS integrated
non-orthogonal multiple access and over-the-air federated learning:
Framework, analysis, and optimization,” <em id="bib.bib9.1.1" class="ltx_emph ltx_font_italic">IEEE Internet Things J.</em>, pp.
1–1, 2022.

</span>
</li>
<li id="bib.bib10" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[10]</span>
<span class="ltx_bibblock">
G. Zhu, Y. Wang, and K. Huang, “Broadband analog aggregation for
low-latency federated edge learning,” <em id="bib.bib10.1.1" class="ltx_emph ltx_font_italic">IEEE Trans. Wireless Commun.</em>,
vol. 19, no. 1, pp. 491–506, Jan. 2020.

</span>
</li>
<li id="bib.bib11" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[11]</span>
<span class="ltx_bibblock">
Y. Sun, S. Zhou, Z. Niu, and D. Gündüz, “Dynamic scheduling for
over-the-air federated edge learning with energy constraints,” <em id="bib.bib11.1.1" class="ltx_emph ltx_font_italic">IEEE J.
Sel. Areas Commun.</em>, vol. 40, no. 1, pp. 227–242, Jan. 2022.

</span>
</li>
<li id="bib.bib12" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[12]</span>
<span class="ltx_bibblock">
M. Mohammadi Amiri and D. Gündüz, “Machine learning at the
wireless edge: Distributed stochastic gradient descent over-the-air,”
<em id="bib.bib12.1.1" class="ltx_emph ltx_font_italic">IEEE Trans. Signal Process.</em>, vol. 68, pp. 2155–2169, 2020.

</span>
</li>
<li id="bib.bib13" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[13]</span>
<span class="ltx_bibblock">
J. Zhang, N. Li, and M. Dedeoglu, “Federated learning over wireless networks:
A band-limited coordinated descent approach,” in <em id="bib.bib13.1.1" class="ltx_emph ltx_font_italic">IEEE INFOCOM</em>, May
2021, pp. 1–10.

</span>
</li>
<li id="bib.bib14" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[14]</span>
<span class="ltx_bibblock">
H. Sifaou and G. Y. Li, “Robust federated learning via over-the-air
computation,” 2021. [Online]. Available:
<span class="ltx_ref ltx_nolink ltx_url ltx_font_typewriter ltx_ref_self">https://arxiv.org/pdf/2111.01221.pdf</span>

</span>
</li>
<li id="bib.bib15" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[15]</span>
<span class="ltx_bibblock">
H. Xing, O. Simeone, and S. Bi, “Federated learning over wireless
device-to-device networks: Algorithms and convergence analysis,” <em id="bib.bib15.1.1" class="ltx_emph ltx_font_italic">IEEE
J. Sel. Areas Commun.</em>, vol. 39, no. 12, pp. 3723–3741, Dec. 2021.

</span>
</li>
</ul>
</section>
<div class="ltx_pagination ltx_role_newpage"></div>
</article>
</div>
<div class="ar5iv-footer"><a href="/html/2208.05642" class="ar5iv-nav-button ar5iv-nav-button-prev">◄</a>
    <a class="ar5iv-home-button" href="/"><img height="40" alt="ar5iv homepage" src="/assets/ar5iv.png"></a>
    <a href="/feeling_lucky" class="ar5iv-text-button">Feeling<br>lucky?</a>
    <a href="/log/2208.05643" class="ar5iv-text-button ar5iv-severity-error">Conversion<br>report</a>
    <a class="ar5iv-text-button" target="_blank" href="https://github.com/dginev/ar5iv/issues/new?template=improve-article--arxiv-id-.md&title=Improve+article+2208.05643">Report<br>an issue</a>
    <a href="https://arxiv.org/abs/2208.05643" class="ar5iv-text-button arxiv-ui-theme">View&nbsp;original<br>on&nbsp;arXiv</a><a href="/html/2208.05645" class="ar5iv-nav-button ar5iv-nav-button-next">►</a>
</div><footer class="ltx_page_footer">
<a class="ar5iv-toggle-color-scheme" href="javascript:toggleColorScheme()" title="Toggle ar5iv color scheme"><span class="color-scheme-icon"></span></a>
<a class="ar5iv-footer-button" href="https://arxiv.org/help/license" target="_blank">Copyright</a>
<a class="ar5iv-footer-button" href="https://arxiv.org/help/policies/privacy_policy" target="_blank">Privacy Policy</a>

<div class="ltx_page_logo">Generated  on Wed Mar 13 17:40:31 2024 by <a target="_blank" href="http://dlmf.nist.gov/LaTeXML/" class="ltx_LaTeXML_logo"><span style="letter-spacing:-0.2em; margin-right:0.1em;">L<span class="ltx_font_smallcaps" style="position:relative; bottom:2.2pt;">a</span>T<span class="ltx_font_smallcaps" style="font-size:120%;position:relative; bottom:-0.2ex;">e</span></span><span style="font-size:90%; position:relative; bottom:-0.2ex;">XML</span><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAAOCAYAAAD5YeaVAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9wKExQZLWTEaOUAAAAddEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIFRoZSBHSU1Q72QlbgAAAdpJREFUKM9tkL+L2nAARz9fPZNCKFapUn8kyI0e4iRHSR1Kb8ng0lJw6FYHFwv2LwhOpcWxTjeUunYqOmqd6hEoRDhtDWdA8ApRYsSUCDHNt5ul13vz4w0vWCgUnnEc975arX6ORqN3VqtVZbfbTQC4uEHANM3jSqXymFI6yWazP2KxWAXAL9zCUa1Wy2tXVxheKA9YNoR8Pt+aTqe4FVVVvz05O6MBhqUIBGk8Hn8HAOVy+T+XLJfLS4ZhTiRJgqIoVBRFIoric47jPnmeB1mW/9rr9ZpSSn3Lsmir1fJZlqWlUonKsvwWwD8ymc/nXwVBeLjf7xEKhdBut9Hr9WgmkyGEkJwsy5eHG5vN5g0AKIoCAEgkEkin0wQAfN9/cXPdheu6P33fBwB4ngcAcByHJpPJl+fn54mD3Gg0NrquXxeLRQAAwzAYj8cwTZPwPH9/sVg8PXweDAauqqr2cDjEer1GJBLBZDJBs9mE4zjwfZ85lAGg2+06hmGgXq+j3+/DsixYlgVN03a9Xu8jgCNCyIegIAgx13Vfd7vdu+FweG8YRkjXdWy329+dTgeSJD3ieZ7RNO0VAXAPwDEAO5VKndi2fWrb9jWl9Esul6PZbDY9Go1OZ7PZ9z/lyuD3OozU2wAAAABJRU5ErkJggg==" alt="Mascot Sammy"></a>
</div></footer>
</div>

    <script>
      var canMathML = typeof(MathMLElement) == "function";
      if (!canMathML) {
        var body = document.querySelector("body");
        body.firstElementChild.setAttribute('style', 'opacity: 0;');
        var loading = document.createElement("div");
        loading.setAttribute("id", "mathjax-loading-spinner");
        var message = document.createElement("div");
        message.setAttribute("id", "mathjax-loading-message");
        message.innerText = "Typesetting Equations...";
        body.prepend(loading);
        body.prepend(message);

        var el = document.createElement("script");
        el.src = "https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js";
        document.querySelector("head").appendChild(el);

        window.MathJax = {
          startup: {
            pageReady: () => {
              return MathJax.startup.defaultPageReady().then(() => {
                body.removeChild(loading);
                body.removeChild(message);
                body.firstElementChild.removeAttribute('style');
              }); } } };
      }
    </script>
    <script>
    // Auxiliary function, building the preview feature when
    // an inline citation is clicked
    function clicked_cite(e) {
      e.preventDefault();
      let cite = this.closest('.ltx_cite');
      let next = cite.nextSibling;
      if (next && next.nodeType == Node.ELEMENT_NODE && next.getAttribute('class') == "ar5iv-bibitem-preview") {
        next.remove();
        return; }
      // Before adding a preview modal,
      // cleanup older previews, in case they're still open
      document.querySelectorAll('span.ar5iv-bibitem-preview').forEach(function(node) {
        node.remove();
      })

      // Create the preview
      preview = document.createElement('span');
      preview.setAttribute('class','ar5iv-bibitem-preview');
      let target = document.getElementById(this.getAttribute('href').slice(1));
      target.childNodes.forEach(function (child) {
        preview.append(child.cloneNode(true));
      });
      let close_x = document.createElement('button');
      close_x.setAttribute("aria-label","Close modal for bibliography item preview");
      close_x.textContent = "×";
      close_x.setAttribute('class', 'ar5iv-button-close-preview');
      close_x.setAttribute('onclick','this.parentNode.remove()');
      preview.append(close_x);
      preview.querySelectorAll('.ltx_tag_bibitem').forEach(function(node) {
        node.remove();
      });
      cite.parentNode.insertBefore(preview, cite.nextSibling);
      return;
    }
    // Global Document initialization:
    // - assign the preview feature to all inline citation links
    document.querySelectorAll(".ltx_cite .ltx_ref").forEach(function (link) {
      link.addEventListener("click", clicked_cite);
    });
    </script>
    </body>
</html>
